ARCHDboot/Fboot/00_base.luaÇfunction dofile(filename)
  local program, reason = loadfile(filename)
  if not program then
    return error(reason .. ':' .. filename, 0)
  end
  return program()
end

function loadfile(filename, mode, env)
  local file, reason = io.open(filename)
  if not file then
    return nil, reason
  end
  local source, reason = file:read("*a")
  file:close()
  if not source then
    return nil, reason
  end
  if string.sub(source, 1, 1) == "#" then
    local endline = string.find(source, "\n", 2, true)
    if endline then
      source = string.sub(source, endline + 1)
    else
      source = ""
    end
  end
  return load(source, "=" .. filename, mode, env)
end

function print(...)
  local args = table.pack(...)
  local stdout = io.stdout
  stdout:setvbuf("line")
  for i = 1, args.n do
    local arg = tostring(args[i])
    if i > 1 then
      arg = "\t" .. arg
    end
    stdout:write(arg)
  end
  stdout:write("\n")
  stdout:setvbuf("no")
  stdout:flush()
end
Fboot/01_process.lua§local process = require("process")

--Initialize coroutine library--
local _coroutine = coroutine -- real coroutine backend

_G.coroutine = {}
package.loaded.coroutine = _G.coroutine

for key,value in pairs(_coroutine) do
  if type(value) == "function" and value ~= "running" and value ~= "create" then
    _G.coroutine[key] = function(...)
      local thread = _coroutine.running()
      local info = process.info(thread)
      -- note the gc thread does not have a process info
      assert(info,"process not found for " .. tostring(thread))
      local data = info.data
      local co = data.coroutine_handler
      local handler = co[key]
      return handler(...)
    end
  else
    _G.coroutine[key] = value
  end
end

local init_thread = _coroutine.running()
local init_load = _G.load

_G.load = function(ld, source, mode, env)
  env = env or select(2, process.running())
  return init_load(ld, source, mode, env)
end

local kernel_create = _coroutine.create
_coroutine.create = function(f,standAlone)
  local co = kernel_create(f)
  if not standAlone then
    table.insert(process.findProcess().instances, co)
  end
  return co
end

_coroutine.wrap = function(f)
  local thread = coroutine.create(f)
  return function(...)
    local result_pack = table.pack(coroutine.resume(thread, ...))
    local result, reason = result_pack[1], result_pack[2]
    assert(result, reason)
    return select(2, table.unpack(result_pack))
  end
end

process.list[init_thread] = {
  path = "/init.lua",
  command = "init",
  env = _ENV,
  data =
  {
    vars={},
    io={}, --init will populate this
    coroutine_handler=setmetatable({}, {__index=_coroutine})
  },
  instances = setmetatable({}, {__mode="v"})
}
Fboot/02_os.luaÍlocal computer = require("computer")
local event = require("event")
local fs = require("filesystem")
local shell = require("shell")
local unicode = require("unicode")
local process = require("process")

local function env()
  return process.info().data.vars
end

os.execute = function(command)
  if not command then
    return type(shell) == "table"
  end
  return shell.execute(command)
end

function os.exit(code)
  error({reason="terminated", code=code}, 0)
end

function os.getenv(varname)
  if varname == '#' then
    return #env()
  elseif varname ~= nil then
    return env()[varname]
  else
    return env()
  end
end

function os.setenv(varname, value)
  checkArg(1, varname, "string", "number")
  if value == nil then
    env()[varname] = nil
  else
    local success, val = pcall(tostring, value)
    if success then
      env()[varname] = val
      return env()[varname]
    else
      return nil, val
    end
  end
end

function os.remove(...)
  return fs.remove(...)
end

function os.rename(...)
  return fs.rename(...)
end

function os.sleep(timeout)
  checkArg(1, timeout, "number", "nil")
  local deadline = computer.uptime() + (timeout or 0)
  repeat
    event.pull(deadline - computer.uptime())
  until computer.uptime() >= deadline
end

function os.tmpname()
  local path = os.getenv("TMPDIR") or "/tmp"
  if fs.exists(path) then
    for i = 1, 10 do
      local name = fs.concat(path, tostring(math.random(1, 0x7FFFFFFF)))
      if not fs.exists(name) then
        return name
      end
    end
  end
end

os.setenv("PATH", "/bin:/usr/bin:/home/bin:.")
os.setenv("TMP", "/tmp") -- Deprecated
os.setenv("TMPDIR", "/tmp")

if computer.tmpAddress() then
  fs.mount(computer.tmpAddress(), os.getenv("TMPDIR") or "/tmp")
end
Fboot/03_io.luaalocal buffer = require("buffer")
local term = require("term")

local io_open = io.open
function io.open(path, mode)
  return io_open(require("shell").resolve(path), mode)
end

local stdinStream = {handle="stdin"}
local stdoutStream = {handle="stdout"}
local stderrStream = {handle="stderr"}
local stdinHistory = {}

local function badFileDescriptor()
  return nil, "bad file descriptor"
end

function stdinStream:close()
  return nil, "cannot close standard file"
end
stdoutStream.close = stdinStream.close
stderrStream.close = stdinStream.close

function stdinStream:read(n, dobreak)
  stdinHistory.dobreak = dobreak
  local result = term.readKeyboard(stdinHistory)
  return result
end

function stdoutStream:write(str)
  term.drawText(str, self.wrap ~= false)
  return self
end

function stderrStream:write(str)
  local gpu = term.gpu()
  local set_depth = gpu and gpu.getDepth() and gpu.getDepth() > 1

  if set_depth then
    set_depth = gpu.setForeground(0xFF0000)
  end
    
  term.drawText(str, true)

  if set_depth then
    gpu.setForeground(set_depth)
  end

  return self
end

stdinStream.seek = badFileDescriptor
stdinStream.write = badFileDescriptor
stdoutStream.read = badFileDescriptor
stdoutStream.seek = badFileDescriptor
stderrStream.read = badFileDescriptor
stderrStream.seek = badFileDescriptor

local core_stdin = buffer.new("r", stdinStream)
local core_stdout = buffer.new("w", stdoutStream)
local core_stderr = buffer.new("w", stderrStream)

core_stdout:setvbuf("no")
core_stderr:setvbuf("no")
core_stdin.tty = true
core_stdout.tty = true
core_stderr.tty = true

core_stdin.close = stdinStream.close
core_stdout.close = stdinStream.close
core_stderr.close = stdinStream.close

local fd_map =
{
  -- key name => method name
  stdin = 'input',
  stdout = 'output',
  stderr = 'error'
}

local io_mt = getmetatable(io) or {}
io_mt.__index = function(t, k)
  if fd_map[k] then
    return io[fd_map[k]]()
  end
end
io_mt.__newindex = function(t, k, v)
  if fd_map[k] then
    io[fd_map[k]](v)
  else
    rawset(io, k, v)
  end
end

setmetatable(io, io_mt)

io.stdin = core_stdin
io.stdout = core_stdout
io.stderr = core_stderr
Fboot/04_component.lua)local component = require("component")
local computer = require("computer")
local event = require("event")

local adding = {}
local removing = {}
local primaries = {}

-------------------------------------------------------------------------------

-- This allows writing component.modem.open(123) instead of writing
-- component.getPrimary("modem").open(123), which may be nicer to read.
setmetatable(component, {
  __index = function(_, key)
    return component.getPrimary(key)
  end,
  __pairs = function(self)
    local parent = false
    return function(_, key)
      if parent then
        return next(primaries, key)
      else
        local k, v = next(self, key)
        if not k then
          parent = true
          return next(primaries)
        else
          return k, v
        end
      end
    end
  end
})

function component.get(address, componentType)
  checkArg(1, address, "string")
  checkArg(2, componentType, "string", "nil")
  for c in component.list(componentType, true) do
    if c:sub(1, address:len()) == address then
      return c
    end
  end
  return nil, "no such component"
end

function component.isAvailable(componentType)
  checkArg(1, componentType, "string")
  if not primaries[componentType] and not adding[componentType] then
    -- This is mostly to avoid out of memory errors preventing proxy
    -- creation cause confusion by trying to create the proxy again,
    -- causing the oom error to be thrown again.
    component.setPrimary(componentType, component.list(componentType, true)())
  end
  return primaries[componentType] ~= nil
end

function component.isPrimary(address)
  local componentType = component.type(address)
  if componentType then
    if component.isAvailable(componentType) then
      return primaries[componentType].address == address
    end
  end
  return false
end

function component.getPrimary(componentType)
  checkArg(1, componentType, "string")
  assert(component.isAvailable(componentType),
    "no primary '" .. componentType .. "' available")
  return primaries[componentType]
end

function component.setPrimary(componentType, address)
  checkArg(1, componentType, "string")
  checkArg(2, address, "string", "nil")
  if address ~= nil then
    address = component.get(address, componentType)
    assert(address, "no such component")
  end

  local wasAvailable = primaries[componentType]
  if wasAvailable and address == wasAvailable.address then
    return
  end
  local wasAdding = adding[componentType]
  if wasAdding and address == wasAdding.address then
    return
  end
  if wasAdding then
    event.cancel(wasAdding.timer)
  end
  primaries[componentType] = nil
  adding[componentType] = nil

  local primary = address and component.proxy(address) or nil
  if wasAvailable then
    computer.pushSignal("component_unavailable", componentType)
  end
  if primary then
    if wasAvailable or wasAdding then
      adding[componentType] = {
        address=address,
        timer=event.timer(0.1, function()
          adding[componentType] = nil
          primaries[componentType] = primary
          computer.pushSignal("component_available", componentType)
        end)
      }
    else
      primaries[componentType] = primary
      computer.pushSignal("component_available", componentType)
    end
  end
end

-------------------------------------------------------------------------------

for address in component.list('screen', true) do
  if #component.invoke(address,'getKeyboards') > 0 then
    component.setPrimary('screen',address)
  end
end

local function onComponentAdded(_, address, componentType)
  if not (primaries[componentType] or adding[componentType]) then
    component.setPrimary(componentType, address)
  end
end

local function onComponentRemoved(_, address, componentType)
  if primaries[componentType] and primaries[componentType].address == address or
     adding[componentType] and adding[componentType].address == address
  then
    component.setPrimary(componentType, component.list(componentType, true)())
  end
end

event.listen("component_added", onComponentAdded)
event.listen("component_removed", onComponentRemoved)
Fboot/10_devfs.lua¢require("filesystem").mount(
setmetatable({
  isReadOnly = function()return false end
},
{
  __index=function(tbl,key)return require("devfs")[key]end
}), "/dev")
Fboot/90_filesystem.lua local component = require("component")
local event = require("event")
local fs = require("filesystem")
local shell = require("shell")

local isInitialized, pendingAutoruns = false, {}

local function onInit()
  isInitialized = true
  for _, run in ipairs(pendingAutoruns) do
    local result, reason = pcall(run)
    if not result then
      local path = fs.concat(os.getenv("TMPDIR") or "/tmp", "event.log")
      local log = io.open(path, "a")
      if log then
        log:write(reason .. "\n")
        log:close()
      end
    end
  end
  pendingAutoruns = nil
end

local function onComponentAdded(_, address, componentType)
  if componentType == "filesystem" then
    local proxy = component.proxy(address)
    if proxy then
      local name = address:sub(1, 3)
      while fs.exists(fs.concat("/mnt", name)) and
            name:len() < address:len() -- just to be on the safe side
      do
        name = address:sub(1, name:len() + 1)
      end
      name = fs.concat("/mnt", name)
      fs.mount(proxy, name)
      if fs.isAutorunEnabled() then
        local function run()
          local file = shell.resolve(fs.concat(name, "autorun"), "lua") or
                       shell.resolve(fs.concat(name, ".autorun"), "lua")
          if file then
            local result, reason = shell.execute(file, _ENV, proxy)
            if not result then
              error(reason, 0)
            end
          end
        end
        if isInitialized then
          run()
        else
          table.insert(pendingAutoruns, run)
        end
      end
    end
  end
end

local function onComponentRemoved(_, address, componentType)
  if componentType == "filesystem" then
    if fs.get(shell.getWorkingDirectory()).address == address then
      shell.setWorkingDirectory("/")
    end
    fs.umount(address)
  end
end

event.listen("init", onInit)
event.listen("component_added", onComponentAdded)
event.listen("component_removed", onComponentRemoved)
Fboot/91_gpu.lua@local component = require("component")
local event = require("event")

local function onComponentAvailable(_, componentType)
  if (componentType == "screen" and component.isAvailable("gpu")) or
     (componentType == "gpu" and component.isAvailable("screen"))
  then
    component.gpu.bind(component.screen.address)
    local depth = 2^(component.gpu.getDepth())
    os.setenv("TERM", "term-"..depth.."color")
    require("computer").pushSignal("gpu_bound", component.gpu.address, component.screen.address)
  end
end

event.listen("component_available", onComponentAvailable)
Fboot/92_keyboard.lualocal component = require("component")
local event = require("event")
local keyboard = require("keyboard")

local function onKeyDown(_, address, char, code)
  if keyboard.pressedChars[address] then
    keyboard.pressedChars[address][char] = true
    keyboard.pressedCodes[address][code] = true
  end
end

local function onKeyUp(_, address, char, code)
  if keyboard.pressedChars[address] then
    keyboard.pressedChars[address][char] = nil
    keyboard.pressedCodes[address][code] = nil
  end
end

local function onComponentAdded(_, address, componentType)
  if componentType == "keyboard" then
    keyboard.pressedChars[address] = {}
    keyboard.pressedCodes[address] = {}
  end
end

local function onComponentRemoved(_, address, componentType)
  if componentType == "keyboard" then
    keyboard.pressedChars[address] = nil
    keyboard.pressedCodes[address] = nil
  end
end

for address in component.list("keyboard", true) do
  onComponentAdded("component_added", address, "keyboard")
end

event.listen("key_down", onKeyDown)
event.listen("key_up", onKeyUp)
event.listen("component_added", onComponentAdded)
event.listen("component_removed", onComponentRemoved)
Fboot/93_term.lua)local component = require("component")
local computer = require("computer")
local event = require("event")
local term = require("term")
local process = require("process")

-- this should be the init level process
process.info().data.window = term.internal.open()

event.listen("gpu_bound", function(ename, gpu, screen)
  gpu=component.proxy(gpu)
  screen=component.proxy(screen)
  term.bind(gpu, screen)
  computer.pushSignal("term_available")
end)

event.listen("component_unavailable", function(_,type)
  if type == "screen" or type == "gpu" then
    if term.isAvailable() then
      local window = term.internal.window()
      if window[type] and not component.proxy(window[type].address) then
        window[type] = nil
      end
    end
    if not term.isAvailable() then
      computer.pushSignal("term_unavailable")
    end
  end
end)

event.listen("screen_resized", function(_,addr,w,h)
  local window = term.internal.window()
  if term.isAvailable(window) and window.screen.address == addr and window.fullscreen then
    window.w,window.h = w,h
  end
end)
Fboot/94_shell.luaòlocal shell = require("shell")

require("event").listen("init", function()
  local file = io.open("/etc/hostname")
  if file then
    os.setenv("HOSTNAME", file:read("*l"))
    os.setenv("PS1", "$HOSTNAME:$PWD# ")
    file:close()
  end
end)
Fboot/99_rc.lua-- Run all enabled rc scripts.
local shell = require("shell")
local rc = shell.resolve("rc", "lua")
if rc then 
  dofile(rc)
end
Dlib/Flib/ECSAPI.luaUP

local advancedLua = require("advancedLua")
local component = require("component")
local term = require("term")
local unicode = require("unicode")
local event = require("event")
local fs = require("filesystem")
local shell = require("shell")
local keyboard = require("keyboard")
local computer = require("computer")
local serialization = require("serialization")


local gpu = component.gpu
local ecs = {}

----------------------------------------------------------------------------------------------------

ecs.windowColors = {
	background = 0xeeeeee,
	usualText = 0x444444,
	subText = 0x888888,
	tab = 0xaaaaaa,
	title = 0xffffff,
	shadow = 0x444444,
}

ecs.colors = {
	white = 0xffffff,
	orange = 0xF2B233,
	magenta = 0xE57FD8,
	lightBlue = 0x99B2F2,
	yellow = 0xDEDE6C,
	lime = 0x7FCC19,
	pink = 0xF2B2CC,
	gray = 0x4C4C4C,
	lightGray = 0x999999,
	cyan = 0x4C99B2,
	purple = 0xB266E5,
	blue = 0x3366CC,
	brown = 0x7F664C,
	green = 0x57A64E,
	red = 0xCC4C4C,
    black = 0x000000,
	["0"] = 0xffffff,
	["1"] = 0xF2B233,
	["2"] = 0xE57FD8,
	["3"] = 0x99B2F2,
	["4"] = 0xDEDE6C,
	["5"] = 0x7FCC19,
	["6"] = 0xF2B2CC,
	["7"] = 0x4C4C4C,
	["8"] = 0x999999,
	["9"] = 0x4C99B2,
	["a"] = 0xB266E5,
	["b"] = 0x3366CC,
	["c"] = 0x7F664C,
	["d"] = 0x57A64E,
	["e"] = 0xCC4C4C,
	["f"] = 0x000000
}

----------------------------------------------------------------------------------------------------

--ÐÐ´ÐµÐºÐ²Ð°ÑÐ½ÑÐ¹ Ð·Ð°Ð¿ÑÐ¾Ñ Ðº Ð²ÐµÐ±-ÑÐµÑÐ²ÐµÑÑ Ð²Ð¼ÐµÑÑÐ¾ ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¾Ð³Ð¾ Internet API, Ð±ÑÐ¾ÑÐ°ÑÑÐµÐ³Ð¾ stderr, ÐºÐ¾Ð³Ð´Ð° ÐµÐ¼Ñ Ð²Ð·Ð´ÑÐ¼Ð°ÐµÑÑÑ
function ecs.internetRequest(url)
	local success, response = pcall(component.internet.request, url)
	if success then
		local responseData = ""
		while true do
			local data, responseChunk = response.read()	
			if data then
				responseData = responseData .. data
			else
				if responseChunk then
					return false, responseChunk
				else
					return true, responseData
				end
			end
		end
	else
		return false, reason
	end
end

--ÐÐ°Ð³ÑÑÐ·ÐºÐ° ÑÐ°Ð¹Ð»Ð° Ñ Ð¸Ð½ÐµÑÐ°
function ecs.getFileFromUrl(url, path)
	local success, response = ecs.internetRequest(url)
	if success then
		fs.makeDirectory(fs.path(path) or "")
		local file = io.open(path, "w")
		file:write(response)
		file:close()
	else
		ecs.error("Could not connect to to URL address \"" .. url .. "\"")
		return
	end
end

--ÐÑÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð¿ÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½Ð¾Ð³Ð¾ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¸Ñ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼
function ecs.disableInterrupting()
	_G.eventInterruptBackup = package.loaded.event.shouldInterrupt 
	_G.eventSoftInterruptBackup = package.loaded.event.shouldSoftInterrupt 
	
	package.loaded.event.shouldInterrupt = function () return false end
	package.loaded.event.shouldSoftInterrupt = function () return false end
end

--ÐÐºÐ»ÑÑÐµÐ½Ð¸Ðµ Ð¿ÑÐ¸Ð½ÑÐ´Ð¸ÑÐµÐ»ÑÐ½Ð¾Ð³Ð¾ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¸Ñ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼
function ecs.enableInterrupting()
	if _G.eventInterruptBackup then
		package.loaded.event.shouldInterrupt = _G.eventInterruptBackup 
		package.loaded.event.shouldSoftInterrupt = _G.eventSoftInterruptBackup
	else
		error("Cant't enable interrupting beacause of it's already enabled.")
	end
end

function ecs.getScaledResolution(scale, debug)
	--ÐÐ°Ð·Ð¾Ð²Ð°Ñ ÐºÐ¾ÑÑÐµÐºÑÐ¸Ñ Ð¼Ð°ÑÑÑÐ°Ð±Ð°, ÑÑÐ¾Ð±Ñ Ð²ÑÑÐºÐ¸Ðµ ÑÐ¼Ð½Ð¸ÐºÐ¸ Ð½Ðµ Ð¿Ð¸ÑÐ°Ð»Ð¸ ÑÐ²Ð¾Ð¸Ð¼Ð¸ Ð¿Ð¾Ð³Ð°Ð½ÑÐ¼Ð¸ ÑÑÑÐ¾Ð½ÐºÐ°Ð¼Ð¸, ÑÐµÐ³Ð¾ Ð½Ðµ ÑÐ»ÐµÐ´ÑÐµÑ
	if scale > 1 then
		scale = 1
	elseif scale < 0.1 then
		scale = 0.1
	end

	--ÐÑÐ¾ÑÑÐµÑ Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ° Ð² Ð¿ÑÐµÐ²Ð´Ð¾Ð¿Ð¸ÐºÑÐµÐ»ÑÑ - Ð·Ð°Ð±ÐµÐ¹, Ð´Ð°Ð¶Ðµ Ð¾Ð±ÑÑÑÐ½ÑÑÑ Ð½Ðµ Ð±ÑÐ´Ñ, ÑÐ°Ð±Ð¾ÑÐ°ÐµÑ ÐºÐ°Ðº ÑÐ°ÑÑ
	local function calculateAspect(screens)
	  local abc = 12

	  if screens == 2 then
	    abc = 28
	  elseif screens > 2 then
	    abc = 28 + (screens - 2) * 16
	  end

	  return abc
	end

	--Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¿ÑÐ¾Ð¿Ð¾ÑÑÐ¸Ñ Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ° Ð² Ð¿ÑÐµÐ²Ð´Ð¾Ð¿Ð¸ÐºÑÐµÐ»ÑÑ
	local xScreens, yScreens = component.proxy(component.gpu.getScreen()).getAspectRatio()
	local xPixels, yPixels = calculateAspect(xScreens), calculateAspect(yScreens)
	local proportion = xPixels / yPixels

	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ Ð´Ð°Ð½Ð½Ð¾Ð¹ Ð²Ð¸Ð´ÐµÐ¾ÐºÐ°ÑÑÑ
	local xMax, yMax = component.gpu.maxResolution()

	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐµÐ¾ÑÐµÑÐ¸ÑÐµÑÐºÐ¾Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ° Ñ ÑÑÐµÑÐ¾Ð¼ ÐµÐ³Ð¾ Ð¿ÑÐ¾Ð¿Ð¾ÑÑÐ¸Ð¸, Ð½Ð¾ Ð±ÐµÐ· ÑÑÐµÑÐ° Ð»Ð¸Ð¼Ð¸ÑÐ° Ð²Ð¸Ð´ÐµÐ¾ÐºÐ°ÑÑÑ
	local newWidth, newHeight
	if proportion >= 1 then
		newWidth = xMax
		newHeight = math.floor(newWidth / proportion / 2)
	else
		newHeight = yMax
		newWidth = math.floor(newHeight * proportion * 2)
	end

	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¾Ð¿ÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ Ð´Ð»Ñ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ° Ñ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ¾Ð¹ Ð²Ð¸Ð´ÐµÐ¾ÐºÐ°ÑÑÑ
	local optimalNewWidth, optimalNewHeight = newWidth, newHeight

	if optimalNewWidth > xMax then
		local difference = newWidth / xMax
		optimalNewWidth = xMax
		optimalNewHeight = math.ceil(newHeight / difference)
	end

	if optimalNewHeight > yMax then
		local difference = newHeight / yMax
		optimalNewHeight = yMax
		optimalNewWidth = math.ceil(newWidth / difference)
	end

	--ÐÐ¾ÑÑÐµÐºÑÐ¸ÑÑÐµÐ¼ Ð¸Ð´ÐµÐ°Ð»ÑÐ½Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ Ð¿Ð¾ Ð·Ð°Ð´Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¼Ð°ÑÑÑÐ°Ð±Ñ
	local finalNewWidth, finalNewHeight = math.floor(optimalNewWidth * scale), math.floor(optimalNewHeight * scale)

	--ÐÑÐ²Ð¾Ð´Ð¸Ð¼ Ð¸Ð½ÑÑ, ÐµÑÐ»Ð¸ Ð½ÑÐ¶Ð½Ð¾
	if debug then
		print(" ")
		print("ÐÐ°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ: "..xMax.."x"..yMax)
		print("ÐÑÐ¾Ð¿Ð¾ÑÑÐ¸Ñ Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ°: "..xPixels.."x"..yPixels)
		print("ÐÐ¾ÑÑÑÐ¸ÑÐ¸ÐµÐ½Ñ Ð¿ÑÐ¾Ð¿Ð¾ÑÑÐ¸Ð¸: "..proportion)
		print(" ")
		print("Ð¢ÐµÐ¾ÑÐµÑÐ¸ÑÐµÑÐºÐ¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ: "..newWidth.."x"..newHeight)
		print("ÐÐ¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ: "..optimalNewWidth.."x"..optimalNewHeight)
		print(" ")
		print("ÐÐ¾Ð²Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ: "..finalNewWidth.."x"..finalNewHeight)
		print(" ")
	end

	return finalNewWidth, finalNewHeight
end

--Ð£ÑÑÐ°Ð½Ð¾Ð²ÐºÐ° Ð¼Ð°ÑÑÑÐ°Ð±Ð° Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ°
function ecs.setScale(scale, debug)
	--Ð£ÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð²ÑÐ±ÑÐ°Ð½Ð½Ð¾Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ
	component.gpu.setResolution(ecs.getScaledResolution(scale, debug))
end

function ecs.rebindGPU(address)
	component.gpu.bind(address)
end

--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð²ÑÑ Ð¸Ð½ÑÑ Ð¾Ð± Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²ÐºÑ Ð² ÐºÐ¸Ð»Ð¾Ð±Ð°Ð¹ÑÐ°Ñ
function ecs.getInfoAboutRAM()
	local free = math.floor(computer.freeMemory() / 1024)
	local total = math.floor(computer.totalMemory() / 1024)
	local used = total - free

	return free, total, used
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð¶ÐµÑÑÐºÐ¸Ñ Ð´Ð¸ÑÐºÐ°Ñ
function ecs.getHDDs()
	local candidates = {}
	for address in component.list("filesystem") do
	  local proxy = component.proxy(address)
	  if proxy.address ~= computer.tmpAddress() and proxy.getLabel() ~= "internet" then
	    local isFloppy, spaceTotal = false, math.floor(proxy.spaceTotal() / 1024)
	    if spaceTotal < 600 then isFloppy = true end
	    table.insert(candidates, {
	    	["spaceTotal"] = spaceTotal,
	    	["spaceUsed"] = math.floor(proxy.spaceUsed() / 1024),
	    	["label"] = proxy.getLabel(),
	    	["address"] = proxy.address,
	    	["isReadOnly"] = proxy.isReadOnly(),
	    	["isFloppy"] = isFloppy,
	    })
	  end
	end
	return candidates
end

--Ð¤Ð¾ÑÐ¼Ð°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð´Ð¸ÑÐº
function ecs.formatHDD(address)
	local proxy = component.proxy(address)
	local list = proxy.list("")
	ecs.info("auto", "auto", "", "Formatting disk...")
	for _, file in pairs(list) do
		if type(file) == "string" then
			if not proxy.isReadOnly(file) then proxy.remove(file) end
		end
	end
	list = nil
end

--Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¸Ð¼Ñ Ð¶ÐµÑÑÐºÐ¾Ð³Ð¾ Ð´Ð¸ÑÐºÐ°
function ecs.setHDDLabel(address, label)
	local proxy = component.proxy(address)
	proxy.setLabel(label or "Untitled")
end

--ÐÐ°Ð¹ÑÐ¸ Ð¼Ð¾Ð½ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹ Ð¿ÑÑÑ ÐºÐ¾Ð½ÐºÑÐµÑÐ½Ð¾Ð³Ð¾ Ð°Ð´ÑÐµÑÐ° Ð´Ð¸ÑÐºÐ°
function ecs.findMount(address)
  for fs1, path in fs.mounts() do
    if fs1.address == component.get(address) then
      return path
    end
  end
end

function ecs.getArraySize(array)
	local size = 0
	for key in pairs(array) do
		size = size + 1
	end
	return size
end

--Ð¡ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ°Ð¹Ð»Ñ Ñ Ð¾Ð´Ð½Ð¾Ð³Ð¾ Ð´Ð¸ÑÐºÐ° Ð½Ð° Ð´ÑÑÐ³Ð¾Ð¹ Ñ Ð·Ð°Ð¼ÐµÐ½Ð¾Ð¹
function ecs.duplicateFileSystem(fromAddress, toAddress)
	local source, destination = ecs.findMount(fromAddress), ecs.findMount(toAddress)
	ecs.info("auto", "auto", "", "Copying file system...")
	shell.execute("bin/cp -rx "..source.."* "..destination)
end

--ÐÐ°Ð³ÑÑÐ·ÐºÐ° ÑÐ°Ð¹Ð»Ð° Ñ Ð¿Ð°ÑÑÐµÐ±Ð¸Ð½Ð°
function ecs.getFromPastebin(paste, path)
	local url = "http://pastebin.com/raw.php?i=" .. paste
	ecs.getFileFromUrl(url, path)
end

--ÐÐ°Ð³ÑÑÐ·ÐºÐ° ÑÐ°Ð¹Ð»Ð° Ñ Ð³Ð¸ÑÑÐ°Ð±Ð°
function ecs.getFromGitHub(url, path)
	url = "https://raw.githubusercontent.com/" .. url
	ecs.getFileFromUrl(url, path)
end

--ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ ÐÐ¡-Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ
function ecs.getOSApplication(application)
    --ÐÑÐ»Ð¸ ÑÑÐ¾ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ
    if application.type == "Application" then
		--Ð£Ð´Ð°Ð»ÑÐµÐ¼ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ, ÐµÑÐ»Ð¸ Ð¾Ð½Ð¾ ÑÐ¶Ðµ ÑÑÑÐµÑÑÐ²Ð¾Ð²Ð°Ð»Ð¾ Ð¸ ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ Ð²ÑÐµ Ð½ÑÐ¶Ð½ÑÐµ Ð¿Ð°Ð¿Ð¾ÑÐºÐ¸
		application.name = "/" .. application.name
		fs.remove(application.name .. ".app")
		fs.makeDirectory(application.name .. ".app/Resources")
		
		--ÐÐ°Ð³ÑÑÐ¶Ð°ÐµÐ¼ Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ Ð¸ÑÐ¿Ð¾Ð»Ð½ÑÐµÐ¼ÑÐ¹ ÑÐ°Ð¹Ð» Ð¸ Ð¸ÐºÐ¾Ð½ÐºÑ
		ecs.getFromGitHub(application.url, application.name .. ".app/" .. fs.name(application.name .. ".lua"))
		ecs.getFromGitHub(application.icon, application.name .. ".app/Resources/Icon.pic")

		--ÐÑÐ»Ð¸ ÐµÑÑÑ ÑÐµÑÑÑÑÑ, ÑÐ¾ Ð·Ð°Ð³ÑÑÐ¶Ð°ÐµÐ¼ ÑÐµÑÑÑÑÑ
		if application.resources then
			for i = 1, #application.resources do
				ecs.getFromGitHub(application.resources[i].url, application.name .. ".app/Resources/" .. application.resources[i].name)
			end
		end

		--ÐÑÐ»Ð¸ ÐµÑÑÑ ÑÐ°Ð¹Ð» "Ð¾ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ðµ", ÑÐ¾ Ð³ÑÑÐ·Ð¸Ð¼ Ð¸ ÐµÐ³Ð¾
		if application.about then
			ecs.getFromGitHub(application.about .. _G.OSSettings.language .. ".txt", application.name .. ".app/Resources/About/" .. _G.OSSettings.language .. ".txt")
		end 

		--ÐÑÐ»Ð¸ Ð¸Ð¼ÐµÐµÑÑÑ ÑÐµÐ¶Ð¸Ð¼ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ ÑÑÐ»ÑÐºÐ°, ÑÐ¾ ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ ÐµÐ³Ð¾
		if application.createShortcut then
			local desktopPath = "MineOS/Desktop/"
			
			if application.createShortcut == "desktop" then
				ecs.createShortCut(desktopPath .. fs.name(application.name) .. ".lnk", application.name .. ".app")
			end
		end

	--ÐÑÐ»Ð¸ ÑÐ¸Ð¿ = Ð´ÑÑÐ³Ð¾Ð¹, ÑÑÐ¶Ð¾Ð¹, Ð° Ð¼Ð± Ð¸ ÑÐ²Ð¾Ð¹ Ð¿Ð°ÑÑÐµÐ±Ð¸Ð½
	elseif application.type == "Pastebin" then
		ecs.getFromPastebin(application.url, application.name)
		
	--ÐÑÐ»Ð¸ Ð¿ÑÐ¾ÑÑÐ¾ ÐºÐ°ÐºÐ¾Ð¹-ÑÐ¾ ÑÐºÑÐ¸Ð¿Ñ
	elseif application.type == "Script" or application.type == "Library" or application.type == "Icon" or application.type == "Wallpaper" then
		ecs.getFromGitHub(application.url, application.name)
	
	--Ð ÐµÑÐ»Ð¸ Ð²Ð°ÑÐµ ÐºÐ°ÐºÐ°Ñ-ÑÐ¾ Ð°Ð±ÑÑÑÐ°ÐºÑÐ½Ð°Ñ ÑÑÐ¹Ð½Ñ, Ð»Ð¸Ð±Ð¾ ÑÑÑÐ»ÐºÐ° Ð½Ð° Ð²ÐµÐ±, ÑÐ¾ Ð·Ð°Ð³ÑÑÐ¶Ð°ÐµÐ¼ Ð¿Ð¾ Ð£Ð Ð-ÐºÐµ
	else
		ecs.getFileFromUrl(application.url, application.name)
	end
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹, ÐºÐ¾ÑÐ¾ÑÑÐµ ÑÑÐµÐ±ÑÐµÑÑÑ Ð¾Ð±Ð½Ð¾Ð²Ð¸ÑÑ
function ecs.getAppsToUpdate(debug)
	--ÐÐ°Ð´Ð°ÐµÐ¼ ÑÑÐ°ÑÑÐ¾Ð²ÑÐµ Ð¿ÑÑÐ¸
	local pathToApplicationsFile = "MineOS/System/OS/Applications.txt"
	local pathToSecondApplicationsFile = "MineOS/System/OS/Applications2.txt"
	--ÐÑÑÑ Ðº ÑÐ°Ð¹Ð»-Ð»Ð¸ÑÑÑ Ð½Ð° Ð¿Ð°ÑÑÐµÐ±Ð¸Ð½Ðµ
	local paste = "3j2x4dDn"
	--ÐÑÐ²Ð¾Ð´Ð¸Ð¼ Ð¸Ð½ÑÑ
	local oldPixels
	if debug then oldPixels = ecs.info("auto", "auto", " ", "Checking for updates...") end
	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ²ÐµÐ¶ÐµÐ½ÑÐºÐ¸Ð¹ ÑÐ°Ð¹Ð»
	ecs.getFromPastebin(paste, pathToSecondApplicationsFile)
	--Ð§Ð¸ÑÐ°ÐµÐ¼ Ð¾Ð±Ð° ÑÐ°Ð¹Ð»Ð°
	local file = io.open(pathToApplicationsFile, "r")
	local applications = serialization.unserialize(file:read("*a"))
	file:close()
	--Ð Ð²ÑÐ¾ÑÐ¾Ð¹
	file = io.open(pathToSecondApplicationsFile, "r")
	local applications2 = serialization.unserialize(file:read("*a"))
	file:close()

	local countOfUpdates = 0

	--ÐÑÐ¾ÑÐ¼Ð°ÑÑÐ¸Ð²Ð°ÐµÐ¼ ÑÐ²ÐµÐ¶ÐµÐ½ÑÐºÐ¸Ð¹ ÑÐ°Ð¹Ð»Ð¸Ðº Ð¸ Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼, ÑÐµ Ð² Ð½ÐµÐ¼ Ð½Ð¾Ð²Ð¾Ð³Ð¾, Ð²ÑÐµ ÑÑÐ°ÑÐ¾Ðµ ÑÐ´Ð°Ð»ÑÐµÐ¼
	local i = 1
	while true do
		--Ð Ð°Ð·ÑÑÐ² ÑÐ¸ÐºÐ»Ð°
		if i > #applications2 then break end
		--ÐÐ¾Ð²Ð°Ñ Ð²ÐµÑÑÐ¸Ñ ÑÐ°Ð¹Ð»Ð°
		local newVersion, oldVersion = applications2[i].version, 0
		--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÑÐ°ÑÑÑ Ð²ÐµÑÑÐ¸Ñ ÑÑÐ¾Ð³Ð¾ ÑÐ°Ð¹Ð»Ð°
		for j = 1, #applications do
			if applications2[i].name == applications[j].name then
				oldVersion = applications[j].version or 0
				break
			end
		end
		--ÐÑÐ»Ð¸ Ð½Ð¾Ð²Ð°Ñ Ð²ÐµÑÑÐ¸Ñ Ð½Ð¾Ð²ÐµÐµ, ÑÐµÐ¼ ÑÑÐ°ÑÐ°Ñ, ÑÐ¾ Ð´Ð¾Ð±Ð°Ð²Ð¸ÑÑ Ð² Ð¼Ð°ÑÑÐ¸Ð² ÑÐ¾, ÑÑÐ¾ Ð½ÑÐ¶Ð½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð¸ÑÑ
		if newVersion > oldVersion then
			applications2[i].needToUpdate = true
			countOfUpdates = countOfUpdates + 1
		end

		i = i + 1
	end
	--ÐÑÐ»Ð¸ ÑÐµÑ ÑÐ¸ÑÐ¾Ð²Ð°Ð»Ð¾ÑÑ, ÑÐ¾ ÑÑÐµÑÐµÑÑ Ð½Ð° ÑÐµÑ
	if oldPixels then ecs.drawOldPixels(oldPixels) end
	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð¼Ð°ÑÑÐ¸Ð² Ñ ÑÐµÐ¼, ÑÐµ Ð½ÑÐ¶Ð½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð¸ÑÑ Ð¸ Ð¿ÑÐ¾ÑÑÐ¾ ÑÑÐ°ÑÑÐ¹ Ð°Ð¿Ð¿Ð»Ð¸ÐºÐ°ÑÐ½Ñ Ð½Ð° Ð²ÑÑÐºÐ¸Ð¹ ÑÐ»ÑÑÐ°Ð¹
	return applications2, countOfUpdates
end

--Ð¡Ð´ÐµÐ»Ð°ÑÑ ÑÑÑÐ¾ÐºÑ Ð¿ÑÐ¸Ð³Ð¾Ð´Ð½Ð¾Ð¹ Ð´Ð»Ñ Ð¾ÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð² ÐÐ¿ÐµÐ½ÐÐ¾Ð¼Ð¿Ð°Ñ
--ÐÐ°Ð¼ÐµÐ½ÑÐµÑ ÑÐ°Ð±ÑÑ Ð½Ð° Ð¿ÑÐ¾Ð±ÐµÐ»Ñ Ð¸ Ð²Ð¸Ð½Ð´Ð¾Ð²ÑÐ¹ Ð²Ð¾Ð·Ð²ÑÐ°Ñ ÐºÐ°ÑÐµÑÐºÐ¸ Ð½Ð° ÑÐµÐ»Ð¾Ð²ÐµÑÐµÑÐºÐ¸Ð¹ UNIX-Ð¾Ð²ÑÐºÐ¸Ð¹
function ecs.stringOptimize(sto4ka, indentatonWidth)
    sto4ka = string.gsub(sto4ka, "\r\n", "\n")
    sto4ka = string.gsub(sto4ka, "	", string.rep(" ", indentatonWidth or 2))
    return stro4ka
end

--ÐÐ ÐÐÐ¡Ð¯Ð¢ÐÐ§ÐÐÐ Ð Ð¨ÐÐ¡Ð¢ÐÐÐÐ¦ÐÐ¢ÐÐ ÐÐ§ÐÐ£Ð®
function ecs.decToBase(IN,BASE)
    local hexCode = "0123456789ABCDEFGHIJKLMNOPQRSTUVW"
    OUT = ""
    local ostatok = 0
    while IN>0 do
        ostatok = math.fmod(IN,BASE) + 1
        IN = math.floor(IN/BASE)
        OUT = string.sub(hexCode,ostatok,ostatok)..OUT
    end
    if #OUT == 1 then OUT = "0"..OUT end
    if OUT == "" then OUT = "00" end
    return OUT
end

--ÐÑÐ°Ð²Ð¸Ð»ÑÐ½Ð¾Ðµ ÐºÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ HEX-Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð² ÑÑÑÐ¾ÐºÐ¾Ð²ÑÑ
function ecs.HEXtoString(color, bitCount, withNull)
	local stro4ka = string.format("%X",color)
	local sStro4ka = unicode.len(stro4ka)
	if sStro4ka < bitCount then
		stro4ka = string.rep("0", bitCount - sStro4ka) .. stro4ka
	end
	sStro4ka = nil
	if withNull then return "0x"..stro4ka else return stro4ka end
end

--ÐÐÐÐÐÐ£ÐÐ ÐÐ Ð ÐÐÐÐ£
function ecs.clickedAtArea(x,y,sx,sy,ex,ey)
  if (x >= sx) and (x <= ex) and (y >= sy) and (y <= ey) then return true end    
  return false
end

--ÐÐ°Ð»Ð¸Ð²ÐºÐ° Ð²ÑÐµÐ³Ð¾ ÑÐºÑÐ°Ð½Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÑÐ²ÐµÑÐ¾Ð¼
function ecs.clearScreen(color)
  if color then component.gpu.setBackground(color) end
  term.clear()
end

--Ð£ÑÑÐ°Ð½Ð¾Ð²ÐºÐ° Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð½ÑÐ¶Ð½Ð¾Ð³Ð¾ ÑÐ²ÐµÑÐ°
function ecs.setPixel(x,y,color)
  component.gpu.setBackground(color)
  component.gpu.set(x,y," ")
end

--ÐÑÐ¾ÑÑÐ°Ñ ÑÑÑÐ°Ð½Ð¾Ð²ÐºÐ° ÑÐ²ÐµÑÐ¾Ð² Ð² Ð¾Ð´Ð½Ñ ÑÑÑÐ¾ÐºÑ, Ð¸Ð±Ð¾ Ñ Ð»ÐµÐ½Ð¸Ð²ÑÐ¹
function ecs.setColor(background, foreground)
	component.gpu.setBackground(background)
	component.gpu.setForeground(foreground)
end

--Ð¦Ð²ÐµÑÐ½Ð¾Ð¹ ÑÐµÐºÑÑ
function ecs.colorText(x,y,textColor,text)
  component.gpu.setForeground(textColor)
  component.gpu.set(x,y,text)
end

--Ð¦Ð²ÐµÑÐ½Ð¾Ð¹ ÑÐµÐºÑÑ Ñ Ð¶Ð¾Ð¿ÐºÐ¾Ð¹!
function ecs.colorTextWithBack(x,y,textColor,backColor,text)
  component.gpu.setForeground(textColor)
  component.gpu.setBackground(backColor)
  component.gpu.set(x,y,text)
end

--ÐÐ½Ð²ÐµÑÑÐ¸Ñ ÑÐ²ÐµÑÐ°
function ecs.invertColor(color)
  return 0xffffff - color
end

--ÐÐ´Ð°Ð¿ÑÐ¸Ð²Ð½ÑÐ¹ ÑÐµÐºÑÑ, Ð¿Ð¾Ð´ÑÑÑÐ°Ð¸Ð²Ð°ÑÑÐ¸Ð¹ÑÑ Ð¿Ð¾Ð´ ÑÐ¾Ð½
function ecs.adaptiveText(x,y,text,textColor)
  component.gpu.setForeground(textColor)
  x = x - 1
  for i=1,unicode.len(text) do
    local info = {component.gpu.get(x+i,y)}
    component.gpu.setBackground(info[3])
    component.gpu.set(x+i,y,unicode.sub(text,i,i))
  end
end

--ÐÐ¾ÑÑÑÐ»ÑÐ½Ð°Ñ Ð·Ð°Ð¼ÐµÐ½Ð° Ð¾Ð±ÑÑÐ½Ð¾Ð¼Ñ string.find()
--Ð Ð°Ð±Ð¾ÑÐ°ÐµÑ Ð¼ÐµÐ´Ð»ÐµÐ½Ð½ÐµÐµ, Ð½Ð¾ ÑÐ¾ÑÑ Ð±Ñ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑ ÑÐ½Ð¸ÐºÐ¾Ð´
function unicode.find(str, pattern, init, plain)
	if init then
		if init < 0 then
			init = -#unicode.sub(str,init)
		elseif init > 0 then
			init = #unicode.sub(str,1,init-1)+1
		end
	end
	
	a, b = string.find(str, pattern, init, plain)
	
	if a then
		local ap,bp = str:sub(1,a-1), str:sub(a,b)
		a = unicode.len(ap)+1
		b = a + unicode.len(bp)-1
		return a,b
	else
		return a
	end
end

--Ð£Ð¼Ð½ÑÐ¹ ÑÐµÐºÑÑ Ð¿Ð¾ Ð°Ð½Ð°Ð»Ð¾Ð³Ð¸Ð¸ Ñ Ð¼Ð°Ð¹Ð½ÑÐ°ÑÐ¾Ð²ÑÐºÐ¸Ð¼. Ð¡ÑÐ°Ð²Ð¸ÑÑ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð¿Ð°ÑÐ°Ð³ÑÐ°ÑÐ°, ÑÐºÐ°Ð·ÑÐ²Ð°ÐµÑÑ ÑÑÐ¹Ð½Ñ - Ð¸ ÑÑÑÐºÑ! Ð Ð°Ð±Ð¾ÑÐ°ÐµÑ!
function ecs.smartText(x, y, text)
	local sText = unicode.len(text)
	local specialSymbol = "Â§"
	--Ð Ð°Ð·Ð±Ð¸ÑÐ°ÐµÐ¼ Ð¿Ð¾ ÐºÑÑÐ¾ÑÐºÐ°Ð¼ ÑÑÑÐ¾ÐºÑ Ð¸ Ð¿Ð¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ²ÐµÑÐ°
	local massiv = {}
	local iterator = 1
	local currentColor = component.gpu.getForeground()
	while iterator <= sText do
		local symbol = unicode.sub(text, iterator, iterator)
		if symbol == specialSymbol then
			currentColor = ecs.colors[unicode.sub(text, iterator + 1, iterator + 1) or "f"]
			iterator = iterator + 1
		else
			table.insert(massiv, {symbol, currentColor})
		end
		symbol = nil
		iterator = iterator + 1
	end
	x = x - 1
	for i = 1, #massiv do
		if currentColor ~= massiv[i][2] then currentColor = massiv[i][2]; component.gpu.setForeground(massiv[i][2]) end
		component.gpu.set(x + i, y, massiv[i][1])
	end
end

--ÐÐ½Ð°Ð»Ð¾Ð³ ÑÐ¼Ð½Ð¾Ð³Ð¾ ÑÐµÐºÑÑÐ°, Ð½Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑÑÐ¸Ð¹ HEX-ÑÐ²ÐµÑÐ° Ð´Ð»Ñ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²ÐºÐ¸
function ecs.formattedText(x, y, text, limit)
	--ÐÐ³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ðµ Ð´Ð»Ð¸Ð½Ñ ÑÑÑÐ¾ÐºÐ¸
	limit = limit or math.huge
	--Ð¡ÑÐ°ÑÑÐ¾Ð²Ð°Ñ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ñ ÐºÑÑÑÐ¾ÑÐ° Ð´Ð»Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸
	local xPos = x
	--Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð¼Ð°ÑÑÐ¸Ð² ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð² Ð´Ð°Ð½Ð½Ð¾Ð¹ ÑÑÑÐ¾ÐºÐ¸
	local symbols = {}
	for i = 1, unicode.len(text) do table.insert(symbols, unicode.sub(text, i, i)) end
	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð²ÑÐµ ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ ÑÑÑÐ¾ÐºÐ¸, Ð¿Ð¾ÐºÐ° Ð½Ðµ Ð¿ÐµÑÐµÐ±ÐµÑÐµÐ¼ Ð²ÑÐµ Ð¸Ð»Ð¸ Ð½Ðµ Ð´Ð¾ÑÑÐ¸Ð³Ð½ÐµÐ¼ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð»Ð¸Ð¼Ð¸ÑÐ°
	local i = 1
	while i <= #symbols and i <= limit do
		--ÐÑÐ»Ð¸ Ð½Ð°ÑÐ¾Ð´Ð¸Ð¼ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð¿Ð°ÑÐ°Ð³ÑÐ°ÑÐ°, ÑÐ¾
		if symbols[i] == "Â§" then
			--ÐÐµÐ½ÑÐµÐ¼ ÑÐ²ÐµÑ ÑÐµÐºÑÑÐ° Ð½Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹
			component.gpu.setForeground(tonumber("0x" .. symbols[i+1] .. symbols[i+2] .. symbols[i+3] .. symbols[i+4] .. symbols[i+5] .. symbols[i+6]))
			--Ð£Ð²ÐµÐ»Ð¸ÑÐ¸Ð²Ð°ÐµÐ¼ Ð»Ð¸Ð¼Ð¸Ñ Ð½Ð° 7, Ñ.Ðº.
			limit = limit + 7
			--Ð¡Ð´Ð²Ð¸Ð³Ð°ÐµÐ¼ Ð¸ÑÐµÑÐ°ÑÐ¾Ñ ÑÐ¸ÐºÐ»Ð° Ð½Ð° 7
			i = i + 7
		end
		--Ð Ð¸ÑÑÐµÐ¼ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð½Ð° Ð½ÑÐ¶Ð½Ð¾Ð¹ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ð¸
		component.gpu.set(xPos, y, symbols[i])
		--Ð£Ð²ÐµÐ»Ð¸ÑÐ¸Ð²Ð°ÐµÐ¼ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ñ ÐºÑÑÑÐ¾ÑÐ° Ð¸ Ð¸ÑÐµÑÐ°ÑÐ¾Ñ Ð½Ð° 1
		xPos = xPos + 1
		i = i + 1
	end
end

--ÐÐ½Ð²ÐµÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹ ÑÐµÐºÑÑ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÐ²ÐµÑÐ° ÑÐ¾Ð½Ð°
function ecs.invertedText(x,y,symbol)
  local info = {component.gpu.get(x,y)}
  ecs.adaptiveText(x,y,symbol,ecs.invertColor(info[3]))
end

--ÐÐ´Ð°Ð¿ÑÐ¸Ð²Ð½Ð¾Ðµ Ð¾ÐºÑÑÐ³Ð»ÐµÐ½Ð¸Ðµ ÑÐ¸ÑÐ»Ð°
function ecs.adaptiveRound(chislo)
  local celaya,drobnaya = math.modf(chislo)
  if drobnaya >= 0.5 then
    return (celaya + 1)
  else
    return celaya
  end
end

--ÐÐºÑÑÐ³Ð»ÐµÐ½Ð¸Ðµ Ð´Ð¾ Ð¾Ð¿ÑÐµÐ´. ÐºÐ¾Ð»-Ð²Ð° Ð·Ð½Ð°ÐºÐ¾Ð² Ð¿Ð¾ÑÐ»Ðµ Ð·Ð°Ð¿ÑÑÐ¾Ð¹
function ecs.round(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

--ÐÐ±ÑÑÐ½ÑÐ¹ ÐºÐ²Ð°Ð´ÑÐ°Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ²ÐµÑÐ°
function ecs.square(x,y,width,height,color)
  component.gpu.setBackground(color)
  component.gpu.fill(x,y,width,height," ")
end

--Ð®Ð½Ð¸ÐºÐ¾Ð´Ð¾Ð²ÑÐºÐ°Ñ ÑÐ°Ð¼ÐºÐ°
function ecs.border(x, y, width, height, back, fore)
	local stringUp = "â"..string.rep("â", width - 2).."â"
	local stringDown = "â"..string.rep("â", width - 2).."â"
	component.gpu.setForeground(fore)
	component.gpu.setBackground(back)
	component.gpu.set(x, y, stringUp)
	component.gpu.set(x, y + height - 1, stringDown)

	local yPos = 1
	for i = 1, (height - 2) do
		component.gpu.set(x, y + yPos, "â")
		component.gpu.set(x + width - 1, y + yPos, "â")
		yPos = yPos + 1
	end
end

--ÐÐ½Ð¾Ð¿ÐºÐ° Ð² Ð²Ð¸Ð´Ðµ ÑÐµÐºÑÑÐ° Ð² ÑÐ°Ð¼ÐºÐµ
function ecs.drawFramedButton(x, y, width, height, text, color)
	ecs.border(x, y, width, height, component.gpu.getBackground(), color)
	component.gpu.fill(x + 1, y + 1, width - 2, height - 2, " ")
	x = x + math.floor(width / 2 - unicode.len(text) / 2)
	y = y + math.floor(width / 2 - 1)
	component.gpu.set(x, y, text)
end

--Ð®Ð½Ð¸ÐºÐ¾Ð´Ð¾Ð²ÑÐºÐ¸Ð¹ ÑÐ°Ð·Ð´ÐµÐ»Ð¸ÑÐµÐ»Ñ
function ecs.separator(x, y, width, back, fore)
	ecs.colorTextWithBack(x, y, fore, back, string.rep("â", width))
end

--ÐÐ²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¾Ðµ ÑÐµÐ½ÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ ÑÐµÐºÑÑÐ° Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐµ (x, y, xy)
function ecs.centerText(mode,coord,text)
	local dlina = unicode.len(text)
	local xSize,ySize = component.gpu.getResolution()

	if mode == "x" then
		component.gpu.set(math.floor(xSize/2-dlina/2),coord,text)
	elseif mode == "y" then
		component.gpu.set(coord,math.floor(ySize/2),text)
	else
		component.gpu.set(math.floor(xSize/2-dlina/2),math.floor(ySize/2),text)
	end
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° "Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ" Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¼Ð°ÑÑÐ¸Ð²Ñ
function ecs.drawCustomImage(x,y,pixels)
	x = x - 1
	y = y - 1
	local pixelsWidth = #pixels[1]
	local pixelsHeight = #pixels
	local xEnd = x + pixelsWidth
	local yEnd = y + pixelsHeight

	for i=1,pixelsHeight do
		for j=1,pixelsWidth do
			if pixels[i][j][3] ~= "#" then
				if component.gpu.getBackground() ~= pixels[i][j][1] then component.gpu.setBackground(pixels[i][j][1]) end
				if component.gpu.getForeground() ~= pixels[i][j][2] then component.gpu.setForeground(pixels[i][j][2]) end
				component.gpu.set(x+j,y+i,pixels[i][j][3])
			end
		end
	end

	return (x+1),(y+1),xEnd,yEnd
end

--ÐÐ¾ÑÑÐµÐºÑÐ¸ÑÐ¾Ð²ÐºÐ° ÑÑÐ°ÑÑÐ¾Ð²ÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ. Core-ÑÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð²ÑÐµÑ Ð¼Ð¾Ð¸Ñ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼
function ecs.correctStartCoords(xStart,yStart,xWindowSize,yWindowSize)
	local xSize,ySize = component.gpu.getResolution()
	if xStart == "auto" then
		xStart = math.floor(xSize/2 - xWindowSize/2)
	end
	if yStart == "auto" then
		yStart = math.ceil(ySize/2 - yWindowSize/2)
	end
	return xStart,yStart
end

--ÐÐ°Ð¿Ð¾Ð¼Ð½Ð¸ÑÑ Ð¾Ð±Ð»Ð°ÑÑÑ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹ Ð¸ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ¸ÑÑ ÐµÐµ Ð² Ð²Ð¸Ð´Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ð°
function ecs.rememberOldPixels(x, y, x2, y2)
	local newPNGMassiv = { ["backgrounds"] = {} }
	local xSize, ySize = component.gpu.getResolution()
	newPNGMassiv.x, newPNGMassiv.y = x, y

	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð²ÐµÑÑ Ð¼Ð°ÑÑÐ¸Ð² ÑÑÐ°Ð½Ð´Ð°ÑÑÐ½Ð¾Ð³Ð¾ PNG-Ð²Ð¸Ð´Ð° Ð¿Ð¾ Ð²ÑÑÐ¾ÑÐµ
	local xCounter, yCounter = 1, 1
	for j = y, y2 do
		xCounter = 1
		for i = x, x2 do

			if (i > xSize or i < 0) or (j > ySize or j < 0) then
				error("Can't remember pixel, because it's located behind the screen: x("..i.."), y("..j..") out of xSize("..xSize.."), ySize("..ySize..")\n")
			end

			local symbol, fore, back = component.gpu.get(i, j)

			newPNGMassiv["backgrounds"][back] = newPNGMassiv["backgrounds"][back] or {}
			newPNGMassiv["backgrounds"][back][fore] = newPNGMassiv["backgrounds"][back][fore] or {}

			table.insert(newPNGMassiv["backgrounds"][back][fore], {xCounter, yCounter, symbol} )

			xCounter = xCounter + 1
			back, fore, symbol = nil, nil, nil
		end

		yCounter = yCounter + 1
	end

	xSize, ySize = nil, nil
	return newPNGMassiv
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð·Ð°Ð¿Ð¾Ð¼Ð½ÐµÐ½Ð½ÑÐµ ÑÐ°Ð½ÐµÐµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸ Ð¸Ð· Ð¼Ð°ÑÑÐ¸Ð²Ð°
function ecs.drawOldPixels(massivSudaPihay)
	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð¼Ð°ÑÑÐ¸Ð² Ñ ÑÐ¾Ð½Ð°Ð¼Ð¸
	for back, backValue in pairs(massivSudaPihay["backgrounds"]) do
		component.gpu.setBackground(back)
		for fore, foreValue in pairs(massivSudaPihay["backgrounds"][back]) do
			component.gpu.setForeground(fore)
			for pixel = 1, #massivSudaPihay["backgrounds"][back][fore] do
				if massivSudaPihay["backgrounds"][back][fore][pixel][3] ~= transparentSymbol then
					component.gpu.set(massivSudaPihay.x + massivSudaPihay["backgrounds"][back][fore][pixel][1] - 1, massivSudaPihay.y + massivSudaPihay["backgrounds"][back][fore][pixel][2] - 1, massivSudaPihay["backgrounds"][back][fore][pixel][3])
				end
			end
		end
	end
end

--ÐÐ³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ðµ Ð´Ð»Ð¸Ð½Ñ ÑÑÑÐ¾ÐºÐ¸. ÐÐ°ÑÑ-ÑÐµÐ² ÑÑÐ½ÐºÑÐ¸Ñ.
function ecs.stringLimit(mode, text, size, noDots)
	if unicode.len(text) <= size then return text end
	local length = unicode.len(text)
	if mode == "start" then
		if noDots then
			return unicode.sub(text, length - size + 1, -1)
		else
			return "â¦" .. unicode.sub(text, length - size + 2, -1)
		end
	else
		if noDots then
			return unicode.sub(text, 1, size)
		else
			return unicode.sub(text, 1, size - 1) .. "â¦"
		end
	end
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ ÑÐµÐºÑÑÐµÐµ ÑÐµÐ°Ð»ÑÐ½Ð¾Ðµ Ð²ÑÐµÐ¼Ñ ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑÐ°, ÑÐ¾ÑÑÑÑÐµÐ³Ð¾ ÑÐµÑÐ²ÐµÑ Ð¼Ð°Ð¹Ð½Ð°
function ecs.getHostTime(timezone)
	timezone = timezone or 2
	--Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ ÑÐ°Ð¹Ð» Ñ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½Ð½Ð¾Ð¹ Ð² Ð½ÐµÐ³Ð¾ Ð¿Ð°ÑÐ°ÑÐµÐ¹
    local file = io.open("HostTime.tmp", "w")
    file:write("")
    file:close()
    --ÐÐ¾ÑÑÐµÐºÑÐ¸Ñ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÐ°ÑÐ¾Ð²Ð¾Ð³Ð¾ Ð¿Ð¾ÑÑÐ°
    local timeCorrection = timezone * 3600
    --ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð´Ð°ÑÑ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ ÑÐ°Ð¹Ð»Ð° Ð² ÑÐ½Ð¸ÐºÑ-Ð²Ð¸Ð´Ðµ
    local lastModified = tonumber(string.sub(fs.lastModified("HostTime.tmp"), 1, -4)) + timeCorrection
    --Ð£Ð´Ð°Ð»ÑÐµÐ¼ ÑÐ°Ð¹Ð», Ð¸Ð±Ð¾ Ð½Ð° ÑÑÐ¹ Ð¾Ð½ Ð½Ð°Ð¼ Ð½Ðµ Ð½ÑÐ¶ÐµÐ½
    fs.remove("HostTime.tmp")
    --ÐÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÑÐµÐ¼ ÑÐ½Ð¸ÐºÑ-Ð²ÑÐµÐ¼Ñ Ð² Ð½Ð¾ÑÐ¼ Ð²ÑÐµÐ¼Ñ
    local year, month, day, hour, minute, second = os.date("%Y", lastModified), os.date("%m", lastModified), os.date("%d", lastModified), os.date("%H", lastModified), os.date("%M", lastModified), os.date("%S", lastModified)
    --ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð²ÑÐµ
    return tonumber(day), tonumber(month), tonumber(year), tonumber(hour), tonumber(minute), tonumber(second)
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ ÑÐ¿Ð¸ÑÐºÐ¾Ðº ÑÐ°Ð¹Ð»Ð¾Ð² Ð¸Ð· ÐºÐ¾Ð½ÐºÑÐµÑÐ½Ð¾Ð¹ Ð´Ð¸ÑÐµÐºÑÐ¾ÑÐ¸Ð¸, ÐºÐ¾ÑÑÑÐ»Ñ
function ecs.getFileList(path)
	local list = fs.list(path)
	local massiv = {}
	for file in list do
		--if string.find(file, "%/$") then file = unicode.sub(file, 1, -2) end
		table.insert(massiv, file)
	end
	list = nil
	return massiv
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ ÑÐ°Ð¹Ð»Ð¾Ð²Ð¾Ðµ Ð´ÑÐµÐ²Ð¾. Ð¡Ð¸Ð»ÑÐ½Ð¾ Ð½Ð°Ð³ÑÑÐ¶Ð°ÐµÑ ÑÐ¸ÑÑÐµÐ¼Ñ, ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ Ð´ÐµÐ±Ð°Ð³Ð°!
function ecs.getFileTree(path)
	local massiv = {}
	local list = ecs.getFileList(path)
	for key, file in pairs(list) do
		if fs.isDirectory(path.."/"..file) then
			table.insert(massiv, getFileTree(path.."/"..file))
		else
			table.insert(massiv, file)
		end
	end
	list = nil

	return massiv
end

--ÐÐ¾Ð¸ÑÐº Ð¿Ð¾ ÑÐ°Ð¹Ð»Ð¾Ð²Ð¾Ð¹ ÑÐ¸ÑÑÐµÐ¼Ðµ
function ecs.find(path, cheBudemIskat)
	--ÐÐ°ÑÑÐ¸Ð², Ð² ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ Ð±ÑÐ´ÑÑ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑÑ Ð²ÑÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð½ÑÐµ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¸Ñ
	local massivNaydennogoGovna = {}
	--ÐÐ¾ÑÑÑÐ»Ñ, Ð½Ð¾ ÑÐ´Ð¾Ð±Ð½ÑÐ¹
	local function dofind(path, cheBudemIskat)
		--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐ°Ð¹Ð»Ð¾Ð² Ð² Ð´Ð¸ÑÐµÐºÑÐ¾ÑÐ¸Ð¸
		local list = ecs.getFileList(path)
		--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð²ÑÐµ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ ÑÐ°Ð¹Ð» Ð»Ð¸ÑÑÐ°
		for key, file in pairs(list) do
			--ÐÑÑÑ Ðº ÑÐ°Ð¹Ð»Ñ
			local pathToFile = path..file
			--ÐÑÐ»Ð¸ Ð½Ð°ÑÐ»Ð¾ ÑÐ¾Ð²Ð¿Ð°Ð´ÐµÐ½Ð¸Ðµ Ð² Ð¸Ð¼ÐµÐ½Ð¸ ÑÐ°Ð¹Ð»Ð°, ÑÐ¾ Ð²ÑÐ´Ð°ÐµÑ Ð¿ÑÑÑ Ðº ÑÑÐ¾Ð¼Ñ ÑÐ°Ð¹Ð»Ñ
			if string.find(unicode.lower(file), unicode.lower(cheBudemIskat)) then
				table.insert(massivNaydennogoGovna, pathToFile)
			end
			--ÐÐ½Ð°Ð»Ð¸Ð·, ÑÑÐ¾ Ð´ÐµÐ»Ð°ÑÑ Ð´Ð°Ð»ÑÑÐµ
			if fs.isDirectory(pathToFile) then
				dofind(pathToFile, cheBudemIskat)
			end
			--ÐÑÐ¸ÑÐ°ÐµÐ¼ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²ÐºÑ
			pathToFile = nil
		end
		--ÐÑÐ¸ÑÐ°ÐµÐ¼ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²ÐºÑ
		list = nil
	end
	--ÐÑÐ¿Ð¾Ð»Ð½ÑÐµÐ¼ ÑÑÐ½ÐºÑÐ¸Ñ
	dofind(path, cheBudemIskat)
	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼, ÑÐµ Ð½Ð°ÑÐ»Ð¾
	return massivNaydennogoGovna
end

--ÐÐ¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÐ¾ÑÐ¼Ð°ÑÐ° ÑÐ°Ð¹Ð»Ð°
function ecs.getFileFormat(path)
	local name = fs.name(path)
	local starting, ending = string.find(name, "(.)%.[%d%w]*$")
	if starting == nil then
		return nil
	else
		return unicode.sub(name,starting + 1, -1)
	end
	name, starting, ending = nil, nil, nil
end

--ÐÑÐ¾Ð²ÐµÑÐ¸ÑÑ, ÑÐºÑÑÑÑÐ¹ Ð»Ð¸ ÑÐ°Ð¹Ð» (.Ð¿Ð¸Ð´Ð¾Ñ, .ÑÑÐ¹ = true; Ð¿Ð¸Ð´Ð¾Ñ, ÑÑÐ¹ = false)
function ecs.isFileHidden(path)
	local name = fs.name(path)
	local starting, ending = string.find(name, "^%.(.*)$")
	if starting == nil then
		return false
	else
		return true
	end
	name, starting, ending = nil, nil, nil
end

--Ð¡ÐºÑÑÑÑ ÑÐ¾ÑÐ¼Ð°Ñ ÑÐ°Ð¹Ð»Ð°
function ecs.hideFileFormat(path)
	local name = fs.name(path)
	local fileFormat = ecs.getFileFormat(name)
	if fileFormat == nil then
		return name
	else
		return unicode.sub(name, 1, unicode.len(name) - unicode.len(fileFormat))
	end
end

--ÐÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ ÐºÐ»Ð¸ÐºÐ° Ð»Ð¸Ð±Ð¾ Ð½Ð°Ð¶Ð°ÑÐ¸Ñ ÐºÐ°ÐºÐ¾Ð¹-Ð»Ð¸Ð±Ð¾ ÐºÐ»Ð°Ð²Ð¸ÑÐ¸
function ecs.waitForTouchOrClick()
	while true do
		local e = { event.pull() }
		if e[1] == "key_down" or e[1] == "touch" then break end
	end
end

--Ð¢Ð¾ Ð¶Ðµ ÑÐ°Ð¼Ð¾Ðµ, Ð½Ð¾ Ð² ÑÐ¾ÐºÑÐ°ÑÐµÐ½Ð½Ð¾Ð¼ Ð²Ð°ÑÐ¸Ð°Ð½ÑÐµ
function ecs.wait()
	ecs.waitForTouchOrClick()
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÐºÐ½Ð¾Ð¿Ð¾ÑÐºÐ¸ Ð·Ð°ÐºÑÑÑÐ¸Ñ Ð¾ÐºÐ½Ð°
function ecs.drawCloses(x, y, active)
	local symbol = "â®¾"
	ecs.colorText(x, y , (active == 1 and ecs.colors.blue) or 0xCC4C4C, symbol)
	ecs.colorText(x + 2, y , (active == 2 and ecs.colors.blue) or 0xDEDE6C, symbol)
	ecs.colorText(x + 4, y , (active == 3 and ecs.colors.blue) or 0x57A64E, symbol)
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð²ÐµÑÑÐ½ÑÑ Ð¾ÐºÐ¾Ð½Ð½ÑÑ Ð¿Ð°Ð½ÐµÐ»Ñ Ñ Ð²ÑÐ±Ð¾ÑÐ¾Ð¼ Ð¾Ð±ÑÐµÐºÑÐ¾Ð²
function ecs.drawTopBar(x, y, width, selectedObject, background, foreground, ...)
	local objects = { ... }
	ecs.square(x, y, width, 3, background)
	local widthOfObjects = 0
	local spaceBetween = 2
	for i = 1, #objects do
		widthOfObjects = widthOfObjects + unicode.len(objects[i][1]) + spaceBetween
	end
	local xPos = x + math.floor(width / 2 - widthOfObjects / 2)
	for i = 1, #objects do
		if i == selectedObject then
			ecs.square(xPos, y, unicode.len(objects[i][1]) + spaceBetween, 3, ecs.colors.blue)
			component.gpu.setForeground(0xffffff)
		else
			component.gpu.setBackground(background)
			component.gpu.setForeground(foreground)
		end
		component.gpu.set(xPos + spaceBetween / 2, y + 2, objects[i][1])
		component.gpu.set(xPos + math.ceil(unicode.len(objects[i][1]) / 2), y + 1, objects[i][2])

		xPos = xPos + unicode.len(objects[i][1]) + spaceBetween
	end
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¾Ð¿-Ð¼ÐµÐ½Ñ, Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»ÑÐ½Ð°Ñ Ð¿Ð¾Ð»Ð¾ÑÐºÐ° ÑÐ°ÐºÐ°Ñ Ñ ÑÐµÐºÑÑÐ°Ð¼Ð¸
function ecs.drawTopMenu(x, y, width, color, selectedObject, ...)
	local objects = { ... }
	local objectsToReturn = {}
	local xPos = x + 2
	local spaceBetween = 2
	ecs.square(x, y, width, 1, color)
	for i = 1, #objects do
		if i == selectedObject then
			ecs.square(xPos - 1, y, unicode.len(objects[i][1]) + spaceBetween, 1, ecs.colors.blue)
			component.gpu.setForeground(0xffffff)
			component.gpu.set(xPos, y, objects[i][1])
			component.gpu.setForeground(objects[i][2])
			component.gpu.setBackground(color)
		else
			if component.gpu.getForeground() ~= objects[i][2] then component.gpu.setForeground(objects[i][2]) end
			component.gpu.set(xPos, y, objects[i][1])
		end
		objectsToReturn[objects[i][1]] = { xPos, y, xPos + unicode.len(objects[i][1]) - 1, y, i }
		xPos = xPos + unicode.len(objects[i][1]) + spaceBetween
	end
	return objectsToReturn
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ ÐºÐ½Ð¾Ð¿ÐºÐ¸ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ ÑÐ¸ÑÐ¸Ð½Ñ
function ecs.drawButton(x,y,width,height,text,backColor,textColor)
	x,y = ecs.correctStartCoords(x,y,width,height)

	local textPosX = math.floor(x + width / 2 - unicode.len(text) / 2)
	local textPosY = math.floor(y + height / 2)
	ecs.square(x,y,width,height,backColor)
	ecs.colorText(textPosX,textPosY,textColor,text)

	return x, y, (x + width - 1), (y + height - 1)
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° ÐºÐ½Ð¾Ð¿ÐºÐ¸ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼Ð¸ Ð¾ÑÑÑÑÐ¿Ð°Ð¼Ð¸ Ð¾Ñ ÑÐµÐºÑÑÐ°
function ecs.drawAdaptiveButton(x,y,offsetX,offsetY,text,backColor,textColor)
	local length = unicode.len(text)
	local width = offsetX*2 + length
	local height = offsetY*2 + 1

	x,y = ecs.correctStartCoords(x,y,width,height)

	ecs.square(x,y,width,height,backColor)
	ecs.colorText(x+offsetX,y+offsetY,textColor,text)

	return x,y,(x+width-1),(y+height-1)
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¾ÐºÐ¾Ð½Ð½Ð¾Ð¹ "ÑÐµÐ½Ð¸"
function ecs.windowShadow(x,y,width,height)
	component.gpu.setBackground(ecs.windowColors.shadow)
	component.gpu.fill(x+width,y+1,2,height," ")
	component.gpu.fill(x+1,y+height,width,1," ")
end

--ÐÑÐ¾ÑÑÐ¾ Ð±ÐµÐ»Ð¾Ðµ Ð¾ÐºÐ¾ÑÐºÐ¾ Ñ ÑÐµÐ½ÑÑ
function ecs.blankWindow(x,y,width,height)
	local oldPixels = ecs.rememberOldPixels(x,y,x+width+1,y+height)

	ecs.square(x,y,width,height,ecs.windowColors.background)

	ecs.windowShadow(x,y,width,height)

	return oldPixels
end

--ÐÐµÐ»Ð¾Ðµ Ð¾ÐºÐ¾ÑÐºÐ¾, Ð½Ð¾ ÑÐ¶Ðµ Ñ ÑÐ¸ÑÐ»Ð¾Ð¼ Ð²Ð²ÐµÑÑÑ!
function ecs.emptyWindow(x,y,width,height,title)

	local oldPixels = ecs.rememberOldPixels(x,y,x+width+1,y+height)

	--ÐÐÐÐ
	component.gpu.setBackground(ecs.windowColors.background)
	component.gpu.fill(x,y+1,width,height-1," ")

	--Ð¢ÐÐ Ð¡ÐÐÐ Ð¥Ð£
	component.gpu.setBackground(ecs.windowColors.tab)
	component.gpu.fill(x,y,width,1," ")

	--Ð¢ÐÐ¢Ð
	component.gpu.setForeground(ecs.windowColors.title)
	local textPosX = x + math.floor(width/2-unicode.len(title)/2) -1
	component.gpu.set(textPosX,y,title)

	--Ð¢ÐÐÐ¬
	ecs.windowShadow(x,y,width,height)

	return oldPixels

end

function ecs.getWordsArrayFromString(s)
	local words = {} 
	for word in string.gmatch(s, "[^%s]+") do table.insert(words, word) end
	return words
end

--ÐÐ¾Ñ Ð»ÑÐ±Ð¸Ð¼Ð°Ñ ÑÑÐ½ÐºÑÐ¸Ñ Ð¾ÑÐ¸Ð±ÐºÐ¸ C:
function ecs.error(...)
	local args = {...}
	local text = ""
	if #args > 1 then
		for i = 1, #args do
			--text = text .. "[" .. i .. "] = " .. tostring(args[i])
			if type(args[i]) == "string" then args[i] = "\"" .. args[i] .. "\"" end 
			text = text .. tostring(args[i])
			if i ~= #args then text = text .. ", " end
		end
	else
		text = tostring(args[1])
	end
	ecs.universalWindow("auto", "auto", math.ceil(component.gpu.getResolution() * 0.45), ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x880000, "ÐÑÐ¸Ð±ÐºÐ°!"}, {"EmptyLine"}, {"WrappedText", 0x262626, text}, {"EmptyLine"}, {"Button", {0x880000, 0xffffff, "OK!"}})
end

--ÐÑÐ¸ÑÑÐ¸ÑÑ ÑÐºÑÐ°Ð½, ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÐºÐ¾Ð¼ÑÐ¾ÑÑÐ½ÑÐµ ÑÐ²ÐµÑÐ° Ð¸ Ð¿Ð¾ÑÑÐ°Ð²Ð¸ÑÑ ÐºÑÑÑÐ¾Ðº Ð½Ð° 1, 1
function ecs.prepareToExit(color1, color2)
	term.setCursor(1, 1)
	ecs.clearScreen(color1 or 0x333333)
	component.gpu.setForeground(color2 or 0xffffff)
	component.gpu.set(1, 1, "")
end

--ÐÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ñ Ð¸Ð· ÑÐ½Ð¸ÐºÐ¾Ð´Ð° Ð² ÑÐ¸Ð¼Ð²Ð¾Ð». ÐÑÐ¾Ð´Ðµ Ð½Ð¾ÑÐ¼, Ð° Ð²ÑÐ¾Ð´Ðµ Ð¸ Ð½Ðµ Ð½Ð¾ÑÐ¼. ÐÐ¾ Ð¿Ð¾Ð»ÐµÐ·Ð½Ð¾.
function ecs.convertCodeToSymbol(code)
	local symbol
	if code ~= 0 and code ~= 13 and code ~= 8 and code ~= 9 and code ~= 200 and code ~= 208 and code ~= 203 and code ~= 205 and not keyboard.isControlDown() then
		symbol = unicode.char(code)
		if keyboard.isShiftPressed then symbol = unicode.upper(symbol) end
	end
	return symbol
end

--Ð¨ÐºÐ°Ð»Ð° Ð¿ÑÐ¾Ð³ÑÐµÑÑÐ° - Ð¼Ð°ÑÑ-ÑÐµÐ²!
function ecs.progressBar(x, y, width, height, background, foreground, percent)
	local activeWidth = math.ceil(width * percent / 100)
	ecs.square(x, y, width, height, background)
	ecs.square(x, y, activeWidth, height, foreground)
end

--ÐÐºÐ¾ÑÐºÐ¾ Ñ Ð¿ÑÐ¾Ð³ÑÐµÑÑÐ±Ð°ÑÐ¾Ð¼! ÐÐ°Ð²Ð½Ð¾ ÑÐ¾ÑÐµÐ»
function ecs.progressWindow(x, y, width, percent, text, returnOldPixels)
	local height = 6
	local barWidth = width - 6

	x, y = ecs.correctStartCoords(x, y, width, height)

	local oldPixels
	if returnOldPixels then
		oldPixels = ecs.rememberOldPixels(x, y, x + width + 1, y + height)
	end

	ecs.emptyWindow(x, y, width, height, " ")
	ecs.colorTextWithBack(x + math.floor(width / 2 - unicode.len(text) / 2), y + 4, 0x000000, ecs.windowColors.background, text)
	ecs.progressBar(x + 3, y + 2, barWidth, 1, 0xCCCCCC, ecs.colors.blue, percent)

	return oldPixels
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð²Ð²Ð¾Ð´Ð° ÑÐµÐºÑÑÐ° Ð² Ð¼Ð¸Ð½Ð¸-Ð¿Ð¾Ð»Ðµ.
function ecs.inputText(x, y, limit, cheBiloVvedeno, background, foreground, justDrawNotEvent, maskTextWith)
	limit = limit or 10
	cheBiloVvedeno = cheBiloVvedeno or ""
	background = background or 0xffffff
	foreground = foreground or 0x000000

	component.gpu.setBackground(background)
	component.gpu.setForeground(foreground)
	component.gpu.fill(x, y, limit, 1, " ")

	local text = cheBiloVvedeno

	local function draw()
		term.setCursorBlink(false)

		local dlina = unicode.len(text)
		local xCursor = x + dlina
		if xCursor > (x + limit - 1) then xCursor = (x + limit - 1) end

		if maskTextWith then
			component.gpu.set(x, y, ecs.stringLimit("start", string.rep("â", dlina), limit))
		else
			component.gpu.set(x, y, ecs.stringLimit("start", text, limit))
		end

		term.setCursor(xCursor, y)

		term.setCursorBlink(true)
	end

	draw()

	if justDrawNotEvent then term.setCursorBlink(false); return cheBiloVvedeno end

	while true do
		local e = {event.pull()}
		if e[1] == "key_down" then
			if e[4] == 14 then
				term.setCursorBlink(false)
				text = unicode.sub(text, 1, -2)
				if unicode.len(text) < limit then component.gpu.set(x + unicode.len(text), y, " ") end
				draw()
			elseif e[4] == 28 then
				term.setCursorBlink(false)
				return text
			else
				local symbol = ecs.convertCodeToSymbol(e[3])
				if symbol then
					text = text..symbol
					draw()
				end
			end
		elseif e[1] == "touch" then
			term.setCursorBlink(false)
			return text
		elseif e[1] == "clipboard" then
			if e[3] then
				text = text..e[3]
				draw()
			end
		end
	end
end

--Ð¡Ð¿ÑÐ¾ÑÐ¸ÑÑ, Ð·Ð°Ð¼ÐµÐ½ÑÑÑ Ð»Ð¸ ÑÐ°Ð¹Ð» (ÐµÑÐ»Ð¸ ÑÐ°ÐºÐ¾Ð²Ð¾Ð¹ ÑÐ¶Ðµ Ð¸Ð¼ÐµÐµÑÑÑ)
function ecs.askForReplaceFile(path, includeForAllButton)
	local cyka = {
		{"EmptyLine"}, 
		{"CenterText", 0x262626, "Ð¤Ð°Ð¹Ð» \"".. fs.name(path) .. "\" ÑÐ¶Ðµ Ð¸Ð¼ÐµÐµÑÑÑ Ð² ÑÑÐ¾Ð¼ Ð¼ÐµÑÑÐµ."}, 
		{"CenterText", 0x262626, "ÐÐ°Ð¼ÐµÐ½Ð¸ÑÑ ÐµÐ³Ð¾ Ð¿ÐµÑÐµÐ¼ÐµÑÐ°ÐµÐ¼ÑÐ¼ Ð¾Ð±ÑÐµÐºÑÐ¾Ð¼?"},
		{"EmptyLine"}
	}
	if includeForAllButton then table.insert(cyka, {"Switch", 0xF2B233, 0xffffff, 0x262626, "ÐÐ»Ñ Ð²ÑÐµÑ", true}) end
	table.insert(cyka, {"Button", {0x444444, 0xFFFFFF, "ÐÐ°Ð¼ÐµÐ½Ð¸ÑÑ"}, {0x666666, 0xFFFFFF, "ÐÑÐ¼ÐµÐ½Ð°"}})

	local action = ecs.universalWindow("auto", "auto", 46, ecs.windowColors.background, true, table.unpack(cyka))
	if action[includeForAllButton and 2 or 1] == "ÐÐ°Ð¼ÐµÐ½Ð¸ÑÑ" then
		return 1, action[includeForAllButton and 1]
	else
		return 2, action[includeForAllButton and 1]
	end
end

--ÐÑÐ¾Ð²ÐµÑÐ¸ÑÑ Ð¸Ð¼Ñ ÑÐ°Ð¹Ð»Ð° Ð½Ð° ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¸Ðµ ÐºÑÐ¸ÑÐµÑÐ¸ÑÐ¼
function ecs.checkName(name, path)
	--ÐÑÐ»Ð¸ Ð²Ð²ÐµÐ»Ð¸ ÑÑÐ¹Ð½Ñ ÐºÐ°ÐºÑÑ-ÑÐ¾, ÑÐ¾
	if name == "" or name == " " or name == nil then
		ecs.error("ÐÐµÐ²ÐµÑÐ½Ð¾Ðµ Ð¸Ð¼Ñ ÑÐ°Ð¹Ð»Ð°.")
		return false
	else
		--ÐÑÐ»Ð¸ ÑÐ°Ð¹Ð» Ñ Ð½Ð¾Ð²ÑÐ¼ Ð¿ÑÑÐµÐ¼ ÑÐ¶Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ, ÑÐ¾
		if fs.exists(path .. name) then
			ecs.error("Ð¤Ð°Ð¹Ð» \"".. name .. "\" ÑÐ¶Ðµ Ð¸Ð¼ÐµÐµÑÑÑ Ð² ÑÑÐ¾Ð¼ Ð¼ÐµÑÑÐµ.")
			return false
		--Ð ÐµÑÐ»Ð¸ Ð²ÑÐµ Ð·Ð°ÐµÐ±Ð¾Ðº, ÑÐ¾
		else
			return true
		end
	end
end

--ÐÐµÑÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð¾Ð² (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.rename(mainPath)
	--ÐÐ°Ð´Ð°ÐµÐ¼ ÑÑÐ°ÑÑÐ¾Ð²ÑÑ ÑÐ½ÑÐ³Ñ
	local name = fs.name(mainPath)
	path = fs.path(mainPath)
	--Ð Ð¸ÑÑÐµÐ¼ Ð¾ÐºÐ¾ÑÐºÐ¾ Ð²Ð²Ð¾Ð´Ð° Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¸Ð¼ÐµÐ½Ð¸ ÑÐ°Ð¹Ð»Ð°
	local inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "ÐÐµÑÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°ÑÑ"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, name}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})
	--ÐÐµÑÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²ÑÐ²Ð°ÐµÐ¼
	if ecs.checkName(inputs[1], path) then
		fs.rename(mainPath, path .. inputs[1])
	end
end

--Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð½Ð¾Ð²ÑÑ Ð¿Ð°Ð¿ÐºÑ (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.newFolder(path)
	--Ð Ð¸ÑÑÐµÐ¼ Ð¾ÐºÐ¾ÑÐºÐ¾ Ð²Ð²Ð¾Ð´Ð° Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¸Ð¼ÐµÐ½Ð¸ ÑÐ°Ð¹Ð»Ð°
	local inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "ÐÐ¾Ð²Ð°Ñ Ð¿Ð°Ð¿ÐºÐ°"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, ""}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})

	if ecs.checkName(inputs[1], path) then
		fs.makeDirectory(path .. inputs[1])
	end
end

--Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð½Ð¾Ð²ÑÐ¹ ÑÐ°Ð¹Ð» (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.newFile(path)
	--Ð Ð¸ÑÑÐµÐ¼ Ð¾ÐºÐ¾ÑÐºÐ¾ Ð²Ð²Ð¾Ð´Ð° Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¸Ð¼ÐµÐ½Ð¸ ÑÐ°Ð¹Ð»Ð°
	local inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "ÐÐ¾Ð²ÑÐ¹ ÑÐ°Ð¹Ð»"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, ""}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})

	if ecs.checkName(inputs[1], path) then
		local MineOSCore = require("MineOSCore")
		MineOSCore.safeLaunch(MineOSCore.paths.applications .. "/MineCode IDE.app/MineCode IDE.lua", "open", path .. inputs[1])
	end
end

--Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð½Ð¾Ð²Ð¾Ðµ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.newApplication(path, startName)
	--Ð Ð¸ÑÑÐµÐ¼ Ð¾ÐºÐ¾ÑÐºÐ¾ Ð²Ð²Ð¾Ð´Ð° Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¸Ð¼ÐµÐ½Ð¸ ÑÐ°Ð¹Ð»Ð°
	local inputs
	if not startName then
		inputs = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "ÐÐ¾Ð²Ð¾Ðµ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, "ÐÐ²ÐµÐ´Ð¸ÑÐµ Ð¸Ð¼Ñ"}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})
	end

	if ecs.checkName(inputs[1] .. ".app", path) then
		local name = path .. inputs[1] .. ".app/Resources/"
		fs.makeDirectory(name)
		fs.copy("MineOS/System/OS/Icons/SampleIcon.pic", name .. "Icon.pic")
		local file = io.open(path .. inputs[1] .. ".app/" .. inputs[1] .. ".lua", "w")
		file:write("local ecs = require(\"ECSAPI\")", "\n")
		file:write("ecs.universalWindow(\"auto\", \"auto\", 30, 0xeeeeee, true, {\"EmptyLine\"}, {\"CenterText\", 0x262626, \"Hello world!\"}, {\"EmptyLine\"}, {\"Button\", {0x880000, 0xffffff, \"Hello!\"}})", "\n")
		file:close()
	end
end

--Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÑÑÐµÑÑÐ²ÑÑÑÐµÐ³Ð¾ ÐÐ£Ð-ÑÐ°Ð¹Ð»Ð°
function ecs.newApplicationFromLuaFile(pathToLuaFile, pathWhereToCreateApplication)
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x000000, "ÐÐ¾Ð²Ð¾Ðµ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, "ÐÐ¼Ñ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ"}, {"Input", 0x262626, 0x880000, "ÐÑÑÑ Ðº Ð¸ÐºÐ¾Ð½ÐºÐµ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ"}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}})
	data[1] = data[1] or "MyApplication"
	data[2] = data[2] or "MineOS/System/OS/Icons/SampleIcon.pic"
	if fs.exists(data[2]) then
		fs.makeDirectory(pathWhereToCreateApplication .. "/" .. data[1] .. ".app/Resources")
		fs.copy(pathToLuaFile, pathWhereToCreateApplication .. "/" .. data[1] .. ".app/" .. data[1] .. ".lua")
		fs.copy(data[2], pathWhereToCreateApplication .. "/" .. data[1] .. ".app/Resources/Icon.pic")

		--ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x000000, "ÐÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¾Ð·Ð´Ð°Ð½Ð¾!"}, {"EmptyLine"}, {"Button", {ecs.colors.green, 0xffffff, "OK"}})
	else
		ecs.error("Ð£ÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ ÑÐ°Ð¹Ð» Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ.")
		return
	end
end

--ÐÑÐ¾ÑÑÐ¾Ðµ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¾Ð½Ð½Ð¾Ðµ Ð¾ÐºÐ¾ÑÐµÑÐºÐ¾. ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ ÑÑÐ°ÑÑÐµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸ - Ð¼Ð°Ð»Ð¾ Ð»Ð¸ Ð¿Ð¾Ð½Ð°Ð´Ð¾Ð±Ð¸ÑÑÑ.
function ecs.info(x, y, title, text)
	x = x or "auto"
	y = y or "auto"
	title = title or " "
	text = text or "Sample text"

	local width = unicode.len(text) + 4
	local height = 4
	x, y = ecs.correctStartCoords(x, y, width, height)

	local oldPixels = ecs.rememberOldPixels(x, y, x + width + 1, y + height)

	ecs.emptyWindow(x, y, width, height, title)
	ecs.colorTextWithBack(x + 2, y + 2, ecs.windowColors.usualText, ecs.windowColors.background, text)

	return oldPixels
end

--ÐÐµÑÑÐ¸ÐºÐ°Ð»ÑÐ½ÑÐ¹ ÑÐºÑÐ¾Ð»Ð»Ð±Ð°Ñ. ÐÐ°ÑÑ-ÑÐµÐ²!
function ecs.srollBar(x, y, width, height, countOfAllElements, currentElement, backColor, frontColor)
	local sizeOfScrollBar = math.ceil(1 / countOfAllElements * height)
	local displayBarFrom = math.floor(y + height * ((currentElement - 1) / countOfAllElements))

	ecs.square(x, y, width, height, backColor)
	ecs.square(x, displayBarFrom, width, sizeOfScrollBar, frontColor)

	sizeOfScrollBar, displayBarFrom = nil, nil
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¿Ð¾Ð»Ñ Ñ ÑÐµÐºÑÑÐ¾Ð¼. Ð¡ÑÐ´Ð° Ð¿Ð¸ÑÐ°ÑÑ Ð¼Ð°ÑÑÐ¸Ð² Ð²Ð¸Ð´Ð° {"ÑÑÑÐ¾ÐºÐ°1", "ÑÑÑÐ¾ÐºÐ°2", "ÑÑÑÐ¾ÐºÐ°3", ...}
function ecs.textField(x, y, width, height, lines, displayFrom, background, foreground, scrollbarBackground, scrollbarForeground)
	x, y = ecs.correctStartCoords(x, y, width, height)

	background = background or 0xffffff
	foreground = foreground or ecs.windowColors.usualText

	local sLines = #lines
	local lineLimit = width - 3

	--ÐÐ°ÑÑÐ¸Ð¼ ÑÑÑÐ¾ÐºÐ¸
	local line = 1
	while lines[line] do
		local sLine = unicode.len(lines[line])
		if sLine > lineLimit then
			local part1, part2 = unicode.sub(lines[line], 1, lineLimit), unicode.sub(lines[line], lineLimit + 1, -1)
			lines[line] = part1
			table.insert(lines, line + 1, part2)
			part1, part2 = nil, nil
		end
		line = line + 1
		sLine = nil
	end
	line = nil

	ecs.square(x, y, width - 1, height, background)
	ecs.srollBar(x + width - 1, y, 1, height, sLines, displayFrom, scrollbarBackground, scrollbarForeground)

	component.gpu.setBackground(background)
	component.gpu.setForeground(foreground)
	local yPos = y
	for i = displayFrom, (displayFrom + height - 1) do
		if lines[i] then
			component.gpu.set(x + 1, yPos, lines[i])
			yPos = yPos + 1
		else
			break
		end
	end

	return sLines
end

--ÐÐ¾Ð»ÑÑÐµÐ½Ð¸Ðµ Ð²ÐµÑÐ½Ð¾Ð³Ð¾ Ð¸Ð¼ÐµÐ½Ð¸ ÑÐ·ÑÐºÐ°. ÐÑÐ¾ÑÑÐ¾ Ð´Ð»Ñ Ð±ÐµÐ·Ð¾Ð¿Ð°ÑÐ½Ð¾ÑÑÐ¸. (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.getCorrectLangName(pathToLangs)
	local language = _G.OSSettings.language .. ".lang"
	if not fs.exists(pathToLangs .. "/" .. language) then
		language = "English.lang"
	end
	return language
end

--Ð§ÑÐµÐ½Ð¸Ðµ ÑÐ·ÑÐºÐ¾Ð²Ð¾Ð³Ð¾ ÑÐ°Ð¹Ð»Ð°  (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.readCorrectLangFile(pathToLangs)
	local lang
	
	local language = ecs.getCorrectLangName(pathToLangs)

	lang = config.readAll(pathToLangs .. "/" .. language)

	return lang
end

-------------------------ÐÐ¡Ð ÐÐÐ¯ ÐÐ¡ÐÐ-------------------------------------------------------------------------------

function ecs.searchInArray(array, textToSearch)
	local newArray = {}
	for i = 1, #array do
		if string.find(unicode.lower(array[i]), unicode.lower(textToSearch)) then table.insert(newArray, array[i]) end
	end
	return newArray
end

function ecs.sortFiles(path, fileList, sortingMethod, showHiddenFiles)
	local sortedFileList = {}
	if sortingMethod == "type" or sortingMethod == 0 then
		local typeList = {}
		for i = 1, #fileList do
			local fileFormat = ecs.getFileFormat(fileList[i]) or "Script"
			if fs.isDirectory(path .. fileList[i]) and fileFormat ~= ".app" then fileFormat = "Folder" end
			typeList[fileFormat] = typeList[fileFormat] or {}
			table.insert(typeList[fileFormat], fileList[i])
		end

		if typeList["Folder"] then
			for i = 1, #typeList["Folder"] do
				table.insert(sortedFileList, typeList["Folder"][i])
			end
			typeList["Folder"] = nil
		end

		for fileFormat in pairs(typeList) do
			for i = 1, #typeList[fileFormat] do
				table.insert(sortedFileList, typeList[fileFormat][i])
			end
		end
	elseif sortingMethod == "name" or sortingMethod == 1 then
		sortedFileList = fileList
	elseif sortingMethod == "date" or sortingMethod == 2 then
		for i = 1, #fileList do
			fileList[i] = {fileList[i], fs.lastModified(path .. fileList[i])}
		end
		table.sort(fileList, function(a,b) return a[2] > b[2] end)
		for i = 1, #fileList do
			table.insert(sortedFileList, fileList[i][1])
		end
	else
		error("Unknown sorting method: " .. tostring(sortingMethod))
	end

	local i = 1
	while i <= #sortedFileList do
		if not showHiddenFiles and ecs.isFileHidden(sortedFileList[i]) then
			table.remove(sortedFileList, i)
		else
			i = i + 1
		end
	end

	return sortedFileList
end

--Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÑÐ°Ð¹Ð» ÐºÐ¾Ð½ÑÐ¸Ð³ÑÑÐ°ÑÐ¸Ð¸ ÐÐ¡
function ecs.saveOSSettings()
	local pathToOSSettings = "MineOS/System/OS/OSSettings.cfg"
	if not _G.OSSettings then error("ÐÐ°ÑÑÐ¸Ð² Ð½Ð°ÑÑÑÐ¾ÐµÐº ÐÐ¡ Ð¾ÑÑÑÑÑÑÐ²ÑÐµÑ Ð² Ð¿Ð°Ð¼ÑÑÐ¸!") end
	fs.makeDirectory(fs.path(pathToOSSettings))
	local file = io.open(pathToOSSettings, "w")
	file:write(serialization.serialize(_G.OSSettings))
	file:close()
end

--ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ ÑÐ°Ð¹Ð» ÐºÐ¾Ð½ÑÐ¸Ð³ÑÑÐ°ÑÐ¸Ð¸ ÐÐ¡, Ð° ÐµÑÐ»Ð¸ ÐµÐ³Ð¾ Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ, ÑÐ¾ ÑÐ¾Ð·Ð´Ð°ÑÑ
function ecs.loadOSSettings()
	local pathToOSSettings = "MineOS/System/OS/OSSettings.cfg"
	if fs.exists(pathToOSSettings) then
		local file = io.open(pathToOSSettings, "r")
		_G.OSSettings = serialization.unserialize(file:read("*a"))
		file:close()
	else
		_G.OSSettings = { showHelpOnApplicationStart = true, language = "Russian" }
		ecs.saveOSSettings()
	end
end

--ÐÑÐ¾Ð±ÑÐ°Ð·Ð¸ÑÑ Ð¾ÐºÐ½Ð¾ Ñ ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ð¼ÑÐ¼ ÑÐ°Ð¹Ð»Ð° Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸
function ecs.applicationHelp(pathToApplication)
	local pathToAboutFile = pathToApplication .. "/resources/About/" .. _G.OSSettings.language .. ".txt"
	if _G.OSSettings and _G.OSSettings.showHelpOnApplicationStart and fs.exists(pathToAboutFile) then
		local applicationName = fs.name(pathToApplication)
		local file = io.open(pathToAboutFile, "r")
		local text = ""
		for line in file:lines() do text = text .. line .. " " end
		file:close()

		local data = ecs.universalWindow("auto", "auto", 30, 0xeeeeee, true,
			{"EmptyLine"},
			{"CenterText", 0x000000, "Ð Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸ " .. applicationName},
			{"EmptyLine"},
			{"TextField", 16, 0xFFFFFF, 0x262626, 0xcccccc, 0x353535, text},
			{"EmptyLine"},
			{"Button", {ecs.colors.orange, 0x262626, "OK"}, {0x999999, 0xffffff, "ÐÐ¾Ð»ÑÑÐµ Ð½Ðµ Ð¿Ð¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ"}}
		)
		if data[1] ~= "OK" then
			_G.OSSettings.showHelpOnApplicationStart = false
			ecs.saveOSSettings()
		end
	end
end

function ecs.correctFileNameIfFileExists(path, requestedName)
	local number = 1
	local fileFormat = ecs.getFileFormat(requestedName) or ""
	requestedName = ecs.hideFileFormat(requestedName)
	while true do
		local finalFileName = requestedName .. string.rep("-copy", number) .. fileFormat
		if fs.exists(path .. "/" .. finalFileName) then
			number = number + 1
		else
			return finalFileName
		end
	end
end

--Ð¡Ð¾Ð·Ð´Ð°ÑÑ ÑÑÐ»ÑÐº Ð´Ð»Ñ ÐºÐ¾Ð½ÐºÑÐµÑÐ½Ð¾Ð¹ Ð¿ÑÐ¾Ð³Ð¸ (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.createShortCut(pathToShortcut, pathToFile)
	local pathToPathToShortcut = fs.path(pathToShortcut) or "/"
	fs.makeDirectory(pathToPathToShortcut)
	if fs.exists(pathToShortcut) then
		pathToShortcut = ecs.correctFileNameIfFileExists(pathToPathToShortcut, pathToShortcut)
	end

	local file = io.open(pathToShortcut, "w")
	file:write("return ", "\"", pathToFile, "\"")
	file:close()
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ Ð´Ð°Ð½Ð½ÑÐµ Ð¾ ÑÐ°Ð¹Ð»Ðµ Ð¸Ð· ÑÑÐ»ÑÐºÐ° (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.readShortcut(path)
	local success, filename = pcall(loadfile(path))
	if success then
		return filename
	else
		error("ÐÑÐ¸Ð±ÐºÐ° ÑÑÐµÐ½Ð¸Ñ ÑÐ°Ð¹Ð»Ð° ÑÑÐ»ÑÐºÐ°. ÐÐµÑÐ¾ÑÑÐ½Ð¾, Ð¾Ð½ ÑÐ¾Ð·Ð´Ð°Ð½ ÐºÑÐ¸Ð²Ð¾, Ð»Ð¸Ð±Ð¾ Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ Ð² Ð¿Ð°Ð¿ÐºÐµ \"" .. fs.path(path) or "" .. "\"")
	end
end

--Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð° (Ð´Ð»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½ÐºÐ¸)
function ecs.editFile(path)
	ecs.prepareToExit()
	shell.execute("edit " .. path)
end

--ÐÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ ÑÐ°Ð¹Ð»Ð¾Ð² Ð¸ Ð¿Ð°Ð¿Ð¾Ðº
function ecs.copy(from, toFolder)
	fs.makeDirectory(toFolder)

	if fs.isDirectory(from) then
		local currentAction, yesToAllAction
		local function recursiveFolderCopy(from, to)
			for file in fs.list(from) do
				local finalFromName = from .. "/" .. file
				local finalToName = to .. "/" .. file

				if fs.exists(finalToName) then
					if not yesToAllAction then
						currentAction, yesToAll = ecs.askForReplaceFile(finalToName, true)
						if yesToAll == true then yesToAllAction = true end
					end
				else
					currentAction = 1
				end

				if currentAction == 1 then
					if fs.isDirectory(finalFromName) then
						fs.makeDirectory(finalToName)
						recursiveFolderCopy(finalFromName, finalToName)
					else
						fs.copy(finalFromName, finalToName)
					end
				end
			end
		end

		recursiveFolderCopy(from, toFolder .. fs.name(from))
	else
		local to = toFolder .. "/" .. fs.name(from)
		local action = 1
		if fs.exists(to) then action = ecs.askForReplaceFile(to) end
		if action == 1 then fs.copy(from, to) end
	end
end

-- ÐÐ½Ð¸Ð¼Ð°ÑÐ¸Ñ Ð·Ð°ÑÑÑÐ°Ð½Ð¸Ñ ÑÐºÑÐ°Ð½Ð°
function ecs.fadeOut(startColor, targetColor, speed)
	local xSize, ySize = component.gpu.getResolution()
	while startColor >= targetColor do
		component.gpu.setBackground(startColor)
		component.gpu.fill(1, 1, xSize, ySize, " ")
		startColor = startColor - 0x111111
		os.sleep(speed or 0)
	end
end

-- ÐÐ½Ð¸Ð¼Ð°ÑÐ¸Ñ Ð·Ð°Ð³Ð¾ÑÐ°Ð½Ð¸Ñ ÑÐºÑÐ°Ð½Ð°
function ecs.fadeIn(startColor, targetColor, speed)
	local xSize, ySize = component.gpu.getResolution()
	while startColor <= targetColor do
		component.gpu.setBackground(startColor)
		component.gpu.fill(1, 1, xSize, ySize, " ")
		startColor = startColor + 0x111111
		os.sleep(speed or 0)
	end
end

-- ÐÐ½Ð¸Ð¼Ð°ÑÐ¸Ñ Ð²ÑÑÐ¾Ð´Ð° Ð² Ð¾Ð»Ð´ÑÐºÑÐ»-ÑÐµÐ»ÐµÐ²Ð¸Ð·Ð¸Ð¾Ð½Ð½Ð¾Ð¼ ÑÑÐ¸Ð»Ðµ
function ecs.TV(speed, targetColor)
	local xSize, ySize = component.gpu.getResolution()
	local xCenter, yCenter = math.floor(xSize / 2), math.floor(ySize / 2)
	component.gpu.setBackground(targetColor or 0x000000)
	
	for y = 1, yCenter do
		component.gpu.fill(1, y - 1, xSize, 1, " ")
		component.gpu.fill(1, ySize - y + 1, xSize, 1, " ")
		os.sleep(speed or 0)
	end
	
	for x = 1, xCenter - 1 do
		component.gpu.fill(x, yCenter, 1, 1, " ")
		component.gpu.fill(xSize - x + 1, yCenter, 1, 1, " ")
		os.sleep(speed or 0)
	end
	os.sleep(0.3)
	component.gpu.fill(1, yCenter, xSize, 1, " ")
end



---------------------------------------------ÐÐÐÐ¨ÐÐ§ÐÐ------------------------------------------------------------


--ÐÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð½Ð¸Ð¶Ðµ, ÐµÐ±Ð°Ð½Ð°. ÐÐ¸Ð¶Ðµ - ÑÑÐ¾ Ð·Ð½Ð°ÑÐ¸Ñ Ð² ÑÐ°Ð¼Ð¾Ð¹ Ð¶Ð¾Ð¿Ðµ ÐºÐ¾Ð´Ð°!
function ecs.universalWindow(x, y, width, background, closeWindowAfter, ...)
	local objects = {...}
	local countOfObjects = #objects

	local pressedButton
	local pressedMultiButton

	--ÐÐ°Ð´Ð°ÐµÐ¼ Ð²ÑÑÐ¾ÑÐ½ÑÐµ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÑ Ð´Ð»Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð²
	local objectsHeights = {
		["button"] = 3,
		["centertext"] = 1,
		["emptyline"] = 1,
		["input"] = 3,
		["slider"] = 3,
		["select"] = 3,
		["selector"] = 3,
		["separator"] = 1,
		["switch"] = 1,
		["color"] = 3,
	}

	--Ð¡ÐºÐ¾ÑÑÐµÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¸ÑÐ¸Ð½Ñ, ÐµÑÐ»Ð¸ Ð½ÑÐ¶Ð½Ð¾
	local function correctWidth(newWidthForAnalyse)
		width = math.max(width, newWidthForAnalyse)
	end

	--ÐÐ¾ÑÑÐµÐºÑÐ¸ÑÑÐµÐ¼ ÑÐ¸ÑÐ¸Ð½Ñ
	for i = 1, countOfObjects do
		local objectType = string.lower(objects[i][1])
		
		if objectType == "centertext" then
			correctWidth(unicode.len(objects[i][3]) + 2)
		elseif objectType == "slider" then --!!!!!!!!!!!!!!!!!! ÐÐÐ¢ Ð¢Ð£Ð¢ ÐÐ ÐÐÐÐ£ÐÐ¬ Ð¤ÐÐÐ¡ÐÐÐ£Ð¢Ð¬
			correctWidth(unicode.len(objects[i][7]..tostring(objects[i][5].." ")) + 2)
		elseif objectType == "select" then
			for j = 4, #objects[i] do
				correctWidth(unicode.len(objects[i][j]) + 2)
			end
		--elseif objectType == "selector" then
			
		--elseif objectType == "separator" then
			
		elseif objectType == "textfield" then
			correctWidth(5)
		elseif objectType == "wrappedtext" then
			correctWidth(6)
		elseif objectType == "button" then
			--ÐÐ¾ÑÑÐµÐºÑÐ¸ÑÑÐµÐ¼ ÑÐ¸ÑÐ¸Ð½Ñ
			local widthOfButtons = 0
			local maxButton = 0
			for j = 2, #objects[i] do
				maxButton = math.max(maxButton, unicode.len(objects[i][j][3]) + 2)
			end
			widthOfButtons = maxButton * #objects[i]
			correctWidth(widthOfButtons)
		elseif objectType == "switch" then
			local dlina = unicode.len(objects[i][5]) + 2 + 10 + 4
			correctWidth(dlina)
		elseif objectType == "color" then 
			correctWidth(unicode.len(objects[i][2]) + 6)
		end
	end

	--Ð¡ÑÐ¸ÑÐ°ÐµÐ¼ Ð²ÑÑÐ¾ÑÑ ÑÑÐ¾Ð¹ ÑÑÐ¹Ð½Ð¸
	local height = 0
	for i = 1, countOfObjects do
		local objectType = string.lower(objects[i][1])
		if objectType == "select" then
			height = height + (objectsHeights[objectType] * (#objects[i] - 3))
		elseif objectType == "textfield" then
			height = height + objects[i][2]
		elseif objectType == "wrappedtext" then
			--ÐÐ°ÑÐ°Ð½ÐµÐµ Ð¿Ð°ÑÑÐ¸Ð¼ ÑÐµÐºÑÑ Ð¿ÐµÑÐµÐ½ÐµÑÐµÐ½Ð½ÑÐ¹
			objects[i].wrapped = string.wrap({objects[i][3]}, width - 4)
			objects[i].height = #objects[i].wrapped
			height = height + objects[i].height
		else
			height = height + objectsHeights[objectType]
		end
	end

	--ÐÐ¾Ð¾ÑÑÐµÐºÑÐ¸ÑÑÐµÐ¼ ÑÑÐ°ÑÑÐ¾Ð²ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ
	x, y = ecs.correctStartCoords(x, y, width, height)
	--ÐÐ°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÐ¼ Ð¸Ð½ÑÑ Ð¾ ÑÐ¾Ð¼, ÑÑÐ¾ Ð±ÑÐ»Ð¾ Ð½Ð°ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¾, ÐµÑÐ»Ð¸ ÑÑÐ¾ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾
	local oldPixels, oldBackground, oldForeground
	if closeWindowAfter then
		oldBackground = component.gpu.getBackground()
		oldForeground = component.gpu.getForeground()
		oldPixels = ecs.rememberOldPixels(x, y, x + width - 1, y + height - 1)
	end
	--Ð¡ÑÐ¸ÑÐ°ÐµÐ¼ Ð²ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¾Ð±ÑÐµÐºÑÐ¾Ð²
	objects[1].y = y
	if countOfObjects > 1 then
		for i = 2, countOfObjects do
			local objectType = string.lower(objects[i - 1][1])
			if objectType == "select" then
				objects[i].y = objects[i - 1].y + (objectsHeights[objectType] * (#objects[i - 1] - 3))
			elseif objectType == "textfield" then
				objects[i].y = objects[i - 1].y + objects[i - 1][2]
			elseif objectType == "wrappedtext" then
				objects[i].y = objects[i - 1].y + objects[i - 1].height
			else
				objects[i].y = objects[i - 1].y + objectsHeights[objectType]
			end
		end
	end

	--ÐÐ±ÑÐµÐºÑÑ Ð´Ð»Ñ ÑÐ°ÑÐ°
	local obj = {}
	local function newObj(class, name, ...)
		obj[class] = obj[class] or {}
		obj[class][name] = {...}
	end

	--ÐÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð¾Ð±ÑÐµÐºÑÐ° Ð¿Ð¾ Ð½Ð¾Ð¼ÐµÑÑ
	local function displayObject(number, active)
		local objectType = string.lower(objects[number][1])
				
		if objectType == "centertext" then
			local xPos = x + math.floor(width / 2 - unicode.len(objects[number][3]) / 2)
			component.gpu.setForeground(objects[number][2])
			component.gpu.setBackground(background)
			component.gpu.set(xPos, objects[number].y, objects[number][3])
		
		elseif objectType == "input" then

			if active then
				--Ð Ð°Ð¼Ð¾ÑÐºÐ°
				ecs.border(x + 1, objects[number].y, width - 2, objectsHeights.input, background, objects[number][3])
				--Ð¢ÐµÑÑÐ¸Ðº
				objects[number][4] = ecs.inputText(x + 3, objects[number].y + 1, width - 6, "", background, objects[number][3], false, objects[number][5])
			else
				--Ð Ð°Ð¼Ð¾ÑÐºÐ°
				ecs.border(x + 1, objects[number].y, width - 2, objectsHeights.input, background, objects[number][2])
				--Ð¢ÐµÐºÑÑÐ¸Ðº
				component.gpu.set(x + 3, objects[number].y + 1, ecs.stringLimit("start", objects[number][4], width - 6))
				ecs.inputText(x + 3, objects[number].y + 1, width - 6, objects[number][4], background, objects[number][2], true, objects[number][5])
			end

			newObj("Inputs", number, x + 1, objects[number].y, x + width - 2, objects[number].y + 2)

		elseif objectType == "slider" then
			local widthOfSlider = width - 2
			local xOfSlider = x + 1
			local yOfSlider = objects[number].y + 1
			local countOfSliderThings = objects[number][5] - objects[number][4]
			local showSliderValue= objects[number][7]

			local dolya = widthOfSlider / countOfSliderThings
			local position = math.floor(dolya * objects[number][6])
			--ÐÐ¾ÑÑÑÐ»Ñ
			if (xOfSlider + position) > (xOfSlider + widthOfSlider - 1)	then position = widthOfSlider - 2 end

			--ÐÐ²Ðµ Ð»Ð¸Ð½Ð¸Ð¸
			ecs.separator(xOfSlider, yOfSlider, position, background, objects[number][3])
			ecs.separator(xOfSlider + position, yOfSlider, widthOfSlider - position, background, objects[number][2])
			--Ð¡Ð»ÑÐ´Ð¸Ñ
			ecs.square(xOfSlider + position, yOfSlider, 2, 1, objects[number][3])

			--Ð¢ÐµÐºÑÑÐ¸Ðº Ð¿Ð¾Ð´ ÑÐ»ÑÐ´Ð¸ÑÐ¾Ð¼
			if showSliderValue then
				local text = showSliderValue .. tostring(objects[number][6]) .. (objects[number][8] or "")
				local textPos = (xOfSlider + widthOfSlider / 2 - unicode.len(text) / 2)
				ecs.square(x, yOfSlider + 1, width, 1, background)
				ecs.colorText(textPos, yOfSlider + 1, objects[number][2], text)
			end

			newObj("Sliders", number, xOfSlider, yOfSlider, x + widthOfSlider, yOfSlider, dolya)

		elseif objectType == "select" then
			local usualColor = objects[number][2]
			local selectionColor = objects[number][3]

			objects[number].selectedData = objects[number].selectedData or 1

			local symbol = "â"
			local yPos = objects[number].y
			for i = 4, #objects[number] do
				--ÐÐ¾ÑÐ¾Ð±ÐºÐ° Ð´Ð»Ñ Ð³Ð°Ð»Ð¾ÑÐºÐ¸
				ecs.border(x + 1, yPos, 5, 3, background, usualColor)
				--Ð¢ÐµÐºÑÑ
				component.gpu.set(x + 7, yPos + 1, objects[number][i])
				--ÐÐ°Ð»Ð¾ÑÐºÐ°
				if objects[number].selectedData == (i - 3) then
					ecs.colorText(x + 3, yPos + 1, selectionColor, symbol)
				else
					component.gpu.set(x + 3, yPos + 1, "  ")
				end

				obj["Selects"] = obj["Selects"] or {}
				obj["Selects"][number] = obj["Selects"][number] or {}
				obj["Selects"][number][i - 3] = { x + 1, yPos, x + width - 2, yPos + 2 }

				yPos = yPos + objectsHeights.select
			end

		elseif objectType == "selector" then
			local borderColor = objects[number][2]
			local arrowColor = objects[number][3]
			local selectorWidth = width - 2
			objects[number].selectedElement = objects[number].selectedElement or objects[number][4]

			local topLine = "â" .. string.rep("â", selectorWidth - 6) .. "â¬ââââ"
			local midLine = "â" .. string.rep(" ", selectorWidth - 6) .. "â   â"
			local botLine = "â" .. string.rep("â", selectorWidth - 6) .. "â´ââââ"

			local yPos = objects[number].y

			local function bordak(borderColor)
				component.gpu.setBackground(background)
				component.gpu.setForeground(borderColor)
				component.gpu.set(x + 1, objects[number].y, topLine)
				component.gpu.set(x + 1, objects[number].y + 1, midLine)
				component.gpu.set(x + 1, objects[number].y + 2, botLine)
				component.gpu.set(x + 3, objects[number].y + 1, ecs.stringLimit("start", objects[number].selectedElement, width - 6))
				ecs.colorText(x + width - 4, objects[number].y + 1, arrowColor, "â¼")
			end

			bordak(borderColor)
		
			--ÐÑÐ¿Ð°Ð´Ð°ÑÑÐ¸Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº, ÑÐ°Ð¼ÑÐ¹ Ð³ÐµÐ¼Ð¾Ñ, Ð±Ð»ÑÐ´Ñ
			if active then
				local xPos, yPos = x + 1, objects[number].y + 3
				local spisokWidth = width - 2
				local countOfElements = #objects[number] - 3
				local spisokHeight = countOfElements + 1
				local oldPixels = ecs.rememberOldPixels( xPos, yPos, xPos + spisokWidth - 1, yPos + spisokHeight - 1)

				local coords = {}

				bordak(arrowColor)

				--Ð Ð°Ð¼ÐºÑ ÑÐ¸ÑÑÐµÐ¼ Ð¿Ð¾Ð²ÐµÑÑ ÑÐ¾Ð½Ð¸ÐºÐ°
				local topLine = "â"..string.rep("â", spisokWidth - 6).."â´ââââ¤"
				local midLine = "â"..string.rep(" ", spisokWidth - 2).."â"
				local botLine = "â"..string.rep("â", selectorWidth - 2) .. "â"
				ecs.colorTextWithBack(xPos, yPos - 1, arrowColor, background, topLine)
				for i = 1, spisokHeight - 1 do
					component.gpu.set(xPos, yPos + i - 1, midLine)
				end
				component.gpu.set(xPos, yPos + spisokHeight - 1, botLine)

				--Ð­Ð»ÐµÐ¼ÐµÐ½ÑÑ ÑÐ¸ÑÑÐµÐ¼
				xPos = xPos + 2
				for i = 1, countOfElements do
					ecs.colorText(xPos, yPos, borderColor, ecs.stringLimit("start", objects[number][i + 3], spisokWidth - 4))
					coords[i] = {xPos - 1, yPos, xPos + spisokWidth - 4, yPos}
					yPos = yPos + 1
				end

				--ÐÐ±ÑÐ°Ð±Ð¾ÑÐºÐ°
				local exit
				while true do
					if exit then break end
					local e = {event.pull()}
					if e[1] == "touch" then
						for i = 1, #coords do
							if ecs.clickedAtArea(e[3], e[4], coords[i][1], coords[i][2], coords[i][3], coords[i][4]) then
								ecs.square(coords[i][1], coords[i][2], spisokWidth - 2, 1, ecs.colors.blue)
								ecs.colorText(coords[i][1] + 1, coords[i][2], 0xffffff, objects[number][i + 3])
								os.sleep(0.3)
								objects[number].selectedElement = objects[number][i + 3]
								exit = true
								break
							end
						end
					end
				end

				ecs.drawOldPixels(oldPixels)
			end

			newObj("Selectors", number, x + 1, objects[number].y, x + width - 2, objects[number].y + 2)

		elseif objectType == "separator" then
			ecs.separator(x, objects[number].y, width, background, objects[number][2])
		
		elseif objectType == "textfield" then
			newObj("TextFields", number, x + 1, objects[number].y, x + width - 2, objects[number].y + objects[number][2] - 1)
			if not objects[number].strings then objects[number].strings = string.wrap({objects[number][7]}, width - 3) end
			objects[number].displayFrom = objects[number].displayFrom or 1
			ecs.textField(x, objects[number].y, width, objects[number][2], objects[number].strings, objects[number].displayFrom, objects[number][3], objects[number][4], objects[number][5], objects[number][6])
		
		elseif objectType == "wrappedtext" then
			component.gpu.setBackground(background)
			component.gpu.setForeground(objects[number][2])
			for i = 1, #objects[number].wrapped do
				component.gpu.set(x + 2, objects[number].y + i - 1, objects[number].wrapped[i])
			end

		elseif objectType == "button" then

			obj["MultiButtons"] = obj["MultiButtons"] or {}
			obj["MultiButtons"][number] = {}

			local widthOfButton = math.floor(width / (#objects[number] - 1))

			local xPos, yPos = x, objects[number].y
			for i = 1, #objects[number] do
				if type(objects[number][i]) == "table" then
					local x1, y1, x2, y2 = ecs.drawButton(xPos, yPos, widthOfButton, 3, objects[number][i][3], objects[number][i][1], objects[number][i][2])
					table.insert(obj["MultiButtons"][number], {x1, y1, x2, y2, widthOfButton})
					xPos = x2 + 1

					if i == #objects[number] then
						ecs.square(xPos, yPos, x + width - xPos, 3, objects[number][i][1])
						obj["MultiButtons"][number][i - 1][5] = obj["MultiButtons"][number][i - 1][5] + x + width - xPos
					end

					x1, y1, x2, y2 = nil, nil, nil, nil
				end
			end

		elseif objectType == "switch" then

			local xPos, yPos = x + 2, objects[number].y
			local activeColor, passiveColor, textColor, text, state = objects[number][2], objects[number][3], objects[number][4], objects[number][5], objects[number][6]
			local switchWidth = 8
			ecs.colorTextWithBack(xPos, yPos, textColor, background, text)

			xPos = x + width - switchWidth - 2
			if state then
				ecs.square(xPos, yPos, switchWidth, 1, activeColor)
				ecs.square(xPos + switchWidth - 2, yPos, 2, 1, passiveColor)
				--ecs.colorTextWithBack(xPos + 4, yPos, passiveColor, activeColor, "ON")
			else
				ecs.square(xPos, yPos, switchWidth, 1, passiveColor - 0x444444)
				ecs.square(xPos, yPos, 2, 1, passiveColor)
				--ecs.colorTextWithBack(xPos + 4, yPos, passiveColor, passiveColor - 0x444444, "OFF")
			end
			newObj("Switches", number, xPos, yPos, xPos + switchWidth - 1, yPos)

		elseif objectType == "color" then
			local xPos, yPos = x + 1, objects[number].y
			local blendedColor = require("colorlib").alphaBlend(objects[number][3], 0xFFFFFF, 180)
			local w = width - 2

			ecs.colorTextWithBack(xPos, yPos + 2, blendedColor, background, string.rep("â", w))
			ecs.colorText(xPos, yPos, objects[number][3], string.rep("â", w))
			ecs.square(xPos, yPos + 1, w, 1, objects[number][3])		

			ecs.colorText(xPos + 1, yPos + 1, 0xffffff - objects[number][3], objects[number][2])
			newObj("Colors", number, xPos, yPos, x + width - 2, yPos + 2)
		end
	end

	--ÐÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð²ÑÐµÑ Ð¾Ð±ÑÐµÐºÑÐ¾Ð²
	local function displayAllObjects()
		for i = 1, countOfObjects do
			displayObject(i)
		end
	end

	--ÐÐ¾Ð´Ð³Ð¾ÑÐ¾Ð²Ð¸ÑÑ Ð¼Ð°ÑÑÐ¸Ð² Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ÑÐ¹
	local function getReturn()
		local massiv = {}

		for i = 1, countOfObjects do
			local type = string.lower(objects[i][1])

			if type == "button" then
				table.insert(massiv, pressedButton)
			elseif type == "input" then
				table.insert(massiv, objects[i][4])
			elseif type == "select" then
				table.insert(massiv, objects[i][objects[i].selectedData + 3])
			elseif type == "selector" then
				table.insert(massiv, objects[i].selectedElement)
			elseif type == "slider" then
				table.insert(massiv, objects[i][6])
			elseif type == "switch" then
				table.insert(massiv, objects[i][6])
			elseif type == "color" then
				table.insert(massiv, objects[i][3])	
			else
				table.insert(massiv, nil)
			end
		end

		return massiv
	end

	local function redrawBeforeClose()
		if closeWindowAfter then
			ecs.drawOldPixels(oldPixels)
			component.gpu.setBackground(oldBackground)
			component.gpu.setForeground(oldForeground)
		end
	end

	--Ð Ð¸ÑÑÐµÐ¼ Ð¾ÐºÐ½Ð¾
	ecs.square(x, y, width, height, background)
	displayAllObjects()

	while true do
		local e = {event.pull()}
		if e[1] == "touch" or e[1] == "drag" then

			--ÐÐ½Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ ÐºÐ»Ð¸Ðº Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÐ¸
			if obj["MultiButtons"] then
				for key in pairs(obj["MultiButtons"]) do
					for i = 1, #obj["MultiButtons"][key] do
						if ecs.clickedAtArea(e[3], e[4], obj["MultiButtons"][key][i][1], obj["MultiButtons"][key][i][2], obj["MultiButtons"][key][i][3], obj["MultiButtons"][key][i][4]) then
							ecs.drawButton(obj["MultiButtons"][key][i][1], obj["MultiButtons"][key][i][2], obj["MultiButtons"][key][i][5], 3, objects[key][i + 1][3], objects[key][i + 1][2], objects[key][i + 1][1])
							os.sleep(0.3)
							pressedButton = objects[key][i + 1][3]
							redrawBeforeClose()
							return getReturn()
						end
					end
				end
			end

			--Ð ÑÐµÐ¿ÐµÑÑ ÐºÐ»Ð¸Ðº Ð½Ð° Ð¸Ð½Ð¿ÑÑÑ!
			if obj["Inputs"] then
				for key in pairs(obj["Inputs"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Inputs"][key][1], obj["Inputs"][key][2], obj["Inputs"][key][3], obj["Inputs"][key][4]) then
						displayObject(key, true)
						displayObject(key)
						break
					end
				end
			end

			--Ð ÑÐµÐ¿ÐµÑÑ Ð³Ð°Ð»Ð¾ÑÐºÐ¾Ð²ÑÐ±Ð¾Ñ!
			if obj["Selects"] then
				for key in pairs(obj["Selects"]) do
					for i in pairs(obj["Selects"][key]) do
						if ecs.clickedAtArea(e[3], e[4], obj["Selects"][key][i][1], obj["Selects"][key][i][2], obj["Selects"][key][i][3], obj["Selects"][key][i][4]) then
							objects[key].selectedData = i
							displayObject(key)
							break
						end
					end
				end
			end

			--Ð¥Ð¼, Ð° Ð²Ð¾Ñ Ð¸ ÑÐµÐ»ÐµÐºÑÐ¾Ñ Ð¿Ð¾Ð´ÑÐµÑÐ°Ð»!
			if obj["Selectors"] then
				for key in pairs(obj["Selectors"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Selectors"][key][1], obj["Selectors"][key][2], obj["Selectors"][key][3], obj["Selectors"][key][4]) then
						displayObject(key, true)
						displayObject(key)
						break
					end
				end
			end

			--Ð¡Ð»Ð°Ð¹Ð´ÐµÑÑ, ÐµÐ¿ÑÐ°! "ÐÐ¾ÑÐ½ÑÐ¹ Ð¼Ð°ÑÐ°Ð½", Ð²ÑÐµ Ð´ÐµÐ»Ñ
			if obj["Sliders"] then
				for key in pairs(obj["Sliders"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Sliders"][key][1], obj["Sliders"][key][2], obj["Sliders"][key][3], obj["Sliders"][key][4]) then
						local xOfSlider, dolya = obj["Sliders"][key][1], obj["Sliders"][key][5]
						local currentPixels = e[3] - xOfSlider
						local currentValue = math.floor(currentPixels / dolya)
						--ÐÐ¾ÑÑÑÐ»Ñ
						if e[3] == obj["Sliders"][key][3] then currentValue = objects[key][5] end
						objects[key][6] = currentValue or objects[key][6]
						displayObject(key)
						break
					end
				end
			end

			if obj["Switches"] then
				for key in pairs(obj["Switches"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Switches"][key][1], obj["Switches"][key][2], obj["Switches"][key][3], obj["Switches"][key][4]) then
						objects[key][6] = not objects[key][6]
						displayObject(key)
						break
					end
				end
			end

			if obj["Colors"] then
				for key in pairs(obj["Colors"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["Colors"][key][1], obj["Colors"][key][2], obj["Colors"][key][3], obj["Colors"][key][4]) then
						local oldColor = objects[key][3]
						objects[key][3] = 0xffffff - objects[key][3]
						displayObject(key)
						os.sleep(0.3)
						objects[key][3] = oldColor
						displayObject(key)

						local paletteWidth, paletteHeight = 75, 27
						local screenWidth, screenHeight = component.gpu.getResolution()
						local paletteX, paletteY = math.floor(screenWidth / 2 - paletteWidth / 2), math.floor(screenHeight / 2 - paletteHeight / 2)
						local oldPixels = ecs.rememberOldPixels(paletteX, paletteY, paletteX + paletteWidth - 1, paletteY + paletteHeight - 1)
						local color = require("palette").draw("auto", "auto", objects[key][3])
						ecs.drawOldPixels(oldPixels)
						objects[key][3] = color or oldColor

						displayObject(key)
						break
					end
				end
			end

		elseif e[1] == "scroll" then
			if obj["TextFields"] then
				for key in pairs(obj["TextFields"]) do
					if ecs.clickedAtArea(e[3], e[4], obj["TextFields"][key][1], obj["TextFields"][key][2], obj["TextFields"][key][3], obj["TextFields"][key][4]) then
						if e[5] == 1 then
							if objects[key].displayFrom > 1 then objects[key].displayFrom = objects[key].displayFrom - 1; displayObject(key) end
						else
							if objects[key].displayFrom < #objects[key].strings then objects[key].displayFrom = objects[key].displayFrom + 1; displayObject(key) end
						end
					end
				end
			end
		elseif e[1] == "key_down" then
			if e[4] == 28 then
				redrawBeforeClose()
				return getReturn()
			end
		end
	end
end

--ÐÐµÐ¼Ð¾Ð½ÑÑÑÐ°ÑÐ¸Ð¾Ð½Ð½Ð¾Ðµ Ð¾ÐºÐ½Ð¾, Ð¿Ð¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑÐµÐµ Ð²ÑÑ Ð¼Ð¾ÑÑ universalWindow
function ecs.demoWindow()
	--ÐÑÐ¸ÑÐ°ÐµÐ¼ ÑÐºÑÐ°Ð½ Ð¿ÐµÑÐµÐ´ ÑÐ·Ð°Ð½Ð¸ÐµÐ¼ Ð¾ÐºÐ½Ð° Ð¸ ÑÑÐ°Ð²Ð¸Ð¼ ÐºÑÑÑÐ¾Ñ Ð½Ð° 1, 1
	ecs.prepareToExit()
	--Ð Ð¸ÑÑÐµÐ¼ Ð¾ÐºÐ½Ð¾ Ð¸ Ð¿Ð¾Ð»ÑÑÐ°ÐµÐ¼ Ð´Ð°Ð½Ð½ÑÐµ Ð¿Ð¾ÑÐ»Ðµ Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ñ Ð½Ð¸Ð¼
	local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
		{"EmptyLine"},
		{"CenterText", 0x880000, "ÐÐ´Ð¾ÑÐ¾Ð²Ð¾, ÐµÐ±Ð°Ð½Ð°!"},
		{"EmptyLine"},
		{"Input", 0x262626, 0x880000, "Ð¡ÑÐ´Ð° Ð²Ð²Ð¾Ð´Ð¸ÑÑ Ð¼Ð¾Ð¶Ð½Ð¾"},
		{"Selector", 0x262626, 0x880000, "ÐÑÐ±Ð¾Ñ ÑÐ¾ÑÐ¼Ð°ÑÐ°", "PNG", "JPG", "GIF", "PSD"},
		{"EmptyLine"},
		{"WrappedText", 0x262626, "Ð¢ÐµÑÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¾Ð³Ð¾ Ð¿ÐµÑÐµÐ½Ð¾ÑÐ° Ð±ÑÐºÐ² Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐ¸ Ð¾Ñ ÑÐ¸ÑÐ¸Ð½Ñ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¾ÐºÐ½Ð°. ÐÐ¾ÐºÐ° ÑÑÐ¾ ÑÑÐ¿Ð¾ ÑÐµÐ¶ÐµÑ Ð½Ð° ÐºÑÑÐºÐ¸, Ð½Ðµ Ð¾ÑÐ¾Ð±Ð¾ ÐºÑÐ°ÑÐ¸Ð²Ð¾."},
		{"EmptyLine"},
		{"Select", 0x262626, 0x880000, "Ð¯ Ð¿Ð¸Ð´Ð¾Ñ", "Ð¯ Ð½Ðµ Ð¿Ð¸Ð´Ð¾Ñ"},
		{"Slider", 0x262626, 0x880000, 1, 100, 50, "Ð£Ð±Ð¸ÑÐ¾ ", " Ð¼Ð»Ð°Ð´ÐµÐ½ÑÐµÐ²"},
		{"EmptyLine"},
		{"Separator", 0xaaaaaa},
		{"Switch", 0xF2B233, 0xffffff, 0x262626, "â ÐÐ²Ð¸Ð°ÑÐµÐ¶Ð¸Ð¼", false},
		{"EmptyLine"},
		{"Switch", 0x3366CC, 0xffffff, 0x262626, "â¾  ÐÐµ Ð±ÐµÑÐ¿Ð¾ÐºÐ¾Ð¸ÑÑ", true},
		{"Separator", 0xaaaaaa},
		{"EmptyLine"},
		{"TextField", 5, 0xffffff, 0x262626, 0xcccccc, 0x3366CC, "Ð¢ÐµÑÑ ÑÐµÐºÑÑÐ¾Ð²Ð¾Ð³Ð¾ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¾Ð½Ð½Ð¾Ð³Ð¾ Ð¿Ð¾Ð»Ñ. ÐÐ¾ ÑÑÑÐ¸ ÑÑÐ¾ ÑÐ¾Ñ Ð¶Ðµ ÑÐ°Ð¼ÑÐ¹ WrappedText, ÑÐ°Ð·Ð²Ðµ ÑÑÐ¾ ÑÑÐ° ÑÑÐµÐ½Ñ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð° Ð¿Ð¾ Ð²ÑÑÐ¾ÑÐµ, Ð¸ ÐµÐµ Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐºÑÐ¾Ð»Ð»Ð¸ÑÑ. ÐÑ Ð¶Ðµ, Ð¿Ð¾ÑÐºÑÐ¾Ð»Ð»Ñ Ð¼ÐµÐ½Ñ! Ð¡ÐºÑÐ¾Ð»Ð»Ñ Ð¼ÐµÐ½Ñ Ð¿Ð¾Ð»Ð½Ð¾ÑÑÑÑ! ÐÐ¾Ñ Ð¶Ð°Ð´Ð½Ð°Ñ Ð¿Ð¸Ð·Ð´Ð° Ð¶Ð°Ð¶Ð´ÐµÑ ÑÐ²Ð¾Ð¹ ÑÑÐ¹!"},
		{"Color", "Ð¦Ð²ÐµÑ ÑÐ¾Ð½Ð°", 0xFF0000},
		{"EmptyLine"},
		{"Button", {0x57A64E, 0xffffff, "ÐÐ°"}, {0xF2B233, 0xffffff, "ÐÐµÑ"}, {0xCC4C4C, 0xffffff, "ÐÑÐ¼ÐµÐ½Ð°"}}
	)
	--ÐÑÐµ ÑÐ°Ð·Ð¾Ðº
	ecs.prepareToExit()
	--ÐÑÐ²Ð¾Ð´Ð¸Ð¼ Ð´Ð°Ð½Ð½ÑÐµ
	print(" ")
	print("ÐÑÐ²Ð¾Ð´ Ð´Ð°Ð½Ð½ÑÑ Ð¸Ð· Ð¾ÐºÐ½Ð°:")
	for i = 1, #data do print("["..i.."] = "..tostring(data[i])) end
	print(" ")
end

-- ecs.demoWindow()

--[[
Ð¤ÑÐ½ÐºÑÐ¸Ñ universalWindow(x, y, width, background, closeWindowAfter, ...)

	Ð­ÑÐ¾ ÑÐ½Ð¸Ð²ÐµÑÑÐ°Ð»ÑÐ½Ð°Ñ Ð¼Ð¾Ð´ÑÐ»ÑÐ½Ð°Ñ ÑÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾ ÑÐ´Ð¾Ð±Ð½Ð¾Ð³Ð¾ Ð¸ Ð±ÑÑÑÑÐ¾Ð³Ð¾ Ð¾ÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
	Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾Ð¹ Ð²Ð°Ð¼ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸. Ð¡ ÐµÐµ Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð²Ð²Ð¾Ð´Ð¸ÑÑ Ð´Ð°Ð½Ð½ÑÐµ Ñ ÐºÐ»Ð°Ð²Ð¸Ð°ÑÑÑÑ, Ð¾ÑÑÑÐµÑÑÐ²Ð»ÑÑÑ Ð²ÑÐ±Ð¾Ñ
	Ð¸Ð· Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½ÑÑ Ð²Ð°ÑÐ¸Ð°Ð½ÑÐ¾Ð², ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÐºÑÐ°ÑÐ¸Ð²ÑÐµ ÐºÐ½Ð¾Ð¿ÐºÐ¸, Ð¾ÑÑÐ¸ÑÐ¾Ð²ÑÐ²Ð°ÑÑ Ð¾Ð±ÑÑÐ½ÑÐ¹ ÑÐµÐºÑÑ,
	Ð¾ÑÑÐ¸ÑÐ¾Ð²ÑÐ²Ð°ÑÑ ÑÐµÐºÑÑÐ¾Ð²ÑÐµ Ð¿Ð¾Ð»Ñ Ñ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑÑ Ð¿ÑÐ¾ÐºÑÑÑÐºÐ¸, ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ°Ð·Ð´ÐµÐ»Ð¸ÑÐµÐ»Ð¸ Ð¸ Ð¿ÑÐ¾ÑÐµÐµ.
	ÐÑÐ±Ð¾Ð¹ Ð¾Ð±ÑÐµÐºÑ Ð²ÑÐ´ÐµÐ»ÑÐµÑÑÑ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ ÐºÐ»Ð¸ÐºÐ° Ð¼ÑÑÐ¸, Ð¿Ð¾ÑÐ»Ðµ ÑÐµÐ³Ð¾ ÑÑÐ½ÐºÑÐ¸Ñ Ð¿ÑÐ¸ÑÑÑÐ¿Ð°ÐµÑ Ðº ÑÐ°Ð±Ð¾ÑÐµ
	Ñ ÑÑÐ¸Ð¼ Ð¾Ð±ÑÐµÐºÑÐ¾Ð¼.
 
ÐÑÐ³ÑÐ¼ÐµÐ½ÑÑ ÑÑÐ½ÐºÑÐ¸Ð¸:

	x Ð¸ y: ÑÑÐ¾ ÑÐ¸ÑÐ»Ð°, Ð¾Ð±Ð¾Ð·Ð½Ð°ÑÐ°ÑÑÐ¸Ðµ ÑÑÐ°ÑÑÐ¾Ð²ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð»ÐµÐ²Ð¾Ð³Ð¾ Ð²ÐµÑÑÐ½ÐµÐ³Ð¾ ÑÐ³Ð»Ð° Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¾ÐºÐ½Ð°.
	ÐÐ¼ÐµÑÑÐ¾ ÑÐ¸ÑÑ Ð²Ñ ÑÐ°ÐºÐ¶Ðµ Ð¼Ð¾Ð¶ÐµÑÐµ Ð½Ð°Ð¿Ð¸ÑÐ°ÑÑ "auto" - Ð¸ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð° Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐ°Ð·Ð¼ÐµÑÑÐ¸Ñ Ð¾ÐºÐ½Ð¾
	Ð¿Ð¾ ÑÐµÐ½ÑÑÑ ÑÐºÑÐ°Ð½Ð° Ð¿Ð¾ Ð²ÑÐ±ÑÐ°Ð½Ð½Ð¾Ð¹ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐµ. ÐÐ»Ð¸ Ð¿Ð¾ Ð¾Ð±ÐµÐ¸Ð¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼, ÐµÑÐ»Ð¸ Ð²Ð°Ð¼ ÑÐ³Ð¾Ð´Ð½Ð¾.
	 
	width: ÑÑÐ¾ ÑÐ¸ÑÐ¸Ð½Ð° Ð¾ÐºÐ½Ð°, ÐºÐ¾ÑÐ¾ÑÑÑ Ð²Ñ Ð¼Ð¾Ð¶ÐµÑÐµ Ð·Ð°Ð´Ð°ÑÑ Ð¿Ð¾ ÑÐ¾Ð±ÑÑÐ²ÐµÐ½Ð½Ð¾Ð¼Ñ Ð¶ÐµÐ»Ð°Ð½Ð¸Ñ. ÐÑÐ»Ð¸ Ð½ÐµÐºÑÐ¾ÑÑÐµ
	Ð¾Ð±ÑÐµÐºÑÑ ÑÑÐµÐ±ÑÑÑ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð¸Ñ Ð¾ÐºÐ½Ð°, ÑÐ¾ Ð¾ÐºÐ½Ð¾ Ð±ÑÐ´ÐµÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð¾ Ð´Ð¾ Ð½ÑÐ¶Ð½Ð¾Ð¹ ÑÐ¸ÑÐ¸Ð½Ñ.
	ÐÐ°, Ð²Ð¾Ñ ÑÐ°ÐºÐ°Ñ Ð²Ð¾Ñ ÑÐ°Ð²ÑÐ¾Ð»Ð¾Ð³Ð¸Ñ ;)

	background: Ð±Ð°Ð·Ð¾Ð²ÑÐ¹ ÑÐ²ÐµÑ Ð¾ÐºÐ½Ð° (ÑÐ²ÐµÑ ÑÐ¾Ð½Ð°, ÐºÐ¾Ð¼Ñ ÐºÐ°Ðº Ð¿Ð¾Ð½ÑÑÐ½ÐµÐµ).

	closeWindowAfter: eÑÐ»Ð¸ true, ÑÐ¾ Ð¾ÐºÐ½Ð¾ Ð¿Ð¾ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¸Ñ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð±ÑÐ´ÐµÑ Ð²ÑÐ³ÑÑÐ¶ÐµÐ½Ð¾, Ð° Ð½Ð° ÐµÐ³Ð¾ Ð¼ÐµÑÑÐµ
	Ð¾ÑÑÐ¸ÑÑÑÑÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ð¸, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð¸Ð¼ÐµÐ»Ð¸ÑÑ Ð½Ð° ÑÐºÑÐ°Ð½Ðµ Ð´Ð¾ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ ÑÑÐ½ÐºÑÐ¸Ð¸. Ð£Ð´Ð¾Ð±Ð½Ð¾, ÐµÑÐ»Ð¸ Ð½Ðµ ÑÐ¾ÑÐµÑÑ
	Ð¿Ð°ÑÐ¸ÑÑÑÑ Ñ Ð¿ÐµÑÐµÑÐ¸ÑÐ¾Ð²ÐºÐ¾Ð¹ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ°.

	... : Ð¼Ð½Ð¾Ð³Ð¾ÑÐ¾ÑÐ¸ÐµÐ¼ ÑÑÑ ÑÐ²Ð»ÑÐµÑÑÑ Ð¿ÐµÑÐµÑÐµÐ½Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð², ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÑÐµÑÐµÐ· Ð·Ð°Ð¿ÑÑÑÑ. ÐÐ°Ð¶Ð´ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ
	ÑÐ²Ð»ÑÐµÑÑÑ Ð¼Ð°ÑÑÐ¸Ð²Ð¾Ð¼ Ð¸ Ð¸Ð¼ÐµÐµÑ ÑÐ¾Ð±ÑÑÐ²ÐµÐ½Ð½ÑÐ¹ ÑÐ¾ÑÐ¼Ð°Ñ. ÐÐ¸Ð¶Ðµ Ð¿ÐµÑÐµÑÐ¸ÑÐ»ÐµÐ½Ñ Ð²ÑÐµ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÐµ ÑÐ¸Ð¿Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð².
		
		{"Button", {Ð¦Ð²ÐµÑ ÐºÐ½Ð¾Ð¿ÐºÐ¸1, Ð¦Ð²ÐµÑ ÑÐµÐºÑÑÐ° Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÐµ1, Ð¡Ð°Ð¼ ÑÐµÐºÑÑ1}, {Ð¦Ð²ÐµÑ ÐºÐ½Ð¾Ð¿ÐºÐ¸2, Ð¦Ð²ÐµÑ ÑÐµÐºÑÑÐ° Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÐµ2, Ð¡Ð°Ð¼ ÑÐµÐºÑÑ2}, ...}

			Ð­ÑÐ¾ Ð¾Ð±ÑÐµÐºÑ Ð´Ð»Ñ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ ÐºÐ½Ð¾Ð¿Ð¾Ðº. ÐÐ°Ð¶Ð´Ð°Ñ ÐºÐ½Ð¾Ð¿ÐºÐ° - ÑÑÐ¾ Ð¼Ð°ÑÑÐ¸Ð², ÑÐ¾ÑÑÐ¾ÑÑÐ¸Ð¹ Ð¸Ð· ÑÑÐµÑ ÑÐ»ÐµÐ¼ÐµÐ½ÑÐ¾Ð²:
			ÑÐ²ÐµÑÐ° ÐºÐ½Ð¾Ð¿ÐºÐ¸, ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ° Ð½Ð° ÐºÐ½Ð¾Ð¿ÐºÐµ Ð¸ ÑÐ°Ð¼Ð¾Ð³Ð¾ ÑÐµÐºÑÑÐ°. ÐÐ½Ð¾Ð¿Ð¾Ðº Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð½ÐµÐ¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð½Ð¾Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾,
			Ð¾Ð´Ð½Ð°ÐºÐ¾ ÑÐµÐ¼ Ð¸Ñ Ð±Ð¾Ð»ÑÑÐµ, ÑÐµÐ¼ Ð±Ð¾Ð»ÑÑÐµÐµ ÑÑÐµÐ±ÑÐµÑÑÑ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ ÑÐºÑÐ°Ð½Ð° Ð¿Ð¾ ÑÐ¸ÑÐ¸Ð½Ðµ.

			ÐÐ½ÑÐµÑÐ°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.

		{"Input", Ð¦Ð²ÐµÑ ÑÐ°Ð¼ÐºÐ¸ Ð¸ ÑÐµÐºÑÑÐ°, Ð¦Ð²ÐµÑ Ð¿ÑÐ¸ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸, Ð¡ÑÐ°ÑÑÐ¾Ð²ÑÐ¹ ÑÐµÐºÑÑ [, ÐÐ°ÑÐºÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð¼]}

			ÐÐ±ÑÐµÐºÑ Ð´Ð»Ñ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð¿Ð¾Ð»ÐµÐ¹ Ð²Ð²Ð¾Ð´Ð° ÑÐµÐºÑÑÐ¾Ð²Ð¾Ð¹ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸. Ð£Ð´Ð¾Ð±Ð½Ð¾ Ð´Ð»Ñ Ð¾ÑÐºÑÑÑÐ¸Ñ Ð¸Ð»Ð¸ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸Ñ ÑÐ°Ð¹Ð»Ð¾Ð²,
			ÐÐ¿ÑÐ¸Ð¾Ð½Ð°Ð»ÑÐ½ÑÐ¹ Ð°ÑÐ³ÑÐ¼ÐµÐ½Ñ "ÐÐ°ÑÐºÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð¼" Ð¿Ð¾Ð»ÐµÐ·ÐµÐ½, ÐµÑÐ»Ð¸ Ð²Ñ Ð´ÐµÐ»Ð°ÐµÑÐµ Ð¿Ð¾Ð»Ðµ Ð´Ð»Ñ Ð²Ð²Ð¾Ð´Ð° Ð¿Ð°ÑÐ¾Ð»Ñ.
			ÐÐ¸ÐºÑÐ¾ Ð½Ðµ ÑÐ²Ð¸Ð´Ð¸Ñ Ð²Ð°Ñ ÑÐµÐºÑÑ. Ð ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ° Ð¿ÐµÑÐµÐ´Ð°ÐµÑÑÑ ÑÐ¸Ð¼Ð²Ð¾Ð», Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ "*".

			ÐÐ½ÑÐµÑÐ°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.

		{"Selector", Ð¦Ð²ÐµÑ ÑÐ°Ð¼ÐºÐ¸, Ð¦Ð²ÐµÑ Ð¿ÑÐ¸ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸, ÐÑÐ±Ð¾Ñ 1, ÐÑÐ±Ð¾Ñ 2, ÐÑÐ±Ð¾Ñ 3 ...}

			ÐÐ½ÐµÑÐ½Ðµ ÑÑÐ¾Ð¶ Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð¼ "Input", Ð¾Ð´Ð½Ð°ÐºÐ¾ Ð² ÑÑÐ¾Ð¼ ÑÐ»ÑÑÐ°Ðµ Ð²Ñ Ð±ÑÐ´ÐµÑÐµ Ð²ÑÐ±Ð¸ÑÐ°ÑÑ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ð¿ÑÐµÐ´Ð»Ð¾Ð¶ÐµÐ½Ð½ÑÑ
			Ð²Ð°ÑÐ¸Ð°Ð½ÑÐ¾Ð² Ð¸Ð· Ð²ÑÐ¿Ð°Ð´Ð°ÑÑÐµÐ³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°. ÐÐ¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ Ð²ÑÐ±ÑÐ°Ð½ Ð¿ÐµÑÐ²ÑÐ¹ Ð²Ð°ÑÐ¸Ð°Ð½Ñ.

			ÐÐ½ÑÐµÑÐ°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.

		{"Select", Ð¦Ð²ÐµÑ ÑÐ°Ð¼ÐºÐ¸, Ð¦Ð²ÐµÑ Ð³Ð°Ð»Ð¾ÑÐºÐ¸, ÐÑÐ±Ð¾Ñ 1, ÐÑÐ±Ð¾Ñ 2, ÐÑÐ±Ð¾Ñ 3 ...}

			ÐÐ±ÑÐµÐºÑ Ð²ÑÐ±Ð¾ÑÐ°. ÐÑÐ»Ð¸ÑÐ°ÐµÑÑÑ Ð¾Ñ "Selector" ÑÐµÐ¼, ÑÑÐ¾ Ð·Ð´ÐµÑÑ Ð²Ñ Ð²ÑÐ±Ð¸ÑÐ°ÐµÑÐµ Ð¾Ð´Ð¸Ð½ Ð¸Ð· Ð²Ð°ÑÐ¸Ð°Ð½ÑÐ¾Ð², Ð¾ÑÐ¼ÐµÑÐ°Ñ
			ÐµÐ³Ð¾ Ð³Ð°Ð»Ð¾ÑÐºÐ¾Ð¹. ÐÐ¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ Ð²ÑÐ±ÑÐ°Ð½ Ð¿ÐµÑÐ²ÑÐ¹ Ð²Ð°ÑÐ¸Ð°Ð½Ñ.

			ÐÐ½ÑÐµÑÐ°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ. 

		{"Slider", Ð¦Ð²ÐµÑ Ð»Ð¸Ð½Ð¸Ð¸ ÑÐ»Ð°Ð¹Ð´ÐµÑÐ°, Ð¦Ð²ÐµÑ Ð¿Ð¸Ð¼Ð¿Ð¾ÑÐºÐ¸ ÑÐ»Ð°Ð¹Ð´ÐµÑÐ°, ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ ÑÐ»Ð°Ð¹Ð´ÐµÑÐ° ÐÐ¢, ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ ÑÐ»Ð°Ð¹Ð´ÐµÑÐ° ÐÐ, Ð¢ÐµÐºÑÑÐµÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ [, Ð¢ÐµÐºÑÑ-Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÐºÐ° ÐÐ] [, Ð¢ÐµÐºÑÑ-Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÐºÐ° ÐÐÐ¡ÐÐ]}

			ÐÐ¾Ð»Ð·ÑÐ½Ð¾Ðº, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑÐ¸Ð¹ Ð·Ð°Ð´Ð°Ð²Ð°ÑÑ Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐµÐ³Ð¾-Ð»Ð¸Ð±Ð¾ Ð² ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼ Ð¸Ð½ÑÐµÑÐ²Ð°Ð»Ðµ. ÐÐ¼ÐµÑÑÑÑ Ð´Ð²Ð°
			Ð¾Ð¿ÑÐ¸Ð¾Ð½Ð°Ð»ÑÐ½ÑÑ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ°, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑÐ¸Ñ ÑÐµÑÐºÐ¾ Ð¿Ð¾Ð½Ð¸Ð¼Ð°ÑÑ, Ñ ÑÐµÐ¼ Ð¸Ð¼ÐµÐ½Ð½Ð¾ Ð¼Ñ Ð¸Ð¼ÐµÐµÐ¼ Ð´ÐµÐ»Ð¾.

			Ð Ð¿ÑÐ¸Ð¼ÐµÑÑ, ÐµÑÐ»Ð¸ Ð°ÑÐ³ÑÐ¼ÐµÐ½Ñ "Ð¢ÐµÐºÑÑ-Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÐºÐ° ÐÐ" Ð±ÑÐ´ÐµÑ ÑÐ°Ð²ÐµÐ½ "Ð¡ÑÐµÐ´ÐµÐ½Ð¾ ", Ð° Ð°ÑÐ³ÑÐ¼ÐµÐ½Ñ "Ð¢ÐµÐºÑÑ-Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÐºÐ° ÐÐÐ¡ÐÐ"
			Ð±ÑÐ´ÐµÑ ÑÐ°Ð²ÐµÐ½ " ÑÐ±Ð»Ð¾Ðº", Ð° Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ»Ð°Ð¹Ð´ÐµÑÐ° Ð±ÑÐ´ÐµÑ ÑÐ°Ð²Ð½Ð¾ 50, ÑÐ¾ Ð½Ð° ÑÐºÑÐ°Ð½Ðµ Ð±ÑÐ´ÐµÑ Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð¾ "Ð¡ÑÐµÐ´ÐµÐ½Ð¾ 50 ÑÐ±Ð»Ð¾Ðº".

			ÐÐ½ÑÐµÑÐ°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.

		{"Switch", ÐÐºÑÐ¸Ð²Ð½ÑÐ¹ ÑÐ²ÐµÑ, ÐÐ°ÑÑÐ¸Ð²Ð½ÑÐ¹ ÑÐ²ÐµÑ, Ð¦Ð²ÐµÑ ÑÐµÐºÑÑÐ°, Ð¢ÐµÐºÑÑ, Ð¡Ð¾ÑÑÐ¾ÑÐ½Ð¸Ðµ}

			 ÐÐµÑÐµÐºÐ»ÑÑÐ°ÑÐµÐ»Ñ, Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑÐ¸Ð¹ Ð´Ð²Ð° ÑÐ¾ÑÑÐ¾ÑÐ½Ð¸Ñ: true Ð¸Ð»Ð¸ false. Ð¢ÐµÐºÑÑ - ÑÑÐ¾ Ð²ÑÐµÐ³Ð¾ Ð»Ð¸ÑÑ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ, Ð½ÐµÐºÐ¾Ðµ
			 Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¿ÐµÑÐµÐºÐ»ÑÑÐ°ÑÐµÐ»Ñ.

			 ÐÐ½ÑÐµÑÐ°ÐºÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.  

		{"CenterText", Ð¦Ð²ÐµÑ ÑÐµÐºÑÑÐ°, Ð¡Ð°Ð¼ ÑÐµÐºÑÑ}

			ÐÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ ÑÐµÐºÑÑÐ° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ²ÐµÑÐ° Ð¿Ð¾ ÑÐµÐ½ÑÑÑ Ð¾ÐºÐ½Ð°. Ð§Ð¸ÑÑÐ¾ Ð´Ð»Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð²Ð½ÑÑ ÑÐµÐ»ÐµÐ¹.

		{"WrappedText", Ð¦Ð²ÐµÑ ÑÐµÐºÑÑÐ°, Ð¢ÐµÐºÑÑ}

			ÐÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð±Ð¾Ð»ÑÑÐ¾Ð³Ð¾ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð° ÑÐµÐºÑÑÐ° Ñ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸Ð¼ Ð¿ÐµÑÐµÐ½Ð¾ÑÐ¾Ð¼. ÐÑÐ¾ÑÐ¾ ÑÐµÐ¶ÐµÑ ÑÐ»Ð¾Ð²Ð° Ð½Ð° ÐºÑÑÐ¾ÑÐºÐ¸,
			Ð¿ÐµÑÐµÐ½Ð¾Ñ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¸ÑÐµÑÐºÐ¸Ð¹. Ð§Ð¸ÑÑÐ¾ Ð´Ð»Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð²Ð½ÑÑ ÑÐµÐ»ÐµÐ¹.
 
        {"TextField", ÐÑÑÐ¾ÑÐ°, Ð¦Ð²ÐµÑ ÑÐ¾Ð½Ð°, Ð¦Ð²ÐµÑ ÑÐµÐºÑÑÐ°, Ð¦Ð²ÐµÑ ÑÐºÑÐ¾Ð»Ð»Ð±Ð°ÑÐ°, Ð¦Ð²ÐµÑ Ð¿Ð¸Ð¼Ð¿Ð¾ÑÐºÐ¸ ÑÐºÑÐ¾Ð»Ð»Ð±Ð°ÑÐ°, Ð¡Ð°Ð¼ ÑÐµÐºÑÑ}
 
        	Ð¢ÐµÐºÑÑÐ¾Ð²Ð¾Ðµ Ð¿Ð¾Ð»Ðµ Ñ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑÑ Ð¿ÑÐ¾ÐºÑÑÑÐºÐ¸. ÐÑÐ»Ð¸ÑÐ°ÐµÑÑÑ Ð¾Ñ "WrappedText"
        	ÑÐ¸ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾Ð¹ Ð²ÑÑÐ¾ÑÐ¾Ð¹. Ð§Ð¸ÑÑÐ¾ Ð´Ð»Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð²Ð½ÑÑ ÑÐµÐ»ÐµÐ¹.
   
        {"Separator", Ð¦Ð²ÐµÑ ÑÐ°Ð·Ð´ÐµÐ»Ð¸ÑÐµÐ»Ñ}
 
        	ÐÐ¸Ð½Ð¸Ñ-ÑÐ°Ð·Ð´ÐµÐ»Ð¸ÑÐµÐ»Ñ, Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÑÑÐ°Ñ Ð»ÑÑÑÐµ Ð¾ÑÐ´ÐµÐ»ÑÑÑ Ð¾Ð±ÑÐµÐºÑÑ Ð´ÑÑÐ³ Ð¾Ñ Ð´ÑÑÐ³Ð°. ÐÐµÐºÐ¾ÑÐ°ÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.
 
		{"EmptyLine"}
 
        	ÐÑÑÑÐ¾Ðµ Ð¿ÑÐ¾ÑÑÑÐ°Ð½ÑÑÐ²Ð¾, Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÑÑÐ°Ñ Ð»ÑÑÑÐµ Ð¾ÑÐ´ÐµÐ»ÑÑÑ Ð¾Ð±ÑÐµÐºÑÑ Ð´ÑÑÐ³ Ð¾Ñ Ð´ÑÑÐ³Ð°. ÐÐµÐºÐ¾ÑÐ°ÑÐ¸Ð²Ð½ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ.
 
		ÐÐ°Ð¶Ð´ÑÐ¹ Ð¸Ð· Ð¾Ð±ÑÐµÐºÑÐ¾Ð² ÑÐ¸ÑÑÐµÑÑÑ Ð¿Ð¾ Ð¿Ð¾ÑÑÐ´ÐºÑ ÑÐ²ÐµÑÑÑ Ð²Ð½Ð¸Ð·. ÐÐ°Ð¶Ð´ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸
		ÑÐ²ÐµÐ»Ð¸ÑÐ¸Ð²Ð°ÐµÑ Ð²ÑÑÐ¾ÑÑ Ð¾ÐºÐ½Ð° Ð´Ð¾ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾Ð³Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ. ÐÑÐ»Ð¸ Ð¾Ð±ÑÐµÐºÑÐ¾Ð² Ð±ÑÐ´ÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð¾ ÑÐ»Ð¸ÑÐºÐ¾Ð¼ Ð¼Ð½Ð¾Ð³Ð¾ -
		Ñ.Ðµ. ÐµÑÐ»Ð¸ Ð¾ÐºÐ½Ð¾ Ð²ÑÐ»ÐµÐ·ÐµÑ Ð·Ð° Ð¿ÑÐµÐ´ÐµÐ»Ñ ÑÐºÑÐ°Ð½Ð°, ÑÐ¾ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð° Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑÑ Ñ Ð¾ÑÐ¸Ð±ÐºÐ¾Ð¹.

	Ð§ÑÐ¾ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ ÑÑÐ½ÐºÑÐ¸Ñ:
		
		ÐÐ¾Ð·Ð²ÑÐ°ÑÐ¾Ð¼ ÑÐ²Ð»ÑÐµÑÑÑ Ð¼Ð°ÑÑÐ¸Ð², Ð¿ÑÐ¾Ð½ÑÐ¼ÐµÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹ Ð¾Ñ 1 Ð´Ð¾ <ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð° Ð¾Ð±ÑÐµÐºÑÐ¾Ð²>.
		Ð Ð¿ÑÐ¸Ð¼ÐµÑÑ, 1 Ð¸Ð½Ð´ÐµÐºÑ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð° ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²ÑÐµÑ 1 ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¾Ð±ÑÐµÐºÑÑ.
		ÐÐ°Ð¶Ð´ÑÐ¹ Ð¸Ð½Ð´ÐµÐºÑ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð½ÐµÑÐµÑ Ð² ÑÐµÐ±Ðµ ÐºÐ°ÐºÐ¸Ðµ-ÑÐ¾ Ð´Ð°Ð½Ð½ÑÐµ, ÐºÐ¾ÑÐ¾ÑÑÐµ Ð²Ñ
		Ð²Ð½ÐµÑÐ»Ð¸ Ð² Ð¾Ð±ÑÐµÐºÑ Ð²Ð¾ Ð²ÑÐµÐ¼Ñ ÑÐ°Ð±Ð¾ÑÑ ÑÑÐ½ÐºÑÐ¸Ð¸.
		ÐÐ°Ð¿ÑÐ¸Ð¼ÐµÑ, ÐµÑÐ»Ð¸ Ð² 1-ÑÐ¹ Ð¾Ð±ÑÐµÐºÑ ÑÐ¸Ð¿Ð° "Input" Ð²Ñ Ð²Ð²ÐµÐ»Ð¸ ÑÑÐ°Ð·Ñ "Hello world",
		ÑÐ¾ Ð¿ÐµÑÐ²ÑÐ¹ Ð¸Ð½Ð´ÐµÐºÑ Ð² Ð²Ð¾Ð·Ð²ÑÐ°ÑÐµÐ½Ð½Ð¾Ð¼ Ð¼Ð°ÑÑÐ¸Ð²Ðµ Ð±ÑÐ´ÐµÑ ÑÐ°Ð²ÐµÐ½ "Hello world".
		ÐÐ¾Ð½ÐºÑÐµÑÐ½ÐµÐµ ÑÑÐ¾ Ð±ÑÐ´ÐµÑ Ð²Ð¾Ñ ÑÐ°Ðº: massiv[1] = "Hello world".

		ÐÑÐ»Ð¸ Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑÐ²Ð¸Ðµ Ñ Ð¾Ð±ÑÐµÐºÑÐ¾Ð¼ Ð½ÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ - Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ, ÐºÐ°Ðº Ð² ÑÐ»ÑÑÐ°Ðµ
		Ñ EmptyLine, CenterText, TextField Ð¸Ð»Ð¸ Separator, ÑÐ¾ Ð² Ð²Ð¾Ð·Ð²ÑÐ°ÑÐµÐ½Ð½Ð¾Ð¼
		Ð¼Ð°ÑÑÐ¸Ð²Ðµ ÑÑÐ¾Ñ Ð¾Ð±ÑÐµÐºÑ ÑÐºÐ°Ð·ÑÐ²Ð°ÑÑÑÑ Ð½Ðµ Ð±ÑÐ´ÐµÑ.

		ÐÐ¾ÑÐ¾Ð²ÑÐµ Ð¿ÑÐ¸Ð¼ÐµÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÑÐ½ÐºÑÐ¸Ð¸ ÑÐºÐ°Ð·Ð°Ð½Ñ Ð½Ð¸Ð¶Ðµ Ð¸ Ð·Ð°ÐºÐ¾Ð¼Ð¼ÐµÐ½ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ñ.
		ÐÑÐ±Ð¸ÑÐ°Ð¹ÑÐµ Ð½ÑÐ¶Ð½ÑÐ¹ Ð¸ ÑÐ°ÑÐºÐ¾Ð¼Ð¼ÐµÐ½ÑÐ¸ÑÑÐ¹ÑÐµ.
]]

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-Ð´ÐµÐ¼Ð¾Ð½ÑÑÑÐ°ÑÐ¾Ñ, Ð¿Ð¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑÐ°Ñ Ð²ÑÐµ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÐµ Ð¾Ð±ÑÐµÐºÑÑ Ð² Ð¾Ð´Ð½Ð¾Ð¼ Ð¾ÐºÐ½Ðµ. ÐÐ¾Ð´ Ð¾ÐºÐ½Ð° Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð²ÑÑÐµ.
--ecs.demoWindow()

--Ð¤ÑÐ½ÐºÑÐ¸Ñ, Ð¿ÑÐµÐ´Ð»Ð°Ð³Ð°ÑÑÐ°Ñ ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ ÑÐ°Ð¹Ð» Ð² Ð½ÑÐ¶Ð½Ð¾Ð¼ Ð¼ÐµÑÑÐµ Ð² Ð½ÑÐ¶Ð½Ð¾Ð¼ ÑÐ¾ÑÐ¼Ð°ÑÐµ.
--ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, "Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÐºÐ°Ðº"}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, "ÐÑÑÑ"}, {"Selector", 0x262626, 0x880000, "PNG", "JPG", "PSD"}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK!"}})

----------------------------------------------------------------------------------------------------

return ecs


Flib/GUI.lua	
----------------------------------------- Libraries -----------------------------------------

require("advancedLua")
local keyboard = require("keyboard")
local buffer = require("doubleBuffering")
local unicode = require("unicode")
local event = require("event")
local syntax = require("syntax")
local fs = require("filesystem")

----------------------------------------- Core constants -----------------------------------------

local GUI = {}

GUI.alignment = {
	horizontal = enum(
		"left",
		"center",
		"right"
	),
	vertical = enum(
		"top",
		"center",
		"bottom"
	)
}

GUI.directions = enum(
	"horizontal",
	"vertical"
)

GUI.colors = {
	disabled = {
		background = 0x888888,
		text = 0xAAAAAA
	},
	contextMenu = {
		separator = 0xAAAAAA,
		default = {
			background = 0xFFFFFF,
			text = 0x2D2D2D
		},
		disabled = {
			text = 0xAAAAAA
		},
		pressed = {
			background = 0x3366CC,
			text = 0xFFFFFF
		},
		transparency = {
			background = 20,
			shadow = 50
		}
	}
}

GUI.dropDownMenuElementTypes = enum(
	"default",
	"separator"
)

GUI.objectTypes = enum(
	"unknown",
	"empty",
	"panel",
	"label",
	"button",
	"framedButton",
	"image",
	"windowActionButtons",
	"windowActionButton",
	"tabBar",
	"tabBarTab",
	"menu",
	"menuItem",
	"window",
	"inputTextBox",
	"textBox",
	"horizontalSlider",
	"switch",
	"progressBar",
	"chart",
	"comboBox",
	"scrollBar",
	"codeView",
	"treeView",
	"colorSelector"
)

----------------------------------------- Primitive objects -----------------------------------------

-- Universal method to check if object was clicked by following coordinates
local function isObjectClicked(object, x, y)
	if x >= object.x and y >= object.y and x <= object.x + object.width - 1 and y <= object.y + object.height - 1 and not object.disabled and not object.isHidden then return true end
	return false
end

-- Limit object's text field to its' size
local function objectTextLimit(object)
	local text, textLength = object.text, unicode.len(object.text)
	if textLength > object.width then text = unicode.sub(text, 1, object.width); textLength = object.width end
	return text, textLength
end

-- Base object to use in everything
function GUI.object(x, y, width, height)
	return {
		x = x,
		y = y,
		width = width,
		height = height,
		isClicked = isObjectClicked
	}
end

function GUI.point(x, y)
	return { x = x, y = y }
end

----------------------------------------- Object alignment -----------------------------------------

-- Set children alignment in parent object
function GUI.setAlignment(object, horizontalAlignment, verticalAlignment)
	object.alignment = {
		horizontal = horizontalAlignment,
		vertical = verticalAlignment
	}
	return object
end

-- Get subObject position inside of parent object
function GUI.getAlignmentCoordinates(object, subObject)	
	local x, y
	if object.alignment.horizontal == GUI.alignment.horizontal.left then
		x = object.x
	elseif object.alignment.horizontal == GUI.alignment.horizontal.center then
		x = math.floor(object.x + object.width / 2 - subObject.width / 2)
	elseif object.alignment.horizontal == GUI.alignment.horizontal.right then
		x = object.x + object.width - subObject.width
	else
		error("Unknown horizontal alignment: " .. tostring(object.alignment.horizontal))
	end

	if object.alignment.vertical == GUI.alignment.vertical.top then
		y = object.y
	elseif object.alignment.vertical == GUI.alignment.vertical.center then
		y = math.floor(object.y + object.height / 2 - subObject.height / 2)
	elseif object.alignment.vertical == GUI.alignment.vertical.bottom then
		y = object.y + object.height - subObject.height
	else
		error("Unknown vertical alignment: " .. tostring(object.alignment.vertical))
	end

	return x, y
end

----------------------------------------- Containers -----------------------------------------

-- Go recursively through every container's object (including other containers) and return object that was clicked firstly by it's GUI-layer position
function GUI.getClickedObject(container, xEvent, yEvent)
	local clickedObject, clickedIndex
	for childIndex = #container.children, 1, -1 do
		if not container.children[childIndex].isHidden then
			container.children[childIndex].x, container.children[childIndex].y = container.children[childIndex].localPosition.x + container.x - 1, container.children[childIndex].localPosition.y + container.y - 1
			if container.children[childIndex].children and #container.children[childIndex].children > 0 then
				clickedObject, clickedIndex = GUI.getClickedObject(container.children[childIndex], xEvent, yEvent)
			    if clickedObject then break end
			elseif container.children[childIndex]:isClicked(xEvent, yEvent) then
				clickedObject, clickedIndex = container.children[childIndex], childIndex
				break
			end
		end
	end

	return clickedObject, clickedIndex
end

local function checkObjectParentExists(object)
	if not object.parent then error("Object doesn't have a parent container") end
end

local function containerObjectIndexOf(object)
	checkObjectParentExists(object)
	for objectIndex = 1, #object.parent.children do
		if object.parent.children[objectIndex] == object then
			return objectIndex
		end
	end
end

-- Move container's object "closer" to our eyes
local function containerObjectMoveForward(object)
	local objectIndex = object:indexOf()
	if objectIndex < #object.parent.children then
		object.parent.children[index], object.parent.children[index + 1] = swap(object.parent.children[index], object.parent.children[index + 1])
	end
end

-- Move container's object "more far out" of our eyes
local function containerObjectMoveBackward(object)
	local objectIndex = object:indexOf()
	if objectIndex > 1 then
		object.parent.children[index], object.parent.children[index - 1] = swap(object.parent.children[index], object.parent.children[index - 1])
	end
end

-- Move container's object to front of all objects
local function containerObjectMoveToFront(object)
	local objectIndex = object:indexOf()
	table.insert(object.parent.children, object)
	table.remove(object.parent.children, objectIndex)
end

-- Move container's object to back of all objects
local function containerObjectMoveToBack(object)
	local objectIndex = object:indexOf()
	table.insert(object.parent.children, 1, object)
	table.remove(object.parent.children, objectIndex + 1)
end

local function containerGetFirstParent(object)
	if object.parent then
		local currentParent = object.parent
		while currentParent.parent do
			currentParent = currentParent.parent
		end
		return currentParent
	else
		error("Object doesn't have any parents")
	end
end

-- Add any object as children to parent container with specified objectType
function GUI.addChildToContainer(container, object, objectType)
	object.type = objectType or GUI.objectTypes.unknown
	object.parent = container
	object.indexOf = containerObjectIndexOf
	object.moveToFront = containerObjectMoveToFront
	object.moveToBack = containerObjectMoveToBack
	object.moveForward = containerObjectMoveForward
	object.moveBackward = containerObjectMoveBackward
	object.getFirstParent = containerGetFirstParent
	object.localPosition = {x = object.x, y = object.y}

	table.insert(container.children, object)
	
	return object
end

-- Add empty GUI.object to container
local function addEmptyObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.object(...), GUI.objectTypes.empty)
end

-- Add button object to container
local function addButtonObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.button(...), GUI.objectTypes.button)
end

-- Add adaptive button object to container
local function addAdaptiveButtonObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.adaptiveButton(...), GUI.objectTypes.button)
end

-- Add framedButton object to container
local function addFramedButtonObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.framedButton(...), GUI.objectTypes.button)
end

-- Add adaptive framedButton object to container
local function addAdaptiveFramedButtonObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.adaptiveFramedButton(...), GUI.objectTypes.button)
end

-- Add label object to container
local function addLabelObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.label(...), GUI.objectTypes.label)
end

-- Add panel object to container
local function addPanelObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.panel(...), GUI.objectTypes.panel)
end

-- Add windowActionButtons object to container
local function addWindowActionButtonsObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.windowActionButtons(...), GUI.objectTypes.windowActionButtons)
end

-- Add another container to container
local function addContainerToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.container(...), GUI.objectTypes.container)
end

-- Add image object to container
local function addImageObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.image(...), GUI.objectTypes.image)
end

-- Add image object to container
local function addTabBarObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.tabBar(...), GUI.objectTypes.tabBar)
end

-- Add InputTextBox object to container
local function addInputTextBoxObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.inputTextBox(...), GUI.objectTypes.inputTextBox)
end

-- Add TextBox object to container
local function addTextBoxObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.textBox(...), GUI.objectTypes.textBox)
end

-- Add Horizontal Slider object to container
local function addHorizontalSliderObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.horizontalSlider(...), GUI.objectTypes.horizontalSlider)
end

-- Add Progressbar object to container
local function addProgressBarObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.progressBar(...), GUI.objectTypes.progressBar)
end

-- Add Switch object to container
local function addSwitchObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.switch(...), GUI.objectTypes.switch)
end

-- Add Chart object to container
local function addChartObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.chart(...), GUI.objectTypes.chart)
end

-- Add ComboBox object to container
local function addComboBoxObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.comboBox(...), GUI.objectTypes.comboBox)
end

-- Add Menu object to container
local function addMenuObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.menu(...), GUI.objectTypes.menu)
end

-- Add ScrollBar object to container
local function addScrollBarObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.scrollBar(...), GUI.objectTypes.scrollBar)
end

-- Add CodeView object to container
local function addCodeViewObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.codeView(...), GUI.objectTypes.codeView)
end

-- Add TreeView object to container
local function addTreeViewObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.treeView(...), GUI.objectTypes.treeView)
end

-- Add ColorSelector object to container
local function addColorSelectorObjectToContainer(container, ...)
	return GUI.addChildToContainer(container, GUI.colorSelector(...), GUI.objectTypes.colorSelector)
end

-- Recursively draw container's content including all children container's content
local function drawContainerContent(container)
	for objectIndex = 1, #container.children do
		if not container.children[objectIndex].isHidden then
			container.children[objectIndex].x, container.children[objectIndex].y = container.children[objectIndex].localPosition.x + container.x - 1, container.children[objectIndex].localPosition.y + container.y - 1
			if container.children[objectIndex].children then
				-- cyka blyad
				-- drawContainerContent(container.children[objectIndex])
				-- We use :draw() method against of recursive call. The reason is possible user-defined :draw() reimplementations
				container.children[objectIndex]:draw()
			else
				-- if container.children[objectIndex].draw then
					container.children[objectIndex]:draw()
				-- else
				-- 	error("Container object with index " .. objectIndex .. " doesn't have :draw() method")
				-- end
			end
		end
	end

	return container
end

-- Delete every container's children object
local function deleteContainersContent(container)
	for objectIndex = 1, #container.children do container.children[objectIndex] = nil end
end

-- Universal container to store any other objects like buttons, labels, etc
function GUI.container(x, y, width, height)
	local container = GUI.object(x, y, width, height)
	container.children = {}
	container.draw = drawContainerContent
	container.getClickedObject = GUI.getClickedObject
	container.deleteChildren = deleteContainersContent

	container.addChild = GUI.addChildToContainer
	container.addObject = addEmptyObjectToContainer
	container.addContainer = addContainerToContainer
	container.addPanel = addPanelObjectToContainer
	container.addLabel = addLabelObjectToContainer
	container.addButton = addButtonObjectToContainer
	container.addAdaptiveButton = addAdaptiveButtonObjectToContainer
	container.addFramedButton = addFramedButtonObjectToContainer
	container.addAdaptiveFramedButton = addAdaptiveFramedButtonObjectToContainer
	container.addWindowActionButtons = addWindowActionButtonsObjectToContainer
	container.addImage = addImageObjectToContainer
	container.addTabBar = addTabBarObjectToContainer
	container.addTextBox = addTextBoxObjectToContainer
	container.addInputTextBox = addInputTextBoxObjectToContainer
	container.addHorizontalSlider = addHorizontalSliderObjectToContainer
	container.addSwitch = addSwitchObjectToContainer
	container.addProgressBar = addProgressBarObjectToContainer
	container.addChart = addChartObjectToContainer
	container.addComboBox = addComboBoxObjectToContainer
	container.addMenu = addMenuObjectToContainer
	container.addScrollBar = addScrollBarObjectToContainer
	container.addCodeView = addCodeViewObjectToContainer
	container.addTreeView = addTreeViewObjectToContainer
	container.addColorSelector = addColorSelectorObjectToContainer

	return container
end

----------------------------------------- Buttons -----------------------------------------

local function drawButton(object)
	local text, textLength = objectTextLimit(object)

	local xText, yText = GUI.getAlignmentCoordinates(object, {width = textLength, height = 1})
	local buttonColor = object.disabled and object.colors.disabled.background or (object.pressed and object.colors.pressed.background or object.colors.default.background)
	local textColor = object.disabled and object.colors.disabled.text or (object.pressed and object.colors.pressed.text or object.colors.default.text)

	if buttonColor then
		if object.buttonType == GUI.objectTypes.button then
			buffer.square(object.x, object.y, object.width, object.height, buttonColor, textColor, " ")
		else
			buffer.frame(object.x, object.y, object.width, object.height, buttonColor)
		end
	end

	buffer.text(xText, yText, textColor, text)

	return object
end

local function pressButton(object)
	object.pressed = true
	drawButton(object)
end

local function releaseButton(object)
	object.pressed = nil
	drawButton(object)
end

local function pressAndReleaseButton(object, pressTime)
	pressButton(object)
	buffer.draw()
	os.sleep(pressTime or 0.2)
	releaseButton(object)
	buffer.draw()
end

-- Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÑÐ°Ð±Ð»Ð¸ÑÑ ÐºÐ½Ð¾Ð¿ÐºÐ¸ ÑÐ¾ Ð²ÑÐµÐ¼Ð¸ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÐ¼Ð¸ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°Ð¼Ð¸
local function createButtonObject(buttonType, x, y, width, height, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
	local object = GUI.object(x, y, width, height)
	object.colors = {
		default = {
			background = buttonColor,
			text = textColor
		},
		pressed = {
			background = buttonPressedColor,
			text = textPressedColor
		},
		disabled = {
			background = GUI.colors.disabled.background,
			text = GUI.colors.disabled.text,
		}
	}
	object.buttonType = buttonType
	object.disabled = disabledState
	object.text = text
	object.press = pressButton
	object.release = releaseButton
	object.pressAndRelease = pressAndReleaseButton
	object.draw = drawButton
	object.setAlignment = GUI.setAlignment
	object:setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.center)

	return object
end

-- ÐÐ½Ð¾Ð¿ÐºÐ° ÑÐ¸ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÐ°Ð·Ð¼ÐµÑÐ¾Ð²
function GUI.button(x, y, width, height, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
	return createButtonObject(GUI.objectTypes.button, x, y, width, height, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
end

-- ÐÐ½Ð¾Ð¿ÐºÐ°, Ð¿Ð¾Ð´ÑÑÑÐ°Ð¸Ð²Ð°ÑÑÐ°ÑÑÑ Ð¿Ð¾Ð´ ÑÐ°Ð·Ð¼ÐµÑ ÑÐµÐºÑÑÐ°
function GUI.adaptiveButton(x, y, xOffset, yOffset, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState) 
	return createButtonObject(GUI.objectTypes.button, x, y, unicode.len(text) + xOffset * 2, yOffset * 2 + 1, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
end

-- ÐÐ½Ð¾Ð¿ÐºÐ° Ð² ÑÐ°Ð¼ÐºÐµ
function GUI.framedButton(x, y, width, height, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
	return createButtonObject(GUI.objectTypes.framedButton, x, y, width, height, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
end

function GUI.adaptiveFramedButton(x, y, xOffset, yOffset, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
	return createButtonObject(GUI.objectTypes.framedButton, x, y, unicode.len(text) + xOffset * 2, yOffset * 2 + 1, buttonColor, textColor, buttonPressedColor, textPressedColor, text, disabledState)
end

----------------------------------------- TabBar -----------------------------------------

local function drawTabBar(object)
	for tab = 1, #object.tabs.children do
		if tab == object.selectedTab then
			object.tabs.children[tab].pressed = true
		else
			object.tabs.children[tab].pressed = false
		end
	end

	object:reimplementedDraw()
	return object
end

function GUI.tabBar(x, y, width, height, spaceBetweenElements, backgroundColor, textColor, backgroundSelectedColor, textSelectedColor, ...)
	local elements, object = {...}, GUI.container(x, y, width, height)
	object.selectedTab = 1
	object.tabsWidth = 0; for elementIndex = 1, #elements do object.tabsWidth = object.tabsWidth + unicode.len(elements[elementIndex]) + 2 + spaceBetweenElements end; object.tabsWidth = object.tabsWidth - spaceBetweenElements
	object.reimplementedDraw = object.draw
	object.draw = drawTabBar

	object:addPanel(1, 1, object.width, object.height, backgroundColor)
	object.tabs = object:addContainer(1, 1, object.width, object.height)

	x = math.floor(width / 2 - object.tabsWidth / 2)
	for elementIndex = 1, #elements do
		local tab = object.tabs:addButton(x, 1, unicode.len(elements[elementIndex]) + 2, height, backgroundColor, textColor, backgroundSelectedColor, textSelectedColor, elements[elementIndex])
		tab.type = GUI.objectTypes.tabBarTab
		x = x + tab.width + spaceBetweenElements
	end	

	return object
end

----------------------------------------- Panel -----------------------------------------

local function drawPanel(object)
	buffer.square(object.x, object.y, object.width, object.height, object.colors.background, 0x000000, " ", object.colors.transparency)
	return object
end

function GUI.panel(x, y, width, height, color, transparency)
	local object = GUI.object(x, y, width, height)
	object.colors = {background = color, transparency = transparency}
	object.draw = drawPanel
	return object
end

----------------------------------------- Label -----------------------------------------

local function drawLabel(object)
	local text, textLength = objectTextLimit(object)
	local xText, yText = GUI.getAlignmentCoordinates(object, {width = textLength, height = 1})
	buffer.text(xText, yText, object.colors.text, text)
	return object
end

function GUI.label(x, y, width, height, textColor, text)
	local object = GUI.object(x, y, width, height)
	object.setAlignment = GUI.setAlignment
	object:setAlignment(GUI.alignment.horizontal.left, GUI.alignment.vertical.top)
	object.colors = {text = textColor}
	object.text = text
	object.draw = drawLabel
	return object
end

----------------------------------------- Image -----------------------------------------

local function drawImage(object)
	buffer.image(object.x, object.y, object.image)
	return object
end

function GUI.image(x, y, image)
	local object = GUI.object(x, y, image.width, image.height)
	object.image = image
	object.draw = drawImage
	return object
end

----------------------------------------- Window action buttons -----------------------------------------

function GUI.windowActionButtons(x, y, fatSymbol)
	local symbol = fatSymbol and "â¬¤" or "â"
	
	local container = GUI.container(x, y, 5, 1)
	container.close = container:addButton(1, 1, 1, 1, nil, 0xFF4940, nil, 0x992400, symbol)
	container.minimize = container:addButton(3, 1, 1, 1, nil, 0xFFB640, nil, 0x996D00, symbol)
	container.maximize = container:addButton(5, 1, 1, 1, nil, 0x00B640, nil, 0x006D40, symbol)

	return container
end

----------------------------------------- Dropdown Menu -----------------------------------------

local function drawDropDownMenuElement(object, itemIndex, isPressed)
	local y = object.y + itemIndex * (object.spaceBetweenElements + 1) - 1
	local yText = math.floor(y)
	
	if object.items[itemIndex].type == GUI.dropDownMenuElementTypes.default then
		local textColor = object.items[itemIndex].disabled and object.colors.disabled.text or (object.items[itemIndex].color or object.colors.default.text)

		-- ÐÐ°Ð¶Ð°ÑÐ¸Ðµ
		if isPressed then
			buffer.square(object.x, y - object.spaceBetweenElements, object.width, object.spaceBetweenElements * 2 + 1, object.colors.pressed.background, object.colors.pressed.text, " ")
			textColor = object.colors.pressed.text
		end

		-- ÐÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÐµÐºÑÑ
		buffer.text(object.x + object.sidesOffset, yText, textColor, string.limit(object.items[itemIndex].text, object.width - object.sidesOffset * 2, false))
		-- Ð¨ÑÑÑÐºÐ°ÑÐ¸ÐºÑÑ
		if object.items[itemIndex].shortcut then
			buffer.text(object.x + object.width - unicode.len(object.items[itemIndex].shortcut) - object.sidesOffset, yText, textColor, object.items[itemIndex].shortcut)
		end
	else
		-- Ð¡ÐµÐ¿Ð°ÑÐ°ÑÐ¾Ñ
		buffer.text(object.x, yText, object.colors.separator, string.rep("â", object.width))
	end
end

local function drawDropDownMenu(object)
	buffer.square(object.x, object.y, object.width, object.height, object.colors.default.background, object.colors.default.text, " ", object.colors.transparency)
	if object.drawShadow then GUI.windowShadow(object.x, object.y, object.width, object.height, GUI.colors.contextMenu.transparency.shadow, true) end
	for itemIndex = 1, #object.items do drawDropDownMenuElement(object, itemIndex, false) end
end

local function showDropDownMenu(object)
	local oldDrawLimit = buffer.getDrawLimit(); buffer.resetDrawLimit()
	object.height = #object.items * (object.spaceBetweenElements + 1) + object.spaceBetweenElements

	local oldPixels = buffer.copy(object.x, object.y, object.width + 1, object.height + 1)
	local function quit()
		buffer.paste(object.x, object.y, oldPixels)
		buffer.draw()
		buffer.setDrawLimit(oldDrawLimit)
	end

	drawDropDownMenu(object)
	buffer.draw()

	while true do
		local e = {event.pull()}
		if e[1] == "touch" then
			local objectFound = false
			for itemIndex = 1, #object.items do
				if 
					e[3] >= object.x and
					e[3] <= object.x + object.width - 1 and
					e[4] == object.y + itemIndex * (object.spaceBetweenElements + 1) - 1
				then
					objectFound = true
					if not object.items[itemIndex].disabled and object.items[itemIndex].type == GUI.dropDownMenuElementTypes.default then
						drawDropDownMenuElement(object, itemIndex, true)
						buffer.draw()
						os.sleep(0.2)
						quit()
						if object.items[itemIndex].onTouch then object.items[itemIndex].onTouch() end
						return object.items[itemIndex].text, itemIndex
					end
					break
				end
			end

			if not objectFound then quit(); return end
		end
	end
end

local function addDropDownMenuItem(object, text, disabled, shortcut, color)
	local item = {}
	item.type = GUI.dropDownMenuElementTypes.default
	item.text = text
	item.disabled = disabled
	item.shortcut = shortcut
	item.color = color

	table.insert(object.items, item)
	return item
end

local function addDropDownMenuSeparator(object)
	local item = {type = GUI.dropDownMenuElementTypes.separator}
	table.insert(object.items, item)
	return item
end

function GUI.dropDownMenu(x, y, width, spaceBetweenElements, backgroundColor, textColor, backgroundPressedColor, textPressedColor, disabledColor, separatorColor, transparency, items)
	local object = GUI.object(x, y, width, 1)
	object.colors = {
		default = {
			background = backgroundColor,
			text = textColor
		},
		pressed = {
			background = backgroundPressedColor,
			text = textPressedColor
		},
		disabled = {
			text = disabledColor
		},
		separator = separatorColor,
		transparency = transparency
	}
	object.sidesOffset = 2
	object.spaceBetweenElements = spaceBetweenElements
	object.addSeparator = addDropDownMenuSeparator
	object.addItem = addDropDownMenuItem
	object.items = {}
	if items then
		for i = 1, #items do
			object:addItem(items[i])
		end
	end
	object.drawShadow = true
	object.draw = drawDropDownMenu
	object.show = showDropDownMenu
	return object
end

----------------------------------------- Context Menu -----------------------------------------

local function showContextMenu(object)
	-- Ð Ð°ÑÑÐµÑ ÑÐ¸ÑÐ¸Ð½Ñ Ð¾ÐºÐ½Ð° Ð¼ÐµÐ½Ñ
	local longestItem, longestShortcut = 0, 0
	for itemIndex = 1, #object.items do
		if object.items[itemIndex].type == GUI.dropDownMenuElementTypes.default then
			longestItem = math.max(longestItem, unicode.len(object.items[itemIndex].text))
			if object.items[itemIndex].shortcut then longestShortcut = math.max(longestShortcut, unicode.len(object.items[itemIndex].shortcut)) end
		end
	end
	object.width = object.sidesOffset + longestItem + (longestShortcut > 0 and 3 + longestShortcut or 0) + object.sidesOffset
	object.height = #object.items * (object.spaceBetweenElements + 1) + object.spaceBetweenElements

	-- Ð ÑÑÐ¾ ÑÑÐ¾Ð± Ð·Ð° ÐºÑÐ°Ñ ÑÐºÑÐ°Ð½Ð° Ð½Ðµ Ð»ÐµÐ·Ð»Ð¾
	if object.y + object.height >= buffer.screen.height then object.y = buffer.screen.height - object.height end
	if object.x + object.width + 1 >= buffer.screen.width then object.x = buffer.screen.width - object.width - 1 end

	return object:reimplementedShow()
end

function GUI.contextMenu(x, y, ...)
	local argumentItems = {...}
	local object = GUI.dropDownMenu(x, y, 1, 0, GUI.colors.contextMenu.default.background, GUI.colors.contextMenu.default.text, GUI.colors.contextMenu.pressed.background, GUI.colors.contextMenu.pressed.text, GUI.colors.contextMenu.disabled.text, GUI.colors.contextMenu.separator, GUI.colors.contextMenu.transparency.background)

	-- ÐÐ°Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð¼ÐµÐ½ÑÑÐºÑ Ð¿Ð°ÑÐ°ÑÐµÐ¹
	for itemIndex = 1, #argumentItems do
		if argumentItems[itemIndex] == "-" then
			object:addSeparator()
		else
			object:addItem(argumentItems[itemIndex][1], argumentItems[itemIndex][2], argumentItems[itemIndex][3], argumentItems[itemIndex][4])
		end
	end

	object.reimplementedShow = object.show
	object.show = showContextMenu
	object.selectedElement = nil
	object.spaceBetweenElements = 0

	return object
end

----------------------------------------- Menu -----------------------------------------

local function menuDraw(menu)
	buffer.square(menu.x, menu.y, menu.width, 1, menu.colors.default.background, menu.colors.default.text, " ", menu.colors.transparency)
	menu:reimplementedDraw()
end

local function menuAddItem(menu, text, textColor)
	local x = 2; for i = 1, #menu.children do x = x + unicode.len(menu.children[i].text) + 2; end
	local item = menu:addAdaptiveButton(x, 1, 1, 0, nil, textColor or menu.colors.default.text, menu.colors.pressed.background, menu.colors.pressed.text, text)
	item.type = GUI.objectTypes.menuItem
	return item
end

function GUI.menu(x, y, width, backgroundColor, textColor, backgroundPressedColor, textPressedColor, backgroundTransparency)
	local menu = GUI.container(x, y, width, 1)
	menu.colors = {
		default = {
			background = backgroundColor,
			text = textColor,
		},
		pressed = {
			background = backgroundPressedColor,
			text = textPressedColor,
		},
		transparency = backgroundTransparency
	}

	menu.addItem = menuAddItem
	menu.reimplementedDraw = menu.draw
	menu.draw = menuDraw

	return menu
end

----------------------------------------- ProgressBar Object -----------------------------------------

local function drawProgressBar(object)
	local activeWidth = math.floor(object.value * object.width / 100)
	if object.thin then
		buffer.text(object.x, object.y, object.colors.passive, string.rep("â", object.width))
		buffer.text(object.x, object.y, object.colors.active, string.rep("â", activeWidth))
	else
		buffer.square(object.x, object.y, object.width, object.height, object.colors.passive)
		buffer.square(object.x, object.y, activeWidth, object.height, object.colors.active)
	end

	if object.showValue then
		local stringValue = tostring((object.valuePrefix or "") .. object.value .. (object.valuePostfix or ""))
		buffer.text(math.floor(object.x + object.width / 2 - unicode.len(stringValue) / 2), object.y + 1, object.colors.value, stringValue)
	end

	return object
end

function GUI.progressBar(x, y, width, activeColor, passiveColor, valueColor, value, thin, showValue, valuePrefix, valuePostfix)
	local object = GUI.object(x, y, width, 1)
	object.value = value
	object.colors = {active = activeColor, passive = passiveColor, value = valueColor}
	object.thin = thin
	object.draw = drawProgressBar
	object.showValue = showValue
	object.valuePrefix = valuePrefix
	object.valuePostfix = valuePostfix
	return object
end

----------------------------------------- Other GUI elements -----------------------------------------

function GUI.windowShadow(x, y, width, height, transparency, thin)
	transparency = transparency or 50
	if thin then
		buffer.square(x + width, y + 1, 1, height - 1, 0x000000, 0x000000, " ", transparency)
		buffer.text(x + 1, y + height, 0x000000, string.rep("â", width), transparency)
		buffer.text(x + width, y, 0x000000, "â", transparency)
	else
		buffer.square(x + width, y + 1, 2, height, 0x000000, 0x000000, " ", transparency)
		buffer.square(x + 2, y + height, width - 2, 1, 0x000000, 0x000000, " ", transparency)
	end
end

------------------------------------------------- ÐÐºÐ½Ð° -------------------------------------------------------------------

-- ÐÑÐ°ÑÐ¸Ð²Ð¾Ðµ Ð¾ÐºÐ¾ÑÐºÐ¾ Ð´Ð»Ñ Ð¾ÑÐ¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ Ð¾Ð± Ð¾ÑÐ¸Ð±ÐºÐµ. ÐÑÐ³ÑÐ¼ÐµÐ½Ñ errorWindowParameters Ð¼Ð¾Ð¶ÐµÑ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ:
-- local errorWindowParameters = {
--   backgroundColor = 0x262626,
--   textColor = 0xFFFFFF,
--   truncate = 50,
--   title = {color = 0xFF8888, text = "ÐÑÐ¸Ð±Ð¾ÑÐºÐ°"}
--   noAnimation = true,
-- }
function GUI.error(text, errorWindowParameters)
	--ÐÑÑÐºÐ¸Ðµ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÑ, Ð±Ð»Ð°-Ð±Ð»Ð°
	local backgroundColor = (errorWindowParameters and errorWindowParameters.backgroundColor) or 0x1b1b1b
	local errorPixMap = {
		{{0xffdb40       , 0xffffff,"#"}, {0xffdb40       , 0xffffff, "#"}, {backgroundColor, 0xffdb40, "â"}, {backgroundColor, 0xffdb40, "â"}, {0xffdb40       , 0xffffff, "#"}, {0xffdb40       , 0xffffff, "#"}},
		{{0xffdb40       , 0xffffff,"#"}, {backgroundColor, 0xffdb40, "â"}, {0xffdb40       , 0xffffff, " "}, {0xffdb40       , 0xffffff, " "}, {backgroundColor, 0xffdb40, "â"}, {0xffdb40       , 0xffffff, "#"}},
		{{backgroundColor, 0xffdb40,"â"}, {0xffdb40       , 0xffffff, "c"}, {0xffdb40       , 0xffffff, "y"}, {0xffdb40       , 0xffffff, "k"}, {0xffdb40       , 0xffffff, "a"}, {backgroundColor, 0xffdb40, "â"}},
	}
	local textColor = (errorWindowParameters and errorWindowParameters.textColor) or 0xFFFFFF
	local buttonWidth = 12
	local verticalOffset = 2
	local minimumHeight = verticalOffset * 2 + #errorPixMap
	local height = 0
	local widthOfText = math.floor(buffer.screen.width * 0.5)

	--ÐÐ±ÐµÐ¼ÑÑ Ñ ÑÐµÐºÑÑÐ¾Ð¼, Ð´ÐµÐ»Ð°ÐµÐ¼ ÐµÐ³Ð¾ Ð¿Ð¸Ð·Ð´Ð°ÑÑÐ¼ Ð²Ð¾ Ð²ÑÐµÑ ÑÐ¼ÑÑÐ»Ð°Ñ
	if type(text) ~= "table" then
		text = tostring(text)
		text = (errorWindowParameters and errorWindowParameters.truncate) and unicode.sub(text, 1, errorWindowParameters.truncate) or text
		text = { text }
	end
	text = string.wrap(text, widthOfText)


	--ÐÐ±Ð°ÑÐ¸Ð¼ Ð²ÑÑÐ¾ÑÑ Ð¿ÑÐ°Ð²Ð¸Ð»ÑÐ½ÑÑe
	height = verticalOffset * 2 + #text + 1
	if errorWindowParameters and errorWindowParameters.title then height = height + 2 end
	if height < minimumHeight then height = minimumHeight end

	--ÐÐ±Ð°ÑÐ¸Ð¼ ÑÑÐ°ÑÑÐ¾Ð²ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸
	local x, y = math.ceil(buffer.screen.width / 2 - widthOfText / 2), math.ceil(buffer.screen.height / 2 - height / 2)
	local OKButton = {}
	local oldPixels = buffer.copy(1, y, buffer.screen.width, height)

	--ÐÑÑÐ¸ÑÐ¾Ð²Ð¾ÑÐºÐ°
	local function draw()
		local yPos = y
		--ÐÐ¾Ð´Ð»Ð¾Ð¶ÐºÐ°
		buffer.square(1, yPos, buffer.screen.width, height, backgroundColor, 0x000000); yPos = yPos + verticalOffset
		buffer.customImage(x - #errorPixMap[1] - 3, yPos, errorPixMap)
		--Ð¢Ð¸ÑÐ», ÐµÐ¿ÑÐ°!
		if errorWindowParameters and errorWindowParameters.title then buffer.text(x, yPos, errorWindowParameters.title.color, errorWindowParameters.title.text); yPos = yPos + 2 end
		--Ð¢ÐµÐºÑÑÑÑ
		for i = 1, #text do buffer.text(x, yPos, textColor, text[i]); yPos = yPos + 1 end; yPos = yPos + 1
		--ÐÐ½Ð¾Ð¿Ð°ÑÐºÐ°
		OKButton = GUI.button(x + widthOfText - buttonWidth, y + height - 2, buttonWidth, 1, 0x3392FF, 0xFFFFFF, 0xFFFFFF, 0x262626, "OK"):draw()
		--ÐÑÑÐ¸ÑÐ¾Ð²Ð°ÑÐºÐ°
		buffer.draw()
	end

	--ÐÑÐ°ÑÐ¾Ð½Ð¸ÑÑÑÐ¹ Ð²ÑÑÐ¾Ð´
	local function quit()
		OKButton:pressAndRelease(0.2)
		buffer.paste(1, y, oldPixels)
		buffer.draw()
	end

	--ÐÐ½Ð¸Ð¼Ð°ÑÑÑ
	if not (errorWindowParameters and errorWindowParameters.noAnimation) then for i = 1, height do buffer.setDrawLimit(1, math.floor(buffer.screen.height / 2) - i, buffer.screen.width, i * 2); draw(); os.sleep(0.05) end; buffer.resetDrawLimit() end
	draw()

	--ÐÐ½Ð°Ð»Ð¸Ð· Ð³Ð¾Ð²Ð½Ð¸ÑÐ°
	while true do
		local e = {event.pull()}
		if e[1] == "key_down" then
			if e[4] == 28 then
				quit(); return
			end
		elseif e[1] == "touch" then
			if OKButton:isClicked(e[3], e[4]) then
				quit(); return
			end
		end
	end
end

----------------------------------------- Universal keyboard-input function -----------------------------------------

local function findValue(t, whatToSearch)
	if type(t) ~= "table" then return end
	for key, value in pairs(t) do
		if type(key) == "string" and string.match(key, "^" .. whatToSearch) then
			local valueType, postfix = type(value), ""
			if valueType == "function" or (valueType == "table" and getmetatable(value) and getmetatable(value).__call) then
				postfix = "()"
			elseif valueType == "table" then
				postfix = "."
			end
			return key .. postfix
		end
	end
end

local function findTable(whereToSearch, t, whatToSearch)
	local beforeFirstDot = string.match(whereToSearch, "^[^%.]+%.")
	-- ÐÑÐ»Ð¸ Ð²Ð¾Ð¾Ð±ÑÐµ ÐµÑÑÑ ÑÐ°Ð±Ð»Ð¸ÑÐ°, Ð³Ð´Ðµ Ð½Ð°Ð´Ð¾ Ð¸ÑÐºÐ°ÑÑ
	if beforeFirstDot then
		beforeFirstDot = unicode.sub(beforeFirstDot, 1, -2)
		if t[beforeFirstDot] then
			return findTable(unicode.sub(whereToSearch, unicode.len(beforeFirstDot) + 2, -1), t[beforeFirstDot], whatToSearch)
		else
			-- ÐÐ°ÑÐ¾Ñ, ÑÐ»ÑÑÐ°Ð¹ ÑÑÐ´Ð°: Ð²Ð¾Ñ Ð² ÑÑÑ Ð·Ð¾Ð½Ñ ÑÑÐ¹Ð½Ñ Ð¼Ð¾Ð¶ÐµÑ Ð·Ð°Ð¹ÑÐ¸ ÑÐ¾Ð»ÑÐºÐ°
			-- ÑÐ°Ð³Ð´Ð°, ÐºÐ°Ð³Ð´Ð° ÑÑ Ð²ÑÑÑÐ½ÑÑ ÐµÐ±ÐµÐ½Ð¸ÑÑ Ð¼Ð°ÑÑÐ¸Ð² Ð²Ð¸Ð´Ð° "abc.cda.blabla.test"
			-- Ð±ÐµÐ· Ð°Ð²ÑÐ¾Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ, Ñ.Ðµ. Ð¾Ð½ ÐÐÐÐÐ¢ Ð±ÑÑÑ Ð½ÐµÐ²ÐµÑÐ½ÑÐ¼, Ð¾Ð´Ð½Ð°ÐºÐ¾ Ð¿ÑÐ¾Ð³Ð° Ð²ÑÐµ
			-- ÑÐ°Ð²Ð½Ð¾ Ð¿ÑÐ¾Ð²ÐµÑÑÐµÑ Ð½Ð° Ð²ÐµÑÐ½Ð¾ÑÑÑ, Ð¸ Ð²Ð¾Ñ ÐµÑÐ»Ð¸ ÐÐ Ð¥Ð£Ð¯ ÑÐ°ÐºÐ¾Ð³Ð¾ Ð³Ð¾Ð²Ð½Ð¸ÑÐ° ÑÐ¸Ð¿Ð° 
			-- ... .blabla Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ, ÑÐ¾ Ð¸Ð½ÑÐµÑÑÐ¿ÑÐµÑÐ°ÑÐ¾Ñ Ð·Ð°ÑÑÑÑÐ¸Ð²Ð°ÐµÑÑÑ Ð¡Ð£ÐÐ«
			-- Ð Ð§Ð¢ÐÐ ÐÐÐÐ¬Ð¨Ð ÐÐÐÐ ÐÐ¡ÐÐ ÐÐ ÐÐÐÐÐÐÐ!11!
		end
	-- ÐÐ»Ð¸ ÐµÑÐ»Ð¸ ÑÐ°Ð±Ð»Ð¸Ñ Ð»Ð¸Ð±Ð¾ Ð²Ð°ÑÐµ Ð½ÐµÑÑ, Ð»Ð¸Ð±Ð¾ ÑÐµÐºÑÑÑÐ¸Ñ ÑÑÐ´Ð° Ð²Ð¾Ð½ Ð²Ð¾ÑÐ»Ð°
	else
		return findValue(t[whereToSearch], whatToSearch)
	end
end

local function autocompleteVariables(sourceText)
	local varPath = string.match(sourceText, "[a-zA-Z0-9%.%_]+$")
	if varPath then
		local prefix = string.sub(sourceText, 1, -unicode.len(varPath) - 1)
		local whereToSearch = string.match(varPath, "[a-zA-Z0-9%.%_]+%.")
		
		if whereToSearch then
			whereToSearch = unicode.sub(whereToSearch, 1, -2)
			local findedTable = findTable(whereToSearch, _G, unicode.sub(varPath, unicode.len(whereToSearch) + 2, -1))
			return findedTable and prefix .. whereToSearch .. "." .. findedTable or sourceText
		else
			local findedValue = findValue(_G, varPath)
			return findedValue and prefix .. findedValue or sourceText
		end
	else
		return sourceText
	end
end

local function inputFieldDraw(inputField)
	if inputField.x < 1 or inputField.y < 1 or inputField.x + inputField.width - 1 > buffer.screen.width or inputField.y > buffer.screen.height then return inputField end
	if inputField.oldPixels then
		buffer.paste(inputField.x, inputField.y, inputField.oldPixels)
	else
		inputField.oldPixels = buffer.copy(inputField.x, inputField.y, inputField.width, 1)
	end
	
	if inputField.highlightLuaSyntax then
		require("syntax").highlightString(inputField.x, inputField.y, inputField.text, 2)
	else
		buffer.text(
			inputField.x,
			inputField.y,
			inputField.colors.text,
			unicode.sub(
				inputField.textMask and string.rep(inputField.textMask, unicode.len(inputField.text)) or inputField.text,
				inputField.textCutFrom,
				inputField.textCutFrom + inputField.width - 1
			)
		)
	end

	if inputField.cursorBlinkState then
		buffer.text(inputField.x + inputField.cursorPosition - inputField.textCutFrom, inputField.y, inputField.cursorColor, inputField.cursorSymbol)
	end

	return inputField
end

local function inputFieldSetCursorPosition(inputField, newPosition)
	if newPosition < 1 then
		newPosition = 1
	elseif newPosition > unicode.len(inputField.text) + 1 then
		newPosition = unicode.len(inputField.text) + 1
	end

	if newPosition > inputField.textCutFrom + inputField.width - 1 then
		inputField.textCutFrom = inputField.textCutFrom + newPosition - (inputField.textCutFrom + inputField.width - 1)
	elseif newPosition < inputField.textCutFrom then
		inputField.textCutFrom = newPosition
	end

	inputField.cursorPosition = newPosition

	return inputField
end

local function inputFieldBeginInput(inputField)
	inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()

	while true do
		local e = { event.pull(inputField.cursorBlinkDelay) }
		if e[1] == "touch" or e[1] == "drag" then
			if inputField:isClicked(e[3], e[4]) then
				inputField:setCursorPosition(inputField.textCutFrom + e[3] - inputField.x)
				inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()
			else
				inputField.cursorBlinkState = false; inputField:draw(); buffer.draw()
				return inputField
			end
		elseif e[1] == "key_down" then
			if e[4] == 28 then
				inputField.cursorBlinkState = false; inputField:draw(); buffer.draw()
				return inputField
			elseif e[4] == 15 then
				if inputField.autocompleteVariables then
					inputField.text = autocompleteVariables(inputField.text)
					inputField:setCursorPosition(unicode.len(inputField.text) + 1)
					inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()
				end
			elseif e[4] == 203 then
				inputField:setCursorPosition(inputField.cursorPosition - 1)
				inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()
			elseif e[4] == 205 then	
				inputField:setCursorPosition(inputField.cursorPosition + 1)
				inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()
			elseif e[4] == 14 then
				inputField.text = unicode.sub(unicode.sub(inputField.text, 1, inputField.cursorPosition - 1), 1, -2) .. unicode.sub(inputField.text, inputField.cursorPosition, -1)
				inputField:setCursorPosition(inputField.cursorPosition - 1)
				inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()
			else
				if not keyboard.isControl(e[3]) then
					inputField.text = unicode.sub(inputField.text, 1, inputField.cursorPosition - 1) .. unicode.char(e[3]) .. unicode.sub(inputField.text, inputField.cursorPosition, -1)
					inputField:setCursorPosition(inputField.cursorPosition + 1)
					inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()
				end
			end
		elseif e[1] == "clipboard" then
			inputField.text = unicode.sub(inputField.text, 1, inputField.cursorPosition - 1) .. e[3] .. unicode.sub(inputField.text, inputField.cursorPosition, -1)
			inputField:setCursorPosition(inputField.cursorPosition + unicode.len(e[3]))
			inputField.cursorBlinkState = true; inputField:draw(); buffer.draw()
		else
			inputField.cursorBlinkState = not inputField.cursorBlinkState; inputField:draw(); buffer.draw()
		end
	end
end

function GUI.inputField(x, y, width, textColor, text, textMask, highlightLuaSyntax, autocompleteVariables)
	local inputField = GUI.object(x, y, width, 1)

	inputField.textCutFrom = 1
	inputField.cursorPosition = 1
	inputField.cursorColor = 0x00A8FF
	inputField.cursorSymbol = "â"
	inputField.cursorBlinkDelay = 0.4
	inputField.cursorBlinkState = false

	inputField.colors = {text = textColor}
	inputField.text = text
	inputField.textMask = textMask
	inputField.highlightLuaSyntax = highlightLuaSyntax
	inputField.autocompleteVariables = autocompleteVariables

	inputField.setCursorPosition = inputFieldSetCursorPosition
	inputField.draw = inputFieldDraw
	inputField.input = inputFieldBeginInput

	inputField:setCursorPosition(unicode.len(inputField.text) + 1)

	return inputField
end

----------------------------------------- Input Text Box object -----------------------------------------

local function drawInputTextBox(inputTextBox)
	local background = inputTextBox.isFocused and inputTextBox.colors.focused.background or inputTextBox.colors.default.background
	local foreground = inputTextBox.isFocused and inputTextBox.colors.focused.text or inputTextBox.colors.default.text
	local y = math.floor(inputTextBox.y + inputTextBox.height / 2)
	local text = inputTextBox.isFocused and (inputTextBox.eraseTextOnFocus and "" or inputTextBox.text) or (inputTextBox.text ~= "" and inputTextBox.text or inputTextBox.placeholderText or "")

	if background then
		buffer.square(inputTextBox.x, inputTextBox.y, inputTextBox.width, inputTextBox.height, background, foreground, " ")
	end

	local inputField = GUI.inputField(inputTextBox.x + 1, y, inputTextBox.width - 2, foreground, text, inputTextBox.textMask, inputTextBox.highlightLuaSyntax, inputTextBox.autocompleteVariables)	
	if inputTextBox.isFocused then
		inputField:input()
		if inputTextBox.validator then
			if inputTextBox.validator(inputField.text) then
				inputTextBox.text = inputField.text
			end
		else
			inputTextBox.text = inputField.text
		end
	else
		local oldHighlightLuaSyntaxValue = inputField.highlightLuaSyntax
		inputField.highlightLuaSyntax = false
		inputField:draw()
		inputField.highlightLuaSyntax = oldHighlightLuaSyntaxValue
	end

	return inputTextBox
end

local function inputTextBoxBeginInput(inputTextBox)
	inputTextBox.isFocused = true
	inputTextBox:draw()
	inputTextBox.isFocused = false

	return inputTextBox
end

function GUI.inputTextBox(x, y, width, height, inputTextBoxColor, textColor, inputTextBoxFocusedColor, textFocusedColor, text, placeholderText, eraseTextOnFocus, textMask, highlightLuaSyntax, autocompleteVariables)
	local inputTextBox = GUI.object(x, y, width, height)
	inputTextBox.colors = {
		default = {
			background = inputTextBoxColor,
			text = textColor
		},
		focused = {
			background = inputTextBoxFocusedColor,
			text = textFocusedColor
		}
	}
	inputTextBox.text = text
	inputTextBox.placeholderText = placeholderText
	inputTextBox.draw = drawInputTextBox
	inputTextBox.input = inputTextBoxBeginInput
	inputTextBox.eraseTextOnFocus = eraseTextOnFocus
	inputTextBox.textMask = textMask

	return inputTextBox
end

----------------------------------------- Text Box object -----------------------------------------

local function drawTextBox(object)
	if object.colors.background then buffer.square(object.x, object.y, object.width, object.height, object.colors.background, object.colors.text, " ", object.colors.transparency) end
	local xPos, yPos = GUI.getAlignmentCoordinates(object, {width = 1, height = object.height - object.offset.vertical * 2})
	local lineLimit = object.width - object.offset.horizontal * 2
	for line = object.currentLine, object.currentLine + object.height - 1 do
		if object.lines[line] then
			local lineType, text, textColor = type(object.lines[line])
			if lineType == "table" then
				text, textColor = string.limit(object.lines[line].text, lineLimit), object.lines[line].color
			elseif lineType == "string" then
				text, textColor = string.limit(object.lines[line], lineLimit), object.colors.text
			else
				error("Unknown TextBox line type: " .. tostring(lineType))
			end

			xPos = GUI.getAlignmentCoordinates(
				{
					x = object.x + object.offset.horizontal,
					y = object.y + object.offset.vertical,
					width = object.width - object.offset.horizontal * 2,
					height = object.height - object.offset.vertical * 2,
					alignment = object.alignment
				},
				{width = unicode.len(text), height = object.height}
			)
			buffer.text(xPos, yPos, textColor, text)
			yPos = yPos + 1
		else
			break
		end
	end

	return object
end

local function scrollDownTextBox(object, count)
	count = count or 1
	local maxCountAvailableToScroll = #object.lines - object.height - object.currentLine + 1
	count = math.min(count, maxCountAvailableToScroll)
	if #object.lines >= object.height and object.currentLine < #object.lines - count then
		object.currentLine = object.currentLine + count
	end
	return object
end

local function scrollUpTextBox(object, count)
	count = count or 1
	if object.currentLine > count and object.currentLine >= 1 then object.currentLine = object.currentLine - count end
	return object
end

local function scrollToStartTextBox(object)
	object.currentLine = 1
	return object
end

local function scrollToEndTextBox(object)
	object.currentLine = #lines
	return object
end

function GUI.textBox(x, y, width, height, backgroundColor, textColor, lines, currentLine, horizontalOffset, verticalOffset)
	local object = GUI.object(x, y, width, height)
	object.colors = { text = textColor, background = backgroundColor }
	object.setAlignment = GUI.setAlignment
	object:setAlignment(GUI.alignment.horizontal.left, GUI.alignment.vertical.top)
	object.lines = lines
	object.currentLine = currentLine or 1
	object.draw = drawTextBox
	object.scrollUp = scrollUpTextBox
	object.scrollDown = scrollDownTextBox
	object.scrollToStart = scrollToStartTextBox
	object.scrollToEnd = scrollToEndTextBox
	object.offset = {horizontal = horizontalOffset or 0, vertical = verticalOffset or 0}

	return object
end

----------------------------------------- Horizontal Slider Object -----------------------------------------

local function drawHorizontalSlider(object)
	-- ÐÐ° Ð²ÑÑÐºÐ¸Ð¹ ÑÐ»ÑÑÐ°Ð¹ Ð´ÐµÐ»Ð°ÐµÐ¼ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð½Ðµ Ð¼ÐµÐ½ÑÑÐµ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ð³Ð¾ Ð¸ Ð½Ðµ Ð±Ð¾Ð»ÑÑÐµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ð³Ð¾
	object.value = math.min(math.max(object.value, object.minimumValue), object.maximumValue)

	-- ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÐ¼ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð¸ Ð¼Ð¸Ð½Ð¸Ð¼Ð°Ð»ÑÐ½Ð¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ, ÐµÑÐ»Ð¸ ÑÑÐµÐ±ÑÐµÑÑÑ
	if object.showMaximumAndMinimumValues then
		local stringMaximumValue, stringMinimumValue = tostring(object.roundValues and math.floor(object.maximumValue) or math.roundToDecimalPlaces(object.maximumValue, 2)), tostring(object.roundValues and math.floor(object.maximumValue) or math.roundToDecimalPlaces(object.minimumValue, 2))
		buffer.text(object.x - unicode.len(stringMinimumValue) - 1, object.y, object.colors.value, stringMinimumValue)
		buffer.text(object.x + object.width + 1, object.y, object.colors.value, stringMaximumValue)
	end

	-- Ð ÐµÑÐµ ÑÐµÐºÑÑÐµÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ¸ÑÑÐµÐ¼, ÐµÑÐ»Ð¸ ÑÐ¾ÑÐµÑÑÑ Ð½Ð°Ð¼
	if object.currentValuePrefix or object.currentValuePostfix then
		local stringCurrentValue = (object.currentValuePrefix or "") .. (object.roundValues and math.floor(object.value) or math.roundToDecimalPlaces(object.value, 2)) .. (object.currentValuePostfix or "")
		buffer.text(math.floor(object.x + object.width / 2 - unicode.len(stringCurrentValue) / 2), object.y + 1, object.colors.value, stringCurrentValue)
	end

	-- Ð Ð¸ÑÑÐµÐ¼ ÑÐ°Ð¼ ÑÐ»Ð°Ð¹Ð´ÐµÑ
	local activeWidth = math.floor(object.width - ((object.maximumValue - object.value) * object.width / (object.maximumValue - object.minimumValue)))
	buffer.text(object.x, object.y, object.colors.passive, string.rep("â", object.width))
	buffer.text(object.x, object.y, object.colors.active, string.rep("â", activeWidth))
	buffer.square(object.x + activeWidth - 1, object.y, 2, 1, object.colors.pipe, 0x000000, " ")

	return object
end

function GUI.horizontalSlider(x, y, width, activeColor, passiveColor, pipeColor, valueColor, minimumValue, maximumValue, value, showMaximumAndMinimumValues, currentValuePrefix, currentValuePostfix)
	local object = GUI.object(x, y, width, 1)
	object.colors = {active = activeColor, passive = passiveColor, pipe = pipeColor, value = valueColor}
	object.draw = drawHorizontalSlider
	object.minimumValue = minimumValue
	object.maximumValue = maximumValue
	object.value = value
	object.showMaximumAndMinimumValues = showMaximumAndMinimumValues
	object.currentValuePrefix = currentValuePrefix
	object.currentValuePostfix = currentValuePostfix
	object.roundValues = false
	return object
end

----------------------------------------- Switch object -----------------------------------------

local function drawSwitch(object)
	local pipeWidth = object.height * 2
	local pipePosition, backgroundColor
	if object.state then pipePosition, backgroundColor = object.x + object.width - pipeWidth, object.colors.active else pipePosition, backgroundColor = object.x, object.colors.passive end
	buffer.square(object.x, object.y, object.width, object.height, backgroundColor, 0x000000, " ")
	buffer.square(pipePosition, object.y, pipeWidth, object.height, object.colors.pipe, 0x000000, " ")
	return object
end

function GUI.switch(x, y, width, activeColor, passiveColor, pipeColor, state)
	local object = GUI.object(x, y, width, 1)
	object.colors = {active = activeColor, passive = passiveColor, pipe = pipeColor, value = valueColor}
	object.draw = drawSwitch
	object.state = state or false
	return object
end

----------------------------------------- Chart object -----------------------------------------

local function drawChart(object)
	-- ÐÐ±Ð¾ÑÐµÐ¼ Ð¿ÐµÐ·Ð´Ð°ÑÑÐµ Ð¾ÑÐ¸
	for i = object.y, object.y + object.height - 2 do buffer.text(object.x, i, object.colors.axis, "â") end
	buffer.text(object.x + 1, object.y + object.height - 1, object.colors.axis, string.rep("â", object.width - 1))
	buffer.text(object.x, object.y + object.height - 1, object.colors.axis, "â")

	if #object.values > 1 then
		local oldDrawLimit = buffer.getDrawLimit()
		buffer.setDrawLimit(object.x, object.y, object.width, object.height)
		
		local delta, fieldWidth, fieldHeight = object.maximumValue - object.minimumValue, object.width - 2, object.height - 1

		-- Ð Ð¸ÑÑÐµÐ¼ Ð»Ð¸Ð½Ð¸Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ð¹
		local roundValues = object.maximumValue > 10
		local step = 0.2 * fieldHeight
		for i = step, fieldHeight, step do
			local value = object.minimumValue + delta * (i / fieldHeight)
			local stringValue = roundValues and tostring(math.floor(value)) or math.doubleToString(value, 1)
			buffer.text(object.x + 1, math.floor(object.y + fieldHeight - i), object.colors.value, string.rep("â", object.width - unicode.len(stringValue) - 2) .. " " .. stringValue)
		end

		-- Ð Ð¸ÑÑÐµÐ¼ Ð³ÑÐ°ÑÐµÐº, Ð¹Ð¾Ð¿ÑÐ°
		local function getDotPosition(valueIndex)
			return
				object.x + math.round((fieldWidth * (valueIndex - 1) / (#object.values - 1))) + 1,
				object.y + math.round(((fieldHeight - 1) * (object.maximumValue - object.values[valueIndex]) / delta))
		end

		local x, y = getDotPosition(1)
		for valueIndex = 2, #object.values do
			local xNew, yNew = getDotPosition(valueIndex)
			buffer.semiPixelLine(x, y * 2, xNew, yNew * 2, object.colors.chart)
			x, y = xNew, yNew
		end

		buffer.setDrawLimit(oldDrawLimit)
	end

	-- ÐÐ¾ÑÐ¸ÑÐ¾Ð²ÑÐ²Ð°ÐµÐ¼ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ Ð¾ÑÐµÐ¹
	if object.axisNames.y then buffer.text(object.x + 1, object.y, object.colors.axis, object.axisNames.y) end
	if object.axisNames.x then buffer.text(object.x + object.width - unicode.len(object.axisNames.x), object.y + object.height - 2, object.colors.axis, object.axisNames.x) end
end

function GUI.chart(x, y, width, height, axisColor, axisValueColor, chartColor, xAxisName, yAxisName, minimumValue, maximumValue, values)
	if minimumValue >= maximumValue then error("Chart's minimum value can't be >= maximum value!") end
	local object = GUI.object(x, y, width, height)
	object.colors = {axis = axisColor, chart = chartColor, value = axisValueColor}
	object.draw = drawChart
	object.values = values
	object.minimumValue = minimumValue
	object.maximumValue = maximumValue
	object.axisNames = {x = xAxisName, y = yAxisName}
	return object
end

----------------------------------------- Combo Box Object -----------------------------------------

local function drawComboBox(object)
	buffer.square(object.x, object.y, object.width, object.height, object.colors.default.background)
	local x, y, limit, arrowSize = object.x + 1, math.floor(object.y + object.height / 2), object.width - 5, object.height
	buffer.text(x, y, object.colors.default.text, string.limit(object.items[object.currentItem].text, limit, false))
	GUI.button(object.x + object.width - arrowSize * 2 + 1, object.y, arrowSize * 2 - 1, arrowSize, object.colors.arrow.background, object.colors.arrow.text, 0x0, 0x0, object.state and "â²" or "â¼"):draw()
end

local function selectComboBoxItem(object)
	object.state = true
	object:draw()

	local dropDownMenu = GUI.dropDownMenu(object.x, object.y + object.height, object.width, object.height == 1 and 0 or 1, object.colors.default.background, object.colors.default.text, object.colors.pressed.background, object.colors.pressed.text, GUI.colors.contextMenu.disabled.text, GUI.colors.contextMenu.separator, GUI.colors.contextMenu.transparency.background, object.items)
	dropDownMenu.items = object.items
	dropDownMenu.sidesOffset = 1
	local _, itemIndex = dropDownMenu:show()

	object.currentItem = itemIndex or object.currentItem
	object.state = false
	object:draw()
	buffer.draw()
end

function GUI.comboBox(x, y, width, height, backgroundColor, textColor, arrowBackgroundColor, arrowTextColor, items)
	local object = GUI.object(x, y, width, height)
	object.colors = {
		default = {
			background = backgroundColor,
			text = textColor
		},
		pressed = {
			background = GUI.colors.contextMenu.pressed.background,
			text = GUI.colors.contextMenu.pressed.text
		},
		arrow = {
			background = arrowBackgroundColor,
			text = arrowTextColor 
		}
	}
	object.items = {}
	object.currentItem = 1
	object.addItem = addDropDownMenuItem
	object.addSeparator = addDropDownMenuSeparator
	if items then
		for i = 1, #items do
			object:addItem(items[i])
		end
	end
	object.draw = drawComboBox
	object.selectItem = selectComboBoxItem
	object.state = false
	return object
end

----------------------------------------- Scrollbar object -----------------------------------------

local function scrollBarDraw(scrollBar)
	local isVertical = scrollBar.height > scrollBar.width
	local valuesDelta = scrollBar.maximumValue - scrollBar.minimumValue + 1
	local part = scrollBar.value / valuesDelta

	if not isVertical and scrollBar.thinHorizontalMode then
		buffer.text(scrollBar.x, scrollBar.y, scrollBar.colors.background, string.rep("â", scrollBar.width))
	else
		buffer.square(scrollBar.x, scrollBar.y, scrollBar.width, scrollBar.height, scrollBar.colors.background, 0x0, " ")
	end

	if isVertical then
		local barSize = math.ceil(scrollBar.shownValueCount / valuesDelta * scrollBar.height)
		local halfBarSize = math.floor(barSize / 2)
		
		scrollBar.ghostPosition.x = scrollBar.x
		scrollBar.ghostPosition.y = scrollBar.y + halfBarSize
		scrollBar.ghostPosition.width = scrollBar.width
		scrollBar.ghostPosition.height = scrollBar.height - barSize

		buffer.square(
			scrollBar.ghostPosition.x,
			math.floor(scrollBar.ghostPosition.y + part * scrollBar.ghostPosition.height - halfBarSize),
			scrollBar.ghostPosition.width,
			barSize,
			scrollBar.colors.foreground, 0x0, " "
		)
	else
		local barSize = math.ceil(scrollBar.shownValueCount / valuesDelta * scrollBar.width)
		local halfBarSize = math.floor(barSize / 2)
		
		scrollBar.ghostPosition.x = scrollBar.x + halfBarSize
		scrollBar.ghostPosition.y = scrollBar.y
		scrollBar.ghostPosition.width = scrollBar.width - barSize
		scrollBar.ghostPosition.height = scrollBar.height

		if not isVertical and scrollBar.thinHorizontalMode then
			buffer.text(math.floor(scrollBar.ghostPosition.x + part * scrollBar.ghostPosition.width - halfBarSize), scrollBar.ghostPosition.y, scrollBar.colors.foreground, string.rep("â", barSize))
		else
			buffer.square(
				math.floor(scrollBar.ghostPosition.x + part * scrollBar.ghostPosition.width - halfBarSize),
				scrollBar.ghostPosition.y,
				barSize,
				scrollBar.ghostPosition.height,
				scrollBar.colors.foreground, 0x0, " "
			)
		end
	end

	return scrollBar
end

function GUI.scrollBar(x, y, width, height, backgroundColor, foregroundColor, minimumValue, maximumValue, value, shownValueCount, onScrollValueIncrement, thinHorizontalMode)
	local scrollBar = GUI.object(x, y, width, height)

	scrollBar.maximumValue = maximumValue
	scrollBar.minimumValue = minimumValue
	scrollBar.value = value
	scrollBar.onScrollValueIncrement = onScrollValueIncrement
	scrollBar.shownValueCount = shownValueCount
	scrollBar.thinHorizontalMode = thinHorizontalMode
	scrollBar.colors = {
		background = backgroundColor,
		foreground = foregroundColor,
	}
	scrollBar.ghostPosition = {}
	scrollBar.draw = scrollBarDraw

	return scrollBar
end

----------------------------------------- CodeView object -----------------------------------------

local function codeViewDraw(codeView)
	-- local toLine = codeView.fromLine + codeView.height - (codeView.scrollBars.horizontal.isHidden and 1 or 2)
	local toLine = codeView.fromLine + codeView.height - 1

	-- Line numbers bar and code area
	codeView.lineNumbersWidth = unicode.len(tostring(toLine)) + 2
	codeView.codeAreaPosition = codeView.x + codeView.lineNumbersWidth
	codeView.codeAreaWidth = codeView.width - codeView.lineNumbersWidth
	buffer.square(codeView.x, codeView.y, codeView.lineNumbersWidth, codeView.height, syntax.colorScheme.lineNumbersBackground, syntax.colorScheme.lineNumbersText, " ")	
	buffer.square(codeView.codeAreaPosition, codeView.y, codeView.codeAreaWidth, codeView.height, syntax.colorScheme.background, syntax.colorScheme.text, " ")

	-- Line numbers texts
	local y = codeView.y
	for line = codeView.fromLine, toLine do
		if codeView.lines[line] then
			local text = tostring(line)
			if codeView.highlights[line] then
				buffer.square(codeView.x, y, codeView.lineNumbersWidth, 1, codeView.highlights[line], syntax.colorScheme.text, " ", 30)
				buffer.square(codeView.codeAreaPosition, y, codeView.codeAreaWidth, 1, codeView.highlights[line], syntax.colorScheme.text, " ")
			end
			buffer.text(codeView.codeAreaPosition - unicode.len(text) - 1, y, syntax.colorScheme.lineNumbersText, text)
			y = y + 1
		else
			break
		end	
	end

	-- Selections
	local oldDrawLimit = buffer.getDrawLimit()
	buffer.setDrawLimit(codeView.codeAreaPosition, codeView.y, codeView.codeAreaWidth, codeView.height)

	local function drawUpperSelection(y, selectionIndex)
		buffer.square(
			codeView.codeAreaPosition + codeView.selections[selectionIndex].from.symbol,
			y + codeView.selections[selectionIndex].from.line - codeView.fromLine,
			codeView.codeAreaWidth - codeView.selections[selectionIndex].from.symbol,
			1,
			codeView.selections[selectionIndex].color or syntax.colorScheme.selection, syntax.colorScheme.text, " "
		)
	end

	local function drawLowerSelection(y, selectionIndex)
		buffer.square(
			codeView.codeAreaPosition,
			y + codeView.selections[selectionIndex].from.line - codeView.fromLine,
			codeView.selections[selectionIndex].to.symbol + 1,
			1,
			codeView.selections[selectionIndex].color or syntax.colorScheme.selection, syntax.colorScheme.text, " "
		)
	end

	if #codeView.selections > 0 then
		for selectionIndex = 1, #codeView.selections do
			y = codeView.y
			local dy = codeView.selections[selectionIndex].to.line - codeView.selections[selectionIndex].from.line
			if dy == 0 then
				buffer.square(
					codeView.codeAreaPosition + codeView.selections[selectionIndex].from.symbol,
					y + codeView.selections[selectionIndex].from.line - codeView.fromLine,
					codeView.selections[selectionIndex].to.symbol - codeView.selections[selectionIndex].from.symbol + 1,
					1,
					codeView.selections[selectionIndex].color or syntax.colorScheme.selection, syntax.colorScheme.text, " "
				)
			elseif dy == 1 then
				drawUpperSelection(y, selectionIndex); y = y + 1
				drawLowerSelection(y, selectionIndex)
			else
				drawUpperSelection(y, selectionIndex); y = y + 1
				for i = 1, dy - 1 do
					buffer.square(codeView.codeAreaPosition, y + codeView.selections[selectionIndex].from.line - codeView.fromLine, codeView.codeAreaWidth, 1, codeView.selections[selectionIndex].color or syntax.colorScheme.selection, syntax.colorScheme.text, " "); y = y + 1
				end
				drawLowerSelection(y, selectionIndex)
			end
		end
	end

	-- Code strings
	y = codeView.y
	buffer.setDrawLimit(codeView.codeAreaPosition + 1, y, codeView.codeAreaWidth - 2, codeView.height)
	for i = codeView.fromLine, toLine do
		if codeView.lines[i] then
			if codeView.highlightLuaSyntax then
				syntax.highlightString(codeView.codeAreaPosition - codeView.fromSymbol + 2, y, codeView.lines[i], codeView.indentationWidth)
			else
				buffer.text(codeView.codeAreaPosition - codeView.fromSymbol + 2, y, syntax.colorScheme.text, codeView.lines[i])
			end
			y = y + 1
		else
			break
		end
	end
	buffer.setDrawLimit(oldDrawLimit)

	if #codeView.lines > codeView.height then
		codeView.scrollBars.vertical.isHidden = false
		codeView.scrollBars.vertical.colors.background, codeView.scrollBars.vertical.colors.foreground = syntax.colorScheme.scrollBarBackground, syntax.colorScheme.scrollBarForeground
		codeView.scrollBars.vertical.minimumValue, codeView.scrollBars.vertical.maximumValue, codeView.scrollBars.vertical.value, codeView.scrollBars.vertical.shownValueCount = 1, #codeView.lines, codeView.fromLine, codeView.height
		codeView.scrollBars.vertical.localPosition.x = codeView.width
		codeView.scrollBars.vertical.localPosition.y = 1
		codeView.scrollBars.vertical.height = codeView.height
	else
		codeView.scrollBars.vertical.isHidden = true
	end

	if codeView.maximumLineLength > codeView.codeAreaWidth - 2 then
		codeView.scrollBars.horizontal.isHidden = false
		codeView.scrollBars.horizontal.colors.background, codeView.scrollBars.horizontal.colors.foreground = syntax.colorScheme.scrollBarBackground, syntax.colorScheme.scrollBarForeground
		codeView.scrollBars.horizontal.minimumValue, codeView.scrollBars.horizontal.maximumValue, codeView.scrollBars.horizontal.value, codeView.scrollBars.horizontal.shownValueCount = 1, codeView.maximumLineLength, codeView.fromSymbol, codeView.codeAreaWidth - 2
		codeView.scrollBars.horizontal.localPosition.x, codeView.scrollBars.horizontal.width = codeView.lineNumbersWidth + 1, codeView.codeAreaWidth - 1
		codeView.scrollBars.horizontal.localPosition.y = codeView.height
	else
		codeView.scrollBars.horizontal.isHidden = true
	end

	codeView:reimplementedDraw()
end

function GUI.codeView(x, y, width, height, lines, fromSymbol, fromLine, maximumLineLength, selections, highlights, highlightLuaSyntax, indentationWidth)
	local codeView = GUI.container(x, y, width, height)
	
	codeView.lines = lines
	codeView.fromSymbol = fromSymbol
	codeView.fromLine = fromLine
	codeView.maximumLineLength = maximumLineLength
	codeView.selections = selections or {}
	codeView.highlights = highlights or {}
	codeView.highlightLuaSyntax = highlightLuaSyntax
	codeView.indentationWidth = indentationWidth

	codeView.scrollBars = {
		vertical = codeView:addScrollBar(1, 1, 1, 1, 0x0, 0x0, 1, 1, 1, 1, 1, false),
		horizontal = codeView:addScrollBar(1, 1, 1, 1, 0x0, 0x0, 1, 1, 1, 1, 1, true)
	}

	codeView.reimplementedDraw = codeView.draw
	codeView.draw = codeViewDraw

	return codeView
end 

----------------------------------------- Color Selector object -----------------------------------------

local function updateFileList(treeView, xOffset, path)
	for file in fs.list(path) do
		local element = {}
		element.path = path .. file
		element.xOffset = xOffset
		element.isDirectory = fs.isDirectory(element.path)
		table.insert(treeView.fileList, element)

		if treeView.directoriesToShowContent[element.path] then
			updateFileList(treeView, xOffset + 2, path .. file)
		end		
	end
end

local function treeViewUpdateFileList(treeView)
	treeView.fileList = {}
	updateFileList(treeView, 1, treeView.workPath)

	return treeView
end

local function treeViewDraw(treeView)
	local y = treeView.y + 1
	local showScrollBar = #treeView.fileList > treeView.height
	local textLimit = treeView.width - (showScrollBar and 2 or 1)

	if treeView.colors.default.background then
		buffer.square(treeView.x, treeView.y, treeView.width, treeView.height, treeView.colors.default.background, treeView.colors.default.text, " ")
	end

	for fileIndex = treeView.fromFile, #treeView.fileList do
		local textColor = treeView.colors.default.text
		if treeView.fileList[fileIndex].path == treeView.currentFile then
			textColor = treeView.colors.selected.text
			buffer.square(treeView.x, y, treeView.width, 1, treeView.colors.selected.background, textColor, " ") 
		end

		if treeView.fileList[fileIndex].isDirectory then
			buffer.text(treeView.x + treeView.fileList[fileIndex].xOffset, y, treeView.colors.arrow, treeView.directoriesToShowContent[treeView.fileList[fileIndex].path] and "â½" or "â·")
			buffer.text(treeView.x + treeView.fileList[fileIndex].xOffset + 2, y, textColor, unicode.sub("â  " .. fs.name(treeView.fileList[fileIndex].path), 1, textLimit - treeView.fileList[fileIndex].xOffset - 2))
		else
			buffer.text(treeView.x + treeView.fileList[fileIndex].xOffset, y, textColor, unicode.sub("  â¡ " .. fs.name(treeView.fileList[fileIndex].path), 1, textLimit - treeView.fileList[fileIndex].xOffset))
		end

		y = y + 1
		if y > treeView.y + treeView.height - 2 then break end
	end

	if showScrollBar then
		GUI.scrollBar(
			treeView.x + treeView.width - 1,
			treeView.y,
			1,
			treeView.height,
			treeView.colors.scrollBar.background, 
			treeView.colors.scrollBar.foreground,
			1,
			#treeView.fileList,
			treeView.fromFile,
			treeView.height - 2,
			1
		):draw()	
	end

	return treeView
end

function GUI.treeView(x, y, width, height, backgroundColor, textColor, selectionColor, selectionTextColor, arrowColor, scrollBarBackground, scrollBarForeground, workPath)
	local treeView = GUI.container(x, y, width, height)
	
	treeView.colors = {
		default = {
			background = backgroundColor,
			text = textColor,
		},
		selected = {
			background = selectionColor,
			text = selectionTextColor,
		},
		scrollBar = {
			background = scrollBarBackground,
			foreground = scrollBarForeground
		},
		arrow = arrowColor
	}
	treeView.directoriesToShowContent = {}
	treeView.fileList = {}
	treeView.workPath = workPath

	treeView.updateFileList = treeViewUpdateFileList
	treeView.draw = treeViewDraw
	treeView.currentFile = nil
	treeView.fromFile = 1

	treeView:updateFileList()

	return treeView
end

----------------------------------------- Color Selector object -----------------------------------------

local function colorSelectorDraw(colorSelector)
	local overlayColor = colorSelector.color < 0x7FFFFF and 0xFFFFFF or 0x000000
	buffer.square(colorSelector.x, colorSelector.y, colorSelector.width, colorSelector.height, colorSelector.color, overlayColor, " ")
	if colorSelector.pressed then
		buffer.square(colorSelector.x, colorSelector.y, colorSelector.width, colorSelector.height, overlayColor, overlayColor, " ", 80)
	end
	buffer.text(colorSelector.x, colorSelector.y + colorSelector.height - 1, overlayColor, string.rep("â", colorSelector.width), 80)
	buffer.text(colorSelector.x + 1, colorSelector.y + math.floor(colorSelector.height / 2), overlayColor, string.limit(colorSelector.text, colorSelector.width - 2))
	return colorSelector
end

function GUI.colorSelector(x, y, width, height, color, text)
	local colorSelector = GUI.object(x, y, width, height)
	colorSelector.color = color
	colorSelector.text = text
	colorSelector.draw = colorSelectorDraw
	return colorSelector
end 

--------------------------------------------------------------------------------------------------------------------------------

-- buffer.start()
-- buffer.clear(0xFF8888)
-- buffer.draw(true)

-- local y = 2
-- for i = 1, 10 do
-- 	GUI.colorSelector(2, y, 30, 3, math.random(0x0, 0xFFFFFF), "Ð¢Ð¸Ð¿Ð° ÑÐ²ÐµÑ " .. i):draw()
-- 	y = y + 4
-- end
-- buffer.draw()

-- local lines = {}
-- local file = io.open("/OS.lua", "r")
-- local maximumLineLength = 0
-- for line in file:lines() do line = line:gsub("	", "  "); table.insert(lines, line); maximumLineLength = math.max(maximumLineLength, unicode.len(line)) end
-- file:close()

-- GUI.codeView(1, 1, buffer.screen.width, buffer.screen.height, lines, 1, 110, maximumLineLength, {{from = {symbol = 14, line = 122}, to = {symbol = 20, line = 128}}}, {[131] = 0xFF4444}, true):draw()
-- -- GUI.scrollBar(1, 5, 1, 20, 0x444444, 0x00DBFF, 1, 100, 50, 20, 1, true):draw()

-- buffer.draw()

--------------------------------------------------------------------------------------------------------------------------------

return GUI






Flib/MineOSCore.luaì
---------------------------------------------- Libraries ------------------------------------------------------------------------

local component = require("component")
local computer = require("computer")
local event = require("event")
local advancedLua = require("advancedLua")
local image = require("image")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local windows = require("windows")
local ecs = require("ECSAPI")
local fs = require("filesystem")
local unicode = require("unicode")

---------------------------------------------- Core constants ------------------------------------------------------------------------

local MineOSCore = {}

MineOSCore.showApplicationIcons = true
MineOSCore.iconWidth = 12
MineOSCore.iconHeight = 6
MineOSCore.iconClickDelay = 0.2

MineOSCore.paths = {}
MineOSCore.paths.OS = "/MineOS/"
MineOSCore.paths.system = MineOSCore.paths.OS .. "System/"
MineOSCore.paths.wallpaper = MineOSCore.paths.system .. "OS/Wallpaper.lnk"
MineOSCore.paths.localizationFile = MineOSCore.paths.system .. "OS/Languages/" .. _G.OSSettings.language .. ".lang"
MineOSCore.paths.icons = MineOSCore.paths.system .. "OS/Icons/"
MineOSCore.paths.applications = MineOSCore.paths.OS .. "Applications/"
MineOSCore.paths.pictures = MineOSCore.paths.OS .. "Pictures/"
MineOSCore.paths.desktop = MineOSCore.paths.OS .. "Desktop/"
MineOSCore.paths.applicationList = MineOSCore.paths.system .. "OS/Applications.txt"
MineOSCore.paths.trash = MineOSCore.paths.OS .. "Trash/"
MineOSCore.paths.OSSettings = MineOSCore.paths.system .. "OS/OSSettings.cfg"

MineOSCore.sortingMethods = enum(
	"type",
	"name",
	"date"
)

MineOSCore.localization = {}

---------------------------------------------- Current sÑript processing methods ------------------------------------------------------------------------

function MineOSCore.getCurrentScriptDirectory()
	return MineOSCore.getFilePath(getCurrentScript())
end

function MineOSCore.getCurrentApplicationResourcesDirectory() 
	return MineOSCore.getCurrentScriptDirectory() .. "/Resources/"
end

function MineOSCore.getLocalization(pathToLocalizationFolder)
	local localizationFileName = pathToLocalizationFolder .. _G.OSSettings.language .. ".lang"
	if fs.exists(localizationFileName) then
		return table.fromFile(localizationFileName)
	else
		error("Localization file \"" .. localizationFileName .. "\" doesn't exists")
	end
end

function MineOSCore.getCurrentApplicationLocalization()
	return MineOSCore.getLocalization(MineOSCore.getCurrentApplicationResourcesDirectory() .. "Localization/")	
end

function MineOSCore.getMethodExecutionTime(method)
	local oldOSClock = os.clock()
	method()
	return os.clock() - oldOSClock
end

function MineOSCore.getAverageMethodExecutionTime(method, countOfTries)
	local averageTime = 0
	for i = 1, countOfTries do
		averageTime = (averageTime + MineOSCore.getMethodExecutionTime(method)) / 2
		os.sleep(0.1)
	end
	return averageTime
end

---------------------------------------------- Filesystem-related methods ------------------------------------------------------------------------

local function getFilenameAndFormat(path)
	local fileName, format = string.match(path, "^(.+)(%.[^%/]+)%/?$")
	return (fileName or path), format
end

function MineOSCore.getFilePath(path)
	return string.match(path, "^(.+%/).") or ""
end

function MineOSCore.getFileName(path)
	return string.match(path, "%/?([^%/]+)%/?$")
end

function MineOSCore.getFileFormat(path)
	local fileName, format = getFilenameAndFormat(path)
	return format
end

function MineOSCore.hideFileFormat(path)
	local fileName, format = getFilenameAndFormat(path)
	return fileName
end

function MineOSCore.isFileHidden(path)
	if string.match(path, "^%..+$") then return true end
	return false
end

function MineOSCore.getFileList(path)
	if not fs.exists(path) then error("Failed to get file list: directory \"" .. tostring(path) .. "\" doesn't exists") end
	if not fs.isDirectory(path) then error("Failed to get file list: path \"" .. tostring(path) .. "\" is not a directory") end

	local fileList = {}
	for file in fs.list(path) do table.insert(fileList, file) end
	return fileList
end

function MineOSCore.sortFileList(path, fileList, sortingMethod, showHiddenFiles)
	local sortedFileList = {}

	if sortingMethod == MineOSCore.sortingMethods.type then
		local typeList = {}
		for i = 1, #fileList do
			local fileFormat = MineOSCore.getFileFormat(fileList[i]) or "Script"
			if fs.isDirectory(path .. fileList[i]) and fileFormat ~= ".app" then fileFormat = "Folder" end
			typeList[fileFormat] = typeList[fileFormat] or {}
			table.insert(typeList[fileFormat], fileList[i])
		end

		if typeList.Folder then
			for i = 1, #typeList.Folder do
				table.insert(sortedFileList, typeList.Folder[i])
			end
			typeList["Folder"] = nil
		end

		for fileFormat in pairs(typeList) do
			for i = 1, #typeList[fileFormat] do
				table.insert(sortedFileList, typeList[fileFormat][i])
			end
		end
	elseif MineOSCore.sortingMethods.name then
		sortedFileList = fileList
	elseif MineOSCore.sortingMethods.date then
		for i = 1, #fileList do
			fileList[i] = {fileList[i], fs.lastModified(path .. fileList[i])}
		end
		table.sort(fileList, function(a,b) return a[2] > b[2] end)
		for i = 1, #fileList do
			table.insert(sortedFileList, fileList[i][1])
		end
	else
		error("Unknown sorting method: " .. tostring(sortingMethod))
	end

	local i = 1
	while i <= #sortedFileList do
		if not showHiddenFiles and MineOSCore.isFileHidden(sortedFileList[i]) then
			table.remove(sortedFileList, i)
		else
			i = i + 1
		end
	end

	return sortedFileList
end

function MineOSCore.limitFileName(text, limit)
	if unicode.len(text) > limit then
		local partSize = math.ceil(limit / 2)
		text = unicode.sub(text, 1, partSize) .. "â¦" .. unicode.sub(text, -partSize + 1, -1)
	end
	return text
end

function MineOSCore.getFolderSize(path)
	local size = 0
	for file in fs.list(path) do
		if fs.isDirectory(path .. file) then
			size = size + MineOSCore.getFolderSize(path .. file)
		else
			size = size + fs.size(path .. file)
		end
	end
	return size
end

---------------------------------------------- MineOS Icons related methods ------------------------------------------------------------------------

function MineOSCore.saveOSSettings()
	table.toFile(MineOSCore.paths.OSSettings, _G.OSSettings, true)
end

function MineOSCore.loadOSSettings()
	_G.OSSettings = table.fromFile(MineOSCore.paths.OSSettings)
end

function MineOSCore.loadIcon(name, path)
	if not MineOSCore.icons[name] then MineOSCore.icons[name] = image.load(path) end
	return MineOSCore.icons[name]
end

--ÐÑÑ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð°Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð´Ð»Ñ Ð¸ÐºÐ¾Ð½Ð¾Ðº
function MineOSCore.loadStandartIcons()
	MineOSCore.icons = {}
	MineOSCore.loadIcon("folder", MineOSCore.paths.icons .. "Folder.pic")
	MineOSCore.loadIcon("script", MineOSCore.paths.icons .. "Script.pic")
	MineOSCore.loadIcon("text", MineOSCore.paths.icons .. "Text.pic")
	MineOSCore.loadIcon("config", MineOSCore.paths.icons .. "Config.pic")
	MineOSCore.loadIcon("lua", MineOSCore.paths.icons .. "Lua.pic")
	MineOSCore.loadIcon("image", MineOSCore.paths.icons .. "Image.pic")
	MineOSCore.loadIcon("pastebin", MineOSCore.paths.icons .. "Pastebin.pic")
	MineOSCore.loadIcon("fileNotExists", MineOSCore.paths.icons .. "FileNotExists.pic")
	MineOSCore.loadIcon("archive", MineOSCore.paths.icons .. "Archive.pic")
	MineOSCore.loadIcon("model3D", MineOSCore.paths.icons .. "3DModel.pic")
	MineOSCore.loadIcon("application", MineOSCore.paths.icons .. "Application.pic")
	MineOSCore.loadIcon("trash", MineOSCore.paths.icons .. "Trash.pic")
end

function MineOSCore.init()
	MineOSCore.localization = table.fromFile(MineOSCore.paths.localizationFile)
	MineOSCore.loadStandartIcons()
end

function MineOSCore.waitForPressingAnyKey()
	print(" ")
	print(MineOSCore.localization.pressAnyKeyToContinue)
	while true do
		local eventType = event.pull()
		if eventType == "key_down" or eventType == "touch" then break end
	end
end

function MineOSCore.analyzeIconFormat(iconObject)
	if iconObject.isDirectory then
		if iconObject.format == ".app" then
			if MineOSCore.showApplicationIcons then
				iconObject.iconImage.image = image.load(iconObject.path .. "/Resources/Icon.pic")
			else
				iconObject.iconImage.image = MineOSCore.icons.application
			end

			iconObject.launch = function()
				ecs.applicationHelp(iconObject.path)
				MineOSCore.safeLaunch(iconObject.path .. "/" .. MineOSCore.hideFileFormat(MineOSCore.getFileName(iconObject.path)) .. ".lua")
			end
		else
			iconObject.iconImage.image = MineOSCore.icons.folder
			iconObject.launch = function()
				computer.pushSignal("MineOSCore", "changeWorkpath", iconObject.path)
			end
		end
	else
		if iconObject.format == ".lnk" then
			iconObject.shortcutPath = ecs.readShortcut(iconObject.path)
			iconObject.shortcutFormat = MineOSCore.getFileFormat(iconObject.shortcutPath)
			iconObject.shortcutIsDirectory = fs.isDirectory(iconObject.shortcutPath)
			iconObject.isShortcut = true

			local shortcutIconObject = MineOSCore.analyzeIconFormat({
				path = iconObject.shortcutPath,
				format = iconObject.shortcutFormat,
				isDirectory = iconObject.shortcutIsDirectory,
				iconImage = iconObject.iconImage
			})

			iconObject.iconImage.image = shortcutIconObject.iconImage.image
			iconObject.launch = shortcutIconObject.launch

			shortcutIconObject = nil
		elseif iconObject.format == ".cfg" or iconObject.format == ".config" then
			iconObject.iconImage.image = MineOSCore.icons.config
			iconObject.launch = function()
				MineOSCore.safeLaunch(MineOSCore.paths.applications .. "/MineCode IDE.app/MineCode IDE.lua", "open", iconObject.path)
			end
		elseif iconObject.format == ".txt" or iconObject.format == ".rtf" then
			iconObject.iconImage.image = MineOSCore.icons.text
			iconObject.launch = function()
				MineOSCore.safeLaunch(MineOSCore.paths.applications .. "/MineCode IDE.app/MineCode IDE.lua", "open", iconObject.path)
			end
		elseif iconObject.format == ".lua" then
		 	iconObject.iconImage.image = MineOSCore.icons.lua
		 	iconObject.launch = function()
				ecs.prepareToExit()
				if MineOSCore.safeLaunch(iconObject.path) then
					MineOSCore.waitForPressingAnyKey()
				end
			end
		elseif iconObject.format == ".pic" or iconObject.format == ".png" then
			iconObject.iconImage.image = MineOSCore.icons.image
			iconObject.launch = function()
				MineOSCore.safeLaunch(MineOSCore.paths.applications .. "Photoshop.app/Photoshop.lua", "open", iconObject.path)
			end
		elseif iconObject.format == ".pkg" then
			iconObject.iconImage.image = MineOSCore.icons.archive
			iconObject.launch = function()
				require("compressor").unpack(iconObject.path, MineOSCore.getFilePath(iconObject.path))
			end
		elseif iconObject.format == ".3dm" then
			iconObject.iconImage.image = MineOSCore.icons.model3D
			iconObject.launch = function()
				MineOSCore.safeLaunch(MineOSCore.paths.applications .. "3DPrint.app/3DPrint.lua", "open", iconObject.path)
			end
		elseif not fs.exists(iconObject.path) then
			iconObject.iconImage.image = MineOSCore.icons.fileNotExists
			iconObject.launch = function()
				GUI.error("Application is corrupted")
			end
		else
			iconObject.iconImage.image = MineOSCore.icons.script
			iconObject.launch = function()
				ecs.prepareToExit()
				if MineOSCore.safeLaunch(iconObject.path) then
					MineOSCore.waitForPressingAnyKey()
				end
			end
		end
	end

	return iconObject
end

function MineOSCore.getParametersForDrawingIcons(fieldWidth, fieldHeight, xSpaceBetweenIcons, ySpaceBetweenIcons)
	local xCountOfIcons, yCountOfIcons = math.floor(fieldWidth / (MineOSCore.iconWidth + xSpaceBetweenIcons)), math.floor(fieldHeight / (MineOSCore.iconHeight + ySpaceBetweenIcons))
	local totalCountOfIcons = xCountOfIcons * yCountOfIcons
	return xCountOfIcons, yCountOfIcons, totalCountOfIcons
end

function MineOSCore.createIconObject(x, y, path, textColor, showFileFormat)
	local iconObject = GUI.container(x, y, MineOSCore.iconWidth, MineOSCore.iconHeight)
	
	iconObject.path = path
	iconObject.size = fs.size(iconObject.path)
	iconObject.isDirectory = fs.isDirectory(iconObject.path)
	iconObject.format = MineOSCore.getFileFormat(iconObject.path)
	iconObject.showFormat = showFileFormat
	iconObject.isShortcut = false
	iconObject.isSelected = false

	iconObject.iconImage = iconObject:addImage(3, 1, {width = 8, height = 4})
	iconObject.textLabel = iconObject:addLabel(1, MineOSCore.iconHeight, MineOSCore.iconWidth, 1, textColor, MineOSCore.getFileName(iconObject.path)):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
	
	local oldDraw = iconObject.draw
	iconObject.draw = function(iconObject)
		if iconObject.isSelected then buffer.square(iconObject.x, iconObject.y, iconObject.width, iconObject.height, 0xFFFFFF, 0x000000, " ", 50) end
		if iconObject.showFormat then
			iconObject.textLabel.text = MineOSCore.limitFileName(MineOSCore.getFileName(iconObject.path), iconObject.textLabel.width)
		else
			iconObject.textLabel.text = MineOSCore.limitFileName(MineOSCore.hideFileFormat(MineOSCore.getFileName(iconObject.path)), iconObject.textLabel.width)
		end
		oldDraw(iconObject)
		if iconObject.isShortcut then buffer.set(iconObject.iconImage.x + iconObject.iconImage.width - 1, iconObject.iconImage.y + iconObject.iconImage.height - 1, 0xFFFFFF, 0x000000, "<") end
	end

	-- ÐÐ¾Ð´Ð´ÐµÑÐ¶ÐºÐ° Ð¸Ð·Ð¼ÐµÐ½ÑÐµÐ¼ÑÑ Ð¸Ð·Ð²Ð½Ðµ ÑÑÐ½ÐºÑÐ¸Ð¹ Ð¿ÑÐ°Ð²Ð¾Ð³Ð¾ Ð¸ Ð»ÐµÐ²Ð¾Ð³Ð¾ ÐºÐ»Ð¸ÐºÐ¾Ð²
	iconObject.onLeftClick = MineOSCore.iconLeftClick
	iconObject.onRightClick = MineOSCore.iconRightClick

	-- ÐÐ±ÑÐ°Ð±Ð¾ÑÐºÐ° ÐºÐ»Ð¸ÐºÐ° Ð½ÐµÐ¿Ð¾ÑÑÐµÐ´ÑÑÐ²ÐµÐ½Ð½Ð¾ Ð½Ð° Ð¸ÐºÐ¾Ð½ÐºÑ
	iconObject.iconImage.onTouch = function(eventData)
		iconObject.isSelected = true
		local firstParent = iconObject:getFirstParent()
		firstParent:draw()
		buffer.draw()

		if eventData[5] == 0 then
			os.sleep(MineOSCore.iconClickDelay)
			iconObject.onLeftClick(iconObject, eventData)
		else
			iconObject.onRightClick(iconObject, eventData)
		end

		iconObject.isSelected = false
		firstParent:draw()
		buffer.draw()
	end

	-- ÐÐ½Ð°Ð»Ð¸Ð· ÑÐ¾ÑÐ¼Ð°ÑÐ° Ð¸ Ð¿ÑÐ¾ÑÐµÐ³Ð¾ Ð³Ð¾Ð²Ð½Ð° Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð´Ð»Ñ Ð¿Ð¾ÑÐ»ÐµÐ´ÑÑÑÐµÐ³Ð¾ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð¸ ÑÑÐ½ÐºÑÐ¸Ð¸-Ð»Ð°ÑÐ½ÑÐµÑÐ°
	MineOSCore.analyzeIconFormat(iconObject)
	
	return iconObject
end

local function updateIconFieldFileList(iconField)
	iconField.fileList = MineOSCore.getFileList(iconField.workpath)
	iconField.fileList = MineOSCore.sortFileList(iconField.workpath, iconField.fileList, iconField.sortingMethod, iconField.showHiddenFiles)
	iconField.children = {}

	local xPos, yPos, counter = 1, 1, 1
	for i = iconField.fromFile, iconField.fromFile + iconField.iconCount.total - 1 do
		if not iconField.fileList[i] then break end

		iconField:addChild(
			MineOSCore.createIconObject(
				xPos, yPos, iconField.workpath .. iconField.fileList[i], iconField.colors.iconText, iconField.showFileFormat
			),
			GUI.objectTypes.container
		)

		xPos, counter = xPos + MineOSCore.iconWidth + iconField.spaceBetweenIcons.x, counter + 1
		if counter > iconField.iconCount.width then
			xPos, counter = 1, 1
			yPos = yPos + MineOSCore.iconHeight + iconField.spaceBetweenIcons.y
		end
	end

	return iconField
end

function MineOSCore.createIconField(x, y, width, height, xCountOfIcons, yCountOfIcons, totalCountOfIcons, xSpaceBetweenIcons, ySpaceBetweenIcons, iconTextColor, showFileFormat, showHiddenFiles, sortingMethod, workpathworkpath)
	local iconField = GUI.container(x, y, width, height)

	iconField.colors = {iconText = iconTextColor}

	iconField.iconCount = {}
	iconField.spaceBetweenIcons = {x = xSpaceBetweenIcons, y = ySpaceBetweenIcons}
	iconField.iconCount.width, iconField.iconCount.height, iconField.iconCount.total = xCountOfIcons, yCountOfIcons, totalCountOfIcons

	iconField.workpath = workpath
	iconField.showFileFormat = showFileFormat
	iconField.showHiddenFiles = showHiddenFiles
	iconField.sortingMethod = sortingMethod
	iconField.fileList = {}
	iconField.fromFile = fromFile

	iconField.updateFileList = updateIconFieldFileList

	return iconField
end

-----------------------------------------------------------------------------------------------------------------------------------

--Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð¿Ð°ÑÑÐ¸Ð½Ð³Ð° Lua-ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ Ð¾Ð± Ð¾ÑÐ¸Ð±ÐºÐµ. ÐÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÑÐµÑ Ð¸Ð· ÑÑÑÐ¾ÐºÐ¸ Ð² Ð¼Ð°ÑÑÐ¸Ð².
function MineOSCore.parseErrorMessage(error, indentationWidth)
	local parsedError = {}

	--ÐÐ°Ð¼ÐµÐ½Ð° /r/n Ð¸ ÑÐ°Ð±ÑÐ¾Ð²
	error = string.gsub(error, "\r\n", "\n")
	error = string.gsub(error, "	", string.rep(" ", indentationWidth or 4))

	--Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ ÑÐ½ÑÐµÑÐ¾Ð²
	local searchFrom, starting, ending = 1
	for i = 1, unicode.len(error) do
		starting, ending = string.find(error, "\n", searchFrom)
		if starting then
			table.insert(parsedError, unicode.sub(error, searchFrom, starting - 1))
			searchFrom = ending + 1
		else
			break
		end
	end

	--ÐÐ° Ð²ÑÑÐºÐ¸Ð¹ ÑÐ»ÑÑÐ°Ð¹, ÐµÑÐ»Ð¸ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ Ð¾Ð± Ð¾ÑÐ¸Ð±ÐºÐµ Ð±ÐµÐ· ÑÐ½ÑÐµÑÐ¾Ð² Ð²Ð¾Ð¾Ð±ÑÐµ, Ñ.Ðµ. Ð¾Ð´Ð½Ð¾ÑÑÑÐ¾ÑÐ½Ð¾Ðµ
	if #parsedError == 0 then table.insert(parsedError, error) end

	return parsedError
end

local function drawErrorWindow(path, programVersion, errorLine, reason)
	local oldDrawLimit = buffer.getDrawLimit(); buffer.resetDrawLimit()
	local width, height = buffer.screen.width, math.floor(buffer.screen.height * 0.45)
	local y = math.floor(buffer.screen.height / 2 - height / 2)

	-- ÐÐºÐ¾ÑÐµÑÐºÐ¾ Ð¸ Ð²ÑÑÐºÐ°Ñ ÑÐ½ÑÐ¶ÐºÐ° Ð½Ð° Ð½ÐµÐ¼
	local window = windows.empty(1, y, width, height, width, height)
	window:addPanel(1, 1, width, 3, 0x383838)
	window:addLabel(1, 2, width, 1, 0xFFFFFF, MineOSCore.localization.errorWhileRunningProgram .. "\"" .. MineOSCore.getFileName(path) .. "\""):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
	local windowActionButtons = window:addWindowActionButtons(2, 2, false)
	local sendToDeveloperButton = window:addAdaptiveButton(9, 1, 2, 1, 0x444444, 0xFFFFFF, 0x343434, 0xFFFFFF, MineOSCore.localization.sendFeedback)

	--ÐÐ¾Ð´Ð¸Ðº Ð½Ð° Ð¾ÐºÐ¾ÑÐµÑÐºÐµ
	local lines = {}
	local fromLine = errorLine - math.floor((height - 3) / 2) + 1; if fromLine <= 0 then fromLine = 1 end
	local toLine = fromLine + window.height - 3 - 1
	local file = io.open(path, "r")
	local lineCounter = 1
	for line in file:lines() do
		if lineCounter >= fromLine and lineCounter <= toLine then
			lines[lineCounter] = string.gsub(line, "	", "  ")
		elseif lineCounter < fromLine then
			lines[lineCounter] = " "
		elseif lineCounter > toLine then
			break
		end
		lineCounter = lineCounter + 1
	end
	file:close()

	local codeView = window:addCodeView(1, 4, math.floor(width * 0.62), height - 3, lines, 1, fromLine, 100, {}, {[errorLine] = 0xFF4444}, true, 2)
	codeView.scrollBars.horizontal.isHidden = true

	-- Ð¢ÐµÐºÑÑÐ±Ð¾ÐºÑÐ¸Ðº
	local stackTextBox = window:addTextBox(codeView.width + 1, 4, window.width - codeView.width, codeView.height, 0xFFFFFF, 0x000000, string.wrap(MineOSCore.parseErrorMessage(reason, 4), window.width - codeView.width - 2), 1, 1, 0)

	-- ÐÑÑÐºÐ¸Ðµ Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ð¿Ð¸Ð·Ð´Ð°ÑÑÐµ
	local function exit()
		windowActionButtons.close:pressAndRelease()
		buffer.setDrawLimit(oldDrawLimit)
		window:close()
	end
	
	windowActionButtons.close.onTouch = exit
	
	window.onDrawStarted = function()
		buffer.clear(0x000000, 50)
	end

	window.onKeyDown = function(eventData)
		if eventData[4] == 28 then exit() end
	end

	sendToDeveloperButton.onTouch = function()
		local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
			{"EmptyLine"},
			{"CenterText", 0x880000, MineOSCore.localization.sendFeedback},
			{"EmptyLine"},
			{"Input", 0x262626, 0x880000, MineOSCore.localization.yourContacts},
			{"Input", 0x262626, 0x880000, MineOSCore.localization.additionalInfo},
			{"EmptyLine"},
			{"CenterText", 0x880000, MineOSCore.localization.stackTraceback .. ":"},
			{"EmptyLine"},
			{"TextField", 5, 0xFFFFFF, 0x000000, 0xcccccc, 0x3366CC, reason},
			{"Button", {0x999999, 0xffffff, "OK"}, {0x777777, 0xffffff, MineOSCore.localization.cancel}}
		)

		if data[3] == "OK" then
			if component.isAvailable("internet") then
				local url = "http://igortimofeev.wallst.ru/MineOSErrorReports/Report.php?path=" .. path .. "&version=" .. string.optimizeForURLRequests(programVersion) .. "&userContacts=" .. string.optimizeForURLRequests(data[1]) .. "&userMessage=" .. string.optimizeForURLRequests(data[2]) .. "&errorMessage=" .. string.optimizeForURLRequests(reason)
				local success, reason = component.internet.request(url)
				if success then
					success:close()
				else
					ecs.error(reason)
				end
			end
			exit()
		end
	end

	-- ÐÐ°ÑÐ¸Ð½Ð°ÐµÐ¼ Ð³Ð¾Ð¼Ð¾ÐµÐ±Ð»Ñ!
	window:draw()
	buffer.draw()
	for i = 1, 3 do component.computer.beep(1500, 0.08) end
	window:handleEvents()
end

function MineOSCore.safeLaunch(path, ...)
	local args = {...}
	local oldResolutionWidth, oldResolutionHeight = buffer.screen.width, buffer.screen.height
	local finalSuccess, finalPath, finalLine, finalTraceback = true
	
	if fs.exists(path) then
		local loadSuccess, loadReason = loadfile(string.canonicalPath("/" .. path))

		if loadSuccess then
			local function launchMethod()
				loadSuccess(table.unpack(args))
			end

			local function tracebackMethod(xpcallTraceback)
				local traceback, info, firstMatch = tostring(xpcallTraceback) .. "\n" .. debug.traceback()
				for runLevel = 0, math.huge do
					info = debug.getinfo(runLevel)
					if info then
						if (info.what == "main" or info.what == "Lua") and info.source ~= "=machine" then
							if firstMatch then
								return {
									path = info.source:sub(2, -1),
									line = info.currentline,
									traceback = traceback
								}
							else
								firstMatch = true
							end
						end
					else
						error("Failed to get debug info for runlevel " .. runLevel)
					end
				end
			end

			local runSuccess, runReason = xpcall(launchMethod, tracebackMethod)
			if type(runReason) == "string" then
				GUI.error(runReason, {title = {color = 0xFFDB40, text = "Warning"}})
			else
				if not runSuccess and not string.match(runReason.traceback, "^table") and not string.find(runReason.traceback, "interrupted", 1, 15) then
					finalSuccess, finalPath, finalLine, finalTraceback = false, runReason.path, runReason.line, runReason.traceback
				end
			end
		else
			finalSuccess, finalPath, finalTraceback = false, path, loadReason
			local match = string.match(loadReason, ":(%d+)%:")
			finalLine = tonumber(match)
			if not match or not finalLine then error("ÐÐµÐ±Ð°Ð¶Ñ Ð³Ð¾Ð²Ð½Ð¾! " .. tostring(loadReason)) end
		end
	else
		GUI.error("Failed to safely launch file that doesn't exists: \"" .. path .. "\"", {title = {color = 0xFFDB40, text = "Warning"}})
	end

	if not finalSuccess then
		drawErrorWindow(finalPath, "1.0", finalLine, finalTraceback)
	end

	component.gpu.setResolution(oldResolutionWidth, oldResolutionHeight)
	buffer.start()

	return finalSuccess, finalPath, finalLine, finalTraceback
end

-----------------------------------------------------------------------------------------------------------------------------------

function MineOSCore.iconLeftClick(iconObject, eventData)
	iconObject.launch()
	computer.pushSignal("MineOSCore", "updateFileList")
end

function MineOSCore.iconRightClick(icon, eventData)
	local action
	-- Ð Ð°Ð·Ð½ÑÐµ ÐºÐ¾Ð½ÑÐµÐºÑÑÐ½ÑÐµ Ð¼ÐµÐ½Ñ
	if icon.isDirectory then
		if icon.format == ".app" then
			action = GUI.contextMenu(eventData[3], eventData[4],
				{MineOSCore.localization.contextMenuShowPackageContent},
				"-",
				{MineOSCore.localization.contextMenuCut},
				{MineOSCore.localization.contextMenuCopy},
				{MineOSCore.localization.contextMenuRename},
				{MineOSCore.localization.contextMenuCreateShortcut, icon.format == ".lnk"},
				"-",
				{MineOSCore.localization.contextMenuArchive},
				{MineOSCore.localization.contextMenuAddToDock},
				"-",
				{MineOSCore.localization.contextMenuProperties},
				{MineOSCore.localization.contextMenuDelete}
			):show()
		else
			action = GUI.contextMenu(eventData[3], eventData[4],
				{MineOSCore.localization.contextMenuCut},
				{MineOSCore.localization.contextMenuCopy},
				{MineOSCore.localization.contextMenuRename},
				{MineOSCore.localization.contextMenuCreateShortcut, icon.format == ".lnk"},
				"-",
				{MineOSCore.localization.contextMenuArchive},
				{MineOSCore.localization.contextMenuAddToDock},
				"-",
				{MineOSCore.localization.contextMenuProperties},
				{MineOSCore.localization.contextMenuDelete}
			):show()
		end
	else
		if icon.isShortcut then
			action = GUI.contextMenu(eventData[3], eventData[4],
				{MineOSCore.localization.contextMenuEdit},
				{MineOSCore.localization.contextMenuShowContainingFolder},
				"-",
				{MineOSCore.localization.contextMenuCut},
				{MineOSCore.localization.contextMenuCopy},
				{MineOSCore.localization.contextMenuRename},
				"-",
				{MineOSCore.localization.contextMenuAddToDock},
				{MineOSCore.localization.contextMenuProperties},
				{MineOSCore.localization.contextMenuDelete}
			):show()
		elseif icon.format == ".pic" then
			action = GUI.contextMenu(eventData[3], eventData[4],
				{MineOSCore.localization.contextMenuSetAsWallpaper},
				"-",
				{MineOSCore.localization.contextMenuCut},
				{MineOSCore.localization.contextMenuCopy},
				{MineOSCore.localization.contextMenuRename},
				{MineOSCore.localization.contextMenuCreateShortcut, icon.format == ".lnk"},
				"-",
				-- {MineOSCore.localization.contextMenuArchive},
				{MineOSCore.localization.contextMenuAddToDock},
				"-",
				{MineOSCore.localization.contextMenuProperties},
				{MineOSCore.localization.contextMenuDelete}
			):show()
		elseif icon.format == ".lua" then
			action = GUI.contextMenu(eventData[3], eventData[4],
				{MineOSCore.localization.contextMenuEdit},
				{MineOSCore.localization.contextMenuFlashEEPROM, (not component.isAvailable("eeprom") or icon.size > 4096)},
				"-",
				{MineOSCore.localization.contextMenuCut},
				{MineOSCore.localization.contextMenuCopy},
				{MineOSCore.localization.contextMenuRename},
				{MineOSCore.localization.contextMenuCreateShortcut, icon.format == ".lnk"},
				-- "-",
				-- {MineOSCore.localization.contextMenuUploadToPastebin, true},
				"-",
				-- {MineOSCore.localization.contextMenuArchive},
				{MineOSCore.localization.contextMenuAddToDock},
				"-",
				{MineOSCore.localization.contextMenuProperties},
				{MineOSCore.localization.contextMenuDelete}
			):show()
		else
			action = GUI.contextMenu(eventData[3], eventData[4],
				{MineOSCore.localization.contextMenuEdit},
				"-",
				{MineOSCore.localization.contextMenuCut},
				{MineOSCore.localization.contextMenuCopy},
				{MineOSCore.localization.contextMenuRename},
				{MineOSCore.localization.contextMenuCreateShortcut, icon.format == ".lnk"},
				"-",
				-- {MineOSCore.localization.contextMenuArchive},
				{MineOSCore.localization.contextMenuAddToDock},
				"-",
				{MineOSCore.localization.contextMenuProperties},
				{MineOSCore.localization.contextMenuDelete}
			):show()
		end
	end

	if action == MineOSCore.localization.contextMenuEdit then
		MineOSCore.safeLaunch(MineOSCore.paths.applications .. "/MineCode IDE.app/MineCode IDE.lua", "open", icon.path)
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == "Ð¡Ð²Ð¾Ð¹ÑÑÐ²Ð°" then
		MineOSCore.showPropertiesWindow(eventData[3], eventData[4], 40, icon)
	elseif action == MineOSCore.localization.contextMenuShowContainingFolder then
		computer.pushSignal("MineOSCore", "changeWorkpath", MineOSCore.getFilePath(icon.shortcutPath))
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuAddToFavourites then
		computer.pushSignal("finderFavouriteAdded", icon.path)
	elseif action == MineOSCore.localization.contextMenuShowPackageContent then
		computer.pushSignal("MineOSCore", "changeWorkpath", icon.path)
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuCopy then
		_G.clipboard = icon.path
	elseif action == MineOSCore.localization.contextMenuCut then
		_G.clipboard = icon.path
		_G.clipboardCut = true
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuDelete then
		if MineOSCore.getFilePath(icon.path) == MineOSCore.paths.trash then
			fs.remove(icon.path)
		else
			local newName = MineOSCore.paths.trash .. MineOSCore.getFileName(icon.path)
			local clearName = MineOSCore.hideFileFormat(MineOSCore.getFileName(icon.path))
			local repeats = 1
			while fs.exists(newName) do
				newName, repeats = MineOSCore.paths.trash .. clearName .. string.rep("-copy", repeats) .. icon.format, repeats + 1
			end
			fs.rename(icon.path, newName)
		end
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuRename then
		ecs.rename(icon.path)
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuCreateShortcut then
		ecs.createShortCut(MineOSCore.getFilePath(icon.path) .. "/" .. ecs.hideFileFormat(MineOSCore.getFileName(icon.path)) .. ".lnk", icon.path)
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuArchive then
		require("compressor").pack(MineOSCore.getFilePath(icon.path) .. MineOSCore.hideFileFormat(MineOSCore.getFileName(icon.path)) .. ".pkg", icon.path)
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuSetAsWallpaper then
		fs.remove(MineOSCore.paths.wallpaper)
		ecs.createShortCut(MineOSCore.paths.wallpaper, icon.path)
		computer.pushSignal("MineOSCore", "updateWallpaper")
	elseif action == MineOSCore.localization.contextMenuFlashEEPROM then
		local file = io.open(icon.path, "r")
		component.eeprom.set(file:read("*a"))
		file:close()
		computer.beep(1500, 0.2)
	elseif action == MineOSCore.localization.contextMenuCreateApplication then
		ecs.newApplicationFromLuaFile(icon.path, MineOSCore.getFilePath(icon.path) or "")
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuAddToDock then
		table.insert(_G.OSSettings.dockShortcuts, {path = icon.path})
		MineOSCore.saveOSSettings()
		computer.pushSignal("MineOSCore", "updateFileList")
	end
end

function MineOSCore.emptyZoneClick(eventData, workspace, workpath)
	local action = GUI.contextMenu(eventData[3], eventData[4],
		{MineOSCore.localization.contextMenuNewFile},
		{MineOSCore.localization.contextMenuNewFolder},
		{MineOSCore.localization.contextMenuNewApplication},
		"-",
		{MineOSCore.localization.contextMenuPaste, (_G.clipboard == nil)}
	):show()

	if action == MineOSCore.localization.contextMenuNewFile then
		ecs.newFile(workpath)
		computer.pushSignal("MineOSCore", "updateFileListAndBufferTrueRedraw")
	elseif action == MineOSCore.localization.contextMenuNewFolder then
		ecs.newFolder(workpath)
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuPaste then
		ecs.copy(_G.clipboard, workpath)
		if _G.clipboardCut then
			fs.remove(_G.clipboard)
			_G.clipboardCut = nil
			_G.clipboard = nil
		end
		computer.pushSignal("MineOSCore", "updateFileList")
	elseif action == MineOSCore.localization.contextMenuNewApplication then
		ecs.newApplication(workpath)
		computer.pushSignal("MineOSCore", "updateFileList")
	end
end

local function addKeyAndValue(window, x, y, key, value)
	window:addLabel(x, y, window.width , 1, 0x333333, key .. ":"); x = x + unicode.len(key) + 2
	return window:addLabel(x, y, window.width, 1, 0x555555, value)
end

function MineOSCore.showPropertiesWindow(x, y, width, iconObject)
	local window = windows.empty(x, y, width, 1)
	local backgroundPanel = window:addPanel(1, 2, window.width, 1, 0xDDDDDD)
	window:addPanel(1, 1, window.width, 1, 0xEEEEEE)
	window:addLabel(1, 1, window.width, 1, 0x333333, MineOSCore.localization.contextMenuProperties):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
	window:addButton(2, 1, 1, 1, nil, 0xFF4940, nil, 0x992400, "â").onTouch = function() window:close() end

	window:addImage(3, 3, iconObject.iconImage.image)

	local y = 3
	addKeyAndValue(window, 13, y, MineOSCore.localization.type, iconObject.format and iconObject.format or (iconObject.isDirectory and MineOSCore.localization.folder or MineOSCore.localization.unknown)); y = y + 1
	local fileSizeLabel = addKeyAndValue(window, 13, y, MineOSCore.localization.size, iconObject.isDirectory and MineOSCore.localization.calculatingSize or string.format("%.2f", iconObject.size / 1024) .. " KB"); y = y + 1
	addKeyAndValue(window, 13, y, MineOSCore.localization.date, os.date("%d.%m.%y, %H:%M", fs.lastModified(iconObject.path))); y = y + 1
	addKeyAndValue(window, 13, y, MineOSCore.localization.path, " ")

	local lines = string.wrap(iconObject.path, window.width - 19)
	local textBox = window:addTextBox(19, y, window.width - 19, #lines, nil, 0x555555, lines, 1)
	window.height = textBox.y + textBox.height 
	backgroundPanel.height = window.height - 1

	if window.x + window.width > buffer.screen.width then window.x = window.x - (window.x + window.width - buffer.screen.width) end
	if window.y + window.height > buffer.screen.height then window.y = window.y - (window.y + window.height - buffer.screen.height) end

	window:draw()
	buffer.draw()

	if iconObject.isDirectory then
		fileSizeLabel.text = string.format("%.2f", MineOSCore.getFolderSize(iconObject.path) / 1024) .. " KB"
		window:draw()
		buffer.draw()
	end

	window:handleEvents()
end

-----------------------------------------------------------------------------------------------------------------------------------

MineOSCore.init()

-----------------------------------------------------------------------------------------------------------------------------------

return MineOSCore





Dlib/OpenComputersGL/Flib/OpenComputersGL/Main.lua2Ë
-------------------------------------------------------- Libraries --------------------------------------------------------

local vector = require("vector")
local matrix = require("matrix")
local buffer = require("doubleBuffering")
local materials = require("OpenComputersGL/Materials")
local renderer = require("OpenComputersGL/Renderer")
local OCGL = {}

-------------------------------------------------------- Constants --------------------------------------------------------

OCGL.axis = {
	x = 1,
	y = 2,
	z = 3,
}

OCGL.vertices = {}
OCGL.triangles = {}
OCGL.lines = {}
OCGL.floatingTexts = {}

-------------------------------------------------------- Vertex field methods --------------------------------------------------------

function OCGL.rotateVector(vector, axis, angle)
	local sin, cos = math.sin(angle), math.cos(angle)
	if axis == OCGL.axis.x then
		vector[1], vector[2], vector[3] = vector[1], cos * vector[2] - sin * vector[3], sin * vector[2] + cos * vector[3]
	elseif axis == OCGL.axis.y then
		vector[1], vector[2], vector[3] = cos * vector[1] + sin * vector[3], vector[2], cos * vector[3] - sin * vector[1]
	elseif axis == OCGL.axis.z then
		vector[1], vector[2], vector[3] = cos * vector[1] - sin * vector[2], sin * vector[1] + cos * vector[2], vector[3]
	else
		error("Axis enum " .. tostring(axis) .. " doesn't exists")
	end
end

function OCGL.translate(xTranslation, yTranslation, zTranslation)
	for vertexIndex = 1, #OCGL.vertices do
		OCGL.vertices[vertexIndex][1], OCGL.vertices[vertexIndex][2], OCGL.vertices[vertexIndex][3] = OCGL.vertices[vertexIndex][1] + xTranslation, OCGL.vertices[vertexIndex][2] + yTranslation, OCGL.vertices[vertexIndex][3] + zTranslation
	end
end

function OCGL.rotate(axis, angle)
	for vertexIndex = 1, #OCGL.vertices do
		OCGL.rotateVector(OCGL.vertices[vertexIndex], axis, angle)
	end
end

-------------------------------------------------------- Render queue methods --------------------------------------------------------

function OCGL.newIndexedTriangle(indexOfVertex1, indexOfVertex2, indexOfVertex3, material)
	return { indexOfVertex1, indexOfVertex2, indexOfVertex3, material }
end

function OCGL.newIndexedLine(indexOfVertex1, indexOfVertex2, color)
	return { indexOfVertex1, indexOfVertex2, color }
end

function OCGL.newIndexedFloatingText(indexOfVertex, color, text)
	return {indexOfVertex, text, color}
end

function OCGL.pushTriangleToRenderQueue(vector3Vertex1, vector3Vertex2, vector3Vertex3, material, meshPointer, meshTriangleIndexPointer)
	table.insert(OCGL.vertices, vector3Vertex1)
	table.insert(OCGL.vertices, vector3Vertex2)
	table.insert(OCGL.vertices, vector3Vertex3)
	table.insert(OCGL.triangles, OCGL.newIndexedTriangle(OCGL.nextVertexIndex, OCGL.nextVertexIndex + 1, OCGL.nextVertexIndex + 2, material, meshPointer, meshTriangleIndexPointer))
	OCGL.nextVertexIndex = OCGL.nextVertexIndex + 3
end

function OCGL.pushLineToRenderQueue(vector3Vertex1, vector3Vertex2, color)
	table.insert(OCGL.vertices, vector3Vertex1)
	table.insert(OCGL.vertices, vector3Vertex2)
	table.insert(OCGL.lines, OCGL.newIndexedLine(OCGL.nextVertexIndex, OCGL.nextVertexIndex + 1, color))
	OCGL.nextVertexIndex = OCGL.nextVertexIndex + 2
end

function OCGL.pushFloatingTextToRenderQueue(vector3Vertex, color, text)
	table.insert(OCGL.vertices, vector3Vertex)
	table.insert(OCGL.floatingTexts, OCGL.newIndexedFloatingText(OCGL.nextVertexIndex, color, text))
	OCGL.nextVertexIndex = OCGL.nextVertexIndex + 1
end

-------------------------------------------------------- Rendering methods --------------------------------------------------------

OCGL.setViewport = renderer.setViewport

function OCGL.clearBuffer(backgroundColor)
	OCGL.nextVertexIndex, OCGL.vertices, OCGL.triangles, OCGL.lines, OCGL.floatingTexts = 1, {}, {}, {}, {}
	renderer.clearDepthBuffer()
	buffer.clear(backgroundColor)
end

function OCGL.createPerspectiveProjection() 
	local zNearDivZ
	for vertexIndex = 1, #OCGL.vertices do
		zNearDivZ = math.abs(renderer.viewport.projectionSurface / OCGL.vertices[vertexIndex][3])
		OCGL.vertices[vertexIndex][1] = zNearDivZ * OCGL.vertices[vertexIndex][1]
		OCGL.vertices[vertexIndex][2] = zNearDivZ * OCGL.vertices[vertexIndex][2]
		-- OCGL.vertices[vertexIndex][3] = zNearDivZ * OCGL.vertices[vertexIndex][3]
	end
end

function OCGL.render(renderMode)
	local vector3Vertex1, vector3Vertex2, vector3Vertex3, material = {}, {}, {}

	-- for lineIndex = 1, #OCGL.lines do
	-- 	vector3Vertex1, vector3Vertex2, material = OCGL.vertices[OCGL.lines[lineIndex][1]], OCGL.vertices[OCGL.lines[lineIndex][2]], OCGL.lines[lineIndex][3]

	-- 	if renderMode == renderer.renderModes.vertices then
	-- 		renderer.renderDot(vector3Vertex1, material)
	-- 		renderer.renderDot(vector3Vertex2, material)
	-- 	else
	-- 		renderer.renderLine(
	-- 			math.floor(vector3Vertex1[1]),
	-- 			math.floor(vector3Vertex1[2]),
	-- 			vector3Vertex1[3],
	-- 			math.floor(vector3Vertex2[1]),
	-- 			math.floor(vector3Vertex2[2]),
	-- 			vector3Vertex2[3],
	-- 			material
	-- 		)
	-- 	end
	-- end

	for floatingTextIndex = 1, #OCGL.floatingTexts do
		vector3Vertex1 = OCGL.vertices[OCGL.floatingTexts[floatingTextIndex][1]]
		renderer.renderFloatingText(
			renderer.viewport.xCenter + vector3Vertex1[1],
			renderer.viewport.yCenter - vector3Vertex1[2],
			vector3Vertex1[3],
			OCGL.floatingTexts[floatingTextIndex][2],
			OCGL.floatingTexts[floatingTextIndex][3]
		)
	end

	for triangleIndex = 1, #OCGL.triangles do
		material = OCGL.triangles[triangleIndex][4]
		vector3Vertex1[1], vector3Vertex1[2], vector3Vertex1[3] = renderer.viewport.xCenter + OCGL.vertices[OCGL.triangles[triangleIndex][1]][1], renderer.viewport.yCenter - OCGL.vertices[OCGL.triangles[triangleIndex][1]][2], OCGL.vertices[OCGL.triangles[triangleIndex][1]][3]
		vector3Vertex2[1], vector3Vertex2[2], vector3Vertex2[3] = renderer.viewport.xCenter + OCGL.vertices[OCGL.triangles[triangleIndex][2]][1], renderer.viewport.yCenter - OCGL.vertices[OCGL.triangles[triangleIndex][2]][2], OCGL.vertices[OCGL.triangles[triangleIndex][2]][3]
		vector3Vertex3[1], vector3Vertex3[2], vector3Vertex3[3] = renderer.viewport.xCenter + OCGL.vertices[OCGL.triangles[triangleIndex][3]][1], renderer.viewport.yCenter - OCGL.vertices[OCGL.triangles[triangleIndex][3]][2], OCGL.vertices[OCGL.triangles[triangleIndex][3]][3]
		
		if
			renderer.isVertexInViewRange(vector3Vertex1[1], vector3Vertex1[2], vector3Vertex1[3]) or
			renderer.isVertexInViewRange(vector3Vertex2[1], vector3Vertex2[2], vector3Vertex2[3]) or
			renderer.isVertexInViewRange(vector3Vertex3[1], vector3Vertex3[2], vector3Vertex3[3])
		then
			if renderMode == renderer.renderModes.material then
				if material.type == materials.types.solid then
					renderer.renderFilledTriangle(
						{
							vector3Vertex1,
							vector3Vertex2,
							vector3Vertex3
						},
						material.color
					)
				else
					error("Material type " .. tostring(material.type) .. " doesn't supported for rendering triangles")
				end
			elseif renderMode == renderer.renderModes.wireframe then
				renderer.renderLine(math.floor(vector3Vertex1[1]), math.floor(vector3Vertex1[2]), vector3Vertex1[3], math.floor(vector3Vertex2[1]), math.floor(vector3Vertex2[2]), vector3Vertex2[3], material.color or renderer.colors.wireframe)
				renderer.renderLine(math.floor(vector3Vertex2[1]), math.floor(vector3Vertex2[2]), vector3Vertex2[3], math.floor(vector3Vertex3[1]), math.floor(vector3Vertex3[2]), vector3Vertex3[3], material.color or renderer.colors.wireframe)
				renderer.renderLine(math.floor(vector3Vertex1[1]), math.floor(vector3Vertex1[2]), vector3Vertex1[3], math.floor(vector3Vertex3[1]), math.floor(vector3Vertex3[2]), vector3Vertex3[3], material.color or renderer.colors.wireframe)
			elseif renderMode == renderer.renderModes.vertices then
				renderer.renderDot(vector3Vertex1, material.color or renderer.colors.wireframe)
				renderer.renderDot(vector3Vertex2, material.color or renderer.colors.wireframe)
				renderer.renderDot(vector3Vertex3, material.color or renderer.colors.wireframe)
			else
				error("Rendermode enum " .. tostring(renderMode) .. " doesn't supported for rendering triangles")
			end
		end
	end
end

-------------------------------------------------------- Raycasting methods --------------------------------------------------------

local function vectorMultiply(a, b)
	return vector.newVector3(a[2] * b[3] - a[3] * b[2], a[3] * b[1] - a[1] * b[3], a[1] * b[2] - a[2] * b[1])
end

local function getVectorDistance(a)
	return math.sqrt(a[1] ^ 2 + a[2] ^ 2 + a[3] ^ 2)
end

-- Ð ÑÐ»ÑÑÐ°Ðµ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ð»ÑÑÐ¸ÐºÐ° ÑÑÐ¾Ñ Ð¼ÐµÑÐ¾Ð´ Ð²ÐµÑÐ½ÐµÑ ÑÐ°Ð¼ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº, Ð° ÑÐ°ÐºÐ¶Ðµ Ð´Ð¸ÑÑÐ°Ð½ÑÐ¸Ñ Ð´Ð¾ ÐµÐ³Ð¾ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÐ¸
function OCGL.triangleRaycast(vector3RayStart, vector3RayEnd)
	local minimalDistance, closestTriangleIndex
	for triangleIndex = 1, #OCGL.triangles do
		-- Ð­ÑÐ¾ Ð²ÐµÑÑÐ¸Ð½Ñ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°
		local A, B, C = OCGL.vertices[OCGL.triangles[triangleIndex][1]], OCGL.vertices[OCGL.triangles[triangleIndex][3]], OCGL.vertices[OCGL.triangles[triangleIndex][3]]
		-- ecs.error(A[1], A[2], A[3], vector3RayStart[1], vector3RayStart[2], vector3RayStart[3])
		-- Ð­ÑÐ¾ ÑÐ· ÑÐµ
		local ABC = vectorMultiply(vector.newVector3(C[1] - A[1], C[2] - A[2], C[3] - A[3]), vector.newVector3(B[1] - A[1], B[2] - A[2], B[3] - A[3]))
		-- Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ´Ð°Ð»ÐµÐ½Ð½Ð¾ÑÑÑ Ð²Ð¸ÑÑÑÐ°Ð»ÑÐ½Ð¾Ð¹ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÐ¸ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ° Ð¾Ñ ÑÑÐ°ÑÑÐ° Ð½Ð°ÑÐµÐ³Ð¾ Ð»ÑÑÐ°
		local D = -ABC[1] * A[1] - ABC[2] * A[2] - ABC[3] * A[3]
		local firstPart = D + ABC[1] * vector3RayStart[1] + ABC[2] * vector3RayStart[2] + ABC[3] * vector3RayStart[3]
		local secondPart = ABC[1] * vector3RayStart[1] - ABC[1] * vector3RayEnd[1] + ABC[2] * vector3RayStart[2] - ABC[2] * vector3RayEnd[2] + ABC[3] * vector3RayStart[3] - ABC[3] * vector3RayEnd[3]
		
		-- ecs.error(firstPart, secondPart)

		-- if firstPart ~= 0 or secondPart ~= 0 then ecs.error(firstPart, secondPart) end
		-- ÐÑÐ»Ð¸ Ð½Ð°Ñ Ð»ÑÑÐ¸Ðº Ð½Ðµ Ð¿Ð°ÑÐ°Ð»Ð»ÐµÐ»ÐµÐ½ ÑÐ¾Ð¹ ÐµÐ±ÑÑÐµÐ¹ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÐ¸ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°
		if secondPart ~= 0 then
			local distance = firstPart / secondPart
			-- Ð ÐµÑÐ»Ð¸ ÑÑÐ¾Ñ Ð¾Ð±ÑÐµÐºÑ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð±Ð»Ð¸Ð¶Ðµ Ðº ÑÑÐ°ÑÑÑ Ð»ÑÑÐ°, Ð½ÐµÐ¶ÐµÐ»Ð¸ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¹
			if (distance >= 0 and distance <= 1) and (not minimalDistance or distance < minimalDistance) then
	
				-- Ð¢Ð¾ ÑÑÐ¸ÑÐ°ÐµÐ¼ ÑÐ¾ÑÐºÑ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ð»ÑÑÐ° Ð² Ð´Ð°Ð½Ð½ÑÑ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÑ (Ð½Ð¾ Ð½Ð¸ ÑÑÑ Ð½Ðµ ÑÐ°ÐºÑ, ÑÑÐ¾ Ð¾Ð½ Ð¿Ð¾Ð¿Ð°Ð´ÐµÑ Ð² ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº!)
				local S = vector.newVector3(
					vector3RayStart[1] + (vector3RayEnd[1] - vector3RayStart[1]) * distance,
					vector3RayStart[2] + (vector3RayEnd[2] - vector3RayStart[2]) * distance,
					vector3RayStart[3] + (vector3RayEnd[3] - vector3RayStart[3]) * distance
				)

				-- ÐÐ°Ð»ÐµÐµ ÑÑÐ¸ÑÐ°ÐµÐ¼ ÑÑÐ¼Ð¼Ñ Ð¿Ð»Ð¾ÑÐ°Ð´ÐµÐ¹ Ð¿Ð°ÑÐ°Ð»Ð»ÐµÐ»Ð¾Ð³ÑÐ°Ð¼Ð¼Ð¾Ð², Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð½ÑÑ ÑÑÐµÐ¼Ñ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°Ð¼Ð¸, Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð²ÑÐ¸ÑÑÑ Ð¿ÑÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ð¸ ÑÐ¾ÑÐºÐ¸ Ð² ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº
				-- ÐÑÑÑ ÑÐ¸Ð¿ ÐºÐ°ÑÐ¾Ñ ÑÐ¼Ð°ÑÐ¸: ÑÐ¾ÑÐºÐ° ÐµÐ±Ð°Ð½ÑÐ»Ð° Ð² ÑÐµÐ½ÑÑ, Ð¸ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº ÑÐ°ÑÐ¿Ð¸Ð´Ð¾ÑÐ°ÑÐ¸Ð»Ð¾ Ð½Ð° ÑÑÐ¸ Ð¼ÐµÐ»ÐºÐ¸Ñ. ÐÑ, Ð¸ ÑÑÐ¸ Ð¼ÐµÐ»ÐºÐ¸Ñ Ð¼Ð¾Ð³ÑÑ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°ÑÑ Ð¿Ð°ÑÐ°Ð»Ð»ÐµÐ»Ð¾Ð³ÑÐ°Ð¼Ð¼Ñ ÑÐ²Ð¾Ð¸
				-- Ð, ÐºÐ°ÑÐ¾Ñ, ÐµÑÐ»Ð¸ ÑÑÐ¼Ð¼Ð° ÑÑÐµÑ Ð¿Ð»Ð¾ÑÐ°Ð´ÐµÐ¹ ÑÑÐ¸Ñ Ð¼ÐµÐ»ÐºÐ¸Ñ ÑÐµÐ±ÐºÐ¾Ð² Ð±ÑÐ´ÐµÑ ÑÐ¸Ð»ÑÐ½Ð¾ Ð¾ÑÐ»Ð¸ÑÐ°ÑÑÑÑ Ð¾Ñ Ð¿Ð»Ð¾ÑÐ°Ð´Ð¸ Ð¶Ð¸ÑÐ½Ð¾Ð³Ð¾ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°, ÑÐ¾ Ð»ÑÑ Ð½Ðµ Ð¿Ð¾Ð¿Ð°Ð»
				-- ÐÑ, Ð° Ð¿Ð»Ð¾ÑÐ°Ð´Ñ ÑÑÐ¸ÑÐ°ÐµÑÑÑ ÑÐµÑÐµÐ· sqrt(x^2+y^2+z^2) Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð¹Ð¾Ð±Ð°-Ð²ÐµÐºÑÐ¾ÑÐ°

				---- *A                      *B


				--                  * Shotxyz


				---                   *C

				local SA = vector.newVector3(A[1] - S[1], A[2] - S[2], A[3] - S[3])
				local SB = vector.newVector3(B[1] - S[1], B[2] - S[2], B[3] - S[3])
				local SC = vector.newVector3(C[1] - S[1], C[2] - S[2], C[3] - S[3])
			
				local vectorDistanceSum = getVectorDistance(vectorMultiply(SA, SB)) + getVectorDistance(vectorMultiply(SB, SC)) + getVectorDistance(vectorMultiply(SC, SA))
				local ABCDistance = getVectorDistance(ABC)

				-- ÐÐ¾Ñ ÑÑÑ Ð¼Ñ ÑÐµÐºÐ°ÐµÐ¼ Ð¿Ð¾Ð³ÑÐµÑÐ½Ð¾ÑÑÑ ÑÐ°ÑÑÐµÑÐ¾Ð². ÐÑÐ»Ð¸ Ð²ÑÐµ Ð·Ð°ÐµÐ±Ð¾Ðº, ÑÐ¾ ÐºÐ¸Ð´Ð°ÐµÐ¼ ÑÑÐ¾Ñ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº Ð² "Ð¿ÑÐ¾Ð²ÐµÑÐµÐ½Ð½ÑÐµ""
				if math.abs(vectorDistanceSum - ABCDistance) < 1 then
					closestTriangleIndex = triangleIndex
					minimalDistance = distance
				end
			end 
		end
	end

	-- ecs.error(closestTriangleIndex)
	if OCGL.triangles[closestTriangleIndex] then
		return OCGL.triangles[closestTriangleIndex][5], OCGL.triangles[closestTriangleIndex][6], minimalDistance
	end
end

-------------------------------------------------------- Constants --------------------------------------------------------

return OCGL
F!lib/OpenComputersGL/Materials.lua6

local materials = {}

------------------------------------------------------------------------------------------------------------------------

materials.types = {
	textured = 1,
	solid = 2,
}

function materials.newSolidMaterial(color)
	return {
		type = materials.types.solid,
		color = color
	}
end

function materials.newTexturedMaterial(texture)
	return {
		type = materials.types.textured,
		texture = texture
	}
end

------------------------------------------------------------------------------------------------------------------------

return materials

F lib/OpenComputersGL/Renderer.lua%§
-------------------------------------------------------- Libraries --------------------------------------------------------

local vector = require("vector")
local unicode = require("unicode")
local materials = require("OpenComputersGL/Materials")
local buffer = require("doubleBuffering")

local renderer = {
	depthBuffer = {},
	viewport = {},
}

-------------------------------------------------------- Constants --------------------------------------------------------

renderer.colors = {
	axis = {
		x = 0xFF0000,
		y = 0x00FF00,
		z = 0x0000FF,
	},
	pivotPoint = 0xFFFFFF,
	wireframe = 0x00FFFF,
}

renderer.renderModes = {
	material = 1,
	wireframe = 2,
	vertices = 3,
}

-------------------------------------------------------- Renderer --------------------------------------------------------

function renderer.clearDepthBuffer()
	for y = 1, renderer.viewport.height do
		renderer.depthBuffer[y] = {}
		for x = 1, renderer.viewport.width do
			renderer.depthBuffer[y][x] = math.huge
		end
	end
end

function renderer.setViewport(x1, y1, x2, y2, nearClippingSurface, farClippingSurface, projectionSurface)
	renderer.viewport.x1 = x1
	renderer.viewport.y1 = y1
	renderer.viewport.x2 = x2
	renderer.viewport.y2 = y2
	renderer.viewport.nearClippingSurface = nearClippingSurface
	renderer.viewport.farClippingSurface = farClippingSurface
	renderer.viewport.projectionSurface = projectionSurface
	renderer.viewport.width = x2 - x1 + 1
	renderer.viewport.height = y2 - y1 + 1
	renderer.viewport.xCenter = math.floor(x1 + renderer.viewport.width / 2)
	renderer.viewport.yCenter = math.floor(y1 + renderer.viewport.height / 2)
end

function renderer.setPixelUsingDepthBuffer(x, y, pixelDepthValue, pixelColor)
	if
		renderer.isVertexInViewRange(x, y, pixelDepthValue)
	then
		if pixelDepthValue < renderer.depthBuffer[y][x] then
			renderer.depthBuffer[y][x] = pixelDepthValue
			buffer.semiPixelRawSet(buffer.getBufferIndexByCoordinates(x, math.ceil(y / 2)), pixelColor, y % 2 == 0)
			-- buffer.set(x, y, pixelColor, 0x0, " ")
		end
	end
end

function renderer.isVertexInViewRange(x, y, z)
	return 
		x >= renderer.viewport.x1 and
		x <= renderer.viewport.x2 and
		y >= renderer.viewport.y1 and
		y <= renderer.viewport.y2 and
		-- z >= renderer.viewport.projectionSurface - (renderer.viewport.projectionSurface - renderer.viewport.nearClippingSurface) * 0.6 and
		z >= renderer.viewport.nearClippingSurface and
		z <= renderer.viewport.farClippingSurface
end

-------------------------------------------------------- Line rendering --------------------------------------------------------

function renderer.renderLine(x1, y1, z1, x2, y2, z2, color)
	local incycleValueFrom, incycleValueTo, outcycleValueFrom, outcycleValueTo, isReversed, incycleValueDelta, outcycleValueDelta = x1, x2, y1, y2, false, math.abs(x2 - x1), math.abs(y2 - y1)
	if incycleValueDelta < outcycleValueDelta then
		incycleValueFrom, incycleValueTo, outcycleValueFrom, outcycleValueTo, isReversed, incycleValueDelta, outcycleValueDelta = y1, y2, x1, x2, true, outcycleValueDelta, incycleValueDelta
	end

	if outcycleValueFrom > outcycleValueTo then
		outcycleValueFrom, outcycleValueTo = outcycleValueTo, outcycleValueFrom
		incycleValueFrom, incycleValueTo = incycleValueTo, incycleValueFrom
		z1, z2 = z2, z1
	end

	local outcycleValue, outcycleValueCounter, outcycleValueTriggerIncrement = outcycleValueFrom, 1, incycleValueDelta / outcycleValueDelta
	local outcycleValueTrigger = outcycleValueTriggerIncrement
	local z, zStep = z1, (z2 - z1) / incycleValueDelta
	
	for incycleValue = incycleValueFrom, incycleValueTo, incycleValueFrom < incycleValueTo and 1 or -1 do
		if isReversed then
			renderer.setPixelUsingDepthBuffer(outcycleValue, incycleValue, z, color)
		else
			renderer.setPixelUsingDepthBuffer(incycleValue, outcycleValue, z, color)
		end

		outcycleValueCounter, z = outcycleValueCounter + 1, z + zStep
		if outcycleValueCounter > outcycleValueTrigger then
			outcycleValue, outcycleValueTrigger = outcycleValue + 1, outcycleValueTrigger + outcycleValueTriggerIncrement
		end
	end
end

function renderer.renderDot(vector3Vertex, color)
	renderer.setPixelUsingDepthBuffer(math.floor(vector3Vertex[1]), math.floor(vector3Vertex[2]), vector3Vertex[3], color)
end

-------------------------------------------------------- Triangles render --------------------------------------------------------

local function fillPart(x1Screen, x2Screen, z1Screen, z2Screen, y, color)
	if x2Screen < x1Screen then x1Screen, x2Screen, z1Screen, z2Screen = x2Screen, x1Screen, z2Screen, z1Screen end

	local z, zStep = z1Screen, (z2Screen - z1Screen) / (x2Screen - x1Screen)
	for x = math.floor(x1Screen), math.floor(x2Screen) do
		renderer.setPixelUsingDepthBuffer(x, y, z, color)
		-- buffer.semiPixelSet(x, y, color)
		z = z + zStep
	end
end

function renderer.renderFilledTriangle(points, color)
	local topID, centerID, bottomID = 1, 1, 1
	for i = 1, 3 do
		points[i][2] = math.floor(points[i][2])
		if points[i][2] < points[topID][2] then topID = i end
		if points[i][2] > points[bottomID][2] then bottomID = i end
	end
	for i = 1, 3 do if i ~= topID and i ~= bottomID then centerID = i end end

	local x1ScreenStep = (points[centerID][1] - points[topID][1]) / (points[centerID][2] - points[topID][2])
	local x2ScreenStep = (points[bottomID][1] - points[topID][1]) / (points[bottomID][2] - points[topID][2])
	local x1Screen, x2Screen = points[topID][1], points[topID][1]

	local z1ScreenStep = (points[centerID][3] - points[topID][3]) / (points[centerID][2] - points[topID][2])
	local z2ScreenStep = (points[bottomID][3] - points[topID][3]) / (points[bottomID][2] - points[topID][2])
	local z1Screen, z2Screen = points[topID][3], points[topID][3]

	-- Ð Ð¸ÑÑÐµÐ¼ Ð¿ÐµÑÐ²ÑÐ¹ ÐºÑÑÐ¾Ðº ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ° Ð¾Ñ Ð²ÐµÑÑÐ½ÐµÐ¹ ÑÐ¾ÑÐºÐ¸ Ð´Ð¾ ÑÐµÐ½ÑÑÐ°Ð»ÑÐ½Ð¾Ð¹
	for y = points[topID][2], points[centerID][2] - 1 do
		fillPart(x1Screen, x2Screen, z1Screen, z2Screen, y, color)
		x1Screen, x2Screen, z1Screen, z2Screen = x1Screen + x1ScreenStep, x2Screen + x2ScreenStep, z1Screen + z1ScreenStep, z2Screen + z2ScreenStep
	end

	-- ÐÐ°Ð»ÐµÐµ ÑÑÐ¸ÑÐ°ÐµÐ¼, ÐºÐ°Ðº Ð±ÑÐ´ÐµÑ Ð¸Ð·Ð¼ÐµÐ½ÑÑÑÑÑ X Ð¾Ñ ÑÐµÐ½ÑÑÐµÐ»ÑÐ½Ð¾Ð¹ ÑÐ¾ÑÐºÐ¸ Ð´Ð¾ Ð½Ð¸Ð¶Ð½ÐµÐ¹
	x1Screen, x1ScreenStep = points[centerID][1], (points[bottomID][1] - points[centerID][1]) / (points[bottomID][2] - points[centerID][2])
	z1Screen, z1ScreenStep = points[centerID][3], (points[bottomID][3] - points[centerID][3]) / (points[bottomID][2] - points[centerID][2])
	-- Ð ÑÐ¸ÑÑÐµÐ¼ Ð½Ð¸Ð¶Ð½Ð¸Ð¹ ÐºÑÑÐ¾Ðº ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ° Ð¾Ñ ÑÐµÐ½ÑÑÐ°Ð»ÑÐ½Ð¾Ð¹ ÑÐ¾ÑÐºÐ¸ Ð´Ð¾ Ð½Ð¸Ð¶Ð½ÐµÐ¹
	for y = points[centerID][2], points[bottomID][2] do
		fillPart(x1Screen, x2Screen, z1Screen, z2Screen, y, color)
		x1Screen, x2Screen, z1Screen, z2Screen = x1Screen + x1ScreenStep, x2Screen + x2ScreenStep, z1Screen + z1ScreenStep, z2Screen + z2ScreenStep
	end
end

function renderer.renderTexturedTriangle(vertices, texture)

end

-------------------------------------------------------- Floating text rendering --------------------------------------------------------

function renderer.renderFloatingText(x, y, z, color, text)
	local textLength = unicode.len(text)
	x, y = math.floor(x - textLength / 2), math.floor(y)
	local yInteger, yFractional = math.modf(y / 2)
	local index, background

	for i = 1, textLength do
		if renderer.isVertexInViewRange(x, y, z) then
			if z < renderer.depthBuffer[y][x] then
				if yFractional == 0 then
					renderer.depthBuffer[y - 1][x] = z
					renderer.depthBuffer[y][x] = z
				else
					renderer.depthBuffer[y][x] = z
					if renderer.depthBuffer[y + 1] then
						renderer.depthBuffer[y + 1][x] = z
					end
				end

				index = buffer.getBufferIndexByCoordinates(x, yInteger)
				background = buffer.rawGet(index)
				buffer.rawSet(index, background, color, unicode.sub(text, i, i))
			end
		end
		x = x + 1
	end
end

-------------------------------------------------------- FPS counter overlay render --------------------------------------------------------

local function drawSegments(x, y, segments, color)
	for i = 1, #segments do
		if segments[i] == 1 then
			buffer.semiPixelSquare(x, y, 3, 1, color)
		elseif segments[i] == 2 then
			buffer.semiPixelSquare(x + 2, y, 1, 3, color)
		elseif segments[i] == 3 then
			buffer.semiPixelSquare(x + 2, y + 2, 1, 3, color)
		elseif segments[i] == 4 then
			buffer.semiPixelSquare(x, y + 4, 3, 1, color)
		elseif segments[i] == 5 then
			buffer.semiPixelSquare(x, y + 2, 1, 3, color)
		elseif segments[i] == 6 then
			buffer.semiPixelSquare(x, y, 1, 3, color)
		elseif segments[i] == 7 then
			buffer.semiPixelSquare(x, y + 2, 3, 1, color)
		else
			error("Ð§Ðµ Ð·Ð° Ð³Ð¾Ð²Ð½Ð¾ ÑÑ ÑÑÐ´Ð° Ð½Ð°Ð¿Ð¸ÑÐ°Ð»? ÐÐµÑÐµÐ´ÐµÐ»ÑÐ²Ð°Ð¹!")
		end
	end
end

function renderer.renderFPSCounter(x, y, renderMethod, color)
	local numbers = {
		["0"] = { 1, 2, 3, 4, 5, 6 },
		["1"] = { 2, 3 },
		["2"] = { 1, 2, 4, 5, 7 },
		["3"] = { 1, 2, 3, 4, 7 },
		["4"] = { 2, 3, 6, 7 },
		["5"] = { 1, 3, 4, 6, 7 },
		["6"] = { 1, 3, 4, 5, 6, 7 },
		["7"] = { 1, 2, 3 },
		["8"] = { 1, 2, 3, 4, 5, 6, 7 },
		["9"] = { 1, 2, 3, 4, 6, 7 },
	}

	-- clock sec - 1 frame
	-- 1 sec - x frames

	local oldClock = os.clock()
	renderMethod()
	local fps = tostring(math.ceil(1 / (os.clock() - oldClock) / 10))

	-- buffer.text(1, 1, 0xFFFFFF, "FPS: " .. os.clock() - oldClock)

	for i = 1, #fps do
		drawSegments(x, y, numbers[fps:sub(i, i)], color)
		x = x + 4
	end

	return x - 3
end



------------------------------------------------------------------------------------------------------------------------

return renderer

Dlib/PolyCatEngine/Flib/PolyCatEngine/Main.luaO=
-------------------------------------------------------- Libraries --------------------------------------------------------

local buffer = require("doubleBuffering")
local vector = require("vector")
local matrix = require("matrix")
local OCGL = require("OpenComputersGL/Main")
local renderer = require("OpenComputersGL/Renderer")
local materials = require("OpenComputersGL/Materials")
local postProcessing = require("PolyCatEngine/PostProcessing")
local polyCatEngine = {}

-------------------------------------------------------- Universal object methods --------------------------------------------------------

function polyCatEngine.newPivotPoint(vector3Position)
	return {
		position = vector3Position,
		axis = {
			vector.newVector3(1, 0, 0),
			vector.newVector3(0, 1, 0),
			vector.newVector3(0, 0, 1),
		}
	}
end

-------------------------------------------------------- Mesh object --------------------------------------------------------

local function pushMeshToRenderQueue(mesh)
	local vector3Vertex1, vector3Vertex2, vector3Vertex3
	for triangleIndex = 1, #mesh.triangles do
		vector3Vertex1, vector3Vertex2, vector3Vertex3 = mesh.vertices[mesh.triangles[triangleIndex][1]], mesh.vertices[mesh.triangles[triangleIndex][2]], mesh.vertices[mesh.triangles[triangleIndex][3]]
		OCGL.pushTriangleToRenderQueue(
			vector.newVector3(vector3Vertex1[1], vector3Vertex1[2], vector3Vertex1[3]),
			vector.newVector3(vector3Vertex2[1], vector3Vertex2[2], vector3Vertex2[3]),
			vector.newVector3(vector3Vertex3[1], vector3Vertex3[2], vector3Vertex3[3]),
			mesh.triangles[triangleIndex][4] or mesh.material,
			mesh,
			triangleIndex
		)
	end
end


function polyCatEngine.newMesh(vector3Position, vertices, triangles, material)
	local mesh = {}

	-- mesh.pivotPoint = polyCatEngine.newPivotPoint(vector3Position)
	mesh.vertices = vertices
	for vertexIndex = 1, #mesh.vertices do
		mesh.vertices[vertexIndex][1], mesh.vertices[vertexIndex][2], mesh.vertices[vertexIndex][3] = mesh.vertices[vertexIndex][1] + vector3Position[1], mesh.vertices[vertexIndex][2] + vector3Position[2], mesh.vertices[vertexIndex][3] + vector3Position[3]
	end
	mesh.triangles = triangles
	mesh.material = material
	mesh.pushToRenderQueue = pushMeshToRenderQueue

	return mesh
end

-------------------------------------------------------- Line object --------------------------------------------------------

local function pushLineToRenderQueue(line)
	OCGL.pushLineToRenderQueue(
		vector.newVector3(line.vertices[1][1], line.vertices[1][2], line.vertices[1][3]),
		vector.newVector3(line.vertices[2][1], line.vertices[2][2], line.vertices[2][3]),
		line.color
	)
end

function polyCatEngine.newLine(vector3Position, vector3Vertex1, vector3Vertex2, color)
	local line = {}

	-- line.pivotPoint = polyCatEngine.newPivotPoint(vector3Position)
	line.vertices = { vector3Vertex1, vector3Vertex2 }
	line.color = color
	line.pushToRenderQueue = pushLineToRenderQueue

	return line
end

-------------------------------------------------------- Floating text object --------------------------------------------------------

local function pushFloatingTextToRenderQueue(floatingText)
	OCGL.pushFloatingTextToRenderQueue(
		vector.newVector3(floatingText.position[1], floatingText.position[2], floatingText.position[3]),
		floatingText.text,
		floatingText.color
	)
end

function polyCatEngine.newFloatingText(vector3Position, color, text)
	local floatingText = {}

	floatingText.position = vector3Position
	floatingText.color = color
	floatingText.text = text
	floatingText.pushToRenderQueue = pushFloatingTextToRenderQueue

	return floatingText
end

-------------------------------------------------------- Plane object --------------------------------------------------------

function polyCatEngine.newPlane(vector3Position, width, height, material)
	local halfWidth, halfHeight = width / 2, height / 2
	return polyCatEngine.newMesh(
		vector3Position,
		{
			vector.newVector3(-halfWidth, 0, -halfHeight),
			vector.newVector3(-halfWidth, 0, halfHeight),
			vector.newVector3(halfWidth, 0, halfHeight),
			vector.newVector3(halfWidth, 0, -halfHeight),
		},
		{
			OCGL.newIndexedTriangle(1, 2, 3),
			OCGL.newIndexedTriangle(1, 4, 3)
		},
		material
	)
end

-------------------------------------------------------- Cube object --------------------------------------------------------

--[[
	|    /
	|  /
	y z
	  x -----

	FRONT		LEFT		BACK		RIGHT		TOP 		BOTTOM
	2######3	3######6	6######7	7######2	7######6	8######5
	########	########	########	########	########	########
	1######4	4######5	5######8	8######1	2######3	1######4
]]

function polyCatEngine.newCube(vector3Position, size, material)
	local halfSize = size / 2
	return polyCatEngine.newMesh(
		vector3Position,
		{
			-- (1-2-3-4)
			vector.newVector3(-halfSize, -halfSize, -halfSize),
			vector.newVector3(-halfSize, halfSize, -halfSize),
			vector.newVector3(halfSize, halfSize, -halfSize),
			vector.newVector3(halfSize, -halfSize, -halfSize),
			-- (5-6-7-8)
			vector.newVector3(halfSize, -halfSize, halfSize),
			vector.newVector3(halfSize, halfSize, halfSize),
			vector.newVector3(-halfSize, halfSize, halfSize),
			vector.newVector3(-halfSize, -halfSize, halfSize),
		},
		{
			-- Front
			OCGL.newIndexedTriangle(1, 2, 3),
			OCGL.newIndexedTriangle(1, 4, 3),
			-- Left
			OCGL.newIndexedTriangle(4, 3, 6),
			OCGL.newIndexedTriangle(4, 5, 6),
			-- Back
			OCGL.newIndexedTriangle(5, 6, 7),
			OCGL.newIndexedTriangle(5, 8, 7),
			-- Right
			OCGL.newIndexedTriangle(8, 7, 2),
			OCGL.newIndexedTriangle(8, 1, 2),
			-- Top
			OCGL.newIndexedTriangle(2, 7, 6),
			OCGL.newIndexedTriangle(2, 3, 6),
			-- Bottom
			OCGL.newIndexedTriangle(1, 8, 5),
			OCGL.newIndexedTriangle(1, 4, 5),
		},
		material
	)
end

-------------------------------------------------------- Grid lines --------------------------------------------------------

function polyCatEngine.newGridLines(vector3Position, axisRange, gridRange, gridRangeStep)
	local objects = {}
	-- Grid
	for x = -gridRange, gridRange, gridRangeStep do
		table.insert(objects, 1, polyCatEngine.newLine(
			vector.newVector3(vector3Position[1] + x, vector3Position[2], vector3Position[3]),
			vector.newVector3(0, 0, -gridRange),
			vector.newVector3(0, 0, gridRange),
			0x444444
		))
	end
	for z = -gridRange, gridRange, gridRangeStep do
		table.insert(objects, 1, polyCatEngine.newLine(
			vector.newVector3(vector3Position[1], vector3Position[2], vector3Position[3] + z),
			vector.newVector3(-gridRange, 0, 0),
			vector.newVector3(gridRange, 0, 0),
			0x444444
		))
	end

	-- Axis
	table.insert(objects, polyCatEngine.newLine(
		vector3Position,
		vector.newVector3(-axisRange, -1, 0),
		vector.newVector3(axisRange, -1, 0),
		renderer.colors.axis.x
	))
	table.insert(objects, polyCatEngine.newLine(
		vector3Position,
		vector.newVector3(0, -axisRange, 0),
		vector.newVector3(0, axisRange, 0),
		renderer.colors.axis.y
	))
	table.insert(objects, polyCatEngine.newLine(
		vector3Position,
		vector.newVector3(0, -1, -axisRange),
		vector.newVector3(0, -1, axisRange),
		renderer.colors.axis.z
	))

	return objects
end

-------------------------------------------------------- Camera object --------------------------------------------------------


local function cameraSetRotation(camera, axisXRotation, axisYRotation, axisZRotation)
	camera.rotation[1], camera.rotation[2], camera.rotation[3] = axisXRotation, axisYRotation, axisZRotation
	return camera
end

local function cameraRotate(camera, axisXAdditionalRotation, axisYAdditionalRotation, axisZAdditionalRotation)
	cameraSetRotation(camera, camera.rotation[1] + axisXAdditionalRotation, camera.rotation[2] + axisYAdditionalRotation, camera.rotation[3] + axisZAdditionalRotation)
	return camera
end

local function cameraLookAt(camera, xLook, yLook, zLook)
	local dx, dy, dz = xLook - camera.position[1], yLook - camera.position[2], zLook - camera.position[3]
	local rad180 = math.rad(180)

	local roty = math.atan(dx / dz)
	if dz < 0 then roty = roty + rad180 end
	
	local rotx = math.atan(math.sqrt(dx ^ 2 + dz ^ 2) / dy) - math.rad(90)
	if dy < 0 then rotx = rotx + rad180 end

	cameraSetRotation(camera, rotx, roty, 0)
end

local function cameraSetPosition(camera, x, y, z)
	camera.position[1], camera.position[2], camera.position[3] = x, y, z
	return camera
end

local function cameraTranslate(camera, xTranslation, yTranslation, zTranslation, xLookingAtTranslation, yLookingAtTranslation, zLookingAtTranslation)
	cameraSetPosition(camera, camera.position[1] + xTranslation, camera.position[2] + yTranslation, camera.position[3] + zTranslation)
	return camera
end

local function cameraSetFOV(camera, FOV)
	if FOV > 0 and FOV < math.pi then
		camera.FOV = FOV
		camera.projectionSurface = camera.farClippingSurface - camera.FOV / math.rad(180) * (camera.farClippingSurface - camera.nearClippingSurface)
	else
		error("FOV can't be < 0 or > 180 degrees")
	end
	-- ecs.error(camera.projectionSurface)
	return camera
end

function polyCatEngine.newCamera(vector3Position, FOV, nearClippingSurface, farClippingSurface)
	local camera = {}

	camera.projectionEnabled = true
	camera.position = vector3Position
	camera.rotation = {}
	camera.nearClippingSurface = nearClippingSurface
	camera.farClippingSurface = farClippingSurface
	camera.FOV = FOV

	camera.setPosition = cameraSetPosition
	camera.translate = cameraTranslate
	camera.rotate = cameraRotate
	camera.setRotation = cameraSetRotation
	camera.setFOV = cameraSetFOV
	camera.lookAt = cameraLookAt

	-- Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ ÑÐ¾ÑÐºÑ "Ð»ÑÐºÐ°" (Ð¸ Ð¼Ð°ÑÑÐ¸ÑÑ Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° ÐºÐ°Ð¼ÐµÑÑ), Ð° ÑÐ°ÐºÐ¶Ðµ ÐµÐµ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÑ Ð¿ÑÐ¾ÐµÐºÑÐ¸Ð¸ ÑÐµÑÐµÐ· Ð¤ÐÐ
	cameraSetRotation(camera, 0, 0, 0)
	cameraSetFOV(camera, camera.FOV)

	return camera
end

-------------------------------------------------------- Scene object --------------------------------------------------------

local function sceneAddObject(scene, object)
	table.insert(scene.objects, object)

	return object
end

local function sceneAddObjects(scene, objects)
	for objectIndex = 1, #objects do
		table.insert(scene.objects, objects[objectIndex])
	end

	return objects
end

local function sceneRender(scene)
	OCGL.setViewport( 1, 1, buffer.screen.width, buffer.screen.height * 2, scene.camera.nearClippingSurface, scene.camera.farClippingSurface, scene.camera.projectionSurface)
	OCGL.clearBuffer(scene.backgroundColor)

	for objectIndex = 1, #scene.objects do
		scene.objects[objectIndex]:pushToRenderQueue()
	end
	
	OCGL.translate(-scene.camera.position[1], -scene.camera.position[2], -scene.camera.position[3])
	OCGL.rotate(OCGL.axis.x, -scene.camera.rotation[1])
	OCGL.rotate(OCGL.axis.y, -scene.camera.rotation[2])
	OCGL.rotate(OCGL.axis.z, -scene.camera.rotation[3])
	
	if scene.camera.projectionEnabled then OCGL.createPerspectiveProjection() end
	OCGL.render(scene.renderMode)
	
	return scene
end

function polyCatEngine.newScene(backgroundColor)
	local scene = {}

	scene.renderMode = renderer.renderModes.material
	scene.backgroundColor = backgroundColor

	scene.objects = {}
	scene.addObject = sceneAddObject
	scene.addObjects = sceneAddObjects
	scene.render = sceneRender

	scene.camera = polyCatEngine.newCamera(vector.newVector3(0, 0, 0), math.rad(90), 1, 100)

	return scene
end

-- -------------------------------------------------------- Raycasting methods --------------------------------------------------------

-- local function vectorMultiply(a, b)
-- 	return vector.newVector3(a[2] * b[3] - a[3] * b[2], a[3] * b[1] - a[1] * b[3], a[1] * b[2] - a[2] * b[1])
-- end

-- local function getVectorDistance(a)
-- 	return math.sqrt(a[1] ^ 2 + a[2] ^ 2 + a[3] ^ 2)
-- end

-- -- Ð ÑÐ»ÑÑÐ°Ðµ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ð»ÑÑÐ¸ÐºÐ° ÑÑÐ¾Ñ Ð¼ÐµÑÐ¾Ð´ Ð²ÐµÑÐ½ÐµÑ ÑÐ°Ð¼ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº, Ð° ÑÐ°ÐºÐ¶Ðµ Ð´Ð¸ÑÑÐ°Ð½ÑÐ¸Ñ Ð´Ð¾ ÐµÐ³Ð¾ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÐ¸
-- function polyCatEngine.triangleRaycast(vector3RayStart, vector3RayEnd)
-- 	local minimalDistance, closestTriangleIndex
-- 	for triangleIndex = 1, #OCGL.triangles do
-- 		-- Ð­ÑÐ¾ Ð²ÐµÑÑÐ¸Ð½Ñ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°
-- 		local A, B, C = OCGL.vertices[OCGL.triangles[triangleIndex][1]], OCGL.vertices[OCGL.triangles[triangleIndex][3]], OCGL.vertices[OCGL.triangles[triangleIndex][3]]
-- 		-- Ð­ÑÐ¾ ÑÐ· ÑÐµ
-- 		local ABC = vectorMultiply(vector.newVector3(C[1] - A[1], C[2] - A[2], C[3] - A[3]), vector.newVector3(B[1] - A[1], B[2] - A[2], B[3] - A[3]))
-- 		-- Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ´Ð°Ð»ÐµÐ½Ð½Ð¾ÑÑÑ Ð²Ð¸ÑÑÑÐ°Ð»ÑÐ½Ð¾Ð¹ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÐ¸ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ° Ð¾Ñ ÑÑÐ°ÑÑÐ° Ð½Ð°ÑÐµÐ³Ð¾ Ð»ÑÑÐ°
-- 		local D = -ABC[1] * A[1] - ABC[2] * A[2] - ABC[3] * A[3]
-- 		local firstPart = D + ABC[1] * vector3RayStart[1] + ABC[2] * vector3RayStart[2] + ABC[3] * vector3RayStart[3]
-- 		local secondPart = ABC[1] * vector3RayStart[1] - ABC[1] * vector3RayEnd[1] + ABC[2] * vector3RayStart[2] - ABC[2] * vector3RayEnd[2] + ABC[3] * vector3RayStart[3] - ABC[3] * vector3RayEnd[3]
		
-- 		-- ÐÑÐ»Ð¸ Ð½Ð°Ñ Ð»ÑÑÐ¸Ðº Ð½Ðµ Ð¿Ð°ÑÐ°Ð»Ð»ÐµÐ»ÐµÐ½ ÑÐ¾Ð¹ ÐµÐ±ÑÑÐµÐ¹ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÐ¸ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°
-- 		if secondPart ~= 0 then
-- 			local distance = firstPart / secondPart
-- 			-- Ð ÐµÑÐ»Ð¸ ÑÑÐ¾Ñ Ð¾Ð±ÑÐµÐºÑ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð±Ð»Ð¸Ð¶Ðµ Ðº ÑÑÐ°ÑÑÑ Ð»ÑÑÐ°, Ð½ÐµÐ¶ÐµÐ»Ð¸ Ð¿ÑÐµÐ´ÑÐ´ÑÑÐ¸Ð¹
-- 			if (distance >= 0 and distance <= 1) and (not minimalDistance or distance < minimalDistance) then
	
-- 				-- Ð¢Ð¾ ÑÑÐ¸ÑÐ°ÐµÐ¼ ÑÐ¾ÑÐºÑ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ñ Ð»ÑÑÐ° Ð² Ð´Ð°Ð½Ð½ÑÑ Ð¿Ð»Ð¾ÑÐºÐ¾ÑÑÑ (Ð½Ð¾ Ð½Ð¸ ÑÑÑ Ð½Ðµ ÑÐ°ÐºÑ, ÑÑÐ¾ Ð¾Ð½ Ð¿Ð¾Ð¿Ð°Ð´ÐµÑ Ð² ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº!)
-- 				local S = vector.newVector3(
-- 					vector3RayStart[1] + (vector3RayEnd[1] - vector3RayStart[1]) * distance,
-- 					vector3RayStart[2] + (vector3RayEnd[2] - vector3RayStart[2]) * distance,
-- 					vector3RayStart[3] + (vector3RayEnd[3] - vector3RayStart[3]) * distance
-- 				)

-- 				-- ÐÐ°Ð»ÐµÐµ ÑÑÐ¸ÑÐ°ÐµÐ¼ ÑÑÐ¼Ð¼Ñ Ð¿Ð»Ð¾ÑÐ°Ð´ÐµÐ¹ Ð¿Ð°ÑÐ°Ð»Ð»ÐµÐ»Ð¾Ð³ÑÐ°Ð¼Ð¼Ð¾Ð², Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð½ÑÑ ÑÑÐµÐ¼Ñ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°Ð¼Ð¸, Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°Ð²ÑÐ¸ÑÑÑ Ð¿ÑÐ¸ Ð¿Ð¾Ð¿Ð°Ð´Ð°Ð½Ð¸Ð¸ ÑÐ¾ÑÐºÐ¸ Ð² ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº
-- 				-- ÐÑÑÑ ÑÐ¸Ð¿ ÐºÐ°ÑÐ¾Ñ ÑÐ¼Ð°ÑÐ¸: ÑÐ¾ÑÐºÐ° ÐµÐ±Ð°Ð½ÑÐ»Ð° Ð² ÑÐµÐ½ÑÑ, Ð¸ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº ÑÐ°ÑÐ¿Ð¸Ð´Ð¾ÑÐ°ÑÐ¸Ð»Ð¾ Ð½Ð° ÑÑÐ¸ Ð¼ÐµÐ»ÐºÐ¸Ñ. ÐÑ, Ð¸ ÑÑÐ¸ Ð¼ÐµÐ»ÐºÐ¸Ñ Ð¼Ð¾Ð³ÑÑ Ð¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°ÑÑ Ð¿Ð°ÑÐ°Ð»Ð»ÐµÐ»Ð¾Ð³ÑÐ°Ð¼Ð¼Ñ ÑÐ²Ð¾Ð¸
-- 				-- Ð, ÐºÐ°ÑÐ¾Ñ, ÐµÑÐ»Ð¸ ÑÑÐ¼Ð¼Ð° ÑÑÐµÑ Ð¿Ð»Ð¾ÑÐ°Ð´ÐµÐ¹ ÑÑÐ¸Ñ Ð¼ÐµÐ»ÐºÐ¸Ñ ÑÐµÐ±ÐºÐ¾Ð² Ð±ÑÐ´ÐµÑ ÑÐ¸Ð»ÑÐ½Ð¾ Ð¾ÑÐ»Ð¸ÑÐ°ÑÑÑÑ Ð¾Ñ Ð¿Ð»Ð¾ÑÐ°Ð´Ð¸ Ð¶Ð¸ÑÐ½Ð¾Ð³Ð¾ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸ÐºÐ°, ÑÐ¾ Ð»ÑÑ Ð½Ðµ Ð¿Ð¾Ð¿Ð°Ð»
-- 				-- ÐÑ, Ð° Ð¿Ð»Ð¾ÑÐ°Ð´Ñ ÑÑÐ¸ÑÐ°ÐµÑÑÑ ÑÐµÑÐµÐ· sqrt(x^2+y^2+z^2) Ð´Ð»Ñ ÐºÐ°Ð¶Ð´Ð¾Ð³Ð¾ Ð¹Ð¾Ð±Ð°-Ð²ÐµÐºÑÐ¾ÑÐ°

-- 				---- *A                      *B


-- 				--                  * Shotxyz


-- 				---                   *C

-- 				local SA = vector.newVector3(A[1] - S[1], A[2] - S[2], A[3] - S[3])
-- 				local SB = vector.newVector3(B[1] - S[1], B[2] - S[2], B[3] - S[3])
-- 				local SC = vector.newVector3(C[1] - S[1], C[2] - S[2], C[3] - S[3])
			
-- 				local vectorDistanceSum = getVectorDistance(vectorMultiply(SA, SB)) + getVectorDistance(vectorMultiply(SB, SC)) + getVectorDistance(vectorMultiply(SC, SA))
-- 				local ABCDistance = getVectorDistance(ABC)

-- 				-- ÐÐ¾Ñ ÑÑÑ Ð¼Ñ ÑÐµÐºÐ°ÐµÐ¼ Ð¿Ð¾Ð³ÑÐµÑÐ½Ð¾ÑÑÑ ÑÐ°ÑÑÐµÑÐ¾Ð². ÐÑÐ»Ð¸ Ð²ÑÐµ Ð·Ð°ÐµÐ±Ð¾Ðº, ÑÐ¾ ÐºÐ¸Ð´Ð°ÐµÐ¼ ÑÑÐ¾Ñ ÑÑÐµÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº Ð² "Ð¿ÑÐ¾Ð²ÐµÑÐµÐ½Ð½ÑÐµ""
-- 				if math.abs(vectorDistanceSum - ABCDistance) < 1 then
-- 					closestTriangleIndex = triangleIndex
-- 					minimalDistance = distance
-- 				end
-- 			end 
-- 		end
-- 	end

-- 	-- ecs.error(closestTriangleIndex)
-- 	return closestTriangleIndex, minimalDistance
-- end

-- -- function polyCatEngine.sceneRaycast(scene, vector3RayStart, vector3RayEnd)
-- -- 	local closestObjectIndex, closestTriangleIndex, minimalDistance
	
-- -- 	for objectIndex = 1, #scene.objects do
-- -- 		if scene.objects[objectIndex].triangles then
-- -- 			local triangleIndex, distance = polyCatEngine.meshRaycast(scene.objects[objectIndex], vector3RayStart, vector3RayEnd)
-- -- 			if triangleIndex and (not minimalDistance or distance < minimalDistance ) then
-- -- 				closestObjectIndex, closestTriangleIndex, minimalDistance = objectIndex, triangleIndex, distance
-- -- 			end
-- -- 		end
-- -- 	end

-- -- 	return closestObjectIndex, closestTriangleIndex, minimalDistance
-- -- end

-------------------------------------------------------- Intro --------------------------------------------------------

function polyCatEngine.newPolyCatMesh(vector3Position, size)
	return polyCatEngine.newMesh(
		vector3Position,
		{
			vector.newVector3(-1.0 * size, 0.8 * size, 0.3 * size),
			vector.newVector3(-0.5 * size, 0.5 * size, 0.3 * size),
			vector.newVector3(0.0 * size, 0.5 * size, 0.3 * size),
			vector.newVector3(0.5 * size, 0.5 * size, 0.3 * size),
			vector.newVector3(1.0 * size, 0.8 * size, 0.3 * size),
			vector.newVector3(0.8 * size, 0.2 * size, 0.3 * size),
			vector.newVector3(0.7 * size, -0.3 * size, 0.3 * size),
			vector.newVector3(0.0 * size, -0.8 * size, 0.3 * size),
			vector.newVector3(-0.7 * size, -0.3 * size, 0.3 * size),
			vector.newVector3(-0.8 * size, 0.2 * size, 0.3 * size),
			vector.newVector3(-0.2 * size, -0.1 * size, 0.0 * size),
			vector.newVector3(0.2 * size, -0.1 * size, 0.0 * size),
			vector.newVector3(0.0 * size, -0.3 * size, 0.0 * size)
		},
		{
			OCGL.newIndexedTriangle(1, 2, 10, materials.newSolidMaterial(0x555555)),
			OCGL.newIndexedTriangle(2, 11, 10, materials.newSolidMaterial(0x6fe7fc)),
			OCGL.newIndexedTriangle(2, 3, 11, materials.newSolidMaterial(0xDDDDDD)),
			OCGL.newIndexedTriangle(3, 12, 11, materials.newSolidMaterial(0xDDDDDD)),
			OCGL.newIndexedTriangle(3, 4, 12, materials.newSolidMaterial(0xDDDDDD)),
			OCGL.newIndexedTriangle(4, 6, 12, materials.newSolidMaterial(0xa8f1fd)),
			OCGL.newIndexedTriangle(4, 5, 6, materials.newSolidMaterial(0x808080)),
			
			OCGL.newIndexedTriangle(6, 7, 8, materials.newSolidMaterial(0xCCCCCC)),
			OCGL.newIndexedTriangle(12, 6, 8, materials.newSolidMaterial(0xCCCCCC)),
			OCGL.newIndexedTriangle(13, 12, 8, materials.newSolidMaterial(0xCCCCCC)),
			
			OCGL.newIndexedTriangle(11, 12, 13, materials.newSolidMaterial(0x555555)),
			OCGL.newIndexedTriangle(11, 13, 8, materials.newSolidMaterial(0xBBBBBB)),
			OCGL.newIndexedTriangle(10, 11, 8, materials.newSolidMaterial(0xBBBBBB)),
			OCGL.newIndexedTriangle(10, 8, 9, materials.newSolidMaterial(0xBBBBBB))
		},
		materials.newSolidMaterial(0xFF0000)
	)
end

function polyCatEngine.intro(vector3Position, size)
	local GUI = require("GUI")
	local scene = polyCatEngine.newScene(0xEEEEEE)
	scene:addObject(polyCatEngine.newPolyCatMesh(vector3Position, size))
	scene:addObject(polyCatEngine.newFloatingText(vector.newVector3(vector3Position[1] + 2, vector3Position[2] - size, vector3Position[3] + size * 0.1), 0xBBBBBB, "Powered by PolyCat Engineâ¢"))

	local from, to, speed = -30, 20, 4
	local transparency, transparencyStep = 0, 100 / math.abs(to - from) * speed

	scene.camera:setPosition(from, 0, -32)
	while scene.camera.position[1] < to do
		scene.camera:translate(speed, 0, 0)
		scene.camera:lookAt(0, 0, 0)
		scene:render()
		local lines = {
			"Copyright Â© 2016-2017 - Developed by ECS, Harch and Pirnogion",
			"All rights reserved",
		}
		GUI.textBox(1, buffer.screen.height - #lines, buffer.screen.width, #lines, nil, 0xBBBBBB, lines, 1):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top):draw()
		if scene.camera.position[1] < to then buffer.clear(0x0, transparency) end
		buffer.draw()

		transparency = transparency + transparencyStep
		-- ecs.error("POS: " .. scene.camera.position[1] .. ", " .. scene.camera.position[2] .. ", " .. scene.camera.position[3] .. ", ROT: " .. math.deg(scene.camera.rotation[1]) .. ", " .. math.deg(scene.camera.rotation[2]) .. ", " .. math.deg(scene.camera.rotation[3]))
		os.sleep(0.01)
	end

	os.sleep(2)

	for i = 100, 0, -20 do
		scene:render()
		buffer.clear(0x0, i)
		buffer.draw()
	end
end

-------------------------------------------------------- Zalupa --------------------------------------------------------

return polyCatEngine
F$lib/PolyCatEngine/PostProcessing.lua
-------------------------------------------------------- Libraries --------------------------------------------------------

local buffer = require("doubleBuffering")
local postProcessing = {}

-------------------------------------------------------- Plane object --------------------------------------------------------

function postProcessing.photofilter(color, transparency)
	buffer.clear(color, transparency)
end

function postProcessing.fadePhotifilter(color, fromTransparency, toTransparency, step)
	for i = fromTransparency, toTransparency, fromTransparency < toTransparency and step or -step do
		postProcessing.photofilter(color, i)
	end
end

-------------------------------------------------------- Zalupa --------------------------------------------------------

return postProcessing
Flib/SHA2.luaÀ-- SHA-256 code in Lua 5.2; based on the pseudo-code from
-- Wikipedia (http://en.wikipedia.org/wiki/SHA-2)


local band, rrotate, bxor, rshift, bnot =
  bit32.band, bit32.rrotate, bit32.bxor, bit32.rshift, bit32.bnot

local string, setmetatable, assert = string, setmetatable, assert

_ENV = nil

-- Initialize table of round constants
-- (first 32 bits of the fractional parts of the cube roots of the first
-- 64 primes 2..311):
local k = {
   0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
   0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
   0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
   0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
   0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
   0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
   0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
   0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
   0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
   0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
   0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
   0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
   0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
   0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
   0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
   0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
}


-- transform a string of bytes in a string of hexadecimal digits
local function str2hexa (s)
  local h = string.gsub(s, ".", function(c)
              return string.format("%02x", string.byte(c))
            end)
  return h
end


-- transform number 'l' in a big-endian sequence of 'n' bytes
-- (coded as a string)
local function num2s (l, n)
  local s = ""
  for i = 1, n do
    local rem = l % 256
    s = string.char(rem) .. s
    l = (l - rem) / 256
  end
  return s
end

-- transform the big-endian sequence of four bytes starting at
-- index 'i' in 's' into a number
local function s232num (s, i)
  local n = 0
  for i = i, i + 3 do
    n = n*256 + string.byte(s, i)
  end
  return n
end


-- append the bit '1' to the message
-- append k bits '0', where k is the minimum number >= 0 such that the
-- resulting message length (in bits) is congruent to 448 (mod 512)
-- append length of message (before pre-processing), in bits, as 64-bit
-- big-endian integer
local function preproc (msg, len)
  local extra = -(len + 1 + 8) % 64
  len = num2s(8 * len, 8)    -- original len in bits, coded
  msg = msg .. "\128" .. string.rep("\0", extra) .. len
  assert(#msg % 64 == 0)
  return msg
end


local function initH224 (H)
  -- (second 32 bits of the fractional parts of the square roots of the
  -- 9th through 16th primes 23..53)
  H[1] = 0xc1059ed8
  H[2] = 0x367cd507
  H[3] = 0x3070dd17
  H[4] = 0xf70e5939
  H[5] = 0xffc00b31
  H[6] = 0x68581511
  H[7] = 0x64f98fa7
  H[8] = 0xbefa4fa4
  return H
end


local function initH256 (H)
  -- (first 32 bits of the fractional parts of the square roots of the
  -- first 8 primes 2..19):
  H[1] = 0x6a09e667
  H[2] = 0xbb67ae85
  H[3] = 0x3c6ef372
  H[4] = 0xa54ff53a
  H[5] = 0x510e527f
  H[6] = 0x9b05688c
  H[7] = 0x1f83d9ab
  H[8] = 0x5be0cd19
  return H
end


local function digestblock (msg, i, H)

    -- break chunk into sixteen 32-bit big-endian words w[1..16]
    local w = {}
    for j = 1, 16 do
      w[j] = s232num(msg, i + (j - 1)*4)
    end

    -- Extend the sixteen 32-bit words into sixty-four 32-bit words:
    for j = 17, 64 do
      local v = w[j - 15]
      local s0 = bxor(rrotate(v, 7), rrotate(v, 18), rshift(v, 3))
      v = w[j - 2]
      local s1 = bxor(rrotate(v, 17), rrotate(v, 19), rshift(v, 10))
      w[j] = w[j - 16] + s0 + w[j - 7] + s1
    end

    -- Initialize hash value for this chunk:
    local a, b, c, d, e, f, g, h =
        H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]

    -- Main loop:
    for i = 1, 64 do
      local s0 = bxor(rrotate(a, 2), rrotate(a, 13), rrotate(a, 22))
      local maj = bxor(band(a, b), band(a, c), band(b, c))
      local t2 = s0 + maj
      local s1 = bxor(rrotate(e, 6), rrotate(e, 11), rrotate(e, 25))
      local ch = bxor (band(e, f), band(bnot(e), g))
      local t1 = h + s1 + ch + k[i] + w[i]

      h = g
      g = f
      f = e
      e = d + t1
      d = c
      c = b
      b = a
      a = t1 + t2
    end

    -- Add (mod 2^32) this chunk's hash to result so far:
    H[1] = band(H[1] + a)
    H[2] = band(H[2] + b)
    H[3] = band(H[3] + c)
    H[4] = band(H[4] + d)
    H[5] = band(H[5] + e)
    H[6] = band(H[6] + f)
    H[7] = band(H[7] + g)
    H[8] = band(H[8] + h)

end


local function finalresult224 (H)
  -- Produce the final hash value (big-endian):
  return
    str2hexa(num2s(H[1], 4)..num2s(H[2], 4)..num2s(H[3], 4)..num2s(H[4], 4)..
             num2s(H[5], 4)..num2s(H[6], 4)..num2s(H[7], 4))
end


local function finalresult256 (H)
  -- Produce the final hash value (big-endian):
  return
    str2hexa(num2s(H[1], 4)..num2s(H[2], 4)..num2s(H[3], 4)..num2s(H[4], 4)..
             num2s(H[5], 4)..num2s(H[6], 4)..num2s(H[7], 4)..num2s(H[8], 4))
end


----------------------------------------------------------------------
local HH = {}    -- to reuse

local function hash224 (msg)
  msg = preproc(msg, #msg)
  local H = initH224(HH)

  -- Process the message in successive 512-bit (64 bytes) chunks:
  for i = 1, #msg, 64 do
    digestblock(msg, i, H)
  end

  return finalresult224(H)
end


local function hash256 (msg)
  msg = preproc(msg, #msg)
  local H = initH256(HH)

  -- Process the message in successive 512-bit (64 bytes) chunks:
  for i = 1, #msg, 64 do
    digestblock(msg, i, H)
  end

  return finalresult256(H)
end
----------------------------------------------------------------------
-- local mt = {}

-- local function new256 ()
--   local o = {H = initH256({}), msg = "", len = 0}
--   setmetatable(o, mt)
--   return o
-- end

-- mt.__index = mt

-- function mt:add (m)
--   self.msg = self.msg .. m
--   self.len = self.len + #m
--   local t = 0
--   while #self.msg - t >= 64 do
--     digestblock(self.msg, t + 1, self.H)
--     t = t + 64 
--   end
--   self.msg = self.msg:sub(t + 1, -1)
-- end


-- function mt:close ()
--   self.msg = preproc(self.msg, self.len)
--   self:add("")
--   return finalresult256(self.H)
-- end
----------------------------------------------------------------------

return {
  hash = hash256
  -- hash256 = hash256,
  -- hash224 = hash224,
  -- new256 = new256,
}Flib/advancedLua.lua*
--[[
	
	Advanced Lua Library v1.1 by ECS

	This library extends a lot of default Lua methods
	and adds some really cool features that haven't been
	implemented yet, such as fastest table serialization,
	table binary searching, string wrapping, numbers rounding, etc.

]]

local filesystem = require("filesystem")
local unicode = require("unicode")
local bit32 = require("bit32")

-------------------------------------------------- System extensions --------------------------------------------------

function _G.getCurrentScript()
	local info
	for runLevel = 0, math.huge do
		info = debug.getinfo(runLevel)
		if info then
			if info.what == "main" then
				return info.source:sub(2, -1)
			end
		else
			error("Failed to get debug info for runlevel " .. runLevel)
		end
	end
end

function enum(...)
	local args, enums = {...}, {}
	for i = 1, #args do
		if type(args[i]) ~= "string" then error("Function argument " .. i .. " have non-string type: " .. type(args[i])) end
		enums[args[i]] = i
	end
	return enums
end

function swap(a, b)
	return b, a
end

-------------------------------------------------- Bit32 extensions --------------------------------------------------

function bit32.numberToByteArray(number)
	local byteArray = {}
	while number > 0 do
		table.insert(byteArray, 1, bit32.band(number, 0xFF))
		number = bit32.rshift(number, 8)
	end
	return byteArray
end

function bit32.byteArrayToNumber(byteArray)
	local number = byteArray[1]
	for i = 2, #byteArray do
		number = bit32.bor(byteArray[i], bit32.lshift(number, 8))
	end
	return number
end

function bit32.bitArrayToByte(bitArray)
	local number = 0
	for i = 1, #bitArray do
		number = bit32.bor(bitArray[i], bit32.lshift(number, 1))
	end
	return number
end

bit32.byteArrayFromNumber = bit32.numberToByteArray
bit32.numberFromByteArray = bit32.byteArrayToNumber

-------------------------------------------------- Math extensions --------------------------------------------------

function math.round(num) 
	if num >= 0 then
		return math.floor(num + 0.5)
	else
		return math.ceil(num - 0.5)
	end
end

function math.roundToDecimalPlaces(num, decimalPlaces)
	local mult = 10 ^ (decimalPlaces or 0)
	return math.floor(num * mult + 0.5) / mult
end

function math.getDigitCount(num)
	return num == 0 and 1 or math.ceil(math.log(num + 1, 10))
end

function math.doubleToString(num, digitCount)
	return string.format("%." .. (digitCount or 1) .. "f", num)
end

function math.shortenNumber(number, digitCount)
	local shortcuts = {
		"K",
		"M",
		"B",
		"T"
	}

	local index = math.floor(math.log(number, 1000))
	if number < 1000 then
		return number
	elseif index > #shortcuts then
		index = #shortcuts
	end

	return math.roundToDecimalPlaces(number / 1000 ^ index, digitCount) .. shortcuts[index]
end

-------------------------------------------------- Table extensions --------------------------------------------------

local function doSerialize(array, prettyLook, indentationSymbol, indentationSymbolAdder, equalsSymbol, currentRecusrionStack, recursionStackLimit)
	local text, keyType, valueType, stringValue = {"{"}
	table.insert(text, (prettyLook and "\n" or nil))
	
	for key, value in pairs(array) do
		keyType, valueType, stringValue = type(key), type(value), tostring(value)

		if keyType == "number" or keyType == "string" then
			table.insert(text, (prettyLook and table.concat({indentationSymbol, indentationSymbolAdder}) or nil))
			table.insert(text, "[")
			table.insert(text, (keyType == "string" and table.concat({"\"", key, "\""}) or key))
			table.insert(text, "]")
			table.insert(text, equalsSymbol)
			
			if valueType == "number" or valueType == "boolean" or valueType == "nil" then
				table.insert(text, stringValue)
			elseif valueType == "string" or valueType == "function" then
				table.insert(text, "\"")
				table.insert(text, stringValue)
				table.insert(text, "\"")
			elseif valueType == "table" then
				-- ÐÐ³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ðµ ÑÑÐµÐºÐ° ÑÐµÐºÑÑÑÐ¸Ð¸
				if currentRecusrionStack < recursionStackLimit then
					table.insert(text, table.concat(doSerialize(value, prettyLook, table.concat({indentationSymbol, indentationSymbolAdder}), indentationSymbolAdder, equalsSymbol, currentRecusrionStack + 1, recursionStackLimit)))
				else
					table.insert(text, "...")
				end
			end
			
			table.insert(text, ",")
			table.insert(text, (prettyLook and "\n" or nil))
		end
	end

	-- Ð£Ð´Ð°Ð»ÑÐµÐ¼ Ð·Ð°Ð¿ÑÑÑÑ
	if prettyLook then
		if #text > 2 then
			table.remove(text, #text - 1)
		end
		-- ÐÑÑÐ°Ð²Ð»ÑÐµÐ¼ Ð·Ð°Ð¾Ð´Ð½Ð¾ ÑÐ¶ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð¸Ð½Ð´ÐµÐ½ÑÐ°ÑÐ¸Ð¸, Ð±Ð»Ð°Ð³Ð¾ ÑÐµÐº Ð½Ð° Ð¿ÑÐ¸ÑÑÐ¸ Ð»ÑÐº Ð¸Ð´ÐµÑ
		table.insert(text, indentationSymbol)
	else
		if #text > 1 then
			table.remove(text, #text)
		end
	end

	table.insert(text, "}")

	return text
end

function table.serialize(array, prettyLook, indentationWidth, indentUsingTabs, recursionStackLimit)
	checkArg(1, array, "table")
	return table.concat(
		doSerialize(
			array,
			prettyLook,
			"",
			string.rep(indentUsingTabs and "	" or " ", indentationWidth or 2),
			prettyLook and " = " or "=",
			1,
			recursionStackLimit or math.huge
		)
	)
end

function table.unserialize(serializedString)
	checkArg(1, serializedString, "string")
	local success, result = pcall(load("return " .. serializedString))
	if success then return result else return nil, result end
end

table.toString = table.serialize
table.fromString = table.unserialize

function table.toFile(path, array, prettyLook, indentationWidth, indentUsingTabs, recursionStackLimit, appendToFile)
	checkArg(1, path, "string")
	checkArg(2, array, "table")
	filesystem.makeDirectory(filesystem.path(path) or "")
	local file = io.open(path, appendToFile and "a" or "w")
	file:write(table.serialize(array, prettyLook, indentationWidth, indentUsingTabs, recursionStackLimit))
	file:close()
end

function table.fromFile(path)
	checkArg(1, path, "string")
	if filesystem.exists(path) then
		if filesystem.isDirectory(path) then
			error("\"" .. path .. "\" is a directory")
		else
			local file = io.open(path, "r")
			local data = table.unserialize(file:read("*a"))
			file:close()
			return data
		end
	else
		error("\"" .. path .. "\" doesn't exists")
	end
end

function table.copy(tableToCopy)
	local function recursiveCopy(source, destination)
		for key, value in pairs(source) do
			if type(value) == "table" then
				destination[key] = {}
				recursiveCopy(source[key], destination[key])
			else
				destination[key] = value
			end
		end
	end

	local tableThatCopied = {}
	recursiveCopy(tableToCopy, tableThatCopied)

	return tableThatCopied
end

function table.binarySearch(t, requestedValue)
	local function recursiveSearch(startIndex, endIndex)
		local difference = endIndex - startIndex
		local centerIndex = math.floor(difference / 2 + startIndex)

		if difference > 1 then
			if requestedValue >= t[centerIndex] then
				return recursiveSearch(centerIndex, endIndex)
			else
				return recursiveSearch(startIndex, centerIndex)
			end
		else
			if math.abs(requestedValue - t[startIndex]) > math.abs(t[endIndex] - requestedValue) then
				return t[endIndex]
			else
				return t[startIndex]
			end
		end
	end

	return recursiveSearch(1, #t)
end

function table.size(t)
	local size = #t
	if size == 0 then for key in pairs(t) do size = size + 1 end end
	return size
end

-------------------------------------------------- String extensions --------------------------------------------------

function string.canonicalPath(str)
	return string.gsub("/" .. str, "%/+", "/")
end

function string.optimize(str, indentationWidth)
	str = string.gsub(str, "\r\n", "\n")
	str = string.gsub(str, "	", string.rep(" ", indentationWidth or 2))
	return str
end

function string.optimizeForURLRequests(code)
	if code then
		code = string.gsub(code, "([^%w ])", function (c)
			return string.format("%%%02X", string.byte(c))
		end)
		code = string.gsub(code, " ", "+")
	end
	return code 
end

function string.unicodeFind(str, pattern, init, plain)
	if init then
		if init < 0 then
			init = -#unicode.sub(str,init)
		elseif init > 0 then
			init = #unicode.sub(str, 1, init - 1) + 1
		end
	end
	
	a, b = string.find(str, pattern, init, plain)
	
	if a then
		local ap, bp = str:sub(1, a - 1), str:sub(a,b)
		a = unicode.len(ap) + 1
		b = a + unicode.len(bp) - 1
		return a, b
	else
		return a
	end
end

function string.limit(text, size, fromLeft, noDots)
	local length = unicode.len(text)
	if length <= size then return text end

	if fromLeft then
		if noDots then
			return unicode.sub(text, length - size + 1, -1)
		else
			return "â¦" .. unicode.sub(text, length - size + 2, -1)
		end
	else
		if noDots then
			return unicode.sub(text, 1, size)
		else
			return unicode.sub(text, 1, size - 1) .. "â¦"
		end
	end
end

function string.wrap(strings, limit)
	strings = type(strings) == "string" and {strings} or strings

	local currentString = 1
	while currentString <= #strings do
		local words = {}; for word in string.gmatch(tostring(strings[currentString]), "[^%s]+") do table.insert(words, word) end

		local newStringThatFormedFromWords, oldStringThatFormedFromWords = "", ""
		local word = 1
		local overflow = false
		while word <= #words do
			oldStringThatFormedFromWords = oldStringThatFormedFromWords .. (word > 1 and " " or "") .. words[word]
			if unicode.len(oldStringThatFormedFromWords) > limit then
				if unicode.len(words[word]) > limit then
					local left = unicode.sub(oldStringThatFormedFromWords, 1, limit)
					local right = unicode.sub(strings[currentString], unicode.len(left) + 1, -1)
					overflow = true
					strings[currentString] = left
					if strings[currentString + 1] then
						strings[currentString + 1] = right .. " " .. strings[currentString + 1]
					else
						strings[currentString + 1] = right
					end 
				end
				break
			else
				newStringThatFormedFromWords = oldStringThatFormedFromWords
			end
			word = word + 1
		end

		if word <= #words and not overflow then
			local fuckToAdd = table.concat(words, " ", word, #words)
			if strings[currentString + 1] then
				strings[currentString + 1] = fuckToAdd .. " " .. strings[currentString + 1]
			else
				strings[currentString + 1] = fuckToAdd
			end
			strings[currentString] = newStringThatFormedFromWords
		end

		currentString = currentString + 1
	end

	return strings
end

-------------------------------------------------- Playground --------------------------------------------------

-- local t =  {
-- 	abc = 123,
-- 	def = {
-- 		cyka = "pidor",
-- 		vagina = {
-- 			chlen = 555,
-- 			devil = 666,
-- 			god = 777,
-- 			serost = {
-- 				tripleTable = "aefaef",
-- 				aaa = "bbb",
-- 				ccc = 123,
-- 			}
-- 		}
-- 	},
-- 	ghi = "HEHE",
-- 	emptyTable = {},
-- }

-- print(table.toString(t, true))

------------------------------------------------------------------------------------------------------------------

return {loaded = true}


Flib/bigLetters.lua)Ò
local unicode = require("unicode")
local buffer = require("doubleBuffering")
local bigLetters = {}

local pixelHeight = 5
local lettersInterval = 2
local unknownSymbol = "*"
local spaceWidth = 2

local letters = {
  ["0"] = {
    { 1, 1, 1 },
    { 1, 0, 1 },
    { 1, 0, 1 },
    { 1, 0, 1 },
    { 1, 1, 1 },
  },
  ["1"] = {
    { 0, 1, 0 },
    { 1, 1, 0 },
    { 0, 1, 0 },
    { 0, 1, 0 },
    { 1, 1, 1 },
  },
  ["2"] = {
    { 1, 1, 1 },
    { 0, 0, 1 },
    { 1, 1, 1 },
    { 1, 0, 0 },
    { 1, 1, 1 },
  },
  ["3"] = {
    { 1, 1, 1 },
    { 0, 0, 1 },
    { 1, 1, 1 },
    { 0, 0, 1 },
    { 1, 1, 1 },
  },
  ["4"] = {
    { 1, 0, 1 },
    { 1, 0, 1 },
    { 1, 1, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
  },
  ["5"] = {
    { 1, 1, 1 },
    { 1, 0, 0 },
    { 1, 1, 1 },
    { 0, 0, 1 },
    { 1, 1, 1 },
  },
  ["6"] = {
    { 1, 1, 1 },
    { 1, 0, 0 },
    { 1, 1, 1 },
    { 1, 0, 1 },
    { 1, 1, 1 },
  },
  ["7"] = {
    { 1, 1, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
  },
  ["8"] = {
    { 1, 1, 1 },
    { 1, 0, 1 },
    { 1, 1, 1 },
    { 1, 0, 1 },
    { 1, 1, 1 },
  },
  ["9"] = {
    { 1, 1, 1 },
    { 1, 0, 1 },
    { 1, 1, 1 },
    { 0, 0, 1 },
    { 1, 1, 1 },
  },




  ["a"] = {
    { 0, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
  },
  ["b"] = {
    { 1, 1, 1, 0},
    { 1, 0, 0, 1},
    { 1, 1, 1, 0},
    { 1, 0, 0, 1},
    { 1, 1, 1, 1},
  },
  ["c"] = {
    { 0, 1, 1, 1 },
    { 1, 0, 0, 0 },
    { 1, 0, 0, 0 },
    { 1, 0, 0, 0 },
    { 0, 1, 1, 1 },
  },
  ["d"] = {
    { 1, 1, 1, 1, 0 },
    { 0, 1, 0, 0, 1 },
    { 0, 1, 0, 0, 1 },
    { 0, 1, 0, 0, 1 },
    { 1, 1, 1, 1, 0 },
  },
  ["e"] = {
    { 1, 1, 1, 1 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 1 },
  },
  ["f"] = {
    { 1, 1, 1, 1 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 0 },
    { 1, 0, 0, 0 },
  },
  ["g"] = {
    { 0, 1, 1, 1},
    { 1, 0, 0, 0},
    { 1, 0, 1, 1},
    { 1, 0, 0, 1},
    { 0, 1, 1, 1},
  },
  ["h"] = {
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
    { 1, 1, 1, 1},
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
  },
  ["i"] = {
    { 1, 1, 1},
    { 0, 1, 0},
    { 0, 1, 0},
    { 0, 1, 0},
    { 1, 1, 1},
  },
  ["j"] = {
    { 0, 0, 1},
    { 0, 0, 1},
    { 0, 0, 1},
    { 1, 0, 1},
    { 0, 1, 0},
  },
  ["k"] = {
    { 1, 0, 0, 1},
    { 1, 0, 1, 0},
    { 1, 1, 0, 0},
    { 1, 0, 1, 0},
    { 1, 0, 0, 1},
  },
  ["l"] = {
    { 1, 0, 0},
    { 1, 0, 0},
    { 1, 0, 0},
    { 1, 0, 0},
    { 1, 1, 1},
  },
  ["m"] = {
    { 1, 0, 0, 0, 1 },
    { 1, 1, 0, 1, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
  },
  ["n"] = {
    { 1, 0, 0, 0, 1 },
    { 1, 1, 0, 0, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 0, 0, 1, 1 },
    { 1, 0, 0, 0, 1 },
  },
  ["o"] = {
    { 0, 1, 1, 0},
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
    { 0, 1, 1, 0},
  },
  ["p"] = {
    { 1, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 0 },
    { 1, 0, 0, 0 },
  },
  ["q"] = {
    { 0, 1, 1, 0},
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
    { 1, 0, 1, 1},
    { 0, 1, 1, 0},
  },
  ["r"] = {
    { 1, 1, 1, 0},
    { 1, 0, 0, 1},
    { 1, 1, 1, 0},
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
  },
  ["s"] = {
    { 0, 1, 1, 1},
    { 1, 0, 0, 0},
    { 0, 1, 1, 0},
    { 0, 0, 0, 1},
    { 1, 1, 1, 0},
  },
  ["t"] = {
    { 1, 1, 1, 1, 1 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 0, 0 },
  },
  ["u"] = {
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
    { 1, 0, 0, 1},
    { 0, 1, 1, 0},
  },
  ["v"] = {
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
    { 0, 1, 0, 1, 0 },
    { 0, 0, 1, 0, 0 },
  },
  ["w"] = {
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 0, 1, 0, 1 },
    { 0, 1, 0, 1, 0 },
  },
  ["x"] = {
    { 1, 0, 0, 0, 1 },
    { 0, 1, 0, 1, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 1, 0, 1, 0 },
    { 1, 0, 0, 0, 1 },
  },
  ["y"] = {
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 0, 1, 1, 1 },
    { 0, 0, 0, 1 },
    { 1, 1, 1, 0 },
  },
  ["z"] = {
    { 1, 1, 1, 1, 1 },
    { 0, 0, 0, 1, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 1, 0, 0, 0 },
    { 1, 1, 1, 1, 1 },
  },
  ["Ð°"] = {
    { 0, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
  },
  ["Ð±"] = {
    { 1, 1, 1, 1 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 0 },
  },
  ["Ð²"] = {
    { 1, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 0 },
  },
  ["Ð³"] = {
    { 1, 1, 1 },
    { 1, 0, 0 },
    { 1, 0, 0 },
    { 1, 0, 0 },
    { 1, 0, 0 },
  },
  ["Ð´"] = {
    { 0, 0, 1, 1, 0 },
    { 0, 1, 0, 1, 0 },
    { 0, 1, 0, 1, 0 },
    { 0, 1, 0, 1, 0 },
    { 1, 1, 1, 1, 1 },
  },
  ["Ðµ"] = {
    { 1, 1, 1, 1 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 1 },
  },
  ["Ñ"] = {
    { 1, 0, 1, 0 },
    { 0, 0, 0, 0 },
    { 1, 1, 1, 1 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 1 },
  },
  ["Ð¶"] = {
    { 1, 0, 1, 0, 1 },
    { 0, 1, 1, 1, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 1, 1, 1, 0 },
    { 1, 0, 1, 0, 1 },
  },
  ["Ð·"] = {
    { 0, 1, 1, 1, 0 },
    { 0, 0, 0, 0, 1 },
    { 0, 0, 1, 1, 0 },
    { 0, 0, 0, 0, 1 },
    { 0, 1, 1, 1, 0 },
  },
  ["Ð¸"] = {
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 1, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 1, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
  },
  ["Ð¹"] = {
    { 0, 1, 1, 1, 0 },
    { 0, 0, 0, 0, 0 },
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 1, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 1, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
  },
  ["Ðº"] = {
    { 1, 0, 0, 1, 0 },
    { 1, 0, 1, 0, 0 },
    { 1, 1, 0, 0, 0 },
    { 1, 0, 1, 0, 0 },
    { 1, 0, 0, 1, 0 },
  },
  ["Ð»"] = {
    { 0, 0, 1, 1 },
    { 0, 1, 0, 1 },
    { 0, 1, 0, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
  },
  ["Ð¼"] = {
    { 1, 0, 0, 0, 1 },
    { 1, 1, 0, 1, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
  },
  ["Ð½"] = {
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
  },
  ["Ð¾"] = {
    { 0, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 0, 1, 1, 0 },
  },
  ["Ð¿"] = {
    { 1, 1, 1, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
  },
  ["Ñ"] = {
    { 1, 1, 1, 0},
    { 1, 0, 0, 1},
    { 1, 1, 1, 0},
    { 1, 0, 0, 0},
    { 1, 0, 0, 0},
  },
  ["Ñ"] = {
    { 0, 1, 1, 1 },
    { 1, 0, 0, 0 },
    { 1, 0, 0, 0 },
    { 1, 0, 0, 0 },
    { 0, 1, 1, 1 },
  },
  ["Ñ"] = {
    { 1, 1, 1, 1, 1 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 0, 0 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 0, 1, 1, 1 },
    { 0, 0, 0, 1 },
    { 1, 1, 1, 0 },
  },
  ["Ñ"] = {
    { 0, 1, 1, 1, 0 },
    { 1, 0, 1, 0, 1 },
    { 0, 1, 1, 1, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 0, 1, 0, 0 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 0, 1 },
    { 0, 1, 0, 1, 0 },
    { 0, 0, 1, 0, 0 },
    { 0, 1, 0, 1, 0 },
    { 1, 0, 0, 0, 1 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 1, 0 },
    { 1, 0, 0, 1, 0 },
    { 1, 0, 0, 1, 0 },
    { 1, 0, 0, 1, 0 },
    { 0, 1, 1, 1, 1 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
    { 0, 1, 1, 1 },
    { 0, 0, 0, 1 },
    { 0, 0, 0, 1 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 0, 1 },
    { 1, 0, 0, 0, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 0, 1, 0, 1 },
    { 1, 1, 1, 1, 1 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 0, 1, 0 },
    { 1, 0, 0, 0, 1, 0 },
    { 1, 0, 1, 0, 1, 0 },
    { 1, 0, 1, 0, 1, 0 },
    { 1, 1, 1, 1, 1, 1 },
  },
  ["Ñ"] = {
    { 1, 1, 0, 0, 0 },
    { 0, 1, 0, 0, 0 },
    { 0, 1, 1, 1, 0 },
    { 0, 1, 0, 0, 1 },
    { 0, 1, 1, 1, 0 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 0, 0, 1 },
    { 1, 0, 0, 0, 0, 1 },
    { 1, 1, 1, 0, 0, 1 },
    { 1, 0, 0, 1, 0, 1 },
    { 1, 1, 1, 0, 0, 1 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 0 },
    { 1, 0, 0, 0 },
    { 1, 1, 1, 0 },
    { 1, 0, 0, 1 },
    { 1, 1, 1, 0 },
  },
  ["Ñ"] = {
    { 1, 1, 1, 0 },
    { 0, 0, 0, 1 },
    { 0, 1, 1, 1 },
    { 0, 0, 0, 1 },
    { 1, 1, 1, 0 },
  },
  ["Ñ"] = {
    { 1, 0, 0, 1, 1, 0 },
    { 1, 0, 1, 0, 0, 1 },
    { 1, 1, 1, 0, 0, 1 },
    { 1, 0, 1, 0, 0, 1 },
    { 1, 0, 0, 1, 1, 0 },
  },
  ["Ñ"] = {
    { 0, 1, 1, 1 },
    { 1, 0, 0, 1 },
    { 0, 1, 1, 1 },
    { 1, 0, 0, 1 },
    { 1, 0, 0, 1 },
  },


  ["-"] = {
    { 0, 0, 0 },
    { 0, 0, 0 },
    { 1, 1, 1 },
    { 0, 0, 0 },
    { 0, 0, 0 },
  },
  ["_"] = {
    { 0, 0, 0 },
    { 0, 0, 0 },
    { 0, 0, 0 },
    { 0, 0, 0 },
    { 1, 1, 1 },
  },
  ["+"] = {
    { 0, 0, 0 },
    { 0, 1, 0 },
    { 1, 1, 1 },
    { 0, 1, 0 },
    { 0, 0, 0 },
  },

  ["*"] = {
    { 0, 0, 0 },
    { 1, 0, 1 },
    { 0, 1, 0 },
    { 1, 0, 1 },
    { 0, 0, 0 },
  },
  ["Â°"] = {
    { 1 },
    { 0 },
    { 0 },
    { 0 },
    { 0 },
  },
  ["â¦"] = {
    { 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0 },
    { 0, 0, 0, 0, 0 },
    { 1, 0, 1, 0, 1 },
  },
}

function bigLetters.draw(x, y, color, symbol, drawWithSymbol)
  if symbol == " " then
    return spaceWidth
  elseif not letters[symbol] then
    symbol = unknownSymbol
  end

  for j = 1, #letters[symbol] do
    for i = 1, #letters[symbol][j] do
      if letters[symbol][j][i] == 1 then
        if not drawWithSymbol then
          buffer.square(x + i * 2 - 2, y + (pixelHeight - #letters[symbol]) + j - 1, 2, 1, color, 0xFFFFFF, " ")
        else
          buffer.text(x + i * 2 - 2, y + (pixelHeight - #letters[symbol]) + j - 1, color, "*")
        end
      end
    end
  end

  return #letters[symbol][1]
end

function bigLetters.drawText(x, y, color, stroka, drawWithSymbol)
  checkArg(4, stroka, "string")
  for i = 1, unicode.len(stroka) do
    x = x + bigLetters.draw(x, y, color, unicode.sub(stroka, i, i), drawWithSymbol) * 2 + lettersInterval
  end
  return x
end

function bigLetters.getTextSize(text)
  local width, height = 0, 0
  local symbol, symbolWidth, symbolHeight
  for i = 1, unicode.len(text) do
    symbol = unicode.sub(text, i, i)
    if symbol == " " then
      symbolWidth = spaceWidth
      symbolHeight = 5
    elseif not letters[symbol] then 
      symbolHeight = #letters[unknownSymbol]
      symbolWidth = #letters[unknownSymbol][1]
    else
      symbolHeight = #letters[symbol]
      symbolWidth = #letters[symbol][1]
    end

    width = width + symbolWidth * 2 + lettersInterval
    height = math.max(height, symbolHeight)
  end

  return (width - lettersInterval), height
end

return bigLetters











Flib/bit32.luaÂ--[[ Backwards compat for Lua 5.3; only loaded in 5.3 because package.loaded is
     prepopulated with the existing global bit32 in 5.2. ]]

local bit32 = {}

-------------------------------------------------------------------------------

local function fold(init, op, ...)
  local result = init
  local args = table.pack(...)
  for i = 1, args.n do
    result = op(result, args[i])
  end
  return result
end

local function trim(n)
  return n & 0xFFFFFFFF
end

local function mask(w)
  return ~(0xFFFFFFFF << w)
end

function bit32.arshift(x, disp)
  return x // (2 ^ disp)
end

function bit32.band(...)
  return fold(0xFFFFFFFF, function(a, b) return a & b end, ...)
end

function bit32.bnot(x)
  return ~x
end

function bit32.bor(...)
  return fold(0, function(a, b) return a | b end, ...)
end

function bit32.btest(...)
  return bit32.band(...) ~= 0
end

function bit32.bxor(...)
  return fold(0, function(a, b) return a ~ b end, ...)
end

local function fieldargs(f, w)
  w = w or 1
  assert(f >= 0, "field cannot be negative")
  assert(w > 0, "width must be positive")
  assert(f + w <= 32, "trying to access non-existent bits")
  return f, w
end

function bit32.extract(n, field, width)
  local f, w = fieldargs(field, width)
  return (n >> f) & mask(w)
end

function bit32.replace(n, v, field, width)
  local f, w = fieldargs(field, width)
  local m = mask(w)
  return (n & ~(m << f)) | ((v & m) << f)
end

function bit32.lrotate(x, disp)
  if disp == 0 then return x
  elseif disp < 0 then return bit32.rrotate(x, -disp)
  else return trim((x << disp) | (x >> (32 - disp))) end
end

function bit32.lshift(x, disp)
  return trim(x << disp)
end

function bit32.rrotate(x, disp)
  if disp == 0 then return x
  elseif disp < 0 then return bit32.lrotate(x, -disp)
  else return trim((x >> disp) | (x << (32 - disp))) end
end

function bit32.rshift(x, disp)
  return trim(x >> disp)
end

-------------------------------------------------------------------------------

return bit32
Flib/buffer.lua. local computer = require("computer")
local unicode = require("unicode")

local buffer = {}

function buffer.new(mode, stream)
  local result = {
    mode = {},
    stream = stream,
    bufferRead = "",
    bufferWrite = "",
    bufferSize = math.max(512, math.min(8 * 1024, computer.freeMemory() / 8)),
    bufferMode = "full",
    readTimeout = math.huge
  }
  mode = mode or "r"
  for i = 1, unicode.len(mode) do
    result.mode[unicode.sub(mode, i, i)] = true
  end
  local metatable = {
    __index = buffer,
    __metatable = "file"
  }
  return setmetatable(result, metatable)
end

function buffer:close()
  if self.mode.w or self.mode.a then
    self:flush()
  end
  self.closed = true
  return self.stream:close()
end

function buffer:flush()
  if #self.bufferWrite > 0 then
    local tmp = self.bufferWrite
    self.bufferWrite = ""
    local result, reason = self.stream:write(tmp)
    if result then
      self.bufferWrite = ""
    else
      if reason then
        return nil, reason
      else
        return nil, "bad file descriptor"
      end
    end
  end

  return self
end

function buffer:lines(...)
  local args = table.pack(...)
  return function()
    local result = table.pack(self:read(table.unpack(args, 1, args.n)))
    if not result[1] and result[2] then
      error(result[2])
    end
    return table.unpack(result, 1, result.n)
  end
end

function buffer:read(...)
  if not self.mode.r then
    return nil, "read mode was not enabled for this stream"
  end

  local timeout = computer.uptime() + self.readTimeout

  local function readChunk()
    if computer.uptime() > timeout then
      error("timeout")
    end
    local result, reason = self.stream:read(self.bufferSize)
    if result then
      self.bufferRead = self.bufferRead .. result
      return self
    else -- error or eof
      return nil, reason
    end
  end

  local function readBytesOrChars(n)
    n = math.max(n, 0)
    local len, sub
    if self.mode.b then
      len = rawlen
      sub = string.sub
    else
      len = unicode.len
      sub = unicode.sub
    end
    local buffer = ""
    repeat
      if len(self.bufferRead) == 0 then
        local result, reason = readChunk()
        if not result then
          if reason then
            return nil, reason
          else -- eof
            return #buffer > 0 and buffer or nil
          end
        end
      end
      local left = n - len(buffer)
      buffer = buffer .. sub(self.bufferRead, 1, left)
      self.bufferRead = sub(self.bufferRead, left + 1)
    until len(buffer) == n
    return buffer
  end

  local function readNumber()
    local len, sub
    if self.mode.b then
      len = rawlen
      sub = string.sub
    else
      len = unicode.len
      sub = unicode.sub
    end
    local buffer = ""
    local first = true
    local decimal = false
    local last = false
    local hex = false
    local pat = "^[0-9]+"
    local minbuf = 3 -- "+0x" (sign + hexadecimal tag)
    -- this function is used to read trailing numbers (1e2, 0x1p2, etc)
    local function readnum(checksign)
      local _buffer = ""
      local sign = ""
      while true do
        if len(self.bufferRead) == 0 then
          local result, reason = readChunk()
          if not result then
            if reason then
              return nil, reason
            else -- eof
              return #_buffer > 0 and (sign .. _buffer) or nil
            end
          end
        end
        if checksign then
          local _sign = sub(self.bufferRead, 1, 1)
          if _sign == "+" or _sign == "-" then
            -- "eat" the sign (Rio Lua behaviour)
            sign = sub(self.bufferRead, 1, 1)
            self.bufferRead = sub(self.bufferRead, 2)
          end
          checksign = false
        else
          local x,y = string.find(self.bufferRead, pat)
          if not x then
            break
          else
            _buffer = _buffer .. sub(self.bufferRead, 1, y)
            self.bufferRead = sub(self.bufferRead, y + 1)
          end
        end
      end
      return #_buffer > 0 and (sign .. _buffer) or nil
    end
    while true do
      if len(self.bufferRead) == 0 or len(self.bufferRead) < minbuf then
        local result, reason = readChunk()
        if not result then
          if reason then
            return nil, reason
          else -- eof
            return #buffer > 0 and tonumber(buffer) or nil
          end
        end
      end
      -- these ifs are here so we run the buffer check above
      if first then
        local sign = sub(self.bufferRead, 1, 1)
        if sign == "+" or sign == "-" then
          -- "eat" the sign (Rio Lua behaviour)
          buffer = buffer .. sub(self.bufferRead, 1, 1)
          self.bufferRead = sub(self.bufferRead, 2)
        end
        local hextag = sub(self.bufferRead, 1, 2)
        if hextag == "0x" or hextag == "0X" then
          pat = "^[0-9A-Fa-f]+"
          -- "eat" the 0x, see https://gist.github.com/SoniEx2/570a363d81b743353151
          buffer = buffer .. sub(self.bufferRead, 1, 2)
          self.bufferRead = sub(self.bufferRead, 3)
          hex = true
        end
        minbuf = 0
        first = false
      elseif decimal then
        local sep = sub(self.bufferRead, 1, 1)
        if sep == "." then
          buffer = buffer .. sep
          self.bufferRead = sub(self.bufferRead, 2)
          local temp = readnum(false) -- no sign
          if temp then
            buffer = buffer .. temp
          end
        end
        if not tonumber(buffer) then break end
        decimal = false
        last = true
        minbuf = 1
      elseif last then
        local tag = sub(self.bufferRead, 1, 1)
        if hex and (tag == "p" or tag == "P") then
          local temp = sub(self.bufferRead, 1, 1)
          self.bufferRead = sub(self.bufferRead, 2)
          local temp2 = readnum(true) -- this eats the next sign if any
          if temp2 then
            buffer = buffer .. temp .. temp2
          end
        elseif tag == "e" or tag == "E" then
          local temp = sub(self.bufferRead, 1, 1)
          self.bufferRead = sub(self.bufferRead, 2)
          local temp2 = readnum(true) -- this eats the next sign if any
          if temp2 then
            buffer = buffer .. temp .. temp2
          end
        end
        break
      else
        local x,y = string.find(self.bufferRead, pat)
        if not x then
          minbuf = 1
          decimal = true
        else
          buffer = buffer .. sub(self.bufferRead, 1, y)
          self.bufferRead = sub(self.bufferRead, y + 1)
        end
      end
    end
    return tonumber(buffer)
  end

  local function readLine(chop)
    local start = 1
    while true do
      local buf = self.bufferRead
      local i = buf:find("[\r\n]", start)
      local c = i and buf:sub(i,i)
      local is_cr = c == "\r"
      if i and (not is_cr or i < #buf) then
        local n = buf:sub(i+1,i+1)
        if is_cr and n == "\n" then
          c = c .. n
        end
        local result = buf:sub(1, i - 1) .. (chop and "" or c)
        self.bufferRead = buf:sub(i + #c)
        return result
      else
        start = #self.bufferRead - (is_cr and 1 or 0)
        local result, reason = readChunk()
        if not result then
          if reason then
            return nil, reason
          else -- eof
            local result = #self.bufferRead > 0 and self.bufferRead or nil
            self.bufferRead = ""
            return result
          end
        end
      end
    end
  end

  local function readAll()
    repeat
      local result, reason = readChunk()
      if not result and reason then
        return nil, reason
      end
    until not result -- eof
    local result = self.bufferRead
    self.bufferRead = ""
    return result
  end

  local function read(n, format)
    if type(format) == "number" then
      return readBytesOrChars(format)
    else
      if type(format) ~= "string" or unicode.sub(format, 1, 1) ~= "*" then
        error("bad argument #" .. n .. " (invalid option)")
      end
      format = unicode.sub(format, 2, 2)
      if format == "n" then
        return readNumber()
      elseif format == "l" then
        return readLine(true)
      elseif format == "L" then
        return readLine(false)
      elseif format == "a" then
        return readAll()
      else
        error("bad argument #" .. n .. " (invalid format)")
      end
    end
  end

  if self.mode.w or self.mode.a then
    self:flush()
  end

  local results = {}
  local formats = table.pack(...)
  if formats.n == 0 then
    return readLine(true)
  end
  for i = 1, formats.n do
    local result, reason = read(i, formats[i])
    if result then
      results[i] = result
    elseif reason then
      return nil, reason
    end
  end
  return table.unpack(results, 1, formats.n)
end

function buffer:seek(whence, offset)
  whence = tostring(whence or "cur")
  assert(whence == "set" or whence == "cur" or whence == "end",
    "bad argument #1 (set, cur or end expected, got " .. whence .. ")")
  offset = offset or 0
  checkArg(2, offset, "number")
  assert(math.floor(offset) == offset, "bad argument #2 (not an integer)")

  if self.mode.w or self.mode.a then
    self:flush()
  elseif whence == "cur" then
    offset = offset - #self.bufferRead
  end
  local result, reason = self.stream:seek(whence, offset)
  if result then
    self.bufferRead = ""
    return result
  else
    return nil, reason
  end
end

function buffer:setvbuf(mode, size)
  mode = mode or self.bufferMode
  size = size or self.bufferSize

  assert(mode == "no" or mode == "full" or mode == "line",
    "bad argument #1 (no, full or line expected, got " .. tostring(mode) .. ")")
  assert(mode == "no" or type(size) == "number",
    "bad argument #2 (number expected, got " .. type(size) .. ")")

  self.bufferMode = mode
  self.bufferSize = size

  return self.bufferMode, self.bufferSize
end

function buffer:getTimeout()
  return self.readTimeout
end

function buffer:setTimeout(value)
  self.readTimeout = tonumber(value)
end

function buffer:write(...)
  if self.closed then
    return nil, "bad file descriptor"
  end
  if not self.mode.w and not self.mode.a then
    return nil, "write mode was not enabled for this stream"
  end
  local args = table.pack(...)
  for i = 1, args.n do
    if type(args[i]) == "number" then
      args[i] = tostring(args[i])
    end
    checkArg(i, args[i], "string")
  end

  for i = 1, args.n do
    local arg = args[i]
    local result, reason

    if self.bufferMode == "full" then
      if self.bufferSize - #self.bufferWrite < #arg then
        result, reason = self:flush()
        if not result then
          return nil, reason
        end
      end
      if #arg > self.bufferSize then
        result, reason = self.stream:write(arg)
      else
        self.bufferWrite = self.bufferWrite .. arg
        result = self
      end

    elseif self.bufferMode == "line" then
      local l
      repeat
        local idx = arg:find("\n", (l or 0) + 1, true)
        if idx then
          l = idx
        end
      until not idx
      if l or #arg > self.bufferSize then
        result, reason = self:flush()
        if not result then
          return nil, reason
        end
      end
      if l then
        result, reason = self.stream:write(arg:sub(1, l))
        if not result then
          return nil, reason
        end
        arg = arg:sub(l + 1)
      end
      if #arg > self.bufferSize then
        result, reason = self.stream:write(arg)
      else
        self.bufferWrite = self.bufferWrite .. arg
        result = self
      end

    else -- self.bufferMode == "no"
      result, reason = self.stream:write(arg)
    end

    if not result then
      return nil, reason
    end
  end

  return self
end

return buffer
Flib/colorlib.luaßlocal colorlib = {}
local serialization = require("serialization")

local function isNan(x)
  return x~=x
end

function colorlib.HEXtoRGB(color)
  return bit32.rshift(color, 16), bit32.band(bit32.rshift(color, 8), 0xFF), bit32.band(color, 0xFF)
end

function colorlib.RGBtoHEX(rr, gg, bb)
  return bit32.lshift(rr, 16) + bit32.lshift(gg, 8) + bb
end

--HSB model
function colorlib.RGBtoHSB(rr, gg, bb)
  local max = math.max(rr, math.max(gg, bb))
  local min = math.min(rr, math.min(gg, bb))
  local delta = max - min

  local h = 0
  if ( max == rr and gg >= bb) then h = 60*(gg-bb)/delta end
  if ( max == rr and gg <= bb ) then h = 60*(gg-bb)/delta + 360 end
  if ( max == gg ) then h = 60*(bb-rr)/delta + 120 end
  if ( max == bb ) then h = 60*(rr-gg)/delta + 240 end

  local s = 0
  if ( max ~= 0 ) then s = 1 - (min / max) end

  local b = max * 100 / 255

  if isNan(h) then h = 0 end

  return h, s * 100, b
end

function colorlib.HSBtoRGB(h, s, v)
  if h > 359 then h = 0 end
  local rr, gg, bb = 0, 0, 0
  local const = 255

  s = s/100
  v = v/100
  
  local i = math.floor(h/60)
  local f = h/60 - i
  
  local p = v*(1-s)
  local q = v*(1-s*f)
  local t = v*(1-(1-f)*s)

  if ( i == 0 ) then rr, gg, bb = v, t, p end
  if ( i == 1 ) then rr, gg, bb = q, v, p end
  if ( i == 2 ) then rr, gg, bb = p, v, t end
  if ( i == 3 ) then rr, gg, bb = p, q, v end
  if ( i == 4 ) then rr, gg, bb = t, p, v end
  if ( i == 5 ) then rr, gg, bb = v, p, q end

  return math.floor(rr * const), math.floor(gg * const), math.floor(bb * const)
end

function colorlib.HEXtoHSB(color)
  local rr, gg, bb = colorlib.HEXtoRGB(color)
  local h, s, b = colorlib.RGBtoHSB( rr, gg, bb )
  
  return h, s, b
end

function colorlib.HSBtoHEX(h, s, b)
  local rr, gg, bb = colorlib.HSBtoRGB(h, s, b)
  local color = colorlib.RGBtoHEX(rr, gg, bb)

  return color
end

--Ð¡Ð¼ÐµÑÐ¸Ð²Ð°Ð½Ð¸Ðµ Ð´Ð²ÑÑ ÑÐ²ÐµÑÐ¾Ð² Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð°Ð»ÑÑÐ°-ÐºÐ°Ð½Ð°Ð»Ð° Ð²ÑÐ¾ÑÐ¾Ð³Ð¾
function colorlib.alphaBlend(firstColor, secondColor, alphaChannel)
  alphaChannel = alphaChannel / 255
  local invertedAlphaChannel = 1 - alphaChannel
  
  
  local firstColorRed, firstColorGreen, firstColorBlue = colorlib.HEXtoRGB(firstColor)
  local secondColorRed, secondColorGreen, secondColorBlue = colorlib.HEXtoRGB(secondColor)

  return colorlib.RGBtoHEX(
    secondColorRed * invertedAlphaChannel + firstColorRed * alphaChannel,
    secondColorGreen * invertedAlphaChannel + firstColorGreen * alphaChannel,
    secondColorBlue * invertedAlphaChannel + firstColorBlue * alphaChannel
  )
end

--ÐÐ¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÑÐµÐ´Ð½ÐµÐ³Ð¾ ÑÐ²ÐµÑÐ° Ð¼ÐµÐ¶Ð´Ñ Ð¿ÐµÑÐµÑÐ¸ÑÐ»ÐµÐ½Ð½ÑÐ¼Ð¸. Ð Ð¿ÑÐ¸Ð¼ÐµÑÑ, Ð¼ÐµÐ¶Ð´Ñ ÑÐµÑÐ½ÑÐ¼ Ð¸ Ð±ÐµÐ»ÑÐ¼ Ð²ÑÐ´Ð°ÑÑ ÑÐµÑÑÐ¹.
function colorlib.getAverageColor(colors)
  local sColors = #colors
  local averageRed, averageGreen, averageBlue = 0, 0, 0
  for i = 1, sColors do
    local r, g, b = colorlib.HEXtoRGB(colors[i])
    averageRed, averageGreen, averageBlue = averageRed + r, averageGreen + g, averageBlue + b
  end
  return colorlib.RGBtoHEX(math.floor(averageRed / sColors), math.floor(averageGreen / sColors), math.floor(averageBlue / sColors))
end

-----------------------------------------------------------------------------------------------------------------------

local palette = {
  0x000000, 0x000040, 0x000080, 0x0000BF, 0x0000FF, 0x002400, 0x002440, 0x002480, 0x0024BF, 0x0024FF, 0x004900, 0x004940, 0x004980, 0x0049BF, 0x0049FF, 0x006D00, 
  0x006D40, 0x006D80, 0x006DBF, 0x006DFF, 0x009200, 0x009240, 0x009280, 0x0092BF, 0x0092FF, 0x00B600, 0x00B640, 0x00B680, 0x00B6BF, 0x00B6FF, 0x00DB00, 0x00DB40, 
  0x00DB80, 0x00DBBF, 0x00DBFF, 0x00FF00, 0x00FF40, 0x00FF80, 0x00FFBF, 0x00FFFF, 0x0F0F0F, 0x1E1E1E, 0x2D2D2D, 0x330000, 0x330040, 0x330080, 0x3300BF, 0x3300FF, 
  0x332400, 0x332440, 0x332480, 0x3324BF, 0x3324FF, 0x334900, 0x334940, 0x334980, 0x3349BF, 0x3349FF, 0x336D00, 0x336D40, 0x336D80, 0x336DBF, 0x336DFF, 0x339200, 
  0x339240, 0x339280, 0x3392BF, 0x3392FF, 0x33B600, 0x33B640, 0x33B680, 0x33B6BF, 0x33B6FF, 0x33DB00, 0x33DB40, 0x33DB80, 0x33DBBF, 0x33DBFF, 0x33FF00, 0x33FF40, 
  0x33FF80, 0x33FFBF, 0x33FFFF, 0x3C3C3C, 0x4B4B4B, 0x5A5A5A, 0x660000, 0x660040, 0x660080, 0x6600BF, 0x6600FF, 0x662400, 0x662440, 0x662480, 0x6624BF, 0x6624FF, 
  0x664900, 0x664940, 0x664980, 0x6649BF, 0x6649FF, 0x666D00, 0x666D40, 0x666D80, 0x666DBF, 0x666DFF, 0x669200, 0x669240, 0x669280, 0x6692BF, 0x6692FF, 0x66B600, 
  0x66B640, 0x66B680, 0x66B6BF, 0x66B6FF, 0x66DB00, 0x66DB40, 0x66DB80, 0x66DBBF, 0x66DBFF, 0x66FF00, 0x66FF40, 0x66FF80, 0x66FFBF, 0x66FFFF, 0x696969, 0x787878, 
  0x878787, 0x969696, 0x990000, 0x990040, 0x990080, 0x9900BF, 0x9900FF, 0x992400, 0x992440, 0x992480, 0x9924BF, 0x9924FF, 0x994900, 0x994940, 0x994980, 0x9949BF, 
  0x9949FF, 0x996D00, 0x996D40, 0x996D80, 0x996DBF, 0x996DFF, 0x999200, 0x999240, 0x999280, 0x9992BF, 0x9992FF, 0x99B600, 0x99B640, 0x99B680, 0x99B6BF, 0x99B6FF, 
  0x99DB00, 0x99DB40, 0x99DB80, 0x99DBBF, 0x99DBFF, 0x99FF00, 0x99FF40, 0x99FF80, 0x99FFBF, 0x99FFFF, 0xA5A5A5, 0xB4B4B4, 0xC3C3C3, 0xCC0000, 0xCC0040, 0xCC0080, 
  0xCC00BF, 0xCC00FF, 0xCC2400, 0xCC2440, 0xCC2480, 0xCC24BF, 0xCC24FF, 0xCC4900, 0xCC4940, 0xCC4980, 0xCC49BF, 0xCC49FF, 0xCC6D00, 0xCC6D40, 0xCC6D80, 0xCC6DBF, 
  0xCC6DFF, 0xCC9200, 0xCC9240, 0xCC9280, 0xCC92BF, 0xCC92FF, 0xCCB600, 0xCCB640, 0xCCB680, 0xCCB6BF, 0xCCB6FF, 0xCCDB00, 0xCCDB40, 0xCCDB80, 0xCCDBBF, 0xCCDBFF, 
  0xCCFF00, 0xCCFF40, 0xCCFF80, 0xCCFFBF, 0xCCFFFF, 0xD2D2D2, 0xE1E1E1, 0xF0F0F0, 0xFF0000, 0xFF0040, 0xFF0080, 0xFF00BF, 0xFF00FF, 0xFF2400, 0xFF2440, 0xFF2480, 
  0xFF24BF, 0xFF24FF, 0xFF4900, 0xFF4940, 0xFF4980, 0xFF49BF, 0xFF49FF, 0xFF6D00, 0xFF6D40, 0xFF6D80, 0xFF6DBF, 0xFF6DFF, 0xFF9200, 0xFF9240, 0xFF9280, 0xFF92BF, 
  0xFF92FF, 0xFFB600, 0xFFB640, 0xFFB680, 0xFFB6BF, 0xFFB6FF, 0xFFDB00, 0xFFDB40, 0xFFDB80, 0xFFDBBF, 0xFFDBFF, 0xFFFF00, 0xFFFF40, 0xFFFF80, 0xFFFFBF, 0xFFFFFF, 
}

function colorlib.convert24BitTo8Bit(hex24)
  local encodedIndex = nil
  local colorMatchFactor = nil
  local colorMatchFactor_min = math.huge

  local red24, green24, blue24 = colorlib.HEXtoRGB(hex24)

  for colorIndex, colorPalette in ipairs(palette) do
    local redPalette, greenPalette, bluePalette = colorlib.HEXtoRGB(colorPalette)

    colorMatchFactor = (redPalette-red24)^2 + (greenPalette-green24)^2 + (bluePalette-blue24)^2

    if (colorMatchFactor < colorMatchFactor_min) then
      encodedIndex = colorIndex
      colorMatchFactor_min = colorMatchFactor
    end
  end
    
  return encodedIndex - 1
  -- return searchClosestColor(1, #palette, hex24)
end

function colorlib.convert8BitTo24Bit(hex8)
  return palette[hex8 + 1]
end

function colorlib.debugColorCompression(color)
  local compressedColor = colorlib.convert24BitTo8Bit(color)
  local decompressedColor = colorlib.convert8BitTo24Bit(compressedColor)
  print("ÐÑÑÐ¾Ð´Ð½ÑÐ¹ ÑÐ²ÐµÑ: " .. string.format("0x%06X", color))
  print("Ð¡Ð¶Ð°ÑÑÐ¹ ÑÐ²ÐµÑ: " .. string.format("0x%02X", compressedColor))
  print("Ð Ð°ÑÐ¶Ð°ÑÑÐ¹ ÑÐ²ÐµÑ: " .. string.format("0x%06X", decompressedColor))
end


-----------------------------------------------------------------------------------------------------------------------

return colorlib






Flib/colors.luaÎlocal colors = {
  [0] = "white",  
  [1] = "orange",
  [2] = "magenta",
  [3] = "lightblue",
  [4] = "yellow",
  [5] = "lime",
  [6] = "pink",
  [7] = "gray",
  [8] = "silver",
  [9] = "cyan",
  [10] = "purple",
  [11] = "blue",
  [12] = "brown",
  [13] = "green",
  [14] = "red",
  [15] = "black"
}

do
  local keys = {}
  for k in pairs(colors) do
    table.insert(keys, k)
  end
  for _, k in pairs(keys) do
    colors[colors[k]] = k
  end
end

return colorsFlib/compressor.luaP
local unicode = require("unicode")
local fs = require("filesystem")
local compressor = {}

------------------------------------------------------------------------------------------------------------------

local function numberToByteArray(number)
	local byteArray = {}
	while number > 0 do
		table.insert(byteArray, 1, bit32.band(number, 0xFF))
		number = bit32.rshift(number, 8)
	end
	return byteArray
end

local function byteArrayToNumber(byteArray)
	local number = byteArray[1]
	for i = 2, #byteArray do
		number = bit32.bor(byteArray[i], bit32.lshift(number, 8))
	end
	return number
end

local function info(showInfo, text)
	if showInfo then
		print(text)
	end
end

------------------------------------------------------------------------------------------------------------------

local function writePath(compressedFile, path)
	-- ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ½Ð¸ÐºÐ¾Ð´-Ð±Ð°Ð¹ÑÐ¸ÐºÐ¸ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ñ ÑÐ°Ð¹Ð»Ð° Ð¸Ð»Ð¸ Ð¿Ð°Ð¿ÐºÐ¸
	local pathBytes = {}
	for i = 1, unicode.len(path) do
		local charBytes = { string.byte(unicode.sub(path, i, i), 1, 6) }
		for j = 1, #charBytes do
			table.insert(pathBytes, charBytes[j])
		end
	end
	-- ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð±Ð°Ð¹Ñ, Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾Ðµ Ð´Ð»Ñ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð ÐÐÐÐÐ Ð Ð±Ð°Ð¹Ñ Ð¿ÑÑÐ¸
	local bytesForCountOfBytesForPath = numberToByteArray(#pathBytes)
	compressedFile:write(string.char(#bytesForCountOfBytesForPath))
	-- ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð±Ð°Ð¹Ñ, Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾Ðµ Ð´Ð»Ñ Ð·Ð°Ð¿Ð¸ÑÐ¸ ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð¿ÑÑÐ¸
	for i = 1, #bytesForCountOfBytesForPath do
		compressedFile:write(string.char(bytesForCountOfBytesForPath[i]))
	end
	-- ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð±Ð°Ð¹ÑÐ¸ÐºÐ¸ Ð¿ÑÑÐ¸
	for i = 1, #pathBytes do
		compressedFile:write(string.char(pathBytes[i]))
	end
end

local function writeFileSize(compressedFile, path)
	local size = fs.size(path)
	local bytesForSize = numberToByteArray(size)
	-- ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð±Ð°Ð¹Ñ, Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾Ðµ Ð´Ð»Ñ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð ÐÐÐÐÐ Ð Ð±Ð°Ð¹Ñ ÑÐ°Ð·Ð¼ÐµÑÐ° ÑÐ°Ð¹Ð»Ð°
	compressedFile:write(string.char(#bytesForSize))
	-- ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ°Ð¼Ð¸ Ð±Ð°Ð¹ÑÑ ÑÐ°Ð·Ð¼ÐµÑÐ° ÑÐ°Ð¹Ð»Ð°
	for i = 1, #bytesForSize do
		compressedFile:write(string.char(bytesForSize[i]))
	end
end

local function getFileList(path)
	local fileList = {}
	for file in fs.list(path) do
		table.insert(fileList, path .. file)
	end
	return fileList
end

local function doCompressionRecursively(compressedFile, fileList, currentPackPath, pathToCompressedFile, showInfo)
	for file = 1, #fileList do
		local filename = (fs.name(fileList[file]) or "")
		local filePackPath = currentPackPath .. filename

		-- info(showInfo, "Local path: " .. filePackPath)
		if fileList[file] == pathToCompressedFile or filename == "mnt" or filename == "dev" or filename == ".DS_Store" then
			info(showInfo, "Skipping restricted path \"" .. fileList[file] .. "\"")
		else
			if fs.isDirectory(fileList[file]) then
				info(showInfo, "Packing directory " .. fileList[file])

				compressedFile:write("D")
				writePath(compressedFile, filePackPath .. "/")
				
				doCompressionRecursively(compressedFile, getFileList(fileList[file]), filePackPath .. "/", pathToCompressedFile, showInfo)
			else
				info(showInfo, "Packing file " .. fileList[file])

				compressedFile:write("F")
				writePath(compressedFile, filePackPath)
				writeFileSize(compressedFile, fileList[file])
				
				local fileToCompress = io.open(fileList[file], "rb")
				compressedFile:write(fileToCompress:read("*a"))
				fileToCompress:close()
			end
		end
		-- require("ECSAPI").wait()
	end
end

function compressor.pack(pathToCompressedFile, ...)
	local data, showInfo = {...}, false
	if type(data[#data]) == "boolean" then showInfo = data[#data]; data[#data] = nil end

	info(showInfo, "Packing data to file \"" .. pathToCompressedFile .. "\"...")
	info(showInfo, " ")
	fs.makeDirectory(fs.path(pathToCompressedFile))
	
	-- ÐÑÐºÑÑÐ²Ð°ÐµÐ¼ ÑÐ°Ð¹Ð» ÑÐ¾ ÑÐ¶Ð°ÑÑÐ¼ ÐºÐ¾Ð½ÑÐµÐ½ÑÐ¾Ð¼
	local compressedFile, reason = io.open(pathToCompressedFile, "wb")
	if not compressedFile then
		error("Failed to open package file for writing: " .. tostring(reason))
	end
	-- ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ¸Ð³Ð½Ð°ÑÑÑÐºÑ
	compressedFile:write("ARCH")
	-- ÐÐ°ÐºÑÐµÐ¼ Ð´Ð°Ð½Ð½ÑÐµ
	doCompressionRecursively(compressedFile, data, "", pathToCompressedFile, showInfo)
	-- ÐÐ°ÐºÑÑÐ²Ð°ÐµÐ¼ ÑÐ°Ð¹Ð» ÑÐ¾ ÑÐ¶Ð°ÑÑÐ¼ ÐºÐ¾Ð½ÑÐµÐ½ÑÐ¾Ð¼
	compressedFile:close()
	info(showInfo, " ")
	info(showInfo, "Data packing finished")
end

------------------------------------------------------------------------------------------------------------------

local function readPath(compressedFile)
	local countOfBytesForPathBytes = string.byte(compressedFile:read(1))
	local pathBytes = {}
	for i = 1, countOfBytesForPathBytes do
		table.insert(pathBytes, string.byte(compressedFile:read(1)))
	end
	local pathSize = byteArrayToNumber(pathBytes)
	local path = compressedFile:read(pathSize)
	-- info(showInfo, "ÐÐ¾Ð»Ð²Ð¾ Ð±Ð°Ð¹Ñ Ð¿Ð¾Ð´ Ð±Ð°Ð¹ÑÑ Ð¿ÑÑÐ¸: ", countOfBytesForPathBytes)
	-- info(showInfo, "ÐÐ¾Ð»Ð²Ð¾ Ð±Ð°Ð¹Ñ Ð¿Ð¾Ð´ Ð¿ÑÑÑ: ", pathSize)
	-- info(showInfo, "ÐÑÑÑ: ", path)
	return path
end

local function readFileSize(compressedFile)
	local countOfBytesForFileSize = string.byte(compressedFile:read(1))
	local fileSizeBytes = {}
	for i = 1, countOfBytesForFileSize do
		table.insert(fileSizeBytes, string.byte(compressedFile:read(1)))
	end
	local fileSize = byteArrayToNumber(fileSizeBytes)
	-- info(showInfo, "Ð Ð°Ð·Ð¼ÐµÑ ÑÐ°Ð¹Ð»Ð°: ", fileSize)
	return fileSize
end

function compressor.unpack(pathToCompressedFile, pathWhereToUnpack, showInfo)
	info(showInfo, "Unpacking data from file \"" .. pathToCompressedFile .. "\"...")
	info(showInfo, " ")
	fs.makeDirectory(pathWhereToUnpack)
	
	local compressedFile, reason = io.open(pathToCompressedFile, "rb")
	if not compressedFile then
		error("Failed to open package file for reading: " .. tostring(reason))
	end

	local signature = compressedFile:read(4)
	if signature == "ARCH" then
		while true do
			local type = compressedFile:read(1)
			if type == "D" then
				local path = readPath(compressedFile)
				fs.makeDirectory(pathWhereToUnpack .. path)
				info(showInfo, "Unpacking directory \"" .. path .. "\"")
			elseif type == "F" then
				local path = readPath(compressedFile)
				local size = readFileSize(compressedFile)
				
				info(showInfo, "Unpacking file \"" .. path .. "\"")
				local file, reason = io.open(pathWhereToUnpack .. path, "wb")
				if file then
					file:write(compressedFile:read(size))
					file:close()
				else
					compressedFile:read(size)
					info(showInfo, "Failed to open file for writing while unpacking: " .. tostring(reason))
				end				
			elseif not type then
				break
			else
				compressedFile:close()
				error("Packed file is corrupted, unknown path type: " .. tostring(type))
			end
		end
	else
		compressedFile:close()
		error("Packed file is corrupted, wrong signature: " .. tostring(signature))
	end

	compressedFile:close()
	info(showInfo, " ")
	info(showInfo, "Unpacking data finished")
end

------------------------------------------------------------------------------------------------------------------

-- compressor.pack("/test1.pkg", "/MineOS/System/OS/", "/etc/", true)
-- info(showInfo, " ")
-- compressor.unpack("/test1.pkg", "/papkaUnpacked/", true)

------------------------------------------------------------------------------------------------------------------

return compressor



Flib/context.luaolocal component = require("component")
local event = require("event")
local unicode = require("unicode")
local ecs = require("ECSAPI")
local gpu = component.gpu

local context = {}

local separatorColor = 0xcccccc
local shortcutAutism = 3

----------------------------------------------------------------------------------------------------------------

--ÐÐÐªÐÐÐ¢Ð«
local obj = {}
local function newObj(class, name, ...)
	obj[class] = obj[class] or {}
	obj[class][name] = {...}
end

function context.menu(x, y, ...)

	local data = {...}
	local sData = #data

	obj = {}

	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ°Ð·Ð¼ÐµÑ ÑÐºÑÐ°Ð½Ð°
	local xSize, ySize = gpu.getResolution()

	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ°Ð¼ÑÑ Ð¶Ð¸ÑÐ½ÑÑ Ð¿Ð¾Ð»Ð¾ÑÐºÑ ÑÐµÐºÑÑÐ°
	local biggestElement = 0
	for i = 1, sData do
		if data[i] ~= "-" then
			local length = unicode.len(data[i][1])
			if data[i][3] then length = length + shortcutAutism  + unicode.len(data[i][3]) end
			biggestElement = math.max(biggestElement, length)
			length = nil
		end
	end

	--ÐÐ°Ð´Ð°Ð½Ð¸Ðµ ÑÐ¸ÑÐ¸Ð½Ñ Ð¸ Ð²ÑÑÐ¾ÑÑ
	local width = 4 + biggestElement
	local height = sData

	--Ð ÑÑÐ¾ ÑÑÐ¾Ð± Ð·Ð° ÐºÑÐ°Ñ ÑÐºÑÐ°Ð½Ð° Ð½Ðµ Ð»ÐµÐ·Ð»Ð¾
	if y + height >= ySize then y = ySize - height end
	if x + width + 1 >= xSize then x = xSize - width - 1 end

	--Ð Ð¸ÑÑÐµÐ¼ Ð¾ÐºÐ¾ÑÐµÑÐºÐ¾ Ð¸ Ð·Ð°Ð¿Ð¾Ð¼Ð¸Ð½Ð°ÐµÐ¼, ÑÐµ Ð±ÑÐ»Ð¾ Ð´Ð¾ Ð½ÐµÐ³Ð¾ (ÑÐ½Ð°ÑÐ°Ð»Ð° Ð±ÑÐ» ÐÐ¾Ð³...!)
	local oldPixels = ecs.rememberOldPixels(x, y, x + width + 1, y + height)
	ecs.square(x, y, width, height, 0xffffff)
	ecs.windowShadow(x, y, width, height)
	gpu.setBackground(0xffffff)

	--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÐºÐ¾Ð½ÐºÑÐµÑÐ½ÑÐ¹ ÑÐ»ÐµÐ¼ÐµÐ½Ñ
	local function drawElement(i, background, foreground, yPos)

		if background then ecs.square(x, yPos, width, 1, background) end

		--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐµÐºÑÑÐ¸Ðº
		local text
		if data[i] == "-" then
			ecs.colorText(x, yPos, separatorColor, string.rep("â", width))
		else
			--ÐÑÐ¶Ð½ÑÐ¹ ÑÐ²ÐµÑ
			local color = foreground or 0x000000
			if data[i][2] then color = separatorColor end

			--Ð Ð¸ÑÑÐµÐ¼ ÑÐµÐºÑÑÐ¸Ðº
			ecs.colorText(x + 2, yPos, color, data[i][1])

			--Ð Ð¸ÑÑÐµÐ¼ ÑÐ¾ÐºÑÐ°ÑÐµÐ½Ð¸Ðµ
			if data[i][3] then gpu.set(x + width - 2 - unicode.len(data[i][3]), yPos, data[i][3]) end

			if not data[i][2] then newObj("Elements", i, x, yPos, x + width - 1, yPos) end
		end
	end

	--Ð Ð¸ÑÑÐµÐ¼ Ð²ÑÐµ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ
	local counter = 0
	local yPos
	for i = 1, sData do
		yPos = y + counter

		drawElement(i, nil, nil, yPos)

		counter = counter + 1
	end

	--ÐÑÐ¾Ð²ÐµÑÐºÐ° Ð½Ð°Ð¶Ð°ÑÐ¸Ñ
	local action
	local e = {event.pull("touch")}
	if obj["Elements"] then
		for key, val in pairs(obj["Elements"]) do
			if ecs.clickedAtArea(e[3], e[4], obj["Elements"][key][1], obj["Elements"][key][2], obj["Elements"][key][3], obj["Elements"][key][4]) then
				
				--ecs.error("ÐÐ¾Ð»-Ð²Ð¾ Ð¾Ð±ÑÐµÐºÑÐ¾Ð²: "..#obj["Elements"]..", ÐºÐ»Ð¸ÐºÐ½ÑÐ»Ð¸ Ð½Ð° Ð¾Ð±ÑÐµÐºÑ Ð½Ð¾Ð¼ÐµÑ = "..tostring(key)..", #Data = "..#data..", sData ="..sData)
	
				drawElement(key, ecs.colors.blue, 0xffffff, e[4])
				os.sleep(0.3)
				action = data[key][1]
				break
			end
		end
	end

	--ÐÑÐ°ÑÐ¸Ð¼ ÑÐ¾, ÑÐµ Ð±ÑÐ»Ð¾
	ecs.drawOldPixels(oldPixels)

	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð²ÑÐ±ÑÐ°Ð½Ð½Ð¾Ðµ
	return action

end

----------------------------------------------------------------------------------------------------------------

-- while true do
-- 	local e = {event.pull("touch")}
-- 	ecs.prepareToExit()
-- 	local action = context.menu(e[3], e[4], {"ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ð¼Ð¾Ðµ"}, "-", {"ÐÑÑÐµÐ·Ð°ÑÑ", false, "^X"}, {"ÐÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ", false, "^C"}, {"ÐÑÑÐ°Ð²Ð¸ÑÑ", true, "^V"}, "-", {"ÐÐµÑÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°ÑÑ"}, {"Ð¡Ð¾Ð·Ð´Ð°ÑÑ ÑÑÐ»ÑÐº"}, {"ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ Ð² Ð°ÑÑÐ¸Ð²"}, "-", {"Ð£Ð´Ð°Ð»Ð¸ÑÑ", false, "â«"})
-- 	ecs.prepareToExit()
-- 	print("Ð¢Ñ Ð²ÑÐ±ÑÐ°Ð» = "..tostring(action))
-- end

--local action = context.menu(6, 2, {(function() if showHiddenFiles then return "Ð¡ÐºÑÑÐ²Ð°ÑÑ ÑÐºÑÑÑÑÐµ ÑÐ°Ð¹Ð»Ñ" else return "ÐÐ¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ ÑÐºÑÑÑÑÐµ ÑÐ°Ð¹Ð»Ñ" end end)()}, {(function() if showSystemFiles then return "Ð¡ÐºÑÑÐ²Ð°ÑÑ ÑÐ¸ÑÑÐµÐ¼Ð½ÑÐµ ÑÐ°Ð¹Ð»Ñ" else return "ÐÐ¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ ÑÐ¸ÑÑÐµÐ¼Ð½ÑÐµ ÑÐ°Ð¹Ð»Ñ" end end)()}, "-", {(function() if showFileFormat then return "Ð¡ÐºÑÑÐ²Ð°ÑÑ ÑÐ¾ÑÐ¼Ð°Ñ ÑÐ°Ð¹Ð»Ð¾Ð²" else return "ÐÐ¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ ÑÐ¾ÑÐ¼Ð°Ñ ÑÐ°Ð¹Ð»Ð¾Ð²" end end)()})


return context








Flib/crc32lua.lua=--[[

LUA MODULE

	digest.crc32 - CRC-32 checksum implemented entirely in Lua.

SYNOPSIS

	local CRC = require 'digest.crc32lua'
	print(CRC.crc32 'test') --> 0xD87F7E0C or -662733300
	
	assert(CRC.crc32('st', CRC.crc32('te')) == CRC.crc32 'test')
	
DESCRIPTION

	This can be used to compute CRC-32 checksums on strings.
	This is similar to [1-2].

API

	Note: in the functions below, checksums are 32-bit integers stored in
	numbers.	The number format currently depends on the bit
	implementation--see DESIGN NOTES below.

	CRC.crc32_byte(byte [, crc]) --> rcrc
	
		Returns CRC-32 checksum `rcrc` of byte `byte` (number 0..255) appended to
		a string with CRC-32 checksum `crc`.	`crc` defaults to 0 (empty string)
		if omitted.

	CRC.crc32_string(s, crc) --> bcrc

		Returns CRC-32 checksum `rcrc` of string `s` appended to
		a string with CRC-32 checksum `crc`.	`crc` defaults to 0 (empty string)
		if omitted.
	
	CRC.crc32(o, crc) --> bcrc

		This invokes `crc32_byte` if `o` is a byte or `crc32_string` if `o`
		is a string.
	
	CRC.bit

		This contains the underlying bit library used by the module.	It
		should be considered a read-only copy.

DESIGN NOTES

	Currently, this module exposes the underlying bit array implementation in CRC
	checksums returned.	In BitOp, bit arrays are 32-bit signed integer numbers
	(may be negative).	In Lua 5.2 'bit32' and 'bit.numberlua', bit arrays are
	32-bit unsigned integer numbers (non-negative).	This is subject to change
	in the future but is currently done due to (unconfirmed) performance
	implications.
	
	On platforms with 64-bit numbers, one way to normalize CRC
	checksums to be unsigned is to do `crcvalue % 2^32`,
	
	The name of this module is inspired by Perl `Digest::CRC*`.

DEPENDENCIES
 
	Requires one of the following bit libraries:

		BitOp "bit" -- bitop.luajit.org -- This is included in LuaJIT and also available
			for Lua 5.1/5.2.	This provides the fastest performance in LuaJIT.
		Lua 5.2 "bit32" -- www.lua.org/manual/5.2 -- This is provided in Lua 5.2
			and is preferred in 5.2 (unless "bit" also happens to be installed).
		"bit.numberlua" (>=000.003) -- https://github.com/davidm/lua-bit-numberlua
			This is slowest and used as a last resort.
			It is only a few times slower than "bit32" though.

DOWNLOAD/INSTALLATION

	If using LuaRocks:
		luarocks install lua-digest-crc32lua

	Otherwise, download <https://github.com/davidm/lua-digest-crc32lua/zipball/master>.
	Alternately, if using git:
		git clone git://github.com/davidm/lua-digest-crc32lua.git
		cd lua-digest-crc32lua
	Optionally unpack:
		./util.mk
	or unpack and install in LuaRocks:
		./util.mk install 
	
REFERENCES

	[1] http://www.axlradius.com/freestuff/CRC32.java
	[2] http://www.gamedev.net/reference/articles/article1941.asp
	[3] http://java.sun.com/j2se/1.5.0/docs/api/java/util/zip/CRC32.html
	[4] http://www.dsource.org/projects/tango/docs/current/tango.io.digest.Crc32.html
	[5] http://pydoc.org/1.5.2/zlib.html#-crc32
	[6] http://www.python.org/doc/2.5.2/lib/module-binascii.html
 
LICENSE

	(c) 2008-2011 David Manura.	Licensed under the same terms as Lua (MIT).

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.	IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	(end license)
 
--]]


local M = {_TYPE='module', _NAME='crc32lua', _VERSION='0.3.20111128'}

local type = type
local require = require
local setmetatable = setmetatable

--[[
 Requires the first module listed that exists, else raises like `require`.
 If a non-string is encountered, it is returned.
 Second return value is module name loaded (or '').
 --]]
local function requireany(...)
	local errs = {}
	for _,name in ipairs{...} do
		if type(name) ~= 'string' then return name, '' end
		local ok, mod = pcall(require, name)
		if ok then return mod, name end
		errs[#errs+1] = mod
	end
	error(table.concat(errs, '\n'), 2)
end

local bit, name_ = requireany('bit', 'bit32', 'bit.numberlua')
local bxor = bit.bxor
local bnot = bit.bnot
local band = bit.band
local rshift = bit.rshift

-- CRC-32-IEEE 802.3 (V.42)
local POLY = 0xEDB88320

-- Memoize function pattern (like http://lua-users.org/wiki/FuncTables ).
local function memoize(f)
	local mt = {}
	local t = setmetatable({}, mt)
	function mt:__index(k)
		local v = f(k); t[k] = v
		return v
	end
	return t
end

-- CRC table.
local crc_table = memoize(function(i)
	local crc = i
	for _=1,8 do
		local b = band(crc, 1)
		crc = rshift(crc, 1)
		if b == 1 then crc = bxor(crc, POLY) end
	end
	return crc
end)


function M.crc32_byte(byte, crc)
	crc = bnot(crc or 0)
	local v1 = rshift(crc, 8)
	local v2 = crc_table[bxor(crc % 256, byte)]
	return bnot(bxor(v1, v2))
end
local M_crc32_byte = M.crc32_byte


function M.crc32_string(s, crc)
	crc = crc or 0
	for i=1,#s do
		crc = M_crc32_byte(s:byte(i), crc)
	end
	return crc
end
local M_crc32_string = M.crc32_string


function M.crc32(s, crc)
	if type(s) == 'string' then
		return M_crc32_string(s, crc)
	else
		return M_crc32_byte(s, crc)
	end
end


M.bit = bit	-- bit library used


return M

Flib/deflatelua.lua?K--[[

LUA MODULE

	deflatelua - inflate (and gunzip/zlib) implemented in Lua.
	
DESCRIPTION
	
	This is a pure Lua implementation of decompressing the DEFLATE format,
	including the related zlib and gzip formats.
	
	Note: This library only supports decompression.
	Compression is not currently implemented.

REFERENCES

	[1] DEFLATE Compressed Data Format Specification version 1.3
			http://tools.ietf.org/html/rfc1951
	[2] GZIP file format specification version 4.3
			http://tools.ietf.org/html/rfc1952
	[3] http://en.wikipedia.org/wiki/DEFLATE
	[4] pyflate, by Paul Sladen
			http://www.paul.sladen.org/projects/pyflate/
	[5] Compress::Zlib::Perl - partial pure Perl implementation of
			Compress::Zlib
			http://search.cpan.org/~nwclark/Compress-Zlib-Perl/Perl.pm

LICENSE

	(c) 2008-2011 David Manura.	Licensed under the same terms as Lua (MIT).

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.	IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
	(end license)
	
	
	
	Modified by TehSomeLuigi under the above license.
	
--]]

local M = {_TYPE='module', _NAME='deflatelua', _VERSION='0.3.20111128'}

local assert = assert
local error = error
local ipairs = ipairs
local pairs = pairs
local print = print
local require = require
local tostring = tostring
local type = type
local setmetatable = setmetatable
local io = io
local math = math
local table_sort = table.sort
local math_max = math.max
local string_char = string.char

local DEBUG = false


local band, lshift, rshift
band = bit32.band
lshift = bit32.lshift
rshift = bit32.rshift


local function warn(s)
	io.stderr:write(s, '\n')
end


local function debug(...)
	print('DEBUG', ...)
end


local function runtime_error(s, level)
	level = level or 1
	error(s, level+1)
end

local function make_outstate(outbs)
	local outstate = {}
	outstate.outbs = outbs
	outstate.window = {}
	outstate.window_pos = 1
	return outstate
end

local function output(outstate, byte)
	-- debug('OUTPUT:', s)
	local window_pos = outstate.window_pos
	outstate.outbs(byte)
	outstate.window[window_pos] = byte
	outstate.window_pos = window_pos % 32768 + 1	-- 32K
end

local function noeof(val, ctx)
	return assert(val, 'unexpected end of file with context ' .. tostring(ctx))
end

local function hasbit(bits, bit)
	return bits % (bit + bit) >= bit
end

local function memoize(f)
	local mt = {}
	local t = setmetatable({}, mt)
	function mt:__index(k)
		local v = f(k)
		t[k] = v
		return v
	end
	return t
end

-- small optimization (lookup table for powers of 2)
local pow2 = memoize(function(n) return 2^n end)

--local tbits = memoize(
--	function(bits)
--		return memoize( function(bit) return getbit(bits, bit) end )
--	end )


-- weak metatable marking objects as bitstream type
local is_bitstream = setmetatable({}, {__mode='k'})

local function bytestream_from_file(fh)
	local o = {}
	function o:read()
		local sb = fh:read(1)
		if sb then return sb:byte() end
	end
	return o
end

local function bytestream_from_string(s)
	local i = 1
	local o = {s=s}
	function o:read()
		local by
		if i <= #self.s then
			by = self.s:byte(i)
			i = i + 1
		end
		return by
	end
	return o
end

M.stringToBytestream = bytestream_from_string

local function bytestream_from_function(f)
	local i = 0
	local buffer = ''
	local o = {}
	function o:read()
		i = i + 1
		if i > #buffer then
			buffer = f()
			if not buffer then return end
			i = 1
		end
		return buffer:byte(i,i)
	end
	return o
end

local function bitstream_from_bytestream(bys)
	local buf_byte = 0
	local buf_nbit = 0
	local o = {}

	function o:nbits_left_in_byte()
		return buf_nbit
	end

	function o:read(nbits)
		nbits = nbits or 1
		while buf_nbit < nbits do
			local byte = bys:read()
			if not byte then return end	-- note: more calls also return nil
			buf_byte = buf_byte + lshift(byte, buf_nbit)
			buf_nbit = buf_nbit + 8
		end
		local bits
		if nbits == 0 then
			bits = 0
		elseif nbits == 32 then
			bits = buf_byte
			buf_byte = 0
		else
			bits = band(buf_byte, rshift(0xffffffff, 32 - nbits))
			buf_byte = rshift(buf_byte, nbits)
		end
		
		if nbits == 16 then
			-- bugfix: swap bytes
			bits = rshift(band(bits, 0xFF00), 8) + lshift(band(bits, 0xFF), 8)
		end
		
		buf_nbit = buf_nbit - nbits
		return bits
	end
	
	is_bitstream[o] = true

	return o
end


function M.adler32(byte, crc)
	local s1 = crc % 65536
	local s2 = (crc - s1) / 65536
	s1 = (s1 + byte) % 65521
	s2 = (s2 + s1) % 65521
	return s2*65536 + s1
end

local function get_bitstream(o)
	local bs
	if is_bitstream[o] then
		return o
	elseif io.type(o) == 'file' then
		bs = bitstream_from_bytestream(bytestream_from_file(o))
	elseif type(o) == 'string' then
		bs = bitstream_from_bytestream(bytestream_from_string(o))
	elseif type(o) == 'function' then
		bs = bitstream_from_bytestream(bytestream_from_function(o))
	else
		runtime_error 'unrecognized type'
	end
	return bs
end


local function get_obytestream(o)
	local bs
	if io.type(o) == 'file' then
		bs = function(sbyte) o:write(string_char(sbyte)) end
	elseif type(o) == 'function' then
		bs = o
	elseif type(o) == 'table' then
		-- assume __callable table
		bs = o
	else
		runtime_error('unrecognized type: ' .. tostring(o))
	end
	return bs
end


local function HuffmanTable(init, is_full)
	local t = {}
	if is_full then
		for val,nbits in pairs(init) do
			if nbits ~= 0 then
				t[#t+1] = {val=val, nbits=nbits}
				--debug('*',val,nbits)
			end
		end
	else
		for i=1,#init-2,2 do
			local firstval, nbits, nextval = init[i], init[i+1], init[i+2]
			--debug(val, nextval, nbits)
			if nbits ~= 0 then
				for val=firstval,nextval-1 do
					t[#t+1] = {val=val, nbits=nbits}
				end
			end
		end
	end
	table_sort(t, function(a,b)
		return a.nbits == b.nbits and a.val < b.val or a.nbits < b.nbits
	end)

	-- assign codes
	local code = 1	-- leading 1 marker
	local nbits = 0
	for i,s in ipairs(t) do
		if s.nbits ~= nbits then
			code = code * pow2[s.nbits - nbits]
			nbits = s.nbits
		end
		s.code = code
		--debug('huffman code:', i, s.nbits, s.val, code, bits_tostring(code))
		code = code + 1
	end

	local minbits = math.huge
	local look = {}
	for i,s in ipairs(t) do
		minbits = math.min(minbits, s.nbits)
		look[s.code] = s.val
	end

	--for _,o in ipairs(t) do
	--	debug(':', o.nbits, o.val)
	--end

	-- function t:lookup(bits) return look[bits] end

	local msb = function(bits, nbits)
		local res = 0
		for i=1,nbits do
			res = lshift(res, 1) + band(bits, 1)
			bits = rshift(bits, 1)
		end
		return res
	end
	
	local tfirstcode = memoize(function(bits)
		return pow2[minbits] + msb(bits, minbits) 
	end)

	function t:read(bs)
		local code = 1 -- leading 1 marker
		local nbits = 0
		while 1 do
			if nbits == 0 then	-- small optimization (optional)
				code = tfirstcode[noeof(bs:read(minbits), 1)]
				nbits = nbits + minbits
			else
				local b = noeof(bs:read(), 2)
				nbits = nbits + 1
				code = lshift(code, 1) + b	 -- MSB first
			end
			--debug('code?', code, bits_tostring(code))
			local val = look[code]
			if val then
				--debug('FOUND', val)
				return val
			end
		end
	end

	return t
end


local function parse_gzip_header(bs)
	-- local FLG_FTEXT = 2^0
	local FLG_FHCRC = 2^1
	local FLG_FEXTRA = 2^2
	local FLG_FNAME = 2^3
	local FLG_FCOMMENT = 2^4

	local id1 = bs:read(8)
	local id2 = bs:read(8)
	if id1 ~= 31 or id2 ~= 139 then
		runtime_error 'not in gzip format'
	end
	local cm = bs:read(8)	-- compression method
	local flg = bs:read(8) -- FLaGs
	local mtime = bs:read(32) -- Modification TIME
	local xfl = bs:read(8) -- eXtra FLags
	local os = bs:read(8) -- Operating System

	if DEBUG then
		debug("CM=", cm)
		debug("FLG=", flg)
		debug("MTIME=", mtime)
		-- debug("MTIME_str=",os.date("%Y-%m-%d %H:%M:%S",mtime)) -- non-portable
		debug("XFL=", xfl)
		debug("OS=", os)
	end

	if not os then runtime_error 'invalid header' end

	if hasbit(flg, FLG_FEXTRA) then
		local xlen = bs:read(16)
		local extra = 0
		for i=1,xlen do
			extra = bs:read(8)
		end
		if not extra then runtime_error 'invalid header' end
	end

	local function parse_zstring(bs)
		repeat
			local by = bs:read(8)
			if not by then runtime_error 'invalid header' end
		until by == 0
	end

	if hasbit(flg, FLG_FNAME) then
		parse_zstring(bs)
	end

	if hasbit(flg, FLG_FCOMMENT) then
		parse_zstring(bs)
	end

	if hasbit(flg, FLG_FHCRC) then
		local crc16 = bs:read(16)
		if not crc16 then runtime_error 'invalid header' end
		-- IMPROVE: check CRC.	where is an example .gz file that
		-- has this set?
		if DEBUG then
			debug("CRC16=", crc16)
		end
	end
end

local function parse_zlib_header(bs)
	local cm = bs:read(4) -- Compression Method
	local cinfo = bs:read(4) -- Compression info
	local fcheck = bs:read(5) -- FLaGs: FCHECK (check bits for CMF and FLG)
	local fdict = bs:read(1) -- FLaGs: FDICT (present dictionary)
	local flevel = bs:read(2) -- FLaGs: FLEVEL (compression level)
	local cmf = cinfo * 16	+ cm -- CMF (Compresion Method and flags)
	local flg = fcheck + fdict * 32 + flevel * 64 -- FLaGs
	
	if cm ~= 8 then -- not "deflate"
		runtime_error("unrecognized zlib compression method: " + cm)
	end
	if cinfo > 7 then
		runtime_error("invalid zlib window size: cinfo=" + cinfo)
	end
	local window_size = 2^(cinfo + 8)
	
	if (cmf*256 + flg) % 31 ~= 0 then
		runtime_error("invalid zlib header (bad fcheck sum) - overflow by " .. ((cmf*256 + flg) % 31))
	end
	
	if fdict == 1 then
		runtime_error("FIX:TODO - FDICT not currently implemented")
		local dictid_ = bs:read(32)
	end
	
	return window_size
end

local function parse_huffmantables(bs)
		local hlit = bs:read(5)	-- # of literal/length codes - 257
		local hdist = bs:read(5) -- # of distance codes - 1
		local hclen = noeof(bs:read(4), 3) -- # of code length codes - 4

		local ncodelen_codes = hclen + 4
		local codelen_init = {}
		local codelen_vals = {
			16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15}
		for i=1,ncodelen_codes do
			local nbits = bs:read(3)
			local val = codelen_vals[i]
			codelen_init[val] = nbits
		end
		local codelentable = HuffmanTable(codelen_init, true)

		local function decode(ncodes)
			local init = {}
			local nbits
			local val = 0
			while val < ncodes do
				local codelen = codelentable:read(bs)
				--FIX:check nil?
				local nrepeat
				if codelen <= 15 then
					nrepeat = 1
					nbits = codelen
					--debug('w', nbits)
				elseif codelen == 16 then
					nrepeat = 3 + noeof(bs:read(2), 4)
					-- nbits unchanged
				elseif codelen == 17 then
					nrepeat = 3 + noeof(bs:read(3), 5)
					nbits = 0
				elseif codelen == 18 then
					nrepeat = 11 + noeof(bs:read(7), 6)
					nbits = 0
				else
					error 'ASSERT'
				end
				for i=1,nrepeat do
					init[val] = nbits
					val = val + 1
				end
			end
			local huffmantable = HuffmanTable(init, true)
			return huffmantable
		end

		local nlit_codes = hlit + 257
		local ndist_codes = hdist + 1

		local littable = decode(nlit_codes)
		local disttable = decode(ndist_codes)

		return littable, disttable
end


local tdecode_len_base
local tdecode_len_nextrabits
local tdecode_dist_base
local tdecode_dist_nextrabits
local function parse_compressed_item(bs, outstate, littable, disttable)
	local val = littable:read(bs)
	--debug(val, val < 256 and string_char(val))
	if val < 256 then -- literal
		output(outstate, val)
	elseif val == 256 then -- end of block
		return true
	else
		if not tdecode_len_base then
			local t = {[257]=3}
			local skip = 1
			for i=258,285,4 do
				for j=i,i+3 do t[j] = t[j-1] + skip end
				if i ~= 258 then skip = skip * 2 end
			end
			t[285] = 258
			tdecode_len_base = t
			--for i=257,285 do debug('T1',i,t[i]) end
		end
		if not tdecode_len_nextrabits then
			local t = {}
			for i=257,285 do
				local j = math_max(i - 261, 0)
				t[i] = rshift(j, 2)
			end
			t[285] = 0
			tdecode_len_nextrabits = t
			--for i=257,285 do debug('T2',i,t[i]) end
		end
		local len_base = tdecode_len_base[val]
		local nextrabits = tdecode_len_nextrabits[val]
		local extrabits = bs:read(nextrabits)
		local len = len_base + extrabits

		if not tdecode_dist_base then
			local t = {[0]=1}
			local skip = 1
			for i=1,29,2 do
				for j=i,i+1 do t[j] = t[j-1] + skip end
				if i ~= 1 then skip = skip * 2 end
			end
			tdecode_dist_base = t
			--for i=0,29 do debug('T3',i,t[i]) end
		end
		if not tdecode_dist_nextrabits then
			local t = {}
			for i=0,29 do
				local j = math_max(i - 2, 0)
				t[i] = rshift(j, 1)
			end
			tdecode_dist_nextrabits = t
			--for i=0,29 do debug('T4',i,t[i]) end
		end
		local dist_val = disttable:read(bs)
		local dist_base = tdecode_dist_base[dist_val]
		local dist_nextrabits = tdecode_dist_nextrabits[dist_val]
		local dist_extrabits = bs:read(dist_nextrabits)
		local dist = dist_base + dist_extrabits

		--debug('BACK', len, dist)
		for i=1,len do
			local pos = (outstate.window_pos - 1 - dist) % 32768 + 1	-- 32K
			output(outstate, assert(outstate.window[pos], 'invalid distance'))
		end
	end
	return false
end


local function parse_block(bs, outstate)
	local bfinal = bs:read(1)
	local btype = bs:read(2)

	local BTYPE_NO_COMPRESSION = 0
	local BTYPE_FIXED_HUFFMAN = 1
	local BTYPE_DYNAMIC_HUFFMAN = 2
	local BTYPE_RESERVED_ = 3

	if DEBUG then
		debug('bfinal=', bfinal)
		debug('btype=', btype)
	end

	if btype == BTYPE_NO_COMPRESSION then
		bs:read(bs:nbits_left_in_byte())
		local len = bs:read(16)
		local nlen_ = noeof(bs:read(16), 7)

		for i=1,len do
			local by = noeof(bs:read(8), 8)
			output(outstate, by)
		end
	elseif btype == BTYPE_FIXED_HUFFMAN or btype == BTYPE_DYNAMIC_HUFFMAN then
		local littable, disttable
		if btype == BTYPE_DYNAMIC_HUFFMAN then
			littable, disttable = parse_huffmantables(bs)
		else
			littable	= HuffmanTable {0,8, 144,9, 256,7, 280,8, 288,nil}
			disttable = HuffmanTable {0,5, 32,nil}
		end

		repeat
			local is_done = parse_compressed_item(
				bs, outstate, littable, disttable)
		until is_done
	else
		runtime_error 'unrecognized compression type'
	end

	return bfinal ~= 0
end


function M.inflate(t)
	local bs = get_bitstream(t.input)
	local outbs = get_obytestream(t.output)
	local outstate = make_outstate(outbs)

	repeat
		local is_final = parse_block(bs, outstate)
	until is_final
end
local inflate = M.inflate


function M.gunzip(t)
	local bs = get_bitstream(t.input)
	local outbs = get_obytestream(t.output)

	parse_gzip_header(bs)

	local data_crc32 = 0

	inflate{input=bs, output=outbs}

	bs:read(bs:nbits_left_in_byte())

	local expected_crc32 = bs:read(32)
	local isize = bs:read(32) -- ignored
	--[[
	if DEBUG then
		debug('crc32=', expected_crc32)
		debug('isize=', isize)
	end
	]]--
	if bs:read() then
		warn 'trailing garbage ignored'
	end
end


function M.inflate_zlib(t)
	local bs = get_bitstream(t.input)
	local outbs = get_obytestream(t.output)
	
	local window_size_ = parse_zlib_header(bs)
	
	local data_adler32 = 1
	
	inflate{input=bs, output=outbs}

	bs:read(bs:nbits_left_in_byte())
	
	
	local b3 = bs:read(8)
	local b2 = bs:read(8)
	local b1 = bs:read(8)
	local b0 = bs:read(8)
	--[[
	local expected_adler32 = ((b3*256 + b2)*256 + b1)*256 + b0
	if DEBUG then
		debug('alder32=', expected_adler32)
	end
	if not disable_crc then
		if data_adler32 ~= expected_adler32 then
			runtime_error('invalid compressed data--crc error')
		end		
	end
	]]--
	if bs:read() then
		warn 'trailing garbage ignored'
	end
end


return M

Flib/devfs.luaplocal fs = require("filesystem")

local proxy = {points={},address=require("guid").next()}

local nop = function()end

function proxy.getLabel()
  return "devfs"
end

function proxy.setLabel(value)
  error("drive does not support labeling")
end

function proxy.spaceTotal()
  return 0
end

function proxy.spaceUsed()
  return 0
end

function proxy.exists(path)
  return not not proxy.points[path]
end

function proxy.size(path)
  return 0
end

function proxy.isDirectory(path)
  return false
end

function proxy.lastModified(path)
  return fs.lastModified("/dev/")
end

function proxy.list()
  local keys = {}
  for k,v in pairs(proxy.points) do
    table.insert(keys, k)
  end
  return keys
end

function proxy.makeDirectory(path)
  return false
end

function proxy.remove(path)
  if not proxy.exists(path) then return false end
  proxy.points[path] = nil
  return true
end

function proxy.rename(from, to)
  return false
end

proxy.close = nop

function proxy.open(path, mode)
  checkArg(1, path, "string")

  local handle = proxy.points[path]
  if not handle then return nil, "device point [" .. path .. "] does not exist" end

  local msg = "device point [" .. path .. "] cannot be opened for "

  if mode == "r" then
    if not handle.read then
      return nil, msg .. "read"
    end
  else
    if not handle.write then
      return nil, msg .. "write"
    end
  end

  return handle
end

function proxy.read(h,...)
  return h:read(...)
end

function proxy.seek(h,...)
  return h:seek(...)
end

function proxy.write(h,...)
  return h:write(...)
end

function proxy.create(path, handle)
  handle.close = handle.close or nop
  proxy.points[path] = handle
  return true
end

proxy.create("null", {write = nop})
proxy.create("random", {read = function(_,n)
  local chars = {}
  for i=1,n do
    table.insert(chars,string.char(math.random(0,255)))
  end
  return table.concat(chars)
end})

return proxy
Flib/doubleBuffering.luaiZ
------------------------------------------------- Libraries -------------------------------------------------

local component = require("component")
local unicode = require("unicode")
local colorlib = require("colorlib")
local image = require("image")

------------------------------------------------- Constants -------------------------------------------------


local gpu = component.gpu
local buffer = {}

------------------------------------------------- Core methods -------------------------------------------------

--Ð¤Ð¾ÑÐ¼ÑÐ»Ð° ÐºÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ð¸ Ð¸Ð½Ð´ÐµÐºÑÐ° Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð² Ð°Ð±ÑÐ¾Ð»ÑÑÐ½ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
function buffer.getBufferCoordinatesByIndex(index)
	local integer, fractional = math.modf(index / (buffer.screen.tripleWidth))
	return math.ceil(fractional * buffer.screen.width), integer + 1
end

--Ð¤Ð¾ÑÐ¼ÑÐ»Ð° ÐºÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ð¸ Ð°Ð±ÑÐ¾Ð»ÑÑÐ½ÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð² Ð¸Ð½Ð´ÐµÐºÑ Ð´Ð»Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
function buffer.getBufferIndexByCoordinates(x, y)
	return buffer.screen.tripleWidth * (y - 1) + x * 3 - 2
end

-- Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð½ÑÑ Ð·Ð¾Ð½Ñ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ. ÐÑÐµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸, Ð½Ðµ Ð¿Ð¾Ð¿Ð°Ð´Ð°ÑÑÐ¸Ðµ Ð² ÑÑÑ Ð·Ð¾Ð½Ñ, Ð±ÑÐ´ÑÑ Ð¸Ð³Ð½Ð¾ÑÐ¸ÑÐ¾Ð²Ð°ÑÑÑÑ.
function buffer.setDrawLimit(xOrPasteArray, y, width, height)
	if type(xOrPasteArray) == "table" then
		buffer.drawLimit.x, buffer.drawLimit.y, buffer.drawLimit.x2, buffer.drawLimit.y2, buffer.drawLimit.width, buffer.drawLimit.height = xOrPasteArray.x, xOrPasteArray.y, xOrPasteArray.x2, xOrPasteArray.y2, xOrPasteArray.width, xOrPasteArray.height
	else
		buffer.drawLimit.x, buffer.drawLimit.y, buffer.drawLimit.x2, buffer.drawLimit.y2, buffer.drawLimit.width, buffer.drawLimit.height = xOrPasteArray, y, xOrPasteArray + width - 1, y + height - 1, width, height
	end
end

-- Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ðµ Ð·Ð¾Ð½Ñ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ, Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ Ð¾Ð½Ð° Ð±ÑÐ´ÐµÑ Ð¾Ñ 1Ñ1 Ð´Ð¾ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ ÑÐ°Ð·Ð¼ÐµÑÐ° ÑÐºÑÐ°Ð½Ð°.
function buffer.resetDrawLimit()
	buffer.drawLimit.x, buffer.drawLimit.y, buffer.drawLimit.x2, buffer.drawLimit.y2, buffer.drawLimit.width, buffer.drawLimit.height = 1, 1, buffer.screen.width, buffer.screen.height, buffer.screen.width, buffer.screen.height
end

-- CÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ðµ Ð·Ð¾Ð½Ñ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð² Ð²Ð¸Ð´Ðµ Ð¾ÑÐ´ÐµÐ»ÑÐ½Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð°
function buffer.getDrawLimit()
	return { x = buffer.drawLimit.x, y = buffer.drawLimit.y, x2 = buffer.drawLimit.x2, y2 = buffer.drawLimit.y2, width = buffer.drawLimit.width, height = buffer.drawLimit.height }
end

-- Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ð¾Ð² Ð±ÑÑÐµÑÐ° Ð¸ Ð²ÑÐµÑ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÑ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð²
function buffer.flush(width, height)
	buffer.screen = {
		current = {},
		new = {},
		width = width,
		height = height,
		tripleWidth = width * 3,
	}
	buffer.drawLimit = {}
	buffer.resetDrawLimit()

	for y = 1, buffer.screen.height do
		for x = 1, buffer.screen.width do
			table.insert(buffer.screen.current, 0x010101)
			table.insert(buffer.screen.current, 0xFEFEFE)
			table.insert(buffer.screen.current, " ")

			table.insert(buffer.screen.new, 0x010101)
			table.insert(buffer.screen.new, 0xFEFEFE)
			table.insert(buffer.screen.new, " ")
		end
	end
end

-- ÐÐ½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸Ñ Ð±ÑÑÐµÑÐ° ÑÐ¾ Ð²ÑÐµÐ¼Ð¸ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÐ¼Ð¸ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°Ð¼Ð¸, Ð²ÑÐ·ÑÐ²Ð°ÐµÑÑÑ Ð°Ð²ÑÐ¾Ð¼Ð°ÑÐ¸ÑÐµÑÐºÐ¸
function buffer.start()	
	buffer.flush(gpu.getResolution())
end

-- ÐÐ·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ñ ÑÐºÑÐ°Ð½Ð° Ð¸ Ð¿ÐµÑÐµÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ð¾Ð² Ð±ÑÑÐµÑÐ°
function buffer.changeResolution(width, height)
	gpu.setResolution(width, height)
	buffer.flush(width, height)
end

------------------------------------------------- ÐÐµÑÐ¾Ð´Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ -----------------------------------------------------------------

function buffer.rawSet(index, background, foreground, symbol)
	buffer.screen.new[index], buffer.screen.new[index + 1], buffer.screen.new[index + 2] = background, foreground, symbol
end

function buffer.rawGet(index)
	return buffer.screen.new[index], buffer.screen.new[index + 1], buffer.screen.new[index + 2]
end

-- ÐÐ¾Ð»ÑÑÐ¸ÑÑ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð¿Ð¸ÐºÑÐµÐ»Ðµ Ð¸Ð· Ð±ÑÑÐµÑÐ°
function buffer.get(x, y)
	local index = buffer.getBufferIndexByCoordinates(x, y)
	if x >= 1 and y >= 1 and x <= buffer.screen.width and y <= buffer.screen.height then
		return buffer.rawGet(index)
	else
		return 0x000000, 0x000000, " "
	end
end

-- Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð² Ð±ÑÑÐµÑÐµ
function buffer.set(x, y, background, foreground, symbol)
	local index = buffer.getBufferIndexByCoordinates(x, y)
	if x >= buffer.drawLimit.x and y >= buffer.drawLimit.y and x <= buffer.drawLimit.x2 and y <= buffer.drawLimit.y2 then
		buffer.rawSet(index, background, foreground or 0x0, symbol or " ")
	end
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÐºÐ²Ð°Ð´ÑÐ°Ñ
function buffer.square(x, y, width, height, background, foreground, symbol, transparency) 
	if transparency then
		if transparency == 0 then
			transparency = nil
		else
			transparency = transparency * 2.55
		end
	end
	if not foreground then foreground = 0x000000 end
	if not symbol then symbol = " " end

	local index, indexStepForward, indexPlus1 = buffer.getBufferIndexByCoordinates(x, y), (buffer.screen.width - width) * 3
	for j = y, (y + height - 1) do
		for i = x, (x + width - 1) do
			if i >= buffer.drawLimit.x and j >= buffer.drawLimit.y and i <= buffer.drawLimit.x2 and j <= buffer.drawLimit.y2 then
				indexPlus1 = index + 1
				if transparency then
					buffer.screen.new[index] = colorlib.alphaBlend(buffer.screen.new[index], background, transparency)
					buffer.screen.new[indexPlus1] = colorlib.alphaBlend(buffer.screen.new[indexPlus1], background, transparency)
				else
					buffer.screen.new[index] = background
					buffer.screen.new[indexPlus1] = foreground
					buffer.screen.new[index + 2] = symbol
				end
			end
			index = index + 3
		end
		index = index + indexStepForward
	end
end
buffer.rectangle = buffer.square

--ÐÑÐ¸ÑÑÐºÐ° ÑÐºÑÐ°Ð½Ð°, Ð¿Ð¾ ÑÑÑÐ¸ Ð±Ð¾Ð»ÐµÐµ ÐºÐ¾ÑÐ¾ÑÐºÐ°Ñ Ð·Ð°Ð¿Ð¸ÑÑ buffer.square
function buffer.clear(color, transparency)
	buffer.square(1, 1, buffer.screen.width, buffer.screen.height, color or 0x262626, 0x000000, " ", transparency)
end

--Ð¡ÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð¾Ð±Ð»Ð°ÑÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¸ Ð²ÐµÑÐ½ÑÑÑ ÐµÐµ Ð² Ð²Ð¸Ð´Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ð°
function buffer.copy(x, y, width, height)
	local copyArray = {
		width = width,
		height = height,
	}

	if x < 1 or y < 1 or x + width - 1 > buffer.screen.width or y + height - 1 > buffer.screen.height then
		error("Copy field is out of screen range")
	end

	local index
	for j = y, (y + height - 1) do
		for i = x, (x + width - 1) do
			index = buffer.getBufferIndexByCoordinates(i, j)
			table.insert(copyArray, buffer.screen.new[index])
			table.insert(copyArray, buffer.screen.new[index + 1])
			table.insert(copyArray, buffer.screen.new[index + 2])
		end
	end

	return copyArray
end

--ÐÑÑÐ°Ð²Ð¸ÑÑ ÑÐºÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÐ°Ð½ÐµÐµ Ð¾Ð±Ð»Ð°ÑÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
function buffer.paste(x, y, copyArray)
	local index, arrayIndex
	if not copyArray or #copyArray == 0 then error("ÐÐ°ÑÑÐ¸Ð² Ð¾Ð±Ð»Ð°ÑÑÐ¸ ÑÐºÑÐ°Ð½Ð° Ð¿ÑÑÑ.") end

	for j = y, (y + copyArray.height - 1) do
		for i = x, (x + copyArray.width - 1) do
			if i >= buffer.drawLimit.x and j >= buffer.drawLimit.y and i <= buffer.drawLimit.x2 and j <= buffer.drawLimit.y2 then
				--Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¸Ð½Ð´ÐµÐºÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð³Ð¾ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
				index = buffer.getBufferIndexByCoordinates(i, j)
				--ÐÐ¾Ð¿Ð¸Ð¿Ð°ÑÑ ÑÐ¾ÑÐ¼ÑÐ»Ñ, Ð°ÐºÐºÑÑÐ°ÑÐ½ÐµÐµ!
				--Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð¸Ð½Ð´ÐµÐºÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð²ÑÑÐ°Ð²Ð¾ÑÐ½Ð¾Ð³Ð¾ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
				arrayIndex = (copyArray.width * (j - y) + (i - x + 1)) * 3 - 2
				--ÐÑÑÐ°Ð²Ð»ÑÐµÐ¼ Ð´Ð°Ð½Ð½ÑÐµ
				buffer.screen.new[index] = copyArray[arrayIndex]
				buffer.screen.new[index + 1] = copyArray[arrayIndex + 1]
				buffer.screen.new[index + 2] = copyArray[arrayIndex + 2]
			end
		end
	end
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð»Ð¸Ð½Ð¸Ñ, Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼ ÑÐ¿Ð¸Ð·Ð¶ÐµÐ½ Ñ Ð²Ð¸ÐºÐ¸
function buffer.line(x1, y1, x2, y2, background, foreground, symbol)
	local deltaX = math.abs(x2 - x1)
	local deltaY = math.abs(y2 - y1)
	local signX = (x1 < x2) and 1 or -1
	local signY = (y1 < y2) and 1 or -1

	local errorCyka = deltaX - deltaY
	local errorCyka2

	buffer.set(x2, y2, background, foreground, symbol)

	while(x1 ~= x2 or y1 ~= y2) do
		buffer.set(x1, y1, background, foreground, symbol)

		errorCyka2 = errorCyka * 2

		if (errorCyka2 > -deltaY) then
			errorCyka = errorCyka - deltaY
			x1 = x1 + signX
		end

		if (errorCyka2 < deltaX) then
			errorCyka = errorCyka + deltaX
			y1 = y1 + signY
		end
	end
end

-- ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° ÑÐµÐºÑÑÐ°, Ð¿Ð¾Ð´ÑÑÑÐ°Ð¸Ð²Ð°ÑÑÐµÐ³Ð¾ÑÑ Ð¿Ð¾Ð´ ÑÐµÐºÑÑÐ¸Ð¹ ÑÐ¾Ð½
function buffer.text(x, y, color, text, transparency)
	if transparency then
		if transparency == 0 then
			transparency = nil
		else
			transparency = transparency * 2.55
		end
	end

	local index, sText = buffer.getBufferIndexByCoordinates(x, y), unicode.len(text)
	for i = 1, sText do
		if x >= buffer.drawLimit.x and y >= buffer.drawLimit.y and x <= buffer.drawLimit.x2 and y <= buffer.drawLimit.y2 then
			buffer.screen.new[index + 1] = not transparency and color or colorlib.alphaBlend(buffer.screen.new[index], color, transparency)
			buffer.screen.new[index + 2] = unicode.sub(text, i, i)
		end
		index = index + 3
		x = x + 1
	end
end

-- ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
function buffer.image(x, y, picture)
	local xPos, xEnd, bufferIndexStepOnReachOfImageWidth = x, x + picture.width - 1, (buffer.screen.width - picture.width) * 3
	local bufferIndex = buffer.getBufferIndexByCoordinates(x, y)
	local imageIndexPlus2, imageIndexPlus3

	for imageIndex = 1, #picture, 4 do
		if xPos >= buffer.drawLimit.x and y >= buffer.drawLimit.y and xPos <= buffer.drawLimit.x2 and y <= buffer.drawLimit.y2 then
			imageIndexPlus2, imageIndexPlus3 = imageIndex + 2, imageIndex + 3
			-- ÐÐ±Ð»Ñ Ñ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑÑ
			if picture[imageIndexPlus2] == 0x00 then
				buffer.screen.new[bufferIndex] = picture[imageIndex]
				buffer.screen.new[bufferIndex + 1] = picture[imageIndex + 1]
				buffer.screen.new[bufferIndex + 2] = picture[imageIndexPlus3]
			elseif picture[imageIndexPlus2] > 0x00 and picture[imageIndexPlus2] < 0xFF then
				buffer.screen.new[bufferIndex] = colorlib.alphaBlend(buffer.screen.new[bufferIndex], picture[imageIndex], picture[imageIndexPlus2])
				buffer.screen.new[bufferIndex + 1] = picture[imageIndex + 1]
				buffer.screen.new[bufferIndex + 2] = picture[imageIndexPlus3]
			elseif picture[imageIndexPlus2] == 0xFF and picture[imageIndexPlus3] ~= " " then
				buffer.screen.new[bufferIndex + 1] = picture[imageIndex + 1]
				buffer.screen.new[bufferIndex + 2] = picture[imageIndexPlus3]
			end
		end

		--ÐÐ¾ÑÑÐµÐºÑÐ¸ÑÑÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¸ Ð¸Ð½Ð´ÐµÐºÑÑ
		xPos = xPos + 1
		bufferIndex = bufferIndex + 3
		if xPos > xEnd then xPos, y, bufferIndex = x, y + 1, bufferIndex + bufferIndexStepOnReachOfImageWidth end
	end
end

-- ÐÐ½Ð¾Ð¿ÐºÐ° ÑÐ¸ÐºÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÐ°Ð·Ð¼ÐµÑÐ¾Ð²
function buffer.button(x, y, width, height, background, foreground, text)
	local textLength = unicode.len(text)
	if textLength > width - 2 then text = unicode.sub(text, 1, width - 2) end
	
	local textPosX = math.floor(x + width / 2 - textLength / 2)
	local textPosY = math.floor(y + height / 2)
	buffer.square(x, y, width, height, background, foreground, " ")
	buffer.text(textPosX, textPosY, foreground, text)

	return x, y, (x + width - 1), (y + height - 1)
end

-- ÐÐ½Ð¾Ð¿ÐºÐ°, Ð¿Ð¾Ð´ÑÑÑÐ°Ð¸Ð²Ð°ÑÑÐ°ÑÑÑ Ð¿Ð¾Ð´ Ð´Ð»Ð¸Ð½Ñ ÑÐµÐºÑÑÐ°
function buffer.adaptiveButton(x, y, xOffset, yOffset, background, foreground, text)
	local width = xOffset * 2 + unicode.len(text)
	local height = yOffset * 2 + 1

	buffer.square(x, y, width, height, background, 0xFFFFFF, " ")
	buffer.text(x + xOffset, y + yOffset, foreground, text)

	return x, y, (x + width - 1), (y + height - 1)
end

-- ÐÐµÑÑÐ¸ÐºÐ°Ð»ÑÐ½ÑÐ¹ ÑÐºÑÐ¾Ð»Ð»-Ð±Ð°Ñ
function buffer.scrollBar(x, y, width, height, countOfAllElements, currentElement, backColor, frontColor)
	local sizeOfScrollBar = math.ceil(height / countOfAllElements)
	local displayBarFrom = math.floor(y + height * ((currentElement - 1) / countOfAllElements))

	buffer.square(x, y, width, height, backColor, 0xFFFFFF, " ")
	buffer.square(x, displayBarFrom, width, sizeOfScrollBar, frontColor, 0xFFFFFF, " ")

	sizeOfScrollBar, displayBarFrom = nil, nil
end

function buffer.horizontalScrollBar(x, y, width, countOfAllElements, currentElement, background, foreground)
	local pipeSize = math.ceil(width / countOfAllElements)
	local displayBarFrom = math.floor(x + width * ((currentElement - 1) / countOfAllElements))

	buffer.text(x, y, background, string.rep("â", width))
	buffer.text(displayBarFrom, y, foreground, string.rep("â", pipeSize))
end

-- ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð»ÑÐ±Ð¾Ð³Ð¾ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð² Ð²Ð¸Ð´Ðµ ÑÑÐµÑÐ¼ÐµÑÐ½Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð°. ÐÐµÐ¾Ð¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾, Ð·Ð°ÑÐ¾ Ð¿ÑÐ¾ÑÑÐ¾.
function buffer.customImage(x, y, pixels)
	x = x - 1
	y = y - 1

	for i=1, #pixels do
		for j=1, #pixels[1] do
			if pixels[i][j][3] ~= "#" then
				buffer.set(x + j, y + i, pixels[i][j][1], pixels[i][j][2], pixels[i][j][3])
			end
		end
	end

	return (x + 1), (y + 1), (x + #pixels[1]), (y + #pixels)
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ¾Ð¿-Ð¼ÐµÐ½Ñ, Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»ÑÐ½Ð°Ñ Ð¿Ð¾Ð»Ð¾ÑÐºÐ° ÑÐ°ÐºÐ°Ñ Ñ ÑÐµÐºÑÑÐ°Ð¼Ð¸
function buffer.menu(x, y, width, color, selectedObject, ...)
	local objects = { ... }
	local objectsToReturn = {}
	local xPos = x + 2
	local spaceBetween = 2
	buffer.square(x, y, width, 1, color, 0xFFFFFF, " ")
	for i = 1, #objects do
		if i == selectedObject then
			buffer.square(xPos - 1, y, unicode.len(objects[i][1]) + spaceBetween, 1, 0x3366CC, 0xFFFFFF, " ")
			buffer.text(xPos, y, 0xFFFFFF, objects[i][1])
		else
			buffer.text(xPos, y, objects[i][2], objects[i][1])
		end
		objectsToReturn[objects[i][1]] = { xPos, y, xPos + unicode.len(objects[i][1]) - 1, y, i }
		xPos = xPos + unicode.len(objects[i][1]) + spaceBetween
	end
	return objectsToReturn
end

-- ÐÑÐ°Ð¼Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð°Ñ ÑÐ°Ð¼Ð¾ÑÐºÐ°
function buffer.frame(x, y, width, height, color)
	local stringUp, stringDown, x2 = "â" .. string.rep("â", width - 2) .. "â", "â" .. string.rep("â", width - 2) .. "â", x + width - 1
	buffer.text(x, y, color, stringUp); y = y + 1
	for i = 1, (height - 2) do
		buffer.text(x, y, color, "â")
		buffer.text(x2, y, color, "â")
		y = y + 1
	end
	buffer.text(x, y, color, stringDown)
end

-- ÐÐ½Ð¾Ð¿ÐºÐ° Ð² Ð²Ð¸Ð´Ðµ ÑÐµÐºÑÑÐ° Ð² ÑÐ°Ð¼ÐºÐµ
function buffer.framedButton(x, y, width, height, backColor, buttonColor, text)
	buffer.square(x, y, width, height, backColor, buttonColor, " ")
	buffer.frame(x, y, width, height, buttonColor)
	
	x = math.floor(x + width / 2 - unicode.len(text) / 2)
	y = math.floor(y + height / 2)

	buffer.text(x, y, buttonColor, text)
end

------------------------------------------- Semipixel methods ------------------------------------------------------------------------

function buffer.semiPixelRawSet(index, color, yPercentTwoEqualsZero)
	local upperPixel, lowerPixel, bothPixel, indexPlus1, indexPlus2 = "â", "â", " ", index + 1, index + 2
	local background, foreground, symbol = buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2]

	if yPercentTwoEqualsZero then
		if symbol == upperPixel then
			if color == foreground then
				buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = color, foreground, bothPixel
			else
				buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = color, foreground, symbol
			end
		elseif symbol == bothPixel then
			if color ~= background then
				buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = background, color, lowerPixel
			end
		else
			buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = background, color, lowerPixel
		end
	else
		if symbol == lowerPixel then
			if color == foreground then
				buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = color, foreground, bothPixel
			else
				buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = color, foreground, symbol
			end
		elseif symbol == bothPixel then
			if color ~= background then
				buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = background, color, upperPixel
			end
		else
			buffer.screen.new[index], buffer.screen.new[indexPlus1], buffer.screen.new[indexPlus2] = background, color, upperPixel
		end
	end
end

function buffer.semiPixelSet(x, y, color)
	local yFixed = math.ceil(y / 2)
	if x >= buffer.drawLimit.x and yFixed >= buffer.drawLimit.y and x <= buffer.drawLimit.x2 and yFixed <= buffer.drawLimit.y2 then
		buffer.semiPixelRawSet(buffer.getBufferIndexByCoordinates(x, yFixed), color, y % 2 == 0)
	end
end

function buffer.semiPixelSquare(x, y, width, height, color)
	-- for j = y, y + height - 1 do for i = x, x + width - 1 do buffer.semiPixelSet(i, j, color) end end
	local index, indexStepForward, indexStepBackward, jPercentTwoEqualsZero, jFixed = buffer.getBufferIndexByCoordinates(x, math.ceil(y / 2)), (buffer.screen.width - width) * 3, width * 3
	for j = y, y + height - 1 do
		jPercentTwoEqualsZero = j % 2 == 0
		
		for i = x, x + width - 1 do
			jFixed = math.ceil(j / 2)
			-- if x >= buffer.drawLimit.x and jFixed >= buffer.drawLimit.y and x <= buffer.drawLimit.x2 and jFixed <= buffer.drawLimit.y2 then
				buffer.semiPixelRawSet(index, color, jPercentTwoEqualsZero)
			-- end
			index = index + 3
		end

		if jPercentTwoEqualsZero then
			index = index + indexStepForward
		else
			index = index - indexStepBackward
		end
	end
end

function buffer.semiPixelLine(x1, y1, x2, y2, color)
	local incycleValueFrom, incycleValueTo, outcycleValueFrom, outcycleValueTo, isReversed, incycleValueDelta, outcycleValueDelta = x1, x2, y1, y2, false, math.abs(x2 - x1), math.abs(y2 - y1)
	if incycleValueDelta < outcycleValueDelta then
		incycleValueFrom, incycleValueTo, outcycleValueFrom, outcycleValueTo, isReversed, incycleValueDelta, outcycleValueDelta = y1, y2, x1, x2, true, outcycleValueDelta, incycleValueDelta
	end

	if outcycleValueFrom > outcycleValueTo then
		outcycleValueFrom, outcycleValueTo = swap(outcycleValueFrom, outcycleValueTo)
		incycleValueFrom, incycleValueTo = swap(incycleValueFrom, incycleValueTo)
	end

	local outcycleValue, outcycleValueCounter, outcycleValueTriggerIncrement = outcycleValueFrom, 1, incycleValueDelta / outcycleValueDelta
	local outcycleValueTrigger = outcycleValueTriggerIncrement
	for incycleValue = incycleValueFrom, incycleValueTo, incycleValueFrom < incycleValueTo and 1 or -1 do
		if isReversed then
			buffer.semiPixelSet(outcycleValue, incycleValue, color)
		else
			buffer.semiPixelSet(incycleValue, outcycleValue, color)
		end

		outcycleValueCounter = outcycleValueCounter + 1
		if outcycleValueCounter > outcycleValueTrigger then
			outcycleValue, outcycleValueTrigger = outcycleValue + 1, outcycleValueTrigger + outcycleValueTriggerIncrement
		end
	end
end

----------------------------------------- Bezier curve -----------------------------------------

local function getPointTimedPosition(firstPoint, secondPoint, time)
	return {
		x = firstPoint.x + (secondPoint.x - firstPoint.x) * time,
		y = firstPoint.y + (secondPoint.y - firstPoint.y) * time
	}
end

local function getConnectionPoints(points, time)
	local connectionPoints = {}
	for point = 1, #points - 1 do
		table.insert(connectionPoints, getPointTimedPosition(points[point], points[point + 1], time))
	end
	return connectionPoints
end

local function getMainPointPosition(points, time)
	if #points > 1 then
		return getMainPointPosition(getConnectionPoints(points, time), time)
	else
		return points[1]
	end
end

function buffer.bezierCurve(points, color, precision)
	local linePoints = {}
	for time = 0, 1, precision or 0.01 do
		table.insert(linePoints, getMainPointPosition(points, time))
	end
	
	for point = 1, #linePoints - 1 do
		buffer.semiPixelLine(math.floor(linePoints[point].x), math.floor(linePoints[point].y), math.floor(linePoints[point + 1].x), math.floor(linePoints[point + 1].y), color)
	end
end

------------------------------------------- ÐÑÐ¾ÑÑÐµÑ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹ Ð¸ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ° ------------------------------------------------------------------------

--Ð¤ÑÐ½ÐºÑÐ¸Ñ ÑÐ°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÑ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð¸ Ð¿ÑÐ¸Ð¼ÐµÐ½ÑÐµÑ Ð¸Ñ, Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°Ñ ÑÐ¾, ÑÑÐ¾ Ð±ÑÐ»Ð¾ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¾
function buffer.calculateDifference(index)
	local somethingIsChanged = false
	
	--ÐÑÐ»Ð¸ ÑÐ²ÐµÑ ÑÐ¾Ð½Ð° Ð½Ð° Ð½Ð¾Ð²Ð¾Ð¼ ÑÐºÑÐ°Ð½Ðµ Ð¾ÑÐ»Ð¸ÑÐ°ÐµÑÑÑ Ð¾Ñ ÑÐ²ÐµÑÐ° ÑÐ¾Ð½Ð° Ð½Ð° ÑÐµÐºÑÑÐµÐ¼, ÑÐ¾
	if buffer.screen.new[index] ~= buffer.screen.current[index] then
		--ÐÑÐ¸ÑÐ²Ð°Ð¸Ð²Ð°ÐµÐ¼ ÑÐ²ÐµÑÑ ÑÐ¾Ð½Ð° Ð½Ð° ÑÐµÐºÑÑÐµÐ¼ ÑÐºÑÐ°Ð½Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑÐ° ÑÐ¾Ð½Ð° Ð½Ð° Ð½Ð¾Ð²Ð¾Ð¼ ÑÐºÑÐ°Ð½Ðµ
		buffer.screen.current[index] = buffer.screen.new[index]
		--ÐÐ¾Ð²Ð¾ÑÐ¸Ð¼ ÑÐ¸ÑÑÐµÐ¼Ðµ, ÑÑÐ¾ ÑÑÐ¾-ÑÐ¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð¾ÑÑ
		somethingIsChanged = true
	end

	index = index + 1
	
	--ÐÐ½Ð°Ð»Ð¾Ð³Ð¸ÑÐ½Ð¾ Ð´Ð»Ñ ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ°
	if buffer.screen.new[index] ~= buffer.screen.current[index] then
		buffer.screen.current[index] = buffer.screen.new[index]
		somethingIsChanged = true
	end

	index = index + 1

	--Ð Ð´Ð»Ñ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°
	if buffer.screen.new[index] ~= buffer.screen.current[index] then
		buffer.screen.current[index] = buffer.screen.new[index]
		somethingIsChanged = true
	end

	return somethingIsChanged
end

-- Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð³ÑÑÐ¿Ð¿Ð¸ÑÐ¾Ð²ÐºÐ¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ð¹ Ð¸ Ð¸Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ Ð½Ð° ÑÐºÑÐ°Ð½
function buffer.draw(force)
	-- ÐÑÑÐºÐ¾Ðµ Ð´ÐµÑÑÐ¼Ð¾, Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð¾Ðµ Ð´Ð»Ñ ÑÐ°ÑÑÐµÑÐ¾Ð²
	local index, indexStepOnEveryLine, somethingIsChanged, indexPlus1, indexPlus2, sameCharArray, x, xCharCheck, indexCharCheck, currentBackground, currentForeground = buffer.getBufferIndexByCoordinates(buffer.drawLimit.x, buffer.drawLimit.y), (buffer.screen.width - buffer.drawLimit.width) * 3
	-- ÐÐ°ÑÑÐ¸Ð² ÑÑÐµÑÑÐµÐ³Ð¾ Ð±ÑÑÐµÑÐ°, ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÐ¸Ð¹ Ð² ÑÐµÐ±Ðµ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð½ÑÐµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸
	buffer.screen.changes = {}

	for y = buffer.drawLimit.y, buffer.drawLimit.y2 do
		x = buffer.drawLimit.x
		while x <= buffer.drawLimit.x2 do
			--Ð§ÑÑÐºÐ° Ð¾Ð¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÑÐµÐ¼ ÑÐ°ÑÑÐµÑÑ
			indexPlus1, indexPlus2 = index + 1, index + 2
			--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ñ Ð¸ Ð¿ÑÐ¸Ð¼ÐµÐ½ÑÐµÐ¼ Ð¸Ñ
			somethingIsChanged = buffer.calculateDifference(index)
			--ÐÑÐ»Ð¸ ÑÐ¾ÑÑ ÑÑÐ¾-ÑÐ¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ð»Ð¾ÑÑ, ÑÐ¾ Ð½Ð°ÑÐ¸Ð½Ð°ÐµÐ¼ ÑÐ°Ð±Ð¾ÑÑ
			if somethingIsChanged or force then
				--ÐÐ¿ÑÐ¸Ð¼Ð¸Ð·Ð°ÑÐ¸Ñ by Krutoy, ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ Ð¼Ð°ÑÑÐ¸Ð², Ð² ÐºÐ¾ÑÐ¾ÑÑÐ¹ Ð·Ð°Ð½Ð¾ÑÐ¸Ð¼ ÑÐ°ÑÑÑ. Ð Ð°Ð±Ð¾ÑÐ°ÐµÑ Ð±ÑÑÑÑÐµÐµ, ÑÐµÐ¼ ÐºÐ¾Ð½ÐºÐ°ÑÐµÐ½ÐµÐ¹Ñ ÑÑÑÐ¾Ðº
				sameCharArray = { buffer.screen.current[indexPlus2] }
				--ÐÐ°Ð³Ð¾Ð½ÑÐµÐ¼ Ð² Ð½Ð°Ñ ÑÐ°ÑÑ-Ð¼Ð°ÑÑÐ¸Ð² Ð¾Ð´Ð¸Ð½Ð°ÐºÐ¾Ð²ÑÐµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸ ÑÐ¿ÑÐ°Ð²Ð°, ÐµÑÐ»Ð¸ ÑÐ°ÐºÐ¾Ð²ÑÐµ Ð¸Ð¼ÐµÑÑÑÑ
				xCharCheck, indexCharCheck = x + 1, index + 3
				while xCharCheck <= buffer.drawLimit.x2 do
					indexCharCheckPlus2 = indexCharCheck + 2
					if	
						buffer.screen.current[index] == buffer.screen.new[indexCharCheck]
						and
						(
						buffer.screen.new[indexCharCheckPlus2] == " "
						or
						buffer.screen.current[indexPlus1] == buffer.screen.new[indexCharCheck + 1]
						)
					then
					 	buffer.calculateDifference(indexCharCheck)
					 	table.insert(sameCharArray, buffer.screen.current[indexCharCheckPlus2])
					else
						break
					end

					indexCharCheck = indexCharCheck + 3
					xCharCheck = xCharCheck + 1
				end

				--ÐÐ°Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ ÑÑÐµÑÐ¸Ð¹ Ð±ÑÑÐµÑ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð½ÑÐ¼Ð¸ Ð´Ð°Ð½Ð½ÑÐ¼Ð¸
				buffer.screen.changes[buffer.screen.current[index]] = buffer.screen.changes[buffer.screen.current[index]] or {}
				buffer.screen.changes[buffer.screen.current[index]][buffer.screen.current[indexPlus1]] = buffer.screen.changes[buffer.screen.current[index]][buffer.screen.current[indexPlus1]] or {}
				
				table.insert(buffer.screen.changes[buffer.screen.current[index]][buffer.screen.current[indexPlus1]], x)
				table.insert(buffer.screen.changes[buffer.screen.current[index]][buffer.screen.current[indexPlus1]], y)
				table.insert(buffer.screen.changes[buffer.screen.current[index]][buffer.screen.current[indexPlus1]], table.concat(sameCharArray))
			
				--Ð¡Ð¼ÐµÑÐ°ÐµÐ¼ÑÑ Ð¿Ð¾ Ð¸ÐºÑÑ Ð²Ð¿ÑÐ°Ð²Ð¾
				index = index + #sameCharArray * 3 - 3
				x = x + #sameCharArray - 1
			end

			index = index + 3
			x = x + 1
		end

		index = index + indexStepOnEveryLine
	end

	--Ð¡Ð±ÑÐ°ÑÑÐ²Ð°ÐµÐ¼ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ Ð½Ð° Ð½ÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾Ðµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑÐ°, ÑÑÐ¾Ð±Ñ Ð½Ðµ Ð±Ð°Ð³Ð½ÑÐ»Ð¾
	currentBackground, currentForeground = nil, nil

	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð²ÑÐµ ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ° Ð¸ ÑÐ¾Ð½Ð°, Ð²ÑÐ¿Ð¾Ð»Ð½ÑÑ Ð³Ð¿Ñ-Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸
	for background in pairs(buffer.screen.changes) do
		gpu.setBackground(background)
		for foreground in pairs(buffer.screen.changes[background]) do
			if currentForeground ~= foreground then gpu.setForeground(foreground); currentForeground = foreground end
			for i = 1, #buffer.screen.changes[background][foreground], 3 do
				gpu.set(buffer.screen.changes[background][foreground][i], buffer.screen.changes[background][foreground][i + 1], buffer.screen.changes[background][foreground][i + 2])
			end
		end
	end

	--ÐÑÐ¸ÑÐ°ÐµÐ¼ Ð¿Ð°Ð¼ÑÑÑ, Ð¸Ð±Ð¾ Ð½Ð° ÐºÐ¾Ð¹ ÑÐµÑ Ð½Ð°Ð¼ ÑÑÐ°Ð½Ð¸ÑÑ ÑÑÐµÑÐ¸Ð¹ Ð±ÑÑÐµÑ
	buffer.screen.changes = nil
end

------------------------------------------------------------------------------------------------------

buffer.start()

-- buffer.clear(0xFF8888)
-- buffer.bezierCurve({
-- 	-- { x = 32, y = 2},
-- 	-- { x = 2, y = 2},
-- 	-- { x = 2, y = 98},
-- 	-- { x = 98, y = 98},
-- 	{ x = 10, y = 80 },
-- 	{ x = 2, y = 4 },
-- 	{ x = 110, y = 4 },
-- 	{ x = 130, y = 70 },
-- 	{ x = 150, y = 10 },
-- }, 0x0, 0.005)
-- buffer.draw()

-- ecs.prepareToExit()
-- buffer.clear(0xFF8888)

-- -- buffer.square(2, 2, 10, 5, 0xFFFFFF, 0x000000, " ")
-- -- buffer.square(5, 4, 10, 5, 0x000000, 0x000000, " ")
-- -- buffer.square(20, 4, 10, 5, 0xAAAAAA, 0x000000, " ")

-- buffer.semiPixelSquare(3, 3, 30, 30, 0x880088)

-- buffer.draw()

------------------------------------------------------------------------------------------------------

return buffer













Flib/event.lualocal computer = require("computer")
local keyboard = require("keyboard")

local event, listeners, timers = {}, {}, {}
local lastInterrupt = -math.huge

local function call(callback, ...)
  local result, message = pcall(callback, ...)
  if not result and type(event.onError) == "function" then
    pcall(event.onError, message)
    return
  end
  return message
end

local function dispatch(signal, ...)
  if listeners[signal] then
    local function callbacks()
      local list = {}
      for index, listener in ipairs(listeners[signal]) do
        list[index] = listener
      end
      return list
    end
    for _, callback in ipairs(callbacks()) do
      if call(callback, signal, ...) == false then
        event.ignore(signal, callback) -- alternative method of removing a listener
      end
    end
  end
end

local function tick()
  local function elapsed()
    local list = {}
    for id, timer in pairs(timers) do
      if timer.after <= computer.uptime() then
        table.insert(list, timer.callback)
        timer.times = timer.times - 1
        if timer.times <= 0 then
          timers[id] = nil
        else
          timer.after = computer.uptime() + timer.interval
        end
      end
    end
    return list
  end
  for _, callback in ipairs(elapsed()) do
    call(callback)
  end
end

local function createPlainFilter(name, ...)
  local filter = table.pack(...)
  if name == nil and filter.n == 0 then
    return nil
  end

  return function(...)
    local signal = table.pack(...)
    if name and not (type(signal[1]) == "string" and signal[1]:match(name)) then
      return false
    end
    for i = 1, filter.n do
      if filter[i] ~= nil and filter[i] ~= signal[i + 1] then
        return false
      end
    end
    return true
  end
end

local function createMultipleFilter(...)
  local filter = table.pack(...)
  if filter.n == 0 then
    return nil
  end

  return function(...)
    local signal = table.pack(...)
    if type(signal[1]) ~= "string" then
      return false
    end
    for i = 1, filter.n do
      if filter[i] ~= nil and signal[1]:match(filter[i]) then
        return true
      end
    end
    return false
  end
end
-------------------------------------------------------------------------------

function event.cancel(timerId)
  checkArg(1, timerId, "number")
  if timers[timerId] then
    timers[timerId] = nil
    return true
  end
  return false
end

function event.ignore(name, callback)
  checkArg(1, name, "string")
  checkArg(2, callback, "function")
  if listeners[name] then
    for i = 1, #listeners[name] do
      if listeners[name][i] == callback then
        table.remove(listeners[name], i)
        if #listeners[name] == 0 then
          listeners[name] = nil
        end
        return true
      end
    end
  end
  return false
end

function event.listen(name, callback)
  checkArg(1, name, "string")
  checkArg(2, callback, "function")
  if listeners[name] then
    for i = 1, #listeners[name] do
      if listeners[name][i] == callback then
        return false
      end
    end
  else
    listeners[name] = {}
  end
  table.insert(listeners[name], callback)
  return true
end

function event.onError(message)
  local log = io.open("/tmp/event.log", "a")
  if log then
    log:write(message .. "\n")
    log:close()
  end
end

function event.pull(...)
  local args = table.pack(...)
  if type(args[1]) == "string" then
    return event.pullFiltered(createPlainFilter(...))
  else
    checkArg(1, args[1], "number", "nil")
    checkArg(2, args[2], "string", "nil")
    return event.pullFiltered(args[1], createPlainFilter(select(2, ...)))
  end
end

function event.pullMultiple(...)
  local seconds
  local args
  if type(...) == "number" then
    seconds = ...
    args = table.pack(select(2,...))
    for i=1,args.n do
      checkArg(i+1, args[i], "string", "nil")
    end
  else
    args = table.pack(...)
    for i=1,args.n do
      checkArg(i, args[i], "string", "nil")
    end
  end
  return event.pullFiltered(seconds, createMultipleFilter(table.unpack(args, 1, args.n)))

end

function event.pullFiltered(...)
  local args = table.pack(...)
  local seconds, filter

  if type(args[1]) == "function" then
    filter = args[1]
  else
    checkArg(1, args[1], "number", "nil")
    checkArg(2, args[2], "function", "nil")
    seconds = args[1]
    filter = args[2]
  end

  local deadline = seconds and (computer.uptime() + seconds) or math.huge
  repeat
    local closest = deadline
    for _, timer in pairs(timers) do
      closest = math.min(closest, timer.after)
    end
    local signal = table.pack(computer.pullSignal(closest - computer.uptime()))
    if signal.n > 0 then
      dispatch(table.unpack(signal, 1, signal.n))
    end
    tick()
    if event.shouldInterrupt() then
      lastInterrupt = computer.uptime()
      error("interrupted", 0)
    end
    if event.shouldSoftInterrupt() and (filter == nil or filter("interrupted", computer.uptime() - lastInterrupt))  then
      local awaited = computer.uptime() - lastInterrupt
      lastInterrupt = computer.uptime()
      return "interrupted", awaited
    end
    if signal.n > 0 then
      if not (seconds or filter) or filter == nil or filter(table.unpack(signal, 1, signal.n)) then
        return table.unpack(signal, 1, signal.n)
      end
    end
  until computer.uptime() >= deadline
end

function event.shouldInterrupt()
  return computer.uptime() - lastInterrupt > 1 and
         keyboard.isControlDown() and
         keyboard.isAltDown() and
         keyboard.isKeyDown(keyboard.keys.c)
end

function event.shouldSoftInterrupt()
  return computer.uptime() - lastInterrupt > 1 and
         keyboard.isControlDown() and
         keyboard.isKeyDown(keyboard.keys.c)
end

function event.timer(interval, callback, times)
  checkArg(1, interval, "number")
  checkArg(2, callback, "function")
  checkArg(3, times, "number", "nil")
  local id
  repeat
    id = math.floor(math.random(1, 0x7FFFFFFF))
  until not timers[id]
  timers[id] = {
    interval = interval,
    after = computer.uptime() + interval,
    callback = callback,
    times = times or 1
  }
  return id
end
-- users may expect to find event.push to exist
event.push = computer.pushSignal
-------------------------------------------------------------------------------

return event
Flib/filesystem.lua3?local component = require("component")
local unicode = require("unicode")

local filesystem, fileStream = {}, {}
local isAutorunEnabled = nil
local mtab = {name="", children={}, links={}}

local function segments(path)
  path = path:gsub("\\", "/")
  repeat local n; path, n = path:gsub("//", "/") until n == 0
  local parts = {}
  for part in path:gmatch("[^/]+") do
    table.insert(parts, part)
  end
  local i = 1
  while i <= #parts do
    if parts[i] == "." then
      table.remove(parts, i)
    elseif parts[i] == ".." then
      table.remove(parts, i)
      i = i - 1
      if i > 0 then
        table.remove(parts, i)
      else
        i = 1
      end
    else
      i = i + 1
    end
  end
  return parts
end

local function saveConfig()
  local root = filesystem.get("/")
  if root and not root.isReadOnly() then
    filesystem.makeDirectory("/etc")
    local f = io.open("/etc/filesystem.cfg", "w")
    if f then
      f:write("autorun="..tostring(isAutorunEnabled))
      f:close()
    end
  end
end

local function findNode(path, create, depth)
  checkArg(1, path, "string")
  depth = depth or 0
  if depth > 100 then
    error("link cycle detected")
  end
  local parts = segments(path)
  local node = mtab
  while #parts > 0 do
    local part = parts[1]
    if not node.children[part] then
      if node.links[part] then
        return findNode(filesystem.concat(node.links[part], table.concat(parts, "/", 2)), create, depth + 1)
      else
        if create then
          node.children[part] = {name=part, parent=node, children={}, links={}}
        else
          local vnode, vrest = node, table.concat(parts, "/")
          local rest = vrest
          while node and not node.fs do
            rest = filesystem.concat(node.name, rest)
            node = node.parent
          end
          return node, rest, vnode, vrest
        end
      end
    end
    node = node.children[part]
    table.remove(parts, 1)
  end
  local vnode, vrest = node, nil
  local rest = nil
  while node and not node.fs do
    rest = rest and filesystem.concat(node.name, rest) or node.name
    node = node.parent
  end
  return node, rest, vnode, vrest
end

local function removeEmptyNodes(node)
  while node and node.parent and not node.fs and not next(node.children) and not next(node.links) do
    node.parent.children[node.name] = nil
    node = node.parent
  end
end

-------------------------------------------------------------------------------

function filesystem.isAutorunEnabled()
  if isAutorunEnabled == nil then
    local env = {}
    local config = loadfile("/etc/filesystem.cfg", nil, env)
    if config then
      pcall(config)
      isAutorunEnabled = not not env.autorun
    else
      isAutorunEnabled = true
    end
    saveConfig()
  end
  return isAutorunEnabled
end

function filesystem.setAutorunEnabled(value)
  checkArg(1, value, "boolean")
  isAutorunEnabled = value
  saveConfig()
end

function filesystem.segments(path)
  return segments(path)
end

function filesystem.canonical(path)
  local result = table.concat(segments(path), "/")
  if unicode.sub(path, 1, 1) == "/" then
    return "/" .. result
  else
    return result
  end
end

function filesystem.concat(pathA, pathB, ...)
  checkArg(1, pathA, "string")
  local function concat(n, a, b, ...)
    if not b then
      return a
    end
    checkArg(n, b, "string")
    return concat(n + 1, a .. "/" .. b, ...)
  end
  return filesystem.canonical(concat(2, pathA, pathB, ...))
end

function filesystem.get(path)
  local node, rest = findNode(path)
  if node.fs then
    local proxy = node.fs
    path = ""
    while node and node.parent do
      path = filesystem.concat(node.name, path)
      node = node.parent
    end
    path = filesystem.canonical(path)
    if path ~= "/" then
      path = "/" .. path
    end
    return proxy, path
  end
  return nil, "no such file system"
end

function filesystem.isLink(path)
  local node, rest, vnode, vrest = findNode(filesystem.path(path))
  if not vrest and vnode.links[filesystem.name(path)] ~= nil then
    return true, vnode.links[filesystem.name(path)]
  end
  return false
end

function filesystem.link(target, linkpath)
  checkArg(1, target, "string")
  checkArg(2, linkpath, "string")

  if filesystem.exists(linkpath) then
    return nil, "file already exists"
  end

  local node, rest, vnode, vrest = findNode(filesystem.path(linkpath), true)
  vnode.links[filesystem.name(linkpath)] = target
  return true
end

function filesystem.mount(fs, path)
  checkArg(1, fs, "string", "table")
  if type(fs) == "string" then
    fs = filesystem.proxy(fs)
  end
  assert(type(fs) == "table", "bad argument #1 (file system proxy or address expected)")
  checkArg(2, path, "string")

  if path ~= "/" and filesystem.exists(path) then
    return nil, "file already exists"
  end

  local node, rest, vnode, vrest = findNode(path, true)
  if vnode.fs then
    return nil, "another filesystem is already mounted here"
  end
  vnode.fs = fs
  return true
end

function filesystem.mounts()
  local function path(node)
    local result = "/"
    while node and node.parent do
      for name, child in pairs(node.parent.children) do
        if child == node then
          result = "/" .. name .. result
          break
        end
      end
      node = node.parent
    end
    return result
  end
  local queue = {mtab}
  return function()
    while #queue > 0 do
      local node = table.remove(queue)
      for _, child in pairs(node.children) do
        table.insert(queue, child)
      end
      if node.fs then
          return node.fs, path(node)
      end
    end
  end
end

function filesystem.path(path)
  local parts = segments(path)
  local result = table.concat(parts, "/", 1, #parts - 1) .. "/"
  if unicode.sub(path, 1, 1) == "/" and unicode.sub(result, 1, 1) ~= "/" then
    return "/" .. result
  else
    return result
  end
end

function filesystem.name(path)
  local parts = segments(path)
  return parts[#parts]
end

function filesystem.proxy(filter)
  checkArg(1, filter, "string")
  local address
  for c in component.list("filesystem", true) do
    if component.invoke(c, "getLabel") == filter then
      address = c
      break
    end
    if c:sub(1, filter:len()) == filter then
      address = c
      break
    end
  end
  if not address then
    return nil, "no such file system"
  end
  return component.proxy(address)
end

function filesystem.umount(fsOrPath)
  checkArg(1, fsOrPath, "string", "table")
  if type(fsOrPath) == "string" then
    local node, rest, vnode, vrest = findNode(fsOrPath)
    if not vrest and vnode.fs then
      vnode.fs = nil
      removeEmptyNodes(vnode)
      return true
    end
  end
  local address = type(fsOrPath) == "table" and fsOrPath.address or fsOrPath
  local result = false
  for proxy, path in filesystem.mounts() do
    local addr = type(proxy) == "table" and proxy.address or proxy
    if string.sub(addr, 1, address:len()) == address then
      local node, rest, vnode, vrest = findNode(path)
      vnode.fs = nil
      removeEmptyNodes(vnode)
      result = true
    end
  end
  return result
end

function filesystem.exists(path)
  local node, rest, vnode, vrest = findNode(path)
  if not vrest or vnode.links[vrest] then -- virtual directory or symbolic link
    return true
  end
  if node and node.fs then
    return node.fs.exists(rest)
  end
  return false
end

function filesystem.size(path)
  local node, rest, vnode, vrest = findNode(path)
  if not vnode.fs and (not vrest or vnode.links[vrest]) then
    return 0 -- virtual directory or symlink
  end
  if node.fs and rest then
    return node.fs.size(rest)
  end
  return 0 -- no such file or directory
end

function filesystem.isDirectory(path)
  local node, rest, vnode, vrest = findNode(path)
  if not vnode.fs and not vrest then
    return true -- virtual directory
  end
  if node.fs then
    return not rest or node.fs.isDirectory(rest)
  end
  return false
end

function filesystem.lastModified(path)
  local node, rest, vnode, vrest = findNode(path)
  if not vnode.fs and not vrest then
    return 0 -- virtual directory
  end
  if node.fs and rest then
    return node.fs.lastModified(rest)
  end
  return 0 -- no such file or directory
end

function filesystem.list(path)
  local node, rest, vnode, vrest = findNode(path)
  if not vnode.fs and vrest and not (node and node.fs) then
    return nil, "no such file or directory"
  end
  local result, reason
  if node and node.fs then
    result, reason = node.fs.list(rest or "")
  end
  result = result or {}
  if not vrest then
    for k in pairs(vnode.children) do
      table.insert(result, k .. "/")
    end
    for k in pairs(vnode.links) do
      table.insert(result, k)
    end
  end
  table.sort(result)
  local i, f = 1, nil
  while i <= #result do
    if result[i] == f then
      table.remove(result, i)
    else
      f = result[i]
      i = i + 1
    end
  end
  local i = 0
  return function()
    i = i + 1
    return result[i]
  end
end

function filesystem.makeDirectory(path)
  if filesystem.exists(path) then
    return nil, "file or directory with that name already exists"
  end
  local node, rest = findNode(path)
  if node.fs and rest then
    return node.fs.makeDirectory(rest)
  end
  if node.fs then
    return nil, "virtual directory with that name already exists"
  end
  return nil, "cannot create a directory in a virtual directory"
end

function filesystem.remove(path)
  local function removeVirtual()
    local node, rest, vnode, vrest = findNode(filesystem.path(path))
    local name = filesystem.name(path)
    if vnode.children[name] then
      vnode.children[name] = nil
      removeEmptyNodes(vnode)
      return true
    elseif vnode.links[name] then
      vnode.links[name] = nil
      removeEmptyNodes(vnode)
      return true
    end
    return false
  end
  local function removePhysical()
    node, rest = findNode(path)
    if node.fs and rest then
      return node.fs.remove(rest)
    end
    return false
  end
  local success = removeVirtual()
  success = removePhysical() or success -- Always run.
  if success then return true
  else return nil, "no such file or directory"
  end
end

function filesystem.rename(oldPath, newPath)
  if filesystem.isLink(oldPath) then
    local node, rest, vnode, vrest = findNode(filesystem.path(oldPath))
    local target = vnode.links[filesystem.name(oldPath)]
    local result, reason = filesystem.link(target, newPath)
    if result then
      filesystem.remove(oldPath)
    end
    return result, reason
  else
    local oldNode, oldRest = findNode(oldPath)
    local newNode, newRest = findNode(newPath)
    if oldNode.fs and oldRest and newNode.fs and newRest then
      if oldNode.fs.address == newNode.fs.address then
        return oldNode.fs.rename(oldRest, newRest)
      else
        local result, reason = filesystem.copy(oldPath, newPath)
        if result then
          return filesystem.remove(oldPath)
        else
          return nil, reason
        end
      end
    end
    return nil, "trying to read from or write to virtual directory"
  end
end

function filesystem.copy(fromPath, toPath)
  if filesystem.isDirectory(fromPath) then
    return nil, "cannot copy folders"
  end
  local input, reason = io.open(fromPath, "rb")
  if not input then
    return nil, reason
  end
  local output, reason = io.open(toPath, "wb")
  if not output then
    input:close()
    return nil, reason
  end
  repeat
    local buffer, reason = input:read(1024)
    if not buffer and reason then
      return nil, reason
    elseif buffer then
      local result, reason = output:write(buffer)
      if not result then
        input:close()
        output:close()
        return nil, reason
      end
    end
  until not buffer
  input:close()
  output:close()
  return true
end

function fileStream:close()
  if self.handle then
    self.fs.close(self.handle)
    self.handle = nil
  end
end

function fileStream:read(n)
  if not self.handle then
    return nil, "file is closed"
  end
  return self.fs.read(self.handle, n)
end

function fileStream:seek(whence, offset)
  if not self.handle then
    return nil, "file is closed"
  end
  return self.fs.seek(self.handle, whence, offset)
end

function fileStream:write(str)
  if not self.handle then
    return nil, "file is closed"
  end
  return self.fs.write(self.handle, str)
end

function filesystem.open(path, mode)
  checkArg(1, path, "string")
  mode = tostring(mode or "r")
  checkArg(2, mode, "string")
  assert(({r=true, rb=true, w=true, wb=true, a=true, ab=true})[mode],
    "bad argument #2 (r[b], w[b] or a[b] expected, got " .. mode .. ")")

  local node, rest = findNode(path)
  if not node.fs or not rest then
    return nil, "file not found"
  end

  local handle, reason = node.fs.open(rest, mode)
  if not handle then
    return nil, reason
  end

  local stream = {fs = node.fs, handle = handle}

  local metatable = {__index = fileStream,
                     __metatable = "filestream"}
  return setmetatable(stream, metatable)
end

-------------------------------------------------------------------------------

return filesystem
Flib/guid.luaÛlocal guid = {}

function guid.toHex(n)
  if type(n) ~= 'number' then
    return nil, string.format("toHex only converts numbers to strings, %s is not a string, but a %s", tostring(n), type(n))
  end
  if n == 0 then
    return '0'
  end

  local hexchars = "0123456789abcdef"
  local result = ""
  local prefix = "" -- maybe later allow for arg to request 0x prefix
  if n < 0 then
    prefix = "-"
    n = -n
  end

  while n > 0 do
    local next = math.floor(n % 16) + 1 -- lua has 1 based array indices
    n = math.floor(n / 16)
    result = hexchars:sub(next, next) .. result
  end

  return prefix .. result
end

function guid.next()
  -- e.g. 3c44c8a9-0613-46a2-ad33-97b6ba2e9d9a
  -- 8-4-4-4-12
  local sets = {8, 4, 4, 12}
  local result = ""

  local i
  for _,set in ipairs(sets) do
    if result:len() > 0 then
      result = result .. "-"
    end
    for i = 1,set do
      result = result .. guid.toHex(math.random(0, 15))
    end
  end

  return result
end

return guid
Flib/image.luaÛ¤
---------------------------------------- OpenComputers Image Format (OCIF) -----------------------------------------------------------

--[[
	
	ÐÐ²ÑÐ¾Ñ: Pornogion
		VK: https://vk.com/id88323331
	Ð¡Ð¾Ð°Ð²ÑÐ¾Ñ: IT
		VK: https://vk.com/id7799889

	ÐÑÐ½Ð¾Ð²Ð½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸:

		image.load(string Ð¿ÑÑÑ): table Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ
			ÐÐ°Ð³ÑÑÐ¶Ð°ÐµÑ ÑÑÑÐµÑÑÐ²ÑÑÑÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð² ÑÐ¾ÑÐ¼Ð°ÑÐµ .pic Ð¸ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ ÐµÐµ
			Ð² ÐºÐ°ÑÐµÑÑÐ²Ðµ Ð¼Ð°ÑÑÐ¸Ð²Ð° (ÑÐ°Ð±Ð»Ð¸ÑÑ).

		image.draw(int x, int y, table Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ)
			Ð Ð¸ÑÑÐµÑ Ð½Ð° ÑÐºÑÐ°Ð½Ðµ Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð½ÑÑ ÑÐ°Ð½ÐµÐµ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼.

		image.save(string Ð¿ÑÑÑ, table Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ [, int Ð¼ÐµÑÐ¾Ð´ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ])
			Ð¡Ð¾ÑÑÐ°Ð½ÑÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¿ÑÑÐ¸ Ð² ÑÐ¾ÑÐ¼Ð°ÑÐµ .pic,
			Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑ Ð¼ÐµÑÐ¾Ð´ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ 3. Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑÐµÑÑÑ
			Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ Ð¸Ð¼ÐµÐ½Ð½Ð¾ ÐµÐ³Ð¾.

	Ð¤ÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸ÐµÐ¼:
		
		image.transform(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int Ð¼Ð°ÑÑÑÐ°Ð± Ð¿Ð¾ ÑÐ¸ÑÐ¸Ð½Ðµ, int Ð¼Ð°ÑÑÑÐ°Ð± Ð¿Ð¾ Ð²ÑÑÐ¾ÑÐµ): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ·Ð¼ÐµÐ½ÑÐµÑ ÑÐ°Ð·Ð¼ÐµÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸ Ð¿Ð¾ Ð¼ÐµÑÐ¾Ð´Ñ Ð¸Ð½ÑÐµÑÐ¿Ð¾Ð»ÑÑÐ¸Ð¸ Ð¿Ð¾ ÑÐ¾ÑÐµÐ´Ð½Ð¸Ð¼ Ð¿Ð¸ÐºÑÐµÐ»ÑÐ¼.
			
		image.expand(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, string Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ, int ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹[, int ÑÐ²ÐµÑ ÑÐ¾Ð½Ð°, int ÑÐ²ÐµÑ ÑÐµÐºÑÑÐ°, int Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ, char ÑÐ¸Ð¼Ð²Ð¾Ð»]): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			Ð Ð°ÑÑÐ¸ÑÑÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð² ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸ (fromRight, fromLeft, fromTop, fromBottom),
			ÑÐ¾Ð·Ð´Ð°Ð²Ð°Ñ Ð¿ÑÐ¸ ÑÑÐ¾Ð¼ Ð¿ÑÑÑÑÐµ Ð±ÐµÐ»ÑÐµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸. ÐÑÐ»Ð¸ ÑÐºÐ°Ð·Ð°Ð½Ñ Ð¾Ð¿ÑÐ¸Ð¾Ð½Ð°Ð»ÑÐ½ÑÐµ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÑ, ÑÐ¾ Ð²Ð¼ÐµÑÑÐ¾ Ð¿ÑÑÑÑÑ
			Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹ Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ Ð²Ð¿Ð¾Ð»Ð½Ðµ ÐºÐ¾Ð½ÐºÑÐµÑÐ½ÑÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ.

		image.crop(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, string Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ðµ, int ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ±ÑÐµÐ·Ð°ÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð² ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸ (fromRight, fromLeft, fromTop, fromBottom),
			ÑÐ´Ð°Ð»ÑÑ Ð»Ð¸ÑÐ½Ð¸Ðµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸.

		image.rotate(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int ÑÐ³Ð¾Ð»): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ¾Ð²Ð¾ÑÐ°ÑÐ¸Ð²Ð°ÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð½Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ ÑÐ³Ð¾Ð». Ð£Ð³Ð¾Ð» Ð¼Ð¾Ð¶ÐµÑ Ð¸Ð¼ÐµÑÑ
			Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ 90, 180 Ð¸ 270 Ð³ÑÐ°Ð´ÑÑÐ¾Ð².

		image.flipVertical(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÑÑÐ°Ð¶Ð°ÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð¿Ð¾ Ð²ÐµÑÑÐ¸ÐºÐ°Ð»Ð¸.

		image.flipHorizontal(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÑÑÐ°Ð¶Ð°ÐµÑ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð¿Ð¾ Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ð¸.

	Ð¤ÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ ÑÐ²ÐµÑÐ¾Ð¼:

		image.hueSaturationBrightness(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int ÑÐ¾Ð½, int Ð½Ð°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÑ, int ÑÑÐºÐ¾ÑÑÑ): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ¾ÑÑÐµÐºÑÐ¸ÑÑÐµÑ ÑÐ²ÐµÑÐ¾Ð²Ð¾Ð¹ ÑÐ¾Ð½, Ð½Ð°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÑ Ð¸ ÑÑÐºÐ¾ÑÑÑ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸.
			ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ¾Ð² Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ Ð¾ÑÑÐ¸ÑÐ°ÑÐµÐ»ÑÐ½ÑÐ¼Ð¸ Ð´Ð»Ñ ÑÐ¼ÐµÐ½ÑÑÐµÐ½Ð¸Ñ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ°
			Ð¸ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸ÑÐµÐ»ÑÐ½ÑÐ¼Ð¸ Ð´Ð»Ñ ÐµÐ³Ð¾ ÑÐ²ÐµÐ»Ð¸ÑÐµÐ½Ð¸Ñ. ÐÑÐ»Ð¸ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ, Ðº Ð¿ÑÐ¸Ð¼ÐµÑÑ, Ð½Ð°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÐ¸
			Ð¼ÐµÐ½ÑÑÑ Ð½Ðµ ÑÑÐµÐ±ÑÐµÑÑÑ, Ð¿ÑÐ¾ÑÑÐ¾ ÑÐºÐ°Ð·ÑÐ²Ð°Ð¹ÑÐµ 0.
			
			ÐÐ»Ñ ÑÐ´Ð¾Ð±ÑÑÐ²Ð° Ð²Ñ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ ÑÐ»ÐµÐ´ÑÑÑÐ¸Ðµ ÑÐ¾ÐºÑÐ°ÑÐµÐ½Ð¸Ñ:
				image.hue(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int ÑÐ¾Ð½): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
				image.saturation(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int Ð½Ð°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÑ): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
				image.brightness(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int ÑÑÐºÐ¾ÑÑÑ): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
				image.blackAndWhite(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°

		image.colorBalance(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int ÐºÑÐ°ÑÐ½ÑÐ¹, int Ð·ÐµÐ»ÐµÐ½ÑÐ¹, int ÑÐ¸Ð½Ð¸Ð¹): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ¾ÑÑÐµÐºÑÐ¸ÑÑÐµÑ ÑÐ²ÐµÑÐ¾Ð²ÑÐµ ÐºÐ°Ð½Ð°Ð»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸. ÐÑÐ³ÑÐ¼ÐµÐ½ÑÑ ÑÐ²ÐµÑÐ¾Ð²ÑÑ
			ÐºÐ°Ð½Ð°Ð»Ð¾Ð² Ð¼Ð¾Ð³ÑÑ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÑÑ ÐºÐ°Ðº Ð¾ÑÑÐ¸ÑÐ°ÑÐµÐ»ÑÐ½ÑÐµ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð´Ð»Ñ ÑÐ¼ÐµÐ½ÑÑÐµÐ½Ð¸Ñ Ð¸Ð½ÑÐµÐ½ÑÐ¸Ð²Ð½Ð¾ÑÑÐ¸ ÐºÐ°Ð½Ð°Ð»Ð°,
			ÑÐ°Ðº Ð¸ Ð¿Ð¾Ð»Ð¾Ð¶Ð¸ÑÐµÐ»ÑÐ½ÑÐµ Ð´Ð»Ñ ÑÐ²ÐµÐ»Ð¸ÑÐµÐ½Ð¸Ñ.

		image.invert(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ½Ð²ÐµÑÑÐ¸ÑÑÐµÑ ÑÐ²ÐµÑÐ° Ð² ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ ÐºÐ°ÑÑÐ¸Ð½ÐºÐµ.

		image.photoFilter(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int ÑÐ²ÐµÑ, int Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ°ÐºÐ»Ð°Ð´ÑÐ²Ð°ÐµÑ Ð½Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ ÑÐ¾ÑÐ¾ÑÐ¸Ð»ÑÑÑ Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑÑ.
			ÐÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð¾Ñ 0 Ð´Ð¾ 255.

		image.replaceColor(table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°, int Ð·Ð°Ð¼ÐµÐ½ÑÐµÐ¼ÑÐ¹Ð¦Ð²ÐµÑ, int ÑÐ²ÐµÑÐÐ»ÑÐÐ°Ð¼ÐµÐ½Ñ): table ÐºÐ°ÑÑÐ¸Ð½ÐºÐ°
			ÐÐ°Ð¼ÐµÐ½ÑÐµÑ Ð² ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸ Ð¾Ð´Ð¸Ð½ ÐºÐ¾Ð½ÐºÑÐµÑÐ½ÑÐ¹ ÑÐ²ÐµÑ Ð½Ð° Ð´ÑÑÐ³Ð¾Ð¹.
]]

--------------------------------------- ÐÐ¾Ð´Ð³ÑÑÐ·ÐºÐ° Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐº --------------------------------------------------------------

local component = require("component")
local unicode = require("unicode")
local fs = require("filesystem")
local colorlib = require("colorlib")
local bit32 = require("bit32")

local image = {}

-------------------------------------------- ÐÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ -------------------------------------------------------------------

--ÐÐ¾Ð½ÑÑÐ°Ð½ÑÑ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ
local constants = {
	OCIFSignature = "OCIF",
	OCIF2Elements = {
		alphaStart = "A",
		symbolStart = "S",
		backgroundStart = "B",
		foregroundStart = "F",
	},
	elementCount = 4,
	byteSize = 8,
	nullChar = 0,
	rawImageLoadStep = 19,
	compressedFileFormat = ".pic",
	pngFileFormat = ".png",
}

---------------------------------------- ÐÐ¾ÐºÐ°Ð»ÑÐ½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ -------------------------------------------------------------------

--Ð¤Ð¾ÑÐ¼ÑÐ»Ð° ÐºÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ð¸ Ð¸Ð½Ð´ÐµÐºÑÐ° Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð² Ð°Ð±ÑÐ¾Ð»ÑÑÐ½ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local function convertIndexToCoords(index, width)
	--ÐÑÐ¸Ð²Ð¾Ð´Ð¸Ð¼ Ð¸Ð½Ð´ÐµÐºÑ Ðº ÐºÐ¾ÑÑÐµÐºÑÐ½Ð¾Ð¼Ñ Ð²Ð¸Ð´Ñ (1 = 1, 4 = 2, 7 = 3, 10 = 4, 13 = 5, ...)
	index = (index + constants.elementCount - 1) / constants.elementCount
	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¾ÑÑÐ°ÑÐ¾Ðº Ð¾Ñ Ð´ÐµÐ»ÐµÐ½Ð¸Ñ Ð¸Ð½Ð´ÐµÐºÑÐ° Ð½Ð° ÑÐ¸ÑÐ¸Ð½Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
	local ostatok = index % width
	--ÐÑÐ»Ð¸ Ð¾ÑÑÐ°ÑÐ¾Ðº ÑÐ°Ð²ÐµÐ½ 0, ÑÐ¾ Ñ ÑÐ°Ð²ÐµÐ½ ÑÐ¸ÑÐ¸Ð½Ðµ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ, Ð° ÐµÑÐ»Ð¸ Ð½ÐµÑ, ÑÐ¾ Ñ ÑÐ°Ð²ÐµÐ½ Ð¾ÑÑÐ°ÑÐºÑ
	local x = (ostatok == 0) and width or ostatok
	--Ð ÑÐµÐ¿ÐµÑÑ ÐºÐ°Ðº Ð´Ð²Ð° Ð¿Ð°Ð»ÑÑÐ° Ð¿Ð¾Ð»ÑÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¿Ð¾ Y
	local y = math.ceil(index / width)
	--ÐÑÐ¸ÑÐ°ÐµÐ¼ Ð¾ÑÑÐ°ÑÐ¾Ðº Ð¸Ð· Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²ÐºÐ¸
	ostatok = nil
	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ
	return x, y
end

--Ð¤Ð¾ÑÐ¼ÑÐ»Ð° ÐºÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ð¸ Ð°Ð±ÑÐ¾Ð»ÑÑÐ½ÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð² Ð¸Ð½Ð´ÐµÐºÑ Ð´Ð»Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local function convertCoordsToIndex(x, y, width)
	return (width * (y - 1) + x) * constants.elementCount - constants.elementCount + 1
end

--ÐÐ¾ÑÑÑÐ»ÑÐ½Ð¾Ðµ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÐ°Ð·Ð¼ÐµÑÐ° Ð¼Ð°ÑÑÐ¸Ð²Ð°, Ð¸Ð±Ð¾ Ð°Ð²ÑÐ¾Ñ Ð»ÑÐ° Ð½Ðµ Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ
--Ð¿Ð¾Ð´ÑÑÐ¸ÑÑÐ²Ð°ÑÑ Ð½ÐµÐ½ÑÐ¼ÐµÑÐ¸ÑÐµÑÐºÐ¸Ðµ Ð¸Ð½Ð´ÐµÐºÑÑ ÑÐµÑÐµÐ· #massiv
--Ð¼Ð´Ð°, Ð¼Ð´Ð°
--...
--Ð¼Ð´Ð°
local function getArraySize(array)
	local size = 0
	for key in pairs(array) do
		size = size + 1
	end
	return size
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð±Ð°Ð¹Ñ, ÐºÐ¾ÑÐ¾ÑÐ¾Ðµ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¸Ð·Ð²Ð»ÐµÑÑ Ð¸Ð· ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ¸ÑÐ»Ð°
local function getCountOfBytes(number)
	if number == 0 or number == 1 then return 1 end
	return math.ceil(math.log(number, 256))
end

--Ð Ð°ÑÐ¿Ð¸Ð´Ð¾ÑÐ°ÑÐ¸ÑÑ ÑÐ¸ÑÐ»Ð¾ Ð½Ð° ÑÐ¾ÑÑÐ°Ð²Ð»ÑÑÑÐ¸Ðµ Ð±Ð°Ð¹ÑÑ
local function extractBytesFromNumber(number, countOfBytesToExtract)
	local bytes = {}
	local byteCutter = 0xff
	for i = 1, countOfBytesToExtract do
		table.insert(bytes, 1, bit32.rshift(bit32.band(number, byteCutter), (i-1)*8))
		byteCutter = bit32.lshift(byteCutter, 8)
	end
	return table.unpack(bytes)
end

--Ð¡ÐºÐ»ÐµÐ¸ÑÑ Ð±Ð°Ð¹ÑÑ Ð¸ ÑÐ¾Ð·Ð´Ð°ÑÑ Ð¸Ð· Ð½Ð¸Ñ ÑÐ¸ÑÐ»Ð¾
local function mergeBytesToNumber(...)
	local bytes = {...}
	local finalNumber = bytes[1]
	for i = 2, #bytes do
		finalNumber = bit32.bor(bit32.lshift(finalNumber, 8), bytes[i])
	end
	return finalNumber
end

-- Ð¡ÐºÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð²ÑÐµ Ð¿ÐµÑÐµÐ´Ð°Ð½Ð½ÑÐµ Ð±Ð°Ð¹ÑÑ Ð² ÑÑÑÐ¾ÐºÑ
local function convertBytesToString(...)
	local bytes = {...}
	for i = 1, #bytes do
		bytes[i] = string.char(bytes[i])
	end
	return table.concat(bytes)
end

--ÐÑÐ´ÐµÐ»Ð¸ÑÑ Ð±Ð¸Ñ-ÑÐµÑÐ¼Ð¸Ð½Ð°ÑÐ¾Ñ Ð² Ð¿ÐµÑÐ²Ð¾Ð¼ Ð±Ð°Ð¹ÑÐµ UTF-8 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°: 1100 0010 --> 0010 0000
local function selectTerminateBit_l()
	local prevByte = nil
	local prevTerminateBit = nil

	return function( byte )
		local x, terminateBit = nil
		if ( prevByte == byte ) then
			return prevTerminateBit
		end

		x = bit32.band( bit32.bnot(byte), 0x000000FF )
		x = bit32.bor( x, bit32.rshift(x, 1) )
		x = bit32.bor( x, bit32.rshift(x, 2) )
		x = bit32.bor( x, bit32.rshift(x, 4) )
		x = bit32.bor( x, bit32.rshift(x, 8) )
		x = bit32.bor( x, bit32.rshift(x, 16) )

		terminateBit = x - bit32.rshift(x, 1)

		prevByte = byte
		prevTerminateBit = terminateBit

		return terminateBit
	end
end
local selectTerminateBit = selectTerminateBit_l()

--ÐÑÐ¾ÑÐ¸ÑÐ°ÑÑ n Ð±Ð°Ð¹ÑÐ¾Ð² Ð¸Ð· ÑÐ°Ð¹Ð»Ð°, Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ Ð¿ÑÐ¾ÑÐ¸ÑÐ°Ð½Ð½ÑÐµ Ð±Ð°Ð¹ÑÑ ÐºÐ°Ðº ÑÐ¸ÑÐ»Ð¾, ÐµÑÐ»Ð¸ Ð½Ðµ ÑÐ´Ð°Ð»Ð¾ÑÑ Ð¿ÑÐ¾ÑÐ¸ÑÐ°ÑÑ, ÑÐ¾ Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ 0
local function readBytes(file, count)
  local readedBytes = file:read(count)
  return mergeBytesToNumber(string.byte(readedBytes, 1, count))
end

--ÐÐ¾Ð´Ð³Ð¾ÑÐ°Ð²Ð»Ð¸Ð²Ð°ÐµÑ ÑÐ²ÐµÑÐ° Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð´Ð»Ñ Ð·Ð°Ð¿Ð¸ÑÐ¸ Ð² ÑÐ°Ð¹Ð» ÑÐ¶Ð°ÑÐ¾Ð³Ð¾ ÑÐ¾ÑÐ¼Ð°ÑÐ°
local function encodePixel(background, foreground, alpha, char)
	--Ð Ð°ÑÑÐµÑÐ°ÑÐ¸Ð²Ð°ÐµÐ¼ Ð¶Ð¸ÑÐ½ÑÐµ ÑÐ²ÐµÑÐ° Ð² ÐºÐ¾Ð¼Ð¿Ð°ÐºÑÐ½ÑÐµ ÑÐ²ÐµÑÐ°
	local ascii_background1, ascii_background2, ascii_background3 = colorlib.HEXtoRGB(background)
	local ascii_foreground1, ascii_foreground2, ascii_foreground3 = colorlib.HEXtoRGB(foreground)
	--Ð Ð°ÑÑÐµÑÐ°ÑÐ¸Ð²Ð°ÐµÐ¼ Ð¶Ð¸ÑÐ½ÑÐ¹ ÐºÐ¾Ð´ ÑÐ½Ð¸ÐºÐ¾Ð´-ÑÐ¸Ð¼Ð²Ð¾Ð»Ð° Ð² Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ Ð¼Ð¸Ð»ÐµÐ½ÑÐºÐ¸Ñ ascii-ÐºÐ¾Ð´Ð¾Ð²
	local ascii_char1, ascii_char2, ascii_char3, ascii_char4, ascii_char5, ascii_char6 = string.byte( char, 1, 6 )
	ascii_char1 = ascii_char1 or constants.nullChar
	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð²ÑÐµ ÑÐ°ÑÑÐµÑÐ°ÑÐµÐ½Ð½Ð¾Ðµ
	return ascii_background1, ascii_background2, ascii_background3, ascii_foreground1, ascii_foreground2, ascii_foreground3, alpha, ascii_char1, ascii_char2, ascii_char3, ascii_char4, ascii_char5, ascii_char6
end

--ÐÐµÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ UTF-8 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°
local function decodeChar(file)
	local first_byte = readBytes(file, 1)
	local charcode_array = {first_byte}
	local len = 1

	local middle = selectTerminateBit(first_byte)
	if ( middle == 32 ) then
		len = 2
	elseif ( middle == 16 ) then 
		len = 3
	elseif ( middle == 8 ) then
		len = 4
	elseif ( middle == 4 ) then
		len = 5
	elseif ( middle == 2 ) then
		len = 6
	end

	for i = 1, len-1 do
		table.insert( charcode_array, readBytes(file, 1) )
	end

	return string.char( table.unpack( charcode_array ) )
end

--ÐÑÐ°Ð²Ð¸Ð»ÑÐ½Ð¾Ðµ ÐºÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ðµ HEX-Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½Ð¾Ð¹ Ð² ÑÑÑÐ¾ÐºÐ¾Ð²ÑÑ
local function HEXtoSTRING(color, bitCount, withNull)
	local stro4ka = string.format("%X",color)
	local sStro4ka = unicode.len(stro4ka)

	if sStro4ka < bitCount then
		stro4ka = string.rep("0", bitCount - sStro4ka) .. stro4ka
	end

	sStro4ka = nil

	if withNull then return "0x"..stro4ka else return stro4ka end
end

--ÐÐ¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÐ¾ÑÐ¼Ð°ÑÐ° ÑÐ°Ð¹Ð»Ð°
local function getFileFormat(path)
	local name = fs.name(path)
	local starting, ending = string.find(name, "(.)%.[%d%w]*$")
	if starting == nil then
		return nil
	else
		return unicode.sub(name, starting + 1, -1)
	end
	name, starting, ending = nil, nil, nil
end

--ÐÑÐ¾ÑÐµÑÑÑ ÑÐ¸Ð³Ð½Ð°ÑÑÑÑ ÑÐ°Ð¹Ð»Ð° Ð¸ ÑÑÐ°Ð²Ð½Ð¸ÑÑ ÐµÐµ Ñ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÐ¾Ð¹
local function readSignature(file)
	local readedSignature = file:read(4)
	if readedSignature ~= constants.OCIFSignature then
		file:close()
		error("Can't load file: wrong OCIF format signature (\""..readedSignature .. "\" ~= \"" ..constants.OCIFSignature .. "\")")
	end
end

--ÐÐ°Ð¿Ð¸ÑÐ°ÑÑ ÑÐ¸Ð³Ð½Ð°ÑÑÑÑ Ð² ÑÐ°Ð¹Ð»
local function writeSignature(file)
	file:write(constants.OCIFSignature)
end

--Ð¡Ð¶Ð°ÑÑ Ð²ÑÐµ ÑÐ²ÐµÑÐ° Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸ Ð² 8-Ð±Ð¸ÑÐ½ÑÑ Ð¿Ð°Ð»Ð¸ÑÑÑ
local function convertImageColorsTo8Bit(picture)
	for i = 1, #picture, 4 do
		picture[i] = colorlib.convert24BitTo8Bit(picture[i])
		picture[i + 1] = colorlib.convert24BitTo8Bit(picture[i + 1])
		if i % 505 == 0 then os.sleep(0) end
	end
	return picture
end

--Ð Ð°ÑÐ¶Ð°ÑÑ Ð²ÑÐµ ÑÐ²ÐµÑÐ° Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸ Ð² 24-Ð±Ð¸ÑÐ½ÑÑ Ð¿Ð°Ð»Ð¸ÑÑÑ
local function convertImageColorsTo24Bit(picture)
	for i = 1, #picture, 4 do
		picture[i] = colorlib.convert8BitTo24Bit(picture[i])
		picture[i + 1] = colorlib.convert8BitTo24Bit(picture[i + 1])
		if i % 505 == 0 then os.sleep(0) end
	end
	return picture
end

------------------------------ ÐÑÐµ, ÑÑÐ¾ ÐºÐ°ÑÐ°ÐµÑÑÑ ÑÐ¾ÑÐ¼Ð°ÑÐ° OCIF1 ------------------------------------------------------------

-- ÐÐ°Ð¿Ð¸ÑÑ Ð² ÑÐ°Ð¹Ð» ÑÐ¶Ð°ÑÐ¾Ð³Ð¾ OCIF-ÑÐ¾ÑÐ¼Ð°ÑÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local function saveOCIF1(file, picture)
	local encodedPixel
	file:write( string.char( picture.width  ) )
	file:write( string.char( picture.height ) )
	
	for i = 1, picture.width * picture.height * constants.elementCount, constants.elementCount do
		encodedPixel =
		{
			encodePixel(picture[i], picture[i + 1], picture[i + 2], picture[i + 3])
		}
		for j = 1, #encodedPixel do
			file:write( string.char( encodedPixel[j] ) )
		end
	end

	file:close()
end

--Ð§ÑÐµÐ½Ð¸Ðµ Ð¸Ð· ÑÐ°Ð¹Ð»Ð° ÑÐ¶Ð°ÑÐ¾Ð³Ð¾ OCIF-ÑÐ¾ÑÐ¼Ð°ÑÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ, Ð²Ð¾Ð·Ð²ÑÐ°ÑÐ°ÐµÑ Ð¼Ð°ÑÑÐ¸Ð² ÑÐ¸Ð¿Ð° 2 (Ð¿Ð¾Ð´ÑÐ¾Ð±Ð½ÐµÐµ Ð¾ ÑÐ¸Ð¿Ð°Ñ ÑÐ¼. ÐºÐ¾Ð½ÐµÑ ÑÐ°Ð¹Ð»Ð°)
local function loadOCIF1(file)
	local picture = {}

	--Ð§Ð¸ÑÐ°ÐµÐ¼ ÑÐ¸ÑÐ¸Ð½Ñ Ð¸ Ð²ÑÑÐ¾ÑÑ ÑÐ°Ð¹Ð»Ð°
	picture.width = readBytes(file, 1)
	picture.height = readBytes(file, 1)

	for i = 1, picture.width * picture.height do
		--Ð§Ð¸ÑÐ°ÐµÐ¼ Ð±ÐµÐºÐ³ÑÐ°ÑÐ½Ð´
		table.insert(picture, readBytes(file, 3))
		--Ð§Ð¸ÑÐ°ÐµÐ¼ ÑÐ¾ÑÐ³ÑÐ°ÑÐ½Ð´
		table.insert(picture, readBytes(file, 3))
		--Ð§Ð¸ÑÐ°ÐµÐ¼ Ð°Ð»ÑÑÑ
		table.insert(picture, readBytes(file, 1))
		--Ð§Ð¸ÑÐ°ÐµÐ¼ ÑÐ¸Ð¼Ð²Ð¾Ð»
		table.insert(picture, decodeChar( file ))
	end

	file:close()

	return picture
end

------------------------------------------ ÐÑÐµ, ÑÑÐ¾ ÐºÐ°ÑÐ°ÐµÑÑÑ ÑÐ¾ÑÐ¼Ð°ÑÐ° OCIF2 ------------------------------------------------

local function saveOCIF2(file, picture, compressColors)
	--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ¸ÑÐ¸Ð½Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
	file:write(string.char(picture.width))
	file:write(string.char(picture.height))

	--ÐÑÑÐ¿Ð¿Ð¸ÑÑÐµÐ¼ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ
	local grouppedPucture = image.convertToGroupedImage(picture)

	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð²ÑÐµ Ð°Ð»ÑÑÑ
	for alpha in pairs(grouppedPucture) do
		--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð°, ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÐµÐ³Ð¾ ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ
		local arraySize = getArraySize(grouppedPucture[alpha])
		local countOfBytesForArraySize = getCountOfBytes(arraySize)
		--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð² ÑÐ°Ð¹Ð» ÑÐ¸Ð¼Ð²Ð¾Ð» ÐÐ»ÑÑÐ°Ð¡ÑÐ°ÑÑÐ°, ÑÐ°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð°Ð»ÑÑÑ Ð¸ ÑÐ°Ð¼Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ Ð°Ð»ÑÑÑ
		file:write(
			constants.OCIF2Elements.alphaStart,
			string.char(countOfBytesForArraySize),
			convertBytesToString(extractBytesFromNumber(arraySize, countOfBytesForArraySize)),
			string.char(alpha)
		)
		
		for symbol in pairs(grouppedPucture[alpha]) do
			--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº
			file:write(constants.OCIF2Elements.symbolStart)
			--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð²ÑÐµÑ ÑÐ²ÐµÑÐ¾Ð² ÑÐµÐºÑÑÐ° Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð»
			if compressColors then
				file:write(
					string.char(getArraySize(grouppedPucture[alpha][symbol])),
					convertBytesToString(string.byte(symbol, 1, 6))
				)
			else
				file:write(	
					convertBytesToString(extractBytesFromNumber(getArraySize(grouppedPucture[alpha][symbol]), 3)),
					convertBytesToString(string.byte(symbol, 1, 6))
				)
			end
		
			for foreground in pairs(grouppedPucture[alpha][symbol]) do
				--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº
				file:write(constants.OCIF2Elements.foregroundStart)
				--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐ²ÐµÑÐ¾Ð² ÑÐ¾Ð½Ð° Ð¸ ÑÐ²ÐµÑ ÑÐµÐºÑÑÐ°
				if compressColors then
					file:write(
						string.char(getArraySize(grouppedPucture[alpha][symbol][foreground])),
						string.char(foreground)
					)
				else
					file:write(
						convertBytesToString(extractBytesFromNumber(getArraySize(grouppedPucture[alpha][symbol][foreground]), 3)),
						convertBytesToString(extractBytesFromNumber(foreground, 3))
					)
				end
		
				for background in pairs(grouppedPucture[alpha][symbol][foreground]) do
					--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº Ð¸ ÑÐ°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ
					file:write(
							constants.OCIF2Elements.backgroundStart,
							convertBytesToString(extractBytesFromNumber(getArraySize(grouppedPucture[alpha][symbol][foreground][background]), 2))
					)
					--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ²ÐµÑ ÑÐ¾Ð½Ð°
					if compressColors then
						file:write(string.char(background))
					else
						file:write(convertBytesToString(extractBytesFromNumber(background, 3)))
					end
			
					--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ
					for y in pairs(grouppedPucture[alpha][symbol][foreground][background]) do
						--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ, ÑÐ°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° y Ð¸ ÑÐ°Ð¼Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ y
						file:write(
							"Y",
							string.char(getArraySize(grouppedPucture[alpha][symbol][foreground][background][y])),
							string.char(y)
						)
						--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÐÐÐ¡Ð«Ð«Ð«
						--Ð«
						for i = 1, #grouppedPucture[alpha][symbol][foreground][background][y] do
							file:write(string.char(grouppedPucture[alpha][symbol][foreground][background][y][i]))
						end
					end
				end
			end
		end
	end

	file:close()
end

local function loadOCIF2(file, decompressColors, useOCIF4)
	local picture = {}

	--Ð§Ð¸ÑÐ°ÐµÐ¼ ÑÐ°Ð·Ð¼ÐµÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
	local readedWidth = string.byte(file:read(1))
	local readedHeight = string.byte(file:read(1))
	picture.width = readedWidth
	picture.height = readedHeight

	local header, alpha, symbol, foreground, background, y, alphaSize, symbolSize, foregroundSize, backgroundSize, ySize = ""
	while true do
		header = file:read(1)
		if not header then break end
		-- print("----------------------")
		-- print("ÐÐ°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº: " .. header)

		if header == "A" then
			local countOfBytesForArraySize = string.byte(file:read(1))
			alphaSize = string.byte(file:read(countOfBytesForArraySize))
			alpha = string.byte(file:read(1))
			-- print("ÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð±Ð°Ð¹Ñ Ð¿Ð¾Ð´ ÑÐ°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: " .. countOfBytesForArraySize)
			-- print("Ð Ð°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²: " .. alphaSize)
			-- print("ÐÐ»ÑÑÐ°: " .. alpha)

		elseif header == "S" then
			if decompressColors then
				symbolSize = string.byte(file:read(1))
			else
				symbolSize = mergeBytesToNumber(string.byte(file:read(3), 1, 3))
			end
			symbol = decodeChar(file)
			-- print("Ð Ð°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ°: " .. symbolSize)
			-- print("Ð¡Ð¸Ð¼Ð²Ð¾Ð»: \"" .. symbol .. "\"")

		elseif header == "F" then
			if decompressColors then
				foregroundSize = string.byte(file:read(1))
				foreground = colorlib.convert8BitTo24Bit(string.byte(file:read(1)))
			else
				foregroundSize = mergeBytesToNumber(string.byte(file:read(3), 1, 3))
				foreground = mergeBytesToNumber(string.byte(file:read(3), 1, 3))
			end
			-- print("Ð Ð°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° ÑÐ²ÐµÑÐ° ÑÐ¾Ð½Ð°: " .. foregroundSize)
			-- print("Ð¦Ð²ÐµÑ ÑÐµÐºÑÑÐ°: " .. foreground)

		elseif header == "B" then
			backgroundSize = mergeBytesToNumber(string.byte(file:read(2), 1, 2))
			if decompressColors then
				background = colorlib.convert8BitTo24Bit(string.byte(file:read(1)))
			else
				background = mergeBytesToNumber(string.byte(file:read(3), 1, 3))
			end
			-- print("Ð Ð°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ: " .. backgroundSize)
			-- print("Ð¦Ð²ÐµÑ ÑÐ¾Ð½Ð°: " .. background)

			--ÐÐ¾Ð´Ð´ÐµÑÐ¶ÐºÐ° Ð·Ð°Ð³ÑÑÐ·ÐºÐ¸ ÑÐ¾ÑÐ¼Ð°ÑÐ° OCIF3
			if not useOCIF4 then
				--Ð§Ð¸ÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ
				for i = 1, backgroundSize, 2 do
					local x = string.byte(file:read(1))
					local y = string.byte(file:read(1))
					local index = convertCoordsToIndex(x, y, readedWidth)
					-- print("ÐÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°: " .. x .. "x" .. y .. ", Ð¸Ð½Ð´ÐµÐºÑ: "..index)

					picture[index] = background
					picture[index + 1] = foreground
					picture[index + 2] = alpha
					picture[index + 3] = symbol
				end	
			end

		--ÐÐ¾Ð²ÑÐ¹ ÑÐ¾ÑÐ¼Ð°Ñ OCIF4
		elseif header == "Y" and useOCIF4 then
			ySize = string.byte(file:read(1))
			y = string.byte(file:read(1))
			-- print("Ð Ð°Ð·Ð¼ÐµÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° Y: " .. ySize)
			-- print("Ð¢ÐµÐºÑÑÐ¸Ð¹ Y: " .. y)

			for i = 1, ySize do
				local x = string.byte(file:read(1))
				local index = convertCoordsToIndex(x, y, readedWidth)
				-- print("ÐÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°: " .. x .. "x" .. y .. ", Ð¸Ð½Ð´ÐµÐºÑ: "..index)

				picture[index] = background
				picture[index + 1] = foreground
				picture[index + 2] = alpha
				picture[index + 3] = symbol
			end		
		else
			error("Error while reading OCIF format: unknown Header type (" .. header .. ")")
		end

	end

	file:close()

	return picture
end

------------------------------ ÐÑÐµ, ÑÑÐ¾ ÐºÐ°ÑÐ°ÐµÑÑÑ ÑÐ¾ÑÐ¼Ð°ÑÐ° RAW ------------------------------------------------------------

--Ð¡Ð¾ÑÑÐ°Ð½ÐµÐ½Ð¸Ðµ Ð² ÑÐ°Ð¹Ð» ÑÑÑÐ¾Ð³Ð¾ ÑÐ¾ÑÐ¼Ð°ÑÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð° 2 (Ð¿Ð¾Ð´ÑÐ¾Ð±Ð½ÐµÐµ Ð¾ ÑÐ¸Ð¿Ð°Ñ ÑÐ¼. ÐºÐ¾Ð½ÐµÑ ÑÐ°Ð¹Ð»Ð°)
local function saveRaw(file, picture)

	file:write("\n")

	local xPos, yPos = 1, 1
	for i = 1, picture.width * picture.height * constants.elementCount, constants.elementCount do
		file:write( HEXtoSTRING(picture[i], 6), " ", HEXtoSTRING(picture[i + 1], 6), " ", HEXtoSTRING(picture[i + 2], 2), " ", picture[i + 3], " ")

		xPos = xPos + 1
		if xPos > picture.width then
			xPos = 1
			yPos = yPos + 1
			file:write("\n")
		end
	end

	file:close()
end

--ÐÐ°Ð³ÑÑÐ·ÐºÐ° Ð¸Ð· ÑÐ°Ð¹Ð»Ð° ÑÑÑÐ¾Ð³Ð¾ ÑÐ¾ÑÐ¼Ð°ÑÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð° 2 (Ð¿Ð¾Ð´ÑÐ¾Ð±Ð½ÐµÐµ Ð¾ ÑÐ¸Ð¿Ð°Ñ ÑÐ¼. ÐºÐ¾Ð½ÐµÑ ÑÐ°Ð¹Ð»Ð°)
local function loadRaw(file)
	--Ð§Ð¸ÑÐ°ÐµÐ¼ Ð¾Ð´Ð¸Ð½ Ð±Ð°Ð¹Ñ "Ð¿ÑÐ¾ÑÑ ÑÐ°Ðº"
	file:read(1)

	local picture = {}
	local background, foreground, alpha, symbol, sLine
	local lineCounter = 0

	for line in file:lines() do
		sLine = unicode.len(line)
		for i = 1, sLine, constants.rawImageLoadStep do
			background = "0x" .. unicode.sub(line, i, i + 5)
			foreground = "0x" .. unicode.sub(line, i + 7, i + 12)
			alpha = "0x" .. unicode.sub(line, i + 14, i + 15)
			symbol = unicode.sub(line, i + 17, i + 17)

			table.insert(picture, tonumber(background))
			table.insert(picture, tonumber(foreground))
			table.insert(picture, tonumber(alpha))
			table.insert(picture, symbol)
		end
		lineCounter = lineCounter + 1
	end

	picture.width = sLine / constants.rawImageLoadStep
	picture.height = lineCounter

	file:close()
	return picture
end

----------------------------------- ÐÑÐµ, ÑÑÐ¾ ÐºÐ°ÑÐ°ÐµÑÑÑ ÑÐµÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ PNG-ÑÐ¾ÑÐ¼Ð°ÑÐ° ------------------------------------------------------------

function image.loadPng(path)
	if not _G.libPNGImage then _G.libPNGImage = require("libPNGImage") end

	local success, pngImageOrErrorMessage = pcall(libPNGImage.newFromFile, path)

	if not success then
		io.stderr:write(" * PNGView: PNG Loading Error *\n")
		io.stderr:write("While attempting to load '" .. path .. "' as PNG, libPNGImage erred:\n")
		io.stderr:write(pngImageOrErrorMessage)
		return
	end

	local picture = {}
	picture.width, picture.height = pngImageOrErrorMessage:getSize()

	local r, g, b, a, hex
	for j = 0, picture.height - 1 do
		for i = 0, picture.width - 1 do
			r, g, b, a = pngImageOrErrorMessage:getPixel(i, j)

			if r and g and b and a and a > 0 then
				hex = colorlib.RGBtoHEX(r, g, b)
				table.insert(picture, hex)
				table.insert(picture, 0x000000)
				table.insert(picture, 0x00)
				table.insert(picture, " ")
			end

		end
	end

	return picture
end

----------------------------------- ÐÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ ------------------------------------------------------------

--ÐÐ¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð¸ ÑÐ³ÑÑÐ¿Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ Ð¿Ð¾ ÑÐ²ÐµÑÐ°Ð¼ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ ÑÐ¸Ð¿Ð° 2 (Ð¿Ð¾Ð´ÑÐ¾Ð±Ð½ÐµÐµ Ð¾ ÑÐ¸Ð¿Ð°Ñ ÑÐ¼. ÐºÐ¾Ð½ÐµÑ ÑÐ°Ð¹Ð»Ð°)
function image.convertToGroupedImage(picture)
	--Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð¼Ð°ÑÑÐ¸Ð² Ð¾Ð¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾Ð¹ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸
	local optimizedPicture = {}
	--ÐÐ°Ð´Ð°ÐµÐ¼ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÑ
	local xPos, yPos, background, foreground, alpha, symbol = 1, 1, nil, nil, nil, nil
	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð²ÑÐµ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ Ð¼Ð°ÑÑÐ¸Ð²Ð°
	for i = 1, picture.width * picture.height * constants.elementCount, constants.elementCount do
		--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ¸Ð¼Ð²Ð¾Ð» Ð¸Ð· Ð½ÐµÐ¾Ð¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð¼Ð°ÑÑÐ¸Ð²Ð°
		background, foreground, alpha, symbol = picture[i], picture[i + 1], picture[i + 2], picture[i + 3]
		--ÐÑÑÐ¿Ð¿Ð¸ÑÑÐµÐ¼ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ Ð¿Ð¾ ÑÐ²ÐµÑÐ°Ð¼
		optimizedPicture[alpha] = optimizedPicture[alpha] or {}
		optimizedPicture[alpha][symbol] = optimizedPicture[alpha][symbol] or {}
		optimizedPicture[alpha][symbol][foreground] = optimizedPicture[alpha][symbol][foreground] or {}
		optimizedPicture[alpha][symbol][foreground][background] = optimizedPicture[alpha][symbol][foreground][background] or {}
		optimizedPicture[alpha][symbol][foreground][background][yPos] = optimizedPicture[alpha][symbol][foreground][background][yPos] or {}

		table.insert(optimizedPicture[alpha][symbol][foreground][background][yPos], xPos)
		--ÐÑÐ»Ð¸ xPos Ð´Ð¾ÑÑÐ¸Ð³Ð°ÐµÑ width Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ, ÑÐ¾ ÑÐ±ÑÐ¾ÑÐ¸ÑÑ Ð½Ð° 1, Ð¸Ð½Ð°ÑÐµ xPos++
		xPos = (xPos == picture.width) and 1 or xPos + 1
		--ÐÑÐ»Ð¸ xPos ÑÐ°Ð²Ð½ÑÐµÑÑÑ 1, ÑÐ¾ yPos++, Ð° ÐµÑÐ»Ð¸ Ð½ÐµÑ, ÑÐ¾ Ð¿Ð¾ÑÑÐ¹
		yPos = (xPos == 1) and yPos + 1 or yPos
	end
	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð¾Ð¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹ Ð¼Ð°ÑÑÐ¸Ð²
	return optimizedPicture
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ ÑÐ¸ÑÐ¸Ð½Ñ Ð¸ Ð²ÑÑÐ¾ÑÑ Ð´Ð»Ñ ÑÐµÑÑÐ°
function image.create(width, height, background, foreground, alpha, symbol, random)
	background, foreground, alpha, symbol = background or 0x0, foreground or 0x0, alpha or 0x0, symbol or " "
	local picture, symbolArray = {width = width, height = height}, {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð", "Ð ", "Ð¡", "Ð¢", "Ð£", "Ð¤", "Ð¥", "Ð¦", "Ð§", "Ð¨", "Ð©", "Ðª", "Ð«", "Ð¬", "Ð­", "Ð®", "Ð¯"}
	for i = 1, picture.width * picture.height do
		if random then
			background = math.random(0x000000, 0xffffff)
			foreground = math.random(0x000000, 0xffffff)
			symbol = symbolArray[math.random(1, #symbolArray)]
		end
		table.insert(picture, background)
		table.insert(picture, foreground)
		table.insert(picture, alpha)
		table.insert(picture, symbol)
	end
	return picture
end

-- Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð¾Ð¿ÑÐ¸Ð¼Ð¸Ð·Ð°ÑÐ¸Ð¸ ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ° Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð² Ñ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸, ÑÐ¼ÐµÐ½ÑÑÐ°ÐµÑ ÑÐ¸ÑÐ»Ð¾ GPU-Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¹ Ð¿ÑÐ¸ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐµ Ð¸Ð· Ð±ÑÑÐµÑÐ°
-- ÐÑÐ·ÑÐ²Ð°ÐµÑÑÑ ÑÐ¾Ð»ÑÐºÐ¾ Ð¿ÑÐ¸ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸Ð¸ ÑÐ°Ð¹Ð»Ð°, ÑÐ°Ðº ÑÑÐ¾ Ð½Ð° Ð±ÑÑÑÑÐ¾Ð´ÐµÐ¹ÑÑÐ²Ð¸Ð¸ Ð½Ðµ ÑÐºÐ°Ð·ÑÐ²Ð°ÐµÑÑÑ,
-- Ð° Ð² ÑÐµÐ»Ð¾Ð¼ ÑÑÑÐºÐ° Ð¾ÑÐµÐ½Ñ Ð¸ Ð¾ÑÐµÐ½Ñ Ð¿Ð¾Ð»ÐµÐ·Ð½Ð°Ñ. Ð¤Ð¸ÐºÑÐ¸Ñ ÐºÑÐ¸Ð²Ð¾ÑÑÐºÐ¾ÑÑÑ ÑÑÐ´Ð¾Ð¶Ð½Ð¸ÐºÐ¾Ð².
function image.optimize(picture)
	local i1, i2, i3 = 0, 0, 0
	for i = 1, #picture, constants.elementCount do
		--Ð£Ð¼ÐµÐ½ÑÑÐ°ÐµÐ¼ Ð½Ð°Ð³ÑÑÐ·ÐºÑ Ð½Ð° Ð¦ÐÐÐ
		i1, i2, i3 = i + 1, i + 2, i + 3
		--ÐÑÐ»Ð¸ ÑÐ²ÐµÑ ÑÐ¾Ð½Ð° ÑÐ°Ð²ÐµÐ½ ÑÐ²ÐµÑÑ ÑÐµÐºÑÑÐ°, Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐµÑÑÑ Ð¿ÑÐµÐ²Ð´Ð¾Ð³ÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸Ðµ Ð¿Ð¾Ð»ÑÐ¿Ð¸ÐºÑÐµÐ»Ð¸
		if picture[i] == picture[i1] and (picture[i3] == "â" or picture[i3] == "â") then
			picture[i3] = " "
		end
		--ÐÑÐ»Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð» ÑÐ°Ð²ÐµÐ½ Ð¿ÑÐ¾Ð»Ð±ÐµÐ»Ñ, Ñ.Ðµ. ÑÐ²ÐµÑ ÑÐµÐºÑÑÐ° Ð½Ðµ ÑÑÐ¸ÑÑÐ²Ð°ÐµÑÑÑ
		if picture[i3] == " " then		
			picture[i1] = 0x000000
		end
	end

	return picture
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð· Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼
function image.get(picture, x, y)
	if x >= 1 and y >= 1 and x <= picture.width and y <= picture.height then
		local index = convertCoordsToIndex(x, y, picture.width)
		return picture[index], picture[index + 1], picture[index + 2], picture[index + 3] 
	else
		return nil
	end
end

--Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸ Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÐ°Ð¼
function image.set(picture, x, y, background, foreground, alpha, symbol, debug)
	if x >= 1 and y >= 1 and x <= picture.width and y <= picture.height then
		local index = convertCoordsToIndex(x, y, picture.width)
		picture[index] = background or 0xFF00FF
		picture[index + 1] = foreground or 0xFF00FF
		picture[index + 2] = alpha or 0x00
		picture[index + 3] = symbol or " "
		return picture
	else
		error("Can't set pixel because it's located out of image coordinates: x = " .. x .. ", y = " .. y)
	end
end

------------------------------------------ Ð¤ÑÐ½ÐºÑÐ¸Ñ ÑÐ½ÑÑÐ¸Ñ ÑÐºÑÐ¸Ð½ÑÐ¾ÑÐ° Ñ ÑÐºÑÐ°Ð½Ð° ------------------------------------------------

--Ð¡Ð´ÐµÐ»Ð°ÑÑ ÑÐºÑÐ¸Ð½ÑÐ¾Ñ ÑÐºÑÐ°Ð½Ð° Ð¸ ÑÐ¾ÑÑÐ°Ð½Ð¸ÑÑ ÐµÐ³Ð¾ Ð¿Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¿ÑÑÐ¸
function image.screenshot(path)
	local picture = {}
	local foreground, background, symbol
	picture.width, picture.height = component.gpu.getResolution()
	
	for j = 1, picture.height do
		for i = 1, picture.width do
			symbol, foreground, background = component.gpu.get(i, j)
			table.insert(picture, background)
			table.insert(picture, foreground)
			table.insert(picture, 0x00)
			table.insert(picture, symbol)
		end
	end

	image.save(path, picture)
end

------------------------------------------ ÐÐµÑÐ¾Ð´Ñ ÑÑÐ°Ð½ÑÑÐ¾ÑÐ¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ------------------------------------------------

--ÐÑÑÐ°Ð²ÐºÐ° ÑÑÐ´Ð° Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹
function image.insertRow(picture, y, rowArray)
	local index = convertCoordsToIndex(1, y, picture.width)
	for i = 1, #rowArray, 4 do
		table.insert(picture, index, rowArray[i + 3])
		table.insert(picture, index, rowArray[i + 2])
		table.insert(picture, index, rowArray[i + 1])
		table.insert(picture, index, rowArray[i])
		index = index + 4
	end
	picture.height = picture.height + 1
	return picture
end

function image.insertColumn(picture, x, columnArray)
	local index = convertCoordsToIndex(x, 1, picture.width)
	for i = 1, #columnArray, 4 do
		table.insert(picture, index, columnArray[i + 3])
		table.insert(picture, index, columnArray[i + 2])
		table.insert(picture, index, columnArray[i + 1])
		table.insert(picture, index, columnArray[i])
		index = index + picture.width * 4 + 4
	end
	picture.width = picture.width + 1
	return picture
end

--Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ ÑÑÐ´Ð° Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹
function image.removeRow(picture, y)
	local index = convertCoordsToIndex(1, y, picture.width)
	for i = 1, picture.width * 4 do table.remove(picture, index) end
	picture.height = picture.height - 1
	return picture
end

--Ð£Ð´Ð°Ð»ÐµÐ½Ð¸Ðµ ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹
function image.removeColumn(picture, x)
	local index = convertCoordsToIndex(x, 1, picture.width)
	for i = 1, picture.height do
		for j = 1, 4 do table.remove(picture, index) end
		index = index + (picture.width) * 4 - 4
	end
	picture.width = picture.width - 1
	return picture
end

--ÐÐ¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÑÐ´Ð° Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹
function image.getRow(picture, y)
	local row, background, foreground, alpha, symbol = {width = picture.width, height = 1}
	for x = 1, picture.width do
		background, foreground, alpha, symbol = image.get(picture, x, y)
		table.insert(row, background)
		table.insert(row, foreground)
		table.insert(row, alpha)
		table.insert(row, symbol)
	end
	return row
end

--ÐÐ¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÐºÐ¾Ð»Ð¾Ð½ÐºÐ¸ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹
function image.getColumn(picture, x)
	local column, background, foreground, alpha, symbol = {width = 1, height = picture.height}
	for y = 1, picture.height do
		background, foreground, alpha, symbol = image.get(picture, x, y)
		table.insert(column, background)
		table.insert(column, foreground)
		table.insert(column, alpha)
		table.insert(column, symbol)
	end
	return column
end

--Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð¿Ð¸Ð¸ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
function image.duplicate(picture)
	local newPicture = {width = picture.width, height = picture.height}
	for i = 1, #picture do newPicture[i] = picture[i] end
	return newPicture
end

--ÐÐ½Ð°Ð»Ð¾Ð³ ÑÐ²Ð¾Ð±Ð¾Ð´Ð½Ð¾Ð³Ð¾ ÑÑÐ°Ð½ÑÑÐ¾ÑÐ¼Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ Ð¸Ð· ÑÐ¾ÑÐ¾ÑÐ¾Ð¿Ð°
function image.transform(picture, newWidth, newHeight)
	local newPicture = image.duplicate(picture)
	local widthScale, heightScale = newWidth / picture.width, newHeight / picture.height
	local deltaWidth, deltaHeight = math.abs(newWidth - picture.width), math.abs(newHeight - picture.height)
	local widthIteration, heightIteration = widthScale > 1 and newWidth / deltaWidth or picture.width / deltaWidth, heightScale > 1 and newHeight / deltaHeight or picture.height / deltaHeight

	-- ecs.error(widthIteration, heightIteration, deltaWidth, picture.width, newWidth)

	--Ð¡Ð¶Ð¸Ð¼Ð°ÐµÐ¼ ÑÐ°ÐºÐ°Ð»Ð¾Ð² Ð¿Ð¾ ÑÐ¸ÑÐ¸Ð½Ðµ
	if widthScale > 1 then
		local x = 1
		while x <= newPicture.width do
			if math.floor(x % widthIteration) == 0 then newPicture = image.insertColumn(newPicture, x, image.getColumn(newPicture, x - 1)) end
			x = x + 1
		end
	elseif widthScale < 1 then
		local x = 1
		while x <= newPicture.width do
			if math.floor(x % widthIteration) == 0 then newPicture = image.removeColumn(newPicture, x) end
			x = x + 1
		end
	end

	--Ð Ð¿Ð¾ Ð²ÑÑÐ¾ÑÐµ
	if heightScale > 1 then
		local y = 1
		while y <= newPicture.height do
			if math.floor(y % heightIteration) == 0 then newPicture = image.insertRow(newPicture, y, image.getRow(newPicture, y - 1)) end
			y = y + 1
		end
	elseif heightScale < 1 then
		local y = 1
		while y <= newPicture.height do
			if math.floor(y % heightIteration) == 0 then newPicture = image.removeRow(newPicture, y) end
			y = y + 1
		end
	end

	return newPicture
end

function image.expand(picture, mode, countOfPixels, background, foreground, alpha, symbol)
	local column = {}; for i = 1, picture.height do table.insert(column, background or 0xFFFFFF); table.insert(column, foreground or 0xFFFFFF); table.insert(column, alpha or 0x00); table.insert(column, symbol or " ") end
	local row = {}; for i = 1, picture.height do table.insert(row, background or 0xFFFFFF); table.insert(row, foreground or 0xFFFFFF); table.insert(row, alpha or 0x00); table.insert(row, symbol or " ") end

	if mode == "fromRight" then
		for i = 1, countOfPixels do picture = image.insertColumn(picture, picture.width + 1, column) end
	elseif mode == "fromLeft" then
		for i = 1, countOfPixels do picture = image.insertColumn(picture, 1, column) end
	elseif mode == "fromTop" then
		for i = 1, countOfPixels do picture = image.insertRow(picture, 1, row) end
	elseif mode == "fromBottom" then
		for i = 1, countOfPixels do picture = image.insertRow(picture, picture.height + 1, row) end
	else
		error("Wrong image expanding mode: only 'fromRight', 'fromLeft', 'fromTop' and 'fromBottom' are supported.")
	end

	return picture
end

function image.crop(picture, mode, countOfPixels)
	if mode == "fromRight" then
		for i = 1, countOfPixels do picture = image.removeColumn(picture, picture.width) end
	elseif mode == "fromLeft" then
		for i = 1, countOfPixels do picture = image.removeColumn(picture, 1) end
	elseif mode == "fromTop" then
		for i = 1, countOfPixels do picture = image.removeRow(picture, 1) end
	elseif mode == "fromBottom" then
		for i = 1, countOfPixels do picture = image.removeRow(picture, picture.height) end
	else
		error("Wrong image cropping mode: only 'fromRight', 'fromLeft', 'fromTop' and 'fromBottom' are supported.")
	end

	return picture
end

function image.flipVertical(picture)
	local newPicture = {}; newPicture.width = picture.width; newPicture.height = picture.height
	for j = picture.height, 1, -1 do
		for i = 1, picture.width do
			local index = convertCoordsToIndex(i, j, picture.width)
			table.insert(newPicture, picture[index]); table.insert(newPicture, picture[index + 1]); table.insert(newPicture, picture[index + 2]); table.insert(newPicture, picture[index + 3])
			picture[index], picture[index + 1], picture[index + 2], picture[index + 3] = nil, nil, nil, nil
		end
	end
	return newPicture
end

function image.flipHorizontal(picture)
	local newPicture = {}; newPicture.width = picture.width; newPicture.height = picture.height
	for j = 1, picture.height do
		for i = picture.width, 1, -1 do
			local index = convertCoordsToIndex(i, j, picture.width)
			table.insert(newPicture, picture[index]); table.insert(newPicture, picture[index + 1]); table.insert(newPicture, picture[index + 2]); table.insert(newPicture, picture[index + 3])
			picture[index], picture[index + 1], picture[index + 2], picture[index + 3] = nil, nil, nil, nil
		end
	end
	return newPicture
end

function image.rotate(picture, angle)
	local function rotateBy90(picture)
		local newPicture = {}; newPicture.width = picture.height; newPicture.height = picture.width
		for i = 1, picture.width do
			for j = picture.height, 1, -1 do
				local index = convertCoordsToIndex(i, j, picture.width)
				table.insert(newPicture, picture[index]); table.insert(newPicture, picture[index + 1]); table.insert(newPicture, picture[index + 2]); table.insert(newPicture, picture[index + 3])
				picture[index], picture[index + 1], picture[index + 2], picture[index + 3] = nil, nil, nil, nil
			end
		end
		return newPicture
	end

	local function rotateBy180(picture)
		local newPicture = {}; newPicture.width = picture.width; newPicture.height = picture.height
		for j = picture.height, 1, -1 do
				for i = picture.width, 1, -1 do
				local index = convertCoordsToIndex(i, j, picture.width)
				table.insert(newPicture, picture[index]); table.insert(newPicture, picture[index + 1]); table.insert(newPicture, picture[index + 2]); table.insert(newPicture, picture[index + 3])
				picture[index], picture[index + 1], picture[index + 2], picture[index + 3] = nil, nil, nil, nil
			end
		end
		return newPicture
	end

	local function rotateBy270(picture)
		local newPicture = {}; newPicture.width = picture.height; newPicture.height = picture.width
		for i = picture.width, 1, -1 do
			for j = 1, picture.height do
				local index = convertCoordsToIndex(i, j, picture.width)
				table.insert(newPicture, picture[index]); table.insert(newPicture, picture[index + 1]); table.insert(newPicture, picture[index + 2]); table.insert(newPicture, picture[index + 3])
				picture[index], picture[index + 1], picture[index + 2], picture[index + 3] = nil, nil, nil, nil
			end
		end
		return newPicture
	end

	if angle == 90 then
		return rotateBy90(picture)
	elseif angle == 180 then
		return rotateBy180(picture)
	elseif angle == 270 then
		return rotateBy270(picture)
	else
		error("Can't rotate image: angle must be 90, 180 or 270 degrees.")
	end
end

------------------------------------------ Ð¤ÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ ÑÐ²ÐµÑÐ¾Ð¼ -----------------------------------------------

function image.hueSaturationBrightness(picture, hue, saturation, brightness)
	local function calculateBrightnessChanges(color)
		local h, s, b = colorlib.HEXtoHSB(color)
		b = b + brightness; if b < 0 then b = 0 elseif b > 100 then b = 100 end
		s = s + saturation; if s < 0 then s = 0 elseif s > 100 then s = 100 end
		h = h + hue; if h < 0 then h = 0 elseif h > 360 then h = 360 end
		return colorlib.HSBtoHEX(h, s, b)
	end

	for i = 1, #picture, 4 do
		picture[i] = calculateBrightnessChanges(picture[i])
		picture[i + 1] = calculateBrightnessChanges(picture[i + 1])
	end

	return picture
end

function image.hue(picture, hue)
	return image.hueSaturationBrightness(picture, hue, 0, 0)
end

function image.saturation(picture, saturation)
	return image.hueSaturationBrightness(picture, 0, saturation, 0)
end

function image.brightness(picture, brightness)
	return image.hueSaturationBrightness(picture, 0, 0, brightness)
end

function image.blackAndWhite(picture)
	return image.hueSaturationBrightness(picture, 0, -100, 0)
end

function image.colorBalance(picture, r, g, b)
	local function calculateRGBChanges(color)
		local rr, gg, bb = colorlib.HEXtoRGB(color)
		rr = rr + r; gg = gg + g; bb = bb + b
		if rr < 0 then rr = 0 elseif rr > 255 then rr = 255 end
		if gg < 0 then gg = 0 elseif gg > 255 then gg = 255 end
		if bb < 0 then bb = 0 elseif bb > 255 then bb = 255 end
		return colorlib.RGBtoHEX(rr, gg, bb)
	end

	for i = 1, #picture, 4 do
		picture[i] = calculateRGBChanges(picture[i])
		picture[i + 1] = calculateRGBChanges(picture[i + 1])
	end

	return picture
end

function image.invert(picture)
	for i = 1, #picture, 4 do
		picture[i] = 0xffffff - picture[i]
		picture[i + 1] = 0xffffff - picture[i + 1]
	end
	return picture 
end

function image.photoFilter(picture, color, transparency)
	if transparency < 0 then transparency = 0 elseif transparency > 255 then transparency = 255 end
	for i = 1, #picture, 4 do
		picture[i] = colorlib.alphaBlend(picture[i], color, transparency)
		picture[i + 1] = colorlib.alphaBlend(picture[i + 1], color, transparency)
	end
	return picture
end

function image.replaceColor(picture, fromColor, toColor)
	for i = 1, #picture, 4 do
		if picture[i] == fromColor then picture[i] = toColor end
	end
	return picture
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ ÑÐ°Ð·Ð¼ÑÑÐ¸Ñ Ð¿Ð¾ ÐÐ°ÑÑÑÑ
function image.gaussianBlur(picture, radius, force)
	--Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð³ÐµÐ½ÐµÑÐ°ÑÐ¸Ð¸ Ð¼Ð°ÑÑÐ¸ÑÑ ÑÐ°Ð·Ð¼ÑÑÐ¸Ñ
	local function createConvolutionMatrix(maximumValue, matrixSize)
		local delta = maximumValue / matrixSize
		local matrix = {}
		for y = 1, matrixSize do
			for x = 1, matrixSize do
				local value = ((x - 1) * delta + (y - 1) * delta) / 2
				matrix[y] = matrix[y] or {}
				matrix[y][x] = value
			end
		end
		return matrix
	end

	--Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ ÑÐ°ÑÐ¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ñ ÑÑÐ°ÑÑÐ¾Ð²Ð¾Ð³Ð¾ ÑÐ²ÐµÑÐ° Ð½Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ñ Ð¼Ð°ÑÑÐ¸ÑÑ
	local function spreadPixelToSpecifiedCoordinates(picture, xCoordinate, yCoordinate, matrixValue, startBackground, startForeground, startAlpha, startSymbol)
		local matrixBackground, matrixForeground, matrixAlpha, matrixSymbol = image.get(picture, xCoordinate, yCoordinate)

		if matrixBackground and matrixForeground then
			local newBackground = colorlib.alphaBlend(startBackground, matrixBackground, matrixValue)
			--ÐÐ¸Ð·Ð´Ð°Ð½Ð¸ÑÑ Ð¾Ð½Ð¾ Ð²ÑÐµ Ð² Ð¶Ð¾Ð¿Ñ, ÐµÐ±Ð°Ð½Ð¸Ð½Ð°
			--ÐÐ¾ÑÐ¾Ñ, ÑÐ¼Ð°ÑÐ¸. ÐÑÐ»Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð» ÑÐ°Ð²ÐµÐ½ Ð¿ÑÐ¾Ð±ÐµÐ»Ñ, ÑÐ¾ Ð¼Ñ Ð¿Ð¾Ð»ÑÐ±Ñ Ð½Ðµ ÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ²ÐµÑ ÑÐµÐºÑÑÐ°, Ð²ÐµÑÐ½Ð¾?
			--ÐÐ¾ Ð² Ð±ÑÐ´ÑÑÐ¸Ñ Ð¸ÑÐµÑÐ°ÑÐ¸ÑÑ ÑÑÐ¾ ÑÐ²ÐµÑ Ð±ÑÐ´ÐµÑ ÑÑÑÐµÐ½, Ð¿Ð¾ÑÑÐ¾Ð¼Ñ Ð²Ð¾Ð·Ð½Ð¸ÐºÐ°Ð»Ð¸ ÑÑÐ°Ð½ÑÐµ Ð±Ð°Ð³Ð¸ Ð³ÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸Ðµ
			--ÐÐ¾ÑÑÐ¾Ð¼Ñ Ð´Ð°Ð¶Ðµ Ð´Ð»Ñ ÐµÐ±ÑÑÐµÐ³Ð¾ Ð¿ÑÐ¾Ð±ÐµÐ»Ð° Ð¼Ñ Ð¿ÑÐ¸ÑÐ²Ð°Ð¸Ð²Ð°ÐµÐ¼ Ð·Ð½Ð°ÑÐµÐ½Ð¸Ðµ ÑÐ²ÐµÑÐ° ÑÐµÐºÑÑÐ°, ÑÐ°Ð²Ð½Ð¾Ð¼Ñ ÐÐÐÐÐÐ£ ÑÐ²ÐµÑÑ ÑÐ¾Ð½Ð°
			--Ð¢.Ðµ. Ð²ÑÐ¾Ð´Ðµ Ð±Ñ ÐºÐ°Ðº Ð¾Ð½Ð¸ Ð¸ ÑÐ°Ð²Ð½Ñ, Ð½Ð¾ Ð¿Ð¾ÑÐ¾Ð¼ Ð¾ÑÑÐµÐ½Ð½Ð¾ Ð²ÑÐµ Ð±ÑÐ´ÐµÑ, ÑÐ³Ñ
			local newForeground = matrixSymbol == " " and newBackground or colorlib.alphaBlend(startForeground, matrixForeground, matrixValue)

			image.set(picture, xCoordinate, yCoordinate, newBackground, newForeground, 0x00, matrixSymbol)
		end
	end

	--Ð¤ÑÐ½ÐºÑÐ¸Ñ, ÑÐ°ÑÐ¿ÑÐµÐ´ÐµÐ»ÑÑÑÐ°Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¿Ð¾ ÑÐ¾ÑÐµÐ´Ð½Ð¸Ð¼ Ð¿Ð¸ÐºÑÐµÐ»ÑÐ¼ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ Ð¼Ð°ÑÑÐ¸ÑÑ
	local function spreadColorToOtherPixels(picture, xStart, yStart, matrix)
		--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÑÐ°ÑÑÐ¾Ð²ÑÐµ Ð´Ð°Ð½Ð½ÑÐµ Ð¾ Ð¿Ð¸ÐºÑÐµÐ»Ðµ
		local startBackground, startForeground, startAlpha, startSymbol = image.get(picture, xStart, yStart)
		local xCoordinate, yCoordinate
		--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð¼Ð°ÑÑÐ¸ÑÑ
		for yMatrix = 1, #matrix do
			for xMatrix = 1, #matrix[yMatrix] do
				--ÐÐ³Ð½Ð¾ÑÐ¸ÑÑÐµÐ¼ ÑÑÐ°ÑÑÐ¾Ð²ÑÐ¹ Ð¿Ð¸ÐºÑÐµÐ»Ñ, Ð½Ð° ÐºÐ¾Ð¹ ÑÐµÑ ÐµÐ³Ð¾ ÑÐ°Ð·Ð¼ÑÐ²Ð°ÑÑ-ÑÐ¾?
				if not (xMatrix == 1 and yMatrix == 1) then
					--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð½Ð¾Ð²ÑÑ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹ Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸
					--Ð Ð² Ð¾Ð±ÑÐ°ÑÐ½Ð¾Ð¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸ Ð¼Ð°ÑÑÐ¸ÑÑ
					xCoordinate, yCoordinate = xStart - xMatrix + 1, yStart - yMatrix + 1
					spreadPixelToSpecifiedCoordinates(picture, xCoordinate, yCoordinate, matrix[yMatrix][xMatrix], startBackground, startForeground, startAlpha, startSymbol)
					--ÐÐ»Ñ Ð½Ð°ÑÐ°Ð»Ð° Ð² Ð¿ÑÐ°Ð²Ð¸Ð»ÑÐ½ÑÑ ÑÑÐ¾ÑÐ¾Ð½Ñ Ð¼Ð°ÑÑÐ¸ÑÑ
					xCoordinate, yCoordinate = xStart + xMatrix - 1, yStart + yMatrix - 1
					spreadPixelToSpecifiedCoordinates(picture, xCoordinate, yCoordinate, matrix[yMatrix][xMatrix], startBackground, startForeground, startAlpha, startSymbol)
				end
			end
		end
	end

	--ÐÐµÐ½ÐµÑÐ¸ÑÑÐµÐ¼ Ð¼Ð°ÑÑÐ¸ÑÑ
	local matrix = createConvolutionMatrix(force or 0x55, radius)
	--Ð Ð°ÑÐ¿ÑÐµÐ´ÐµÐ»ÑÐµÐ¼ Ð²ÑÐµ Ð¿Ð¸ÐºÑÐµÐ»Ð¸ Ð¿Ð¾ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
	for y = 1, picture.height do
		for x = 1, picture.width do
			spreadColorToOtherPixels(picture, x, y, matrix)
		end
	end
	return picture
end

----------------------------------------- Ð¡ÑÑÐ¾ÐºÐ¾Ð²Ð°Ñ Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¹ -------------------------------------------------------------------

--ÐÑÐµÐ¾Ð±ÑÐ°Ð·Ð¾Ð²Ð°ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð² ÑÑÑÐ¾ÐºÐ¾Ð²ÑÑ Ð¸Ð½ÑÐµÑÐ¿ÑÐµÑÐ°ÑÐ¸Ñ, ÐºÐ¾ÑÐ¾ÑÐ°Ñ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð²ÑÑÐ°Ð²Ð»ÐµÐ½Ð° Ð² ÐºÐ¾Ð´
--Ð£Ð´Ð¾Ð±Ð½Ð¾, ÐµÑÐ»Ð¸ Ð½Ðµ ÑÐ¾ÑÐµÑÑÑ Ð²Ð¾Ð·Ð¸ÑÑÑÑ Ñ ÑÐ°Ð¹Ð»Ð¾Ð²Ð¾Ð¹ ÑÐ¸ÑÑÐµÐ¼Ð¾Ð¹
function image.toString(picture)
	local stringedPicture = {}
	picture = convertImageColorsTo8Bit(picture)
	table.insert(stringedPicture, string.format("%02X", picture.width))
	table.insert(stringedPicture, string.format("%02X", picture.height))
	for i = 1, #picture, 4 do
		table.insert(stringedPicture, string.format("%02X", picture[i]))
		table.insert(stringedPicture, string.format("%02X", picture[i + 1]))
		table.insert(stringedPicture, string.format("%02X", picture[i + 2]))
		table.insert(stringedPicture, picture[i + 3])
	end
	picture = convertImageColorsTo24Bit(picture)
	return table.concat(stringedPicture)
end

--ÐÐ¾Ð»ÑÑÐ¸ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð¸Ð· ÑÑÑÐ¾ÐºÐ¾Ð²Ð¾Ð¹ Ð¸Ð½ÑÐµÑÐ¿ÑÐµÑÐ°ÑÐ¸Ð¸, ÑÐ¾Ð·Ð´Ð°Ð½Ð½Ð¾Ð¹ ÑÐ°Ð½ÐµÐµ
function image.fromString(stringedPicture)
	local picture = {}
	local subIndex = 1
	picture.width = tonumber("0x" .. unicode.sub(stringedPicture, subIndex, subIndex + 1)); subIndex = subIndex + 2
	picture.height = tonumber("0x" .. unicode.sub(stringedPicture, subIndex, subIndex + 1)); subIndex = subIndex + 2
	
	for pixel = 1, picture.width * picture.height do
		table.insert(picture, tonumber("0x" .. unicode.sub(stringedPicture, subIndex, subIndex + 1))); subIndex = subIndex + 2
		table.insert(picture, tonumber("0x" .. unicode.sub(stringedPicture, subIndex, subIndex + 1))); subIndex = subIndex + 2
		table.insert(picture, tonumber("0x" .. unicode.sub(stringedPicture, subIndex, subIndex + 1))); subIndex = subIndex + 2
		table.insert(picture, unicode.sub(stringedPicture, subIndex, subIndex)); subIndex = subIndex + 1
	end
	picture = convertImageColorsTo24Bit(picture)
	return picture
end

----------------------------------------- ÐÑÐ½Ð¾Ð²Ð½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ -------------------------------------------------------------------

--Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð»ÑÐ±Ð¾Ð³Ð¾ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÐ¼Ð¾Ð³Ð¾ ÑÐ¾ÑÐ¼Ð°ÑÐ°
function image.save(path, picture, encodingMethod)
	encodingMethod = encodingMethod or 4
	--Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð¿Ð°Ð¿ÐºÑ Ð¿Ð¾Ð´ ÑÐ°Ð¹Ð», ÐµÑÐ»Ð¸ ÐµÐµ Ð½ÐµÑ
	fs.makeDirectory(fs.path(path))
	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ¾ÑÐ¼Ð°Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ°Ð¹Ð»Ð°
	local fileFormat = getFileFormat(path)

	--ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¸Ðµ ÑÐ¾ÑÐ¼Ð°ÑÐ° ÑÐ°Ð¹Ð»Ð°
	if fileFormat == constants.compressedFileFormat then
		--ÐÐ¿ÑÐ¸Ð¼Ð¸Ð·Ð¸ÑÑÐµÐ¼ ÐºÐ°ÑÑÐ¸Ð½ÐºÑ
		picture = image.optimize(picture)
		--ÐÑÐºÑÑÐ²Ð°ÐµÐ¼ ÑÐ°Ð¹Ð»
		local file = io.open(path, "w")
		--ÐÐ°Ð¿Ð¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ¸Ð³Ð½Ð°ÑÑÑÑ
		writeSignature(file)
		--Ð Ð°Ð·Ð±Ð¸ÑÐ°ÐµÐ¼ÑÑ Ñ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²ÐºÐ¾Ð¹
		if encodingMethod == 0 or string.lower(encodingMethod) == "raw" then
			file:write(string.char(encodingMethod))
			saveRaw(file, picture)
		elseif encodingMethod == 1 or string.lower(encodingMethod) == "ocif1" then
			file:write(string.char(encodingMethod))
			saveOCIF1(file, picture)
		elseif encodingMethod == 2 or string.lower(encodingMethod) == "ocif2" then
			file:write(string.char(encodingMethod))
			saveOCIF2(file, picture)
		elseif encodingMethod == 3 or string.lower(encodingMethod) == "ocif3" then
			error("Saving in encoding method 3 is deprecated and no longer supported. Use method 4 instead of it.")
		elseif encodingMethod == 4 or string.lower(encodingMethod) == "ocif4" then
			file:write(string.char(encodingMethod))
			picture = convertImageColorsTo8Bit(picture)
			saveOCIF2(file, picture, true)
			picture = convertImageColorsTo24Bit(picture)
		elseif encodingMethod == 6 then
			file:close()
			file = io.open(path, "w")
			file:write(image.toString(picture))
			file:close()
		else
			file:close()
			error("Unsupported encoding method.\n")
		end
	else
		file:close()
		error("Unsupported file format.\n")
	end
end

--ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð»ÑÐ±Ð¾Ð³Ð¾ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÐ¼Ð¾Ð³Ð¾ ÑÐ¾ÑÐ¼Ð°ÑÐ°
function image.load(path)
	--ÐÐ¸Ð½ÑÑÑ Ð¾ÑÐ¸Ð±ÐºÑ, ÐµÑÐ»Ð¸ ÑÐ°ÐºÐ¾Ð³Ð¾ ÑÐ°Ð¹Ð»Ð° Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ
	if not fs.exists(path) then error("File \""..path.."\" does not exists.\n") end
	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ¾ÑÐ¼Ð°Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐ°Ð¹Ð»Ð°
	local fileFormat = getFileFormat(path)
	--ÐÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÐ¾Ð¾ÑÐ²ÐµÑÑÑÐ²Ð¸Ðµ ÑÐ¾ÑÐ¼Ð°ÑÐ° ÑÐ°Ð¹Ð»Ð°
	if fileFormat == constants.compressedFileFormat then
		local file = io.open(path, "rb")
		--Ð§Ð¸ÑÐ°ÐµÐ¼ ÑÐ¸Ð³Ð½Ð°ÑÑÑÑ ÑÐ°Ð¹Ð»Ð°
		readSignature(file)
		--Ð§Ð¸ÑÐ°ÐµÐ¼ Ð¼ÐµÑÐ¾Ð´ Ð¾Ð±ÑÐ°Ð±Ð¾ÑÐºÐ¸ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
		local encodingMethod = string.byte(file:read(1))
		--Ð§Ð¸ÑÐ°ÐµÐ¼ ÑÐ°Ð¹Ð»Ñ Ð² Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑÐ¸ Ð¾Ñ Ð¼ÐµÑÐ¾Ð´Ð°
		--print("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ ÑÐ°Ð¹Ð» ÑÐ¸Ð¿Ð° " .. encodingMethod)
		if encodingMethod == 0 then
			return image.optimize(loadRaw(file))
		elseif encodingMethod == 1 then
			return image.optimize(loadOCIF1(file))
		elseif encodingMethod == 2 then
			return image.optimize(loadOCIF2(file))
		elseif encodingMethod == 3 then
			return image.optimize(loadOCIF2(file, true))
		elseif encodingMethod == 4 then
			return image.optimize(loadOCIF2(file, true, true))
		else
			file:close()
			error("Unsupported encoding method: " .. encodingMethod .. "\n")
		end
	--ÐÐ¾Ð´Ð´ÐµÑÐ¶ÐºÐ° ÐÐÐ-ÑÐ¾ÑÐ¼Ð°ÑÐ°
	elseif fileFormat == constants.pngFileFormat then
		return image.loadPng(path)
	else
		error("Unsupported file format: " .. fileFormat .. "\n")
	end
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÑÐ¸Ð¿Ð° 3 (Ð¿Ð¾Ð´ÑÐ¾Ð±Ð½ÐµÐµ Ð¾ ÑÐ¸Ð¿Ð°Ñ ÑÐ¼. ÐºÐ¾Ð½ÐµÑ ÑÐ°Ð¹Ð»Ð°)
function image.draw(x, y, picture)
	--ÐÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÑÐµÐ¼ Ð² Ð³ÑÑÐ¿Ð¿Ð¾Ð²Ð¾Ðµ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ
	picture = image.convertToGroupedImage(picture)
	--ÐÑÐµ ÐºÐ°Ðº Ð¾Ð±ÑÑÐ½Ð¾
	x, y = x - 1, y - 1

	local xPos, yPos, currentBackground
	for alpha in pairs(picture) do
		for symbol in pairs(picture[alpha]) do
			for foreground in pairs(picture[alpha][symbol]) do
				if component.gpu.getForeground ~= foreground then component.gpu.setForeground(foreground) end
				for background in pairs(picture[alpha][symbol][foreground]) do
					if component.gpu.getBackground ~= background then component.gpu.setBackground(background) end
					currentBackground = background

					for yArray in pairs(picture[alpha][symbol][foreground][background]) do
						for xArray = 1, #picture[alpha][symbol][foreground][background][yArray] do
							xPos, yPos = x + picture[alpha][symbol][foreground][background][yArray][xArray], y + yArray
							
							--ÐÑÐ»Ð¸ Ð°Ð»ÑÑÐ° Ð¸Ð¼ÐµÐµÑÑÑ, Ð½Ð¾ Ð¾Ð½Ð° Ð½Ðµ ÑÐ¾Ð²ÑÐµÐ¼ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð°
							if (alpha > 0x00 and alpha < 0xFF) or (alpha == 0xFF and symbol ~= " ")then
								_, _, currentBackground = component.gpu.get(xPos, yPos)
								currentBackground = colorlib.alphaBlend(currentBackground, background, alpha)
								component.gpu.setBackground(currentBackground)

								component.gpu.set(xPos, yPos, symbol)

							elseif alpha == 0x00 then
								if currentBackground ~= background then
									currentBackground = background
									component.gpu.setBackground(currentBackground)
								end

								component.gpu.set(xPos, yPos, symbol)
							end
							--ecs.wait()
						end
					end
				end
			end
		end
	end
end

local function createSaveAndLoadFiles()
	ecs.prepareToExit()
	ecs.error("Ð¡Ð¾Ð·Ð´Ð°Ñ/Ð·Ð°Ð³ÑÑÐ¶Ð°Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ")
	-- local cyka = image.load("MineOS/System/OS/Icons/Love.pic")
	local cyka = image.createImage(4, 4)
	ecs.error("Ð Ð¸ÑÑÑ Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð½Ð¾Ðµ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ")
	image.draw(2, 2, cyka)
	ecs.error("Ð¡Ð¾ÑÑÐ°Ð½ÑÑ ÐµÐ³Ð¾ Ð² 4 ÑÐ¾ÑÐ¼Ð°ÑÐ°Ñ")
	image.save("0.pic", cyka, 0)
	image.save("1.pic", cyka, 1)
	image.save("4.pic", cyka, 4)
	ecs.prepareToExit()
	ecs.error("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ Ð²ÑÐµ 4 ÑÐ¾ÑÐ¼Ð°ÑÐ° Ð¸ ÑÐ¸ÑÑÑ Ð¸Ñ")
	local cyka0 = image.load("0.pic")
	image.draw(2, 2, cyka0)
	local cyka1 = image.load("1.pic")
	image.draw(10, 2, cyka1)
	local cyka4 = image.load("4.pic")
	image.draw(34, 2, cyka4)
end

------------------------------------------------------------------------------------------------------------------------

-- local picture = image.load("MineOS/System/OS/Icons/Love.pic")
-- buffer.clear(0xFF8888)
-- buffer.draw(true)

-- buffer.image(1, 1, picture)
-- buffer.draw()

-- local newPicture = transform(picture, 0.5, 2)

-- local columnArray = {}; for i = 1, picture.height do table.insert(columnArray, 0xFFFFFF); table.insert(columnArray, 0x000000); table.insert(columnArray, 0x00); table.insert(columnArray, " ") end
-- local rowArray = {}; for i = 1, picture.width do table.insert(rowArray, 0xFFFFFF); table.insert(rowArray, 0x000000); table.insert(rowArray, 0x00); table.insert(rowArray, " ") end
-- local rowArray = image.getRow(picture, 2)
-- picture = image.insertColumn(picture, 1, columnArray)
-- picture = image.insertRow(picture, 3, rowArray)
-- picture = image.removeColumn(picture, 1)

-- buffer.image(1, 19, picture)
-- buffer.image(1, 19, newPicture)
-- buffer.draw()

------------------------------------------------------------------------------------------------------------------------

return image











Flib/internet.lua
tlocal buffer = require("buffer")
local component = require("component")
local event = require("event")

local internet = {}

-------------------------------------------------------------------------------

function internet.request(url, data, headers)
  checkArg(1, url, "string")
  checkArg(2, data, "string", "table", "nil")
  checkArg(3, headers, "table", "nil")

  local inet = component.internet
  if not inet then
    error("no primary internet card found", 2)
  end

  local post
  if type(data) == "string" then
    post = data
  elseif type(data) == "table" then
    for k, v in pairs(data) do
      post = post and (post .. "&") or ""
      post = post .. tostring(k) .. "=" .. tostring(v)
    end
  end

  local request, reason = inet.request(url, post, headers)
  if not request then
    error(reason, 2)
  end

  return function()
    while true do
      local data, reason = request.read()
      if not data then
        request.close()
        if reason then
          error(reason, 2)
        else
          return nil -- eof
        end
      elseif #data > 0 then
        return data
      end
      -- else: no data, block
      os.sleep(0)
    end
  end
end

-------------------------------------------------------------------------------

local socketStream = {}

function socketStream:close()
  if self.socket then
    self.socket.close()
    self.socket = nil
  end
end

function socketStream:seek()
  return nil, "bad file descriptor"
end

function socketStream:read(n)
  if not self.socket then
    return nil, "connection is closed"
  end
  return self.socket.read(n)
end

function socketStream:write(value)
  if not self.socket then
    return nil, "connection is closed"
  end
  while #value > 0 do
    local written, reason = self.socket.write(value)
    if not written then
      return nil, reason
    end
    value = string.sub(value, written + 1)
  end
  return true
end

function internet.socket(address, port)
  checkArg(1, address, "string")
  checkArg(2, port, "number", "nil")
  if port then
    address = address .. ":" .. port
  end

  local inet = component.internet
  local socket, reason = inet.connect(address)
  if not socket then
    return nil, reason
  end

  local stream = {inet = inet, socket = socket}
  local metatable = {__index = socketStream,
                     __metatable = "socketstream"}
  return setmetatable(stream, metatable)
end

function internet.open(address, port)
  local stream, reason = internet.socket(address, port)
  if not stream then
    return nil, reason
  end
  return buffer.new("rwb", stream)
end

-------------------------------------------------------------------------------

return internetF
lib/io.lua	klocal io = {}

-------------------------------------------------------------------------------

function io.close(file)
  return (file or io.output()):close()
end

function io.flush()
  return io.output():flush()
end

function io.lines(filename, ...)
  if filename then
    local file, reason = io.open(filename)
    if not file then
      error(reason, 2)
    end
    local args = table.pack(...)
    return function()
      local result = table.pack(file:read(table.unpack(args, 1, args.n)))
      if not result[1] then
        if result[2] then
          error(result[2], 2)
        else -- eof
          file:close()
          return nil
        end
      end
      return table.unpack(result, 1, result.n)
    end
  else
    return io.input():lines()
  end
end

function io.open(path, mode)
  -- These requires are not on top because this is a bootstrapped file.
  local stream, result = require("filesystem").open(path, mode)
  if stream then
    return require("buffer").new(mode, stream)
  else
    return nil, result
  end
end

function io.stream(fd,file,mode)
  checkArg(1,fd,'number')
  assert(fd>=0,'fd must be >= 0. 0 is input, 1 is stdout, 2 is stderr')
  if file then
    if type(file) == "string" then
      local result, reason = io.open(file, mode)
      if not result then
        error(reason, 2)
      end
      file = result
    elseif not io.type(file) then
      error("bad argument #1 (string or file expected, got " .. type(file) .. ")", 2)
    end
    require("process").info().data.io[fd] = file
  end
  return require("process").info().data.io[fd]
end

function io.input(file)
  return io.stream(0, file, 'r')
end

function io.output(file)
  return io.stream(1, file,'w')
end

function io.error(file)
  return io.stream(2, file,'w')
end

function io.popen(prog, mode, env)
  return require('pipes').popen(prog, mode, env)
end

function io.read(...)
  return io.input():read(...)
end

function io.tmpfile()
  local name = os.tmpname()
  if name then
    return io.open(name, "a")
  end
end

function io.type(object)
  if type(object) == "table" then
    if getmetatable(object) == "file" then
      if object.stream.handle then
        return "file"
      else
        return "closed file"
      end
    end
  end
  return nil
end

function io.write(...)
  return io.output():write(...)
end

-------------------------------------------------------------------------------

return io
Flib/json.lua-- -*- coding: utf-8 -*-
--
-- Simple JSON encoding and decoding in pure Lua.
--
-- Copyright 2010-2014 Jeffrey Friedl
-- http://regex.info/blog/
--
-- Latest version: http://regex.info/blog/lua/json
--
-- This code is released under a Creative Commons CC-BY "Attribution" License:
-- http://creativecommons.org/licenses/by/3.0/deed.en_US
--
-- It can be used for any purpose so long as the copyright notice above,
-- the web-page links above, and the 'AUTHOR_NOTE' string below are
-- maintained. Enjoy.
--
local VERSION = 20141223.14 -- version history at end of file
local AUTHOR_NOTE = "-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json) version 20141223.14 ]-"

--
-- The 'AUTHOR_NOTE' variable exists so that information about the source
-- of the package is maintained even in compiled versions. It's also
-- included in OBJDEF below mostly to quiet warnings about unused variables.
--
local OBJDEF = {
   VERSION      = VERSION,
   AUTHOR_NOTE  = AUTHOR_NOTE,
}


--
-- Simple JSON encoding and decoding in pure Lua.
-- http://www.json.org/
--
--
--   JSON = assert(loadfile "JSON.lua")() -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
--
--
--
-- DECODING (from a JSON string to a Lua table)
--
--
--   JSON = assert(loadfile "JSON.lua")() -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   If the JSON text is for an object or an array, e.g.
--     { "what": "books", "count": 3 }
--   or
--     [ "Larry", "Curly", "Moe" ]
--
--   the result is a Lua table, e.g.
--     { what = "books", count = 3 }
--   or
--     { "Larry", "Curly", "Moe" }
--
--
--   The encode and decode routines accept an optional second argument,
--   "etc", which is not used during encoding or decoding, but upon error
--   is passed along to error handlers. It can be of any type (including nil).
--
--
--
-- ERROR HANDLING
--
--   With most errors during decoding, this code calls
--
--      JSON:onDecodeError(message, text, location, etc)
--
--   with a message about the error, and if known, the JSON text being
--   parsed and the byte count where the problem was discovered. You can
--   replace the default JSON:onDecodeError() with your own function.
--
--   The default onDecodeError() merely augments the message with data
--   about the text and the location if known (and if a second 'etc'
--   argument had been provided to decode(), its value is tacked onto the
--   message as well), and then calls JSON.assert(), which itself defaults
--   to Lua's built-in assert(), and can also be overridden.
--
--   For example, in an Adobe Lightroom plugin, you might use something like
--
--          function JSON:onDecodeError(message, text, location, etc)
--             LrErrors.throwUserError("Internal Error: invalid JSON data")
--          end
--
--   or even just
--
--          function JSON.assert(message)
--             LrErrors.throwUserError("Internal Error: " .. message)
--          end
--
--   If JSON:decode() is passed a nil, this is called instead:
--
--      JSON:onDecodeOfNilError(message, nil, nil, etc)
--
--   and if JSON:decode() is passed HTML instead of JSON, this is called:
--
--      JSON:onDecodeOfHTMLError(message, text, nil, etc)
--
--   The use of the fourth 'etc' argument allows stronger coordination
--   between decoding and error reporting, especially when you provide your
--   own error-handling routines. Continuing with the the Adobe Lightroom
--   plugin example:
--
--          function JSON:onDecodeError(message, text, location, etc)
--             local note = "Internal Error: invalid JSON data"
--             if type(etc) = 'table' and etc.photo then
--                note = note .. " while processing for " .. etc.photo:getFormattedMetadata('fileName')
--             end
--             LrErrors.throwUserError(note)
--          end
--
--            :
--            :
--
--          for i, photo in ipairs(photosToProcess) do
--               :             
--               :             
--               local data = JSON:decode(someJsonText, { photo = photo })
--               :             
--               :             
--          end
--
--
--
--
--
-- DECODING AND STRICT TYPES
--
--   Because both JSON objects and JSON arrays are converted to Lua tables,
--   it's not normally possible to tell which original JSON type a
--   particular Lua table was derived from, or guarantee decode-encode
--   round-trip equivalency.
--
--   However, if you enable strictTypes, e.g.
--
--      JSON = assert(loadfile "JSON.lua")() --load the routines
--      JSON.strictTypes = true
--
--   then the Lua table resulting from the decoding of a JSON object or
--   JSON array is marked via Lua metatable, so that when re-encoded with
--   JSON:encode() it ends up as the appropriate JSON type.
--
--   (This is not the default because other routines may not work well with
--   tables that have a metatable set, for example, Lightroom API calls.)
--
--
-- ENCODING (from a lua table to a JSON string)
--
--   JSON = assert(loadfile "JSON.lua")() -- one-time load of the routines
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
--   local custom_pretty    = JSON:encode(lua_table_or_value, etc, { pretty = true, indent = "|  ", align_keys = false })
--
--   On error during encoding, this code calls:
--
--     JSON:onEncodeError(message, etc)
--
--   which you can override in your local JSON object.
--
--   The 'etc' in the error call is the second argument to encode()
--   and encode_pretty(), or nil if it wasn't provided.
--
--
-- PRETTY-PRINTING
--
--   An optional third argument, a table of options, allows a bit of
--   configuration about how the encoding takes place:
--
--     pretty = JSON:encode(val, etc, {
--                                       pretty = true,      -- if false, no other options matter
--                                       indent = "   ",     -- this provides for a three-space indent per nesting level
--                                       align_keys = false, -- see below
--                                     })
--
--   encode() and encode_pretty() are identical except that encode_pretty()
--   provides a default options table if none given in the call:
--
--       { pretty = true, align_keys = false, indent = "  " }
--
--   For example, if
--
--      JSON:encode(data)
--
--   produces:
--
--      {"city":"Kyoto","climate":{"avg_temp":16,"humidity":"high","snowfall":"minimal"},"country":"Japan","wards":11}
--
--   then
--
--      JSON:encode_pretty(data)
--
--   produces:
--
--      {
--        "city": "Kyoto",
--        "climate": {
--          "avg_temp": 16,
--          "humidity": "high",
--          "snowfall": "minimal"
--        },
--        "country": "Japan",
--        "wards": 11
--      }
--
--   The following three lines return identical results:
--       JSON:encode_pretty(data)
--       JSON:encode_pretty(data, nil, { pretty = true, align_keys = false, indent = "  " })
--       JSON:encode       (data, nil, { pretty = true, align_keys = false, indent = "  " })
--
--   An example of setting your own indent string:
--
--     JSON:encode_pretty(data, nil, { pretty = true, indent = "|    " })
--
--   produces:
--
--      {
--      |    "city": "Kyoto",
--      |    "climate": {
--      |    |    "avg_temp": 16,
--      |    |    "humidity": "high",
--      |    |    "snowfall": "minimal"
--      |    },
--      |    "country": "Japan",
--      |    "wards": 11
--      }
--
--   An example of setting align_keys to true:
--
--     JSON:encode_pretty(data, nil, { pretty = true, indent = "  ", align_keys = true })
--  
--   produces:
--   
--      {
--           "city": "Kyoto",
--        "climate": {
--                     "avg_temp": 16,
--                     "humidity": "high",
--                     "snowfall": "minimal"
--                   },
--        "country": "Japan",
--          "wards": 11
--      }
--
--   which I must admit is kinda ugly, sorry. This was the default for
--   encode_pretty() prior to version 20141223.14.
--
--
--  AMBIGUOUS SITUATIONS DURING THE ENCODING
--
--   During the encode, if a Lua table being encoded contains both string
--   and numeric keys, it fits neither JSON's idea of an object, nor its
--   idea of an array. To get around this, when any string key exists (or
--   when non-positive numeric keys exist), numeric keys are converted to
--   strings.
--
--   For example, 
--     JSON:encode({ "one", "two", "three", SOMESTRING = "some string" }))
--   produces the JSON object
--     {"1":"one","2":"two","3":"three","SOMESTRING":"some string"}
--
--   To prohibit this conversion and instead make it an error condition, set
--      JSON.noKeyConversion = true
--




--
-- SUMMARY OF METHODS YOU CAN OVERRIDE IN YOUR LOCAL LUA JSON OBJECT
--
--    assert
--    onDecodeError
--    onDecodeOfNilError
--    onDecodeOfHTMLError
--    onEncodeError
--
--  If you want to create a separate Lua JSON object with its own error handlers,
--  you can reload JSON.lua or use the :new() method.
--
---------------------------------------------------------------------------

local default_pretty_indent  = "  "
local default_pretty_options = { pretty = true, align_keys = false, indent = default_pretty_indent }

local isArray  = { __tostring = function() return "JSON array"  end }    isArray.__index  = isArray
local isObject = { __tostring = function() return "JSON object" end }    isObject.__index = isObject


function OBJDEF:newArray(tbl)
   return setmetatable(tbl or {}, isArray)
end

function OBJDEF:newObject(tbl)
   return setmetatable(tbl or {}, isObject)
end

local function unicode_codepoint_as_utf8(codepoint)
   --
   -- codepoint is a number
   --
   if codepoint <= 127 then
      return string.char(codepoint)

   elseif codepoint <= 2047 then
      --
      -- 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8
      --
      local highpart = math.floor(codepoint / 0x40)
      local lowpart  = codepoint - (0x40 * highpart)
      return string.char(0xC0 + highpart,
                         0x80 + lowpart)

   elseif codepoint <= 65535 then
      --
      -- 1110yyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x1000)
      local remainder = codepoint - 0x1000 * highpart
      local midpart   = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midpart

      highpart = 0xE0 + highpart
      midpart  = 0x80 + midpart
      lowpart  = 0x80 + lowpart

      --
      -- Check for an invalid character (thanks Andy R. at Adobe).
      -- See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070
      --
      if ( highpart == 0xE0 and midpart < 0xA0 ) or
         ( highpart == 0xED and midpart > 0x9F ) or
         ( highpart == 0xF0 and midpart < 0x90 ) or
         ( highpart == 0xF4 and midpart > 0x8F )
      then
         return "?"
      else
         return string.char(highpart,
                            midpart,
                            lowpart)
      end

   else
      --
      -- 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x40000)
      local remainder = codepoint - 0x40000 * highpart
      local midA      = math.floor(remainder / 0x1000)
      remainder       = remainder - 0x1000 * midA
      local midB      = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midB

      return string.char(0xF0 + highpart,
                         0x80 + midA,
                         0x80 + midB,
                         0x80 + lowpart)
   end
end

function OBJDEF:onDecodeError(message, text, location, etc)
   if text then
      if location then
         message = string.format("%s at char %d of: %s", message, location, text)
      else
         message = string.format("%s: %s", message, text)
      end
   end

   if etc ~= nil then
      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

OBJDEF.onDecodeOfNilError  = OBJDEF.onDecodeError
OBJDEF.onDecodeOfHTMLError = OBJDEF.onDecodeError

function OBJDEF:onEncodeError(message, etc)
   if etc ~= nil then
      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

local function grok_number(self, text, start, etc)
   --
   -- Grab the integer part
   --
   local integer_part = text:match('^-?[1-9]%d*', start)
                     or text:match("^-?0",        start)

   if not integer_part then
      self:onDecodeError("expected number", text, start, etc)
   end

   local i = start + integer_part:len()

   --
   -- Grab an optional decimal part
   --
   local decimal_part = text:match('^%.%d+', i) or ""

   i = i + decimal_part:len()

   --
   -- Grab an optional exponential part
   --
   local exponent_part = text:match('^[eE][-+]?%d+', i) or ""

   i = i + exponent_part:len()

   local full_number_text = integer_part .. decimal_part .. exponent_part
   local as_number = tonumber(full_number_text)

   if not as_number then
      self:onDecodeError("bad number", text, start, etc)
   end

   return as_number, i
end


local function grok_string(self, text, start, etc)

   if text:sub(start,start) ~= '"' then
      self:onDecodeError("expected string's opening quote", text, start, etc)
   end

   local i = start + 1 -- +1 to bypass the initial quote
   local text_len = text:len()
   local VALUE = ""
   while i <= text_len do
      local c = text:sub(i,i)
      if c == '"' then
         return VALUE, i + 1
      end
      if c ~= '\\' then
         VALUE = VALUE .. c
         i = i + 1
      elseif text:match('^\\b', i) then
         VALUE = VALUE .. "\b"
         i = i + 2
      elseif text:match('^\\f', i) then
         VALUE = VALUE .. "\f"
         i = i + 2
      elseif text:match('^\\n', i) then
         VALUE = VALUE .. "\n"
         i = i + 2
      elseif text:match('^\\r', i) then
         VALUE = VALUE .. "\r"
         i = i + 2
      elseif text:match('^\\t', i) then
         VALUE = VALUE .. "\t"
         i = i + 2
      else
         local hex = text:match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
         if hex then
            i = i + 6 -- bypass what we just read

            -- We have a Unicode codepoint. It could be standalone, or if in the proper range and
            -- followed by another in a specific range, it'll be a two-code surrogate pair.
            local codepoint = tonumber(hex, 16)
            if codepoint >= 0xD800 and codepoint <= 0xDBFF then
               -- it's a hi surrogate... see whether we have a following low
               local lo_surrogate = text:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
               if lo_surrogate then
                  i = i + 6 -- bypass the low surrogate we just read
                  codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16)
               else
                  -- not a proper low, so we'll just leave the first codepoint as is and spit it out.
               end
            end
            VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint)

         else

            -- just pass through what's escaped
            VALUE = VALUE .. text:match('^\\(.)', i)
            i = i + 2
         end
      end
   end

   self:onDecodeError("unclosed string", text, start, etc)
end

local function skip_whitespace(text, start)

   local _, match_end = text:find("^[ \n\r\t]+", start) -- [http://www.ietf.org/rfc/rfc4627.txt] Section 2
   if match_end then
      return match_end + 1
   else
      return start
   end
end

local grok_one -- assigned later

local function grok_object(self, text, start, etc)
   if text:sub(start,start) ~= '{' then
      self:onDecodeError("expected '{'", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '{'

   local VALUE = self.strictTypes and self:newObject { } or { }

   if text:sub(i,i) == '}' then
      return VALUE, i + 1
   end
   local text_len = text:len()
   while i <= text_len do
      local key, new_i = grok_string(self, text, i, etc)

      i = skip_whitespace(text, new_i)

      if text:sub(i, i) ~= ':' then
         self:onDecodeError("expected colon", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)

      local new_val, new_i = grok_one(self, text, i)

      VALUE[key] = new_val

      --
      -- Expect now either '}' to end things, or a ',' to allow us to continue.
      --
      i = skip_whitespace(text, new_i)

      local c = text:sub(i,i)

      if c == '}' then
         return VALUE, i + 1
      end

      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '}'", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)
   end

   self:onDecodeError("unclosed '{'", text, start, etc)
end

local function grok_array(self, text, start, etc)
   if text:sub(start,start) ~= '[' then
      self:onDecodeError("expected '['", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '['
   local VALUE = self.strictTypes and self:newArray { } or { }
   if text:sub(i,i) == ']' then
      return VALUE, i + 1
   end

   local VALUE_INDEX = 1

   local text_len = text:len()
   while i <= text_len do
      local val, new_i = grok_one(self, text, i)

      -- can't table.insert(VALUE, val) here because it's a no-op if val is nil
      VALUE[VALUE_INDEX] = val
      VALUE_INDEX = VALUE_INDEX + 1

      i = skip_whitespace(text, new_i)

      --
      -- Expect now either ']' to end things, or a ',' to allow us to continue.
      --
      local c = text:sub(i,i)
      if c == ']' then
         return VALUE, i + 1
      end
      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '['", text, i, etc)
      end
      i = skip_whitespace(text, i + 1)
   end
   self:onDecodeError("unclosed '['", text, start, etc)
end


grok_one = function(self, text, start, etc)
   -- Skip any whitespace
   start = skip_whitespace(text, start)

   if start > text:len() then
      self:onDecodeError("unexpected end of string", text, nil, etc)
   end

   if text:find('^"', start) then
      return grok_string(self, text, start, etc)

   elseif text:find('^[-0123456789 ]', start) then
      return grok_number(self, text, start, etc)

   elseif text:find('^%{', start) then
      return grok_object(self, text, start, etc)

   elseif text:find('^%[', start) then
      return grok_array(self, text, start, etc)

   elseif text:find('^true', start) then
      return true, start + 4

   elseif text:find('^false', start) then
      return false, start + 5

   elseif text:find('^null', start) then
      return nil, start + 4

   else
      self:onDecodeError("can't parse JSON", text, start, etc)
   end
end

function OBJDEF:decode(text, etc)
   if type(self) ~= 'table' or self.__index ~= OBJDEF then
      OBJDEF:onDecodeError("JSON:decode must be called in method format", nil, nil, etc)
   end

   if text == nil then
      self:onDecodeOfNilError(string.format("nil passed to JSON:decode()"), nil, nil, etc)
   elseif type(text) ~= 'string' then
      self:onDecodeError(string.format("expected string argument to JSON:decode(), got %s", type(text)), nil, nil, etc)
   end

   if text:match('^%s*$') then
      return nil
   end

   if text:match('^%s*<') then
      -- Can't be JSON... we'll assume it's HTML
      self:onDecodeOfHTMLError(string.format("html passed to JSON:decode()"), text, nil, etc)
   end

   --
   -- Ensure that it's not UTF-32 or UTF-16.
   -- Those are perfectly valid encodings for JSON (as per RFC 4627 section 3),
   -- but this package can't handle them.
   --
   if text:sub(1,1):byte() == 0 or (text:len() >= 2 and text:sub(2,2):byte() == 0) then
      self:onDecodeError("JSON package groks only UTF-8, sorry", text, nil, etc)
   end

   local success, value = pcall(grok_one, self, text, 1, etc)

   if success then
      return value
   else
      -- if JSON:onDecodeError() didn't abort out of the pcall, we'll have received the error message here as "value", so pass it along as an assert.
      if self.assert then
         self.assert(false, value)
      else
         assert(false, value)
      end
      -- and if we're still here, return a nil and throw the error message on as a second arg
      return nil, value
   end
end

local function backslash_replacement_function(c)
   if c == "\n" then
      return "\\n"
   elseif c == "\r" then
      return "\\r"
   elseif c == "\t" then
      return "\\t"
   elseif c == "\b" then
      return "\\b"
   elseif c == "\f" then
      return "\\f"
   elseif c == '"' then
      return '\\"'
   elseif c == '\\' then
      return '\\\\'
   else
      return string.format("\\u%04x", c:byte())
   end
end

local chars_to_be_escaped_in_JSON_string
   = '['
   ..    '"'    -- class sub-pattern to match a double quote
   ..    '%\\'  -- class sub-pattern to match a backslash
   ..    '%z'   -- class sub-pattern to match a null
   ..    '\001' .. '-' .. '\031' -- class sub-pattern to match control characters
   .. ']'

local function json_string_literal(value)
   local newval = value:gsub(chars_to_be_escaped_in_JSON_string, backslash_replacement_function)
   return '"' .. newval .. '"'
end

local function object_or_array(self, T, etc)
   --
   -- We need to inspect all the keys... if there are any strings, we'll convert to a JSON
   -- object. If there are only numbers, it's a JSON array.
   --
   -- If we'll be converting to a JSON object, we'll want to sort the keys so that the
   -- end result is deterministic.
   --
   local string_keys = { }
   local number_keys = { }
   local number_keys_must_be_strings = false
   local maximum_number_key

   for key in pairs(T) do
      if type(key) == 'string' then
         table.insert(string_keys, key)
      elseif type(key) == 'number' then
         table.insert(number_keys, key)
         if key <= 0 or key >= math.huge then
            number_keys_must_be_strings = true
         elseif not maximum_number_key or key > maximum_number_key then
            maximum_number_key = key
         end
      else
         self:onEncodeError("can't encode table with a key of type " .. type(key), etc)
      end
   end

   if #string_keys == 0 and not number_keys_must_be_strings then
      --
      -- An empty table, or a numeric-only array
      --
      if #number_keys > 0 then
         return nil, maximum_number_key -- an array
      elseif tostring(T) == "JSON array" then
         return nil
      elseif tostring(T) == "JSON object" then
         return { }
      else
         -- have to guess, so we'll pick array, since empty arrays are likely more common than empty objects
         return nil
      end
   end

   table.sort(string_keys)

   local map
   if #number_keys > 0 then
      --
      -- If we're here then we have either mixed string/number keys, or numbers inappropriate for a JSON array
      -- It's not ideal, but we'll turn the numbers into strings so that we can at least create a JSON object.
      --

      if self.noKeyConversion then
         self:onEncodeError("a table with both numeric and string keys could be an object or array; aborting", etc)
      end

      --
      -- Have to make a shallow copy of the source table so we can remap the numeric keys to be strings
      --
      map = { }
      for key, val in pairs(T) do
         map[key] = val
      end

      table.sort(number_keys)

      --
      -- Throw numeric keys in there as strings
      --
      for _, number_key in ipairs(number_keys) do
         local string_key = tostring(number_key)
         if map[string_key] == nil then
            table.insert(string_keys , string_key)
            map[string_key] = T[number_key]
         else
            self:onEncodeError("conflict converting table with mixed-type keys into a JSON object: key " .. number_key .. " exists both as a string and a number.", etc)
         end
      end
   end

   return string_keys, nil, map
end

--
-- Encode
--
-- 'options' is nil, or a table with possible keys:
--    pretty            -- if true, return a pretty-printed version
--    indent            -- a string (usually of spaces) used to indent each nested level
--    align_keys        -- if true, align all the keys when formatting a table
--
local encode_value -- must predeclare because it calls itself
function encode_value(self, value, parents, etc, options, indent)

   if value == nil then
      return 'null'

   elseif type(value) == 'string' then
      return json_string_literal(value)

   elseif type(value) == 'number' then
      if value ~= value then
         --
         -- NaN (Not a Number).
         -- JSON has no NaN, so we have to fudge the best we can. This should really be a package option.
         --
         return "null"
      elseif value >= math.huge then
         --
         -- Positive infinity. JSON has no INF, so we have to fudge the best we can. This should
         -- really be a package option. Note: at least with some implementations, positive infinity
         -- is both ">= math.huge" and "<= -math.huge", which makes no sense but that's how it is.
         -- Negative infinity is properly "<= -math.huge". So, we must be sure to check the ">="
         -- case first.
         --
         return "1e+9999"
      elseif value <= -math.huge then
         --
         -- Negative infinity.
         -- JSON has no INF, so we have to fudge the best we can. This should really be a package option.
         --
         return "-1e+9999"
      else
         return tostring(value)
      end

   elseif type(value) == 'boolean' then
      return tostring(value)

   elseif type(value) ~= 'table' then
      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)

   else
      --
      -- A table to be converted to either a JSON object or array.
      --
      local T = value

      if type(options) ~= 'table' then
         options = {}
      end
      if type(indent) ~= 'string' then
         indent = ""
      end

      if parents[T] then
         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
      else
         parents[T] = true
      end

      local result_value

      local object_keys, maximum_number_key, map = object_or_array(self, T, etc)
      if maximum_number_key then
         --
         -- An array...
         --
         local ITEMS = { }
         for i = 1, maximum_number_key do
            table.insert(ITEMS, encode_value(self, T[i], parents, etc, options, indent))
         end

         if options.pretty then
            result_value = "[ " .. table.concat(ITEMS, ", ") .. " ]"
         else
            result_value = "["  .. table.concat(ITEMS, ",")  .. "]"
         end

      elseif object_keys then
         --
         -- An object
         --
         local TT = map or T

         if options.pretty then

            local KEYS = { }
            local max_key_length = 0
            for _, key in ipairs(object_keys) do
               local encoded = encode_value(self, tostring(key), parents, etc, options, indent)
               if options.align_keys then
                  max_key_length = math.max(max_key_length, #encoded)
               end
               table.insert(KEYS, encoded)
            end
            local key_indent = indent .. tostring(options.indent or "")
            local subtable_indent = key_indent .. string.rep(" ", max_key_length) .. (options.align_keys and "  " or "")
            local FORMAT = "%s%" .. string.format("%d", max_key_length) .. "s: %s"

            local COMBINED_PARTS = { }
            for i, key in ipairs(object_keys) do
               local encoded_val = encode_value(self, TT[key], parents, etc, options, subtable_indent)
               table.insert(COMBINED_PARTS, string.format(FORMAT, key_indent, KEYS[i], encoded_val))
            end
            result_value = "{\n" .. table.concat(COMBINED_PARTS, ",\n") .. "\n" .. indent .. "}"

         else

            local PARTS = { }
            for _, key in ipairs(object_keys) do
               local encoded_val = encode_value(self, TT[key],       parents, etc, options, indent)
               local encoded_key = encode_value(self, tostring(key), parents, etc, options, indent)
               table.insert(PARTS, string.format("%s:%s", encoded_key, encoded_val))
            end
            result_value = "{" .. table.concat(PARTS, ",") .. "}"

         end
      else
         --
         -- An empty array/object... we'll treat it as an array, though it should really be an option
         --
         result_value = "[]"
      end

      parents[T] = false
      return result_value
   end
end


function OBJDEF:encode(value, etc, options)
   if type(self) ~= 'table' or self.__index ~= OBJDEF then
      OBJDEF:onEncodeError("JSON:encode must be called in method format", etc)
   end
   return encode_value(self, value, {}, etc, options or nil)
end

function OBJDEF:encode_pretty(value, etc, options)
   if type(self) ~= 'table' or self.__index ~= OBJDEF then
      OBJDEF:onEncodeError("JSON:encode_pretty must be called in method format", etc)
   end
   return encode_value(self, value, {}, etc, options or default_pretty_options)
end

function OBJDEF.__tostring()
   return "JSON encode/decode package"
end

OBJDEF.__index = OBJDEF

function OBJDEF:new(args)
   local new = { }

   if args then
      for key, val in pairs(args) do
         new[key] = val
      end
   end

   return setmetatable(new, OBJDEF)
end

return OBJDEF:new()

--
-- Version history:
--
--   20141223.14   The encode_pretty() routine produced fine results for small datasets, but isn't really
--                 appropriate for anything large, so with help from Alex Aulbach I've made the encode routines
--                 more flexible, and changed the default encode_pretty() to be more generally useful.
--
--                 Added a third 'options' argument to the encode() and encode_pretty() routines, to control
--                 how the encoding takes place.
--
--                 Updated docs to add assert() call to the loadfile() line, just as good practice so that
--                 if there is a problem loading JSON.lua, the appropriate error message will percolate up.
--
--   20140920.13   Put back (in a way that doesn't cause warnings about unused variables) the author string,
--                 so that the source of the package, and its version number, are visible in compiled copies.
--
--   20140911.12   Minor lua cleanup.
--                 Fixed internal reference to 'JSON.noKeyConversion' to reference 'self' instead of 'JSON'.
--                 (Thanks to SmugMug's David Parry for these.)
--
--   20140418.11   JSON nulls embedded within an array were being ignored, such that
--                     ["1",null,null,null,null,null,"seven"],
--                 would return
--                     {1,"seven"}
--                 It's now fixed to properly return
--                     {1, nil, nil, nil, nil, nil, "seven"}
--                 Thanks to "haddock" for catching the error.
--
--   20140116.10   The user's JSON.assert() wasn't always being used. Thanks to "blue" for the heads up.
--
--   20131118.9    Update for Lua 5.3... it seems that tostring(2/1) produces "2.0" instead of "2",
--                 and this caused some problems.
--
--   20131031.8    Unified the code for encode() and encode_pretty(); they had been stupidly separate,
--                 and had of course diverged (encode_pretty didn't get the fixes that encode got, so
--                 sometimes produced incorrect results; thanks to Mattie for the heads up).
--
--                 Handle encoding tables with non-positive numeric keys (unlikely, but possible).
--
--                 If a table has both numeric and string keys, or its numeric keys are inappropriate
--                 (such as being non-positive or infinite), the numeric keys are turned into
--                 string keys appropriate for a JSON object. So, as before,
--                         JSON:encode({ "one", "two", "three" })
--                 produces the array
--                         ["one","two","three"]
--                 but now something with mixed key types like
--                         JSON:encode({ "one", "two", "three", SOMESTRING = "some string" }))
--                 instead of throwing an error produces an object:
--                         {"1":"one","2":"two","3":"three","SOMESTRING":"some string"}
--
--                 To maintain the prior throw-an-error semantics, set
--                      JSON.noKeyConversion = true
--                 
--   20131004.7    Release under a Creative Commons CC-BY license, which I should have done from day one, sorry.
--
--   20130120.6    Comment update: added a link to the specific page on my blog where this code can
--                 be found, so that folks who come across the code outside of my blog can find updates
--                 more easily.
--
--   20111207.5    Added support for the 'etc' arguments, for better error reporting.
--
--   20110731.4    More feedback from David Kolf on how to make the tests for Nan/Infinity system independent.
--
--   20110730.3    Incorporated feedback from David Kolf at http://lua-users.org/wiki/JsonModules:
--
--                   * When encoding lua for JSON, Sparse numeric arrays are now handled by
--                     spitting out full arrays, such that
--                        JSON:encode({"one", "two", [10] = "ten"})
--                     returns
--                        ["one","two",null,null,null,null,null,null,null,"ten"]
--
--                     In 20100810.2 and earlier, only up to the first non-null value would have been retained.
--
--                   * When encoding lua for JSON, numeric value NaN gets spit out as null, and infinity as "1+e9999".
--                     Version 20100810.2 and earlier created invalid JSON in both cases.
--
--                   * Unicode surrogate pairs are now detected when decoding JSON.
--
--   20100810.2    added some checking to ensure that an invalid Unicode character couldn't leak in to the UTF-8 encoding
--
--   20100731.1    initial public release
--
Flib/keyboard.lua¥local component = require("component")

local keyboard = {pressedChars = {}, pressedCodes = {}}

-- these key definitions are only a subset of all the defined keys
-- __index loads all key data from /lib/tools/keyboard_full.lua (only once)
-- new key metadata should be added here if required for boot
keyboard.keys = {
  c               = 0x2E,
  d               = 0x20,
  q               = 0x10,
  back            = 0x0E, -- backspace
  delete          = 0xD3,
  down            = 0xD0,
  enter           = 0x1C,
  home            = 0xC7,
  lcontrol        = 0x1D,
  left            = 0xCB,
  lmenu           = 0x38, -- left Alt
  lshift          = 0x2A,
  pageDown        = 0xD1,
  rcontrol        = 0x9D,
  right           = 0xCD,
  rmenu           = 0xB8, -- right Alt
  rshift          = 0x36,
  space           = 0x39,
  tab             = 0x0F,
  up              = 0xC8,
  ["end"]         = 0xCF,
}

-- Create inverse mapping for name lookup.
setmetatable(keyboard.keys,
{
  __index = function(tbl, k)
    getmetatable(keyboard.keys).__index = nil -- to be safe
    loadfile("/lib/tools/keyboard_full.lua","t",setmetatable({keyboard=keyboard},{__index=_G}))()
    return tbl[k]
  end
})

-------------------------------------------------------------------------------

local function getKeyboardAddress(address)
  if address then
    return address
  else
    local primary = component.isAvailable("keyboard") and component.getPrimary("keyboard")
    if primary then
      return primary.address
    end
  end
end

local function getPressedCodes(address)
  address = getKeyboardAddress(address)
  return address and keyboard.pressedCodes[address] or false
end

local function getPressedChars(address)
  address = getKeyboardAddress(address)
  return address and keyboard.pressedChars[address] or false
end

function keyboard.isAltDown(address)
  checkArg(1, address, "string", "nil")
  local pressedCodes = getPressedCodes(address)
  return pressedCodes and (pressedCodes[keyboard.keys.lmenu] or pressedCodes[keyboard.keys.rmenu]) ~= nil
end

function keyboard.isControl(char)
  return type(char) == "number" and (char < 0x20 or (char >= 0x7F and char <= 0x9F))
end

function keyboard.isControlDown(address)
  checkArg(1, address, "string", "nil")
  local pressedCodes = getPressedCodes(address)
  return pressedCodes and (pressedCodes[keyboard.keys.lcontrol] or pressedCodes[keyboard.keys.rcontrol]) ~= nil
end

function keyboard.isKeyDown(charOrCode, address)
  checkArg(1, charOrCode, "string", "number")
  checkArg(2, address, "string", "nil")
  if type(charOrCode) == "string" then
    local pressedChars = getPressedChars(address)
    return pressedChars and pressedChars[utf8 and utf8.codepoint(charOrCode) or charOrCode:byte()]
  elseif type(charOrCode) == "number" then
    local pressedCodes = getPressedCodes(address)
    return pressedCodes and pressedCodes[charOrCode]
  end
end

function keyboard.isShiftDown(address)
  checkArg(1, address, "string", "nil")
  local pressedCodes = getPressedCodes(address)
  return pressedCodes and (pressedCodes[keyboard.keys.lshift] or pressedCodes[keyboard.keys.rshift]) ~= nil
end

-------------------------------------------------------------------------------

return keyboard
Flib/libPNGImage.lua<local PNGImage = {}

--
-- libPNGimage by TehSomeLuigi
-- Revision:
PNGImage.rev = 1
--
-- A library to load, edit and save PNGs for OpenComputers
--

--[[
	
	Feel free to use however you wish.
	This header must however be preserved should this be redistributed, even
	if in a modified form.
	
	This software comes with no warranties whatsoever.
	
	2014 TehSomeLuigi

]]--


--local DEFLATE = require("libDEFLATE")
local DeflateLua = require("deflatelua")
local CRC32Lua = require("crc32lua")

local bit = require("bit32")

local PNGImagemetatable = {}
PNGImagemetatable.__index = PNGImage




PNGImage.ColourTypes = {
	Greyscale=0,
	Truecolour=2,
	IndexedColour=3,
	GreyscaleAlpha=4,
	TruecolourAlpha=6
}






local band = bit.band
local rshift = bit.rshift



-- Unpack 32-bit unsigned integer (most-significant-byte, MSB, first)
-- from byte string.
local function __unpack_msb_uint32(s)
	local a,b,c,d = s:byte(1,#s)
	local num = (((a*256) + b) * 256 + c) * 256 + d
	return num
end

local function __write_msb_uint32(fh, int)
	-- MSB B2 B1 LSB
	
	local msb = rshift(band(0xFF000000, int), 24)
	local b2 = rshift(band(0x00FF0000, int), 16)
	local b1 = rshift(band(0x0000FF00, int), 8)
	local lsb = band(0x000000FF, int)
	
	fh:write(string.char(msb))
	fh:write(string.char(b2))
	fh:write(string.char(b1))
	fh:write(string.char(lsb))
end

local function __wbuf_msb_uint32(buf, int)
	-- MSB B2 B1 LSB
	
	local msb = rshift(band(0xFF000000, int), 24)
	local b2 = rshift(band(0x00FF0000, int), 16)
	local b1 = rshift(band(0x0000FF00, int), 8)
	local lsb = band(0x000000FF, int)
	
	buf(msb)
	buf(b2)
	buf(b1)
	buf(lsb)
end

local function __sep_msb_uint32(int)
	-- MSB B2 B1 LSB
	
	local msb = rshift(band(0xFF000000, int), 24)
	local b2 = rshift(band(0x00FF0000, int), 16)
	local b1 = rshift(band(0x0000FF00, int), 8)
	local lsb = band(0x000000FF, int)
	
	return msb, b2, b1, lsb
end

local function __pack_msb_uint16(int)
	return string.char(rshift(band(int, 0xFF00), 8), band(int, 0xFF))
end

local function __pack_lsb_uint16(int)
	return string.char(band(int, 0xFF), rshift(band(int, 0xFF00), 8))
end

-- Read 32-bit unsigned integer (most-significant-byte, MSB, first) from file.
local function __read_msb_uint32(fh)
	return __unpack_msb_uint32(fh:read(4))
end

-- Read unsigned byte (integer) from file
local function __read_byte(fh)
	return fh:read(1):byte()
end



local function getBitWidthPerPixel(ihdr)
	if ihdr.color_type == PNGImage.ColourTypes.Greyscale then -- Greyscale
		return ihdr.bit_depth
	end
	if ihdr.color_type == PNGImage.ColourTypes.Truecolour then -- Truecolour
		return ihdr.bit_depth * 3
	end
	if ihdr.color_type == PNGImage.ColourTypes.IndexedColour then -- Indexed-colour
		return ihdr.bit_depth
	end
	if ihdr.color_type == PNGImage.ColourTypes.GreyscaleAlpha then -- Greyscale + Alpha
		return ihdr.bit_depth * 2
	end
	if ihdr.color_type == PNGImage.ColourTypes.TruecolourAlpha then -- Truecolour + Alpha
		return ihdr.bit_depth * 4
	end
end

local function getByteWidthPerScanline(ihdr)
	return math.ceil((ihdr.width * getBitWidthPerPixel(ihdr)) / 8)
end

local outssmt = {}

function outssmt:__call(write)
	self.str = self.str .. string.char(write)
end

function outssmt.OutStringStream()
	local outss = {str=""}
	setmetatable(outss, outssmt)
	return outss
end




local function __parse_IHDR(fh, len)
	if len ~= 13 then
		error("PNG IHDR Corrupt - should be 13 bytes long")
	end
	
	local ihdr = {}
	
	ihdr.width = __read_msb_uint32(fh)
	ihdr.height = __read_msb_uint32(fh)
	ihdr.bit_depth = __read_byte(fh)
	ihdr.color_type = __read_byte(fh)
	ihdr.compression_method = __read_byte(fh)
	ihdr.filter_method = __read_byte(fh)
	ihdr.interlace_method = __read_byte(fh)
	
	--[[
	print("width=", ihdr.width)
	print("height=", ihdr.height)
	print("bit_depth=", ihdr.bit_depth)
	print("color_type=", ihdr.color_type)
	print("compression_method=", ihdr.compression_method)
	print("filter_method=", ihdr.filter_method)
	print("interlace_method=", ihdr.interlace_method)
	]]--
	
	return ihdr
end

--[[
local function __parse_IDAT(fh, len, commeth)
	if commeth ~= 0 then
		error("Only zlib/DEFLATE compression supported")
	end
	
	local d, msg = DEFLATE.inflate(fh, len);
	
	if not d then
		return nil, msg
	end
	
	local oh = io.open('dump.dat', 'wb')
	oh:write(d.dat)
	oh:close()
	
	return true
end
]]--

local function __parse_IDAT(fh, len, commeth, outss)
	if commeth ~= 0 then
		error("Only zlib/DEFLATE compression supported")
	end
	
	
	--local oh = io.open('dump.dat', 'wb')
	--oh:write(d.dat)
	
	--local ph = io.open('pass.dat', 'wb')
	
	local input = fh:read(len)
	
	--ph:write(input)
	--ph:close()
	
	local cfg = {input=input, output=outss, disable_crc=true}
	
	DeflateLua.inflate_zlib(cfg)
	
	--oh:close()
	
--	if not d then
--		return nil, msg
--	end
	
	return true
end



local function getPNGStdByteAtXY(ihdr, oss, x, y)
	local bpsl = getByteWidthPerScanline(ihdr) -- don't include filterType byte -- we don't store that after it has been read
	if (x <= 0) or (y <= 0) then
		return 0 -- this is what the spec says we should return when the coordinate is out of bounds -- in this part of the code, the coordinates are ONE-BASED like in good Lua
	end
	local offset_by_y = (y - 1) * bpsl
	-- now read it!
	local idx = offset_by_y + x
	return oss.str:sub(idx, idx):byte()
end


local function __paeth_predictor(a, b, c)
	local p = a + b - c
	local pa = math.abs(p - a)
	local pb = math.abs(p - b)
	local pc = math.abs(p - c)
	if pa <= pb and pa <= pc then
		return a
	elseif pb <= pc then
		return b
	else
		return c
	end
end



local function __parse_IDAT_effective_bytes(outss, ihdr)
	local bpsl = getByteWidthPerScanline(ihdr)
	local bypsl = math.ceil(getBitWidthPerPixel(ihdr) / 8)
	
	if outss.str:len() == 0 then
		error("Empty string: outss")
	end
	
	local bys = DeflateLua.stringToBytestream(outss.str)
	
	if not bys then
		error("Did not get a bytestream from string", bys, outss)
	end
	
	local out2 = outssmt.OutStringStream() -- __callable table with metatable that stores what you give it
	
	local y = 0
	
	-- x the byte being filtered;
	-- a the byte corresponding to x in the pixel immediately before the pixel containing x (or the byte immediately before x, when the bit depth is less than 8);
	-- b the byte corresponding to x in the previous scanline;
	-- c the byte corresponding to b in the pixel immediately before the pixel containing b (or the byte immediately before b, when the bit depth is less than 8).
	
	while true do
		local filterType = bys:read()
		
		if filterType == nil then
			break
		end
		
		y = y + 1
		
		for x = 1, bpsl do
			--[..c..][..b..]
			--[..a..][..x <--- what is being processed (x)
			local a = getPNGStdByteAtXY(ihdr, out2, x - bypsl, y)
			local b = getPNGStdByteAtXY(ihdr, out2, x, y - 1)
			local c = getPNGStdByteAtXY(ihdr, out2, x - bypsl, y - 1)
			
			local outVal = 0
			
			if filterType == 0 then
				-- Recon(x) = Filt(x)
				outVal = bys:read()
			elseif filterType == 1 then
				-- Recon(x) = Filt(x) + Recon(a)
				outVal = bys:read() + a
			elseif filterType == 2 then
				-- Recon(x) = Filt(x) + Recon(b)
				outVal = bys:read() + b
			elseif filterType == 3 then
				-- Recon(x) = Filt(x) + floor((Recon(a) + Recon(b)) / 2)
				outVal = bys:read() + math.floor((a + b) / 2)
			elseif filterType == 4 then
				-- Recon(x) = Filt(x) + PaethPredictor(Recon(a), Recon(b), Recon(c))
				outVal = bys:read() + __paeth_predictor(a, b, c)
			else
				error("Unsupported Filter Type: " .. tostring(filterType))
			end
			
			outVal = outVal % 256
			
			out2(outVal)
		end
	end
	
	return out2
end



local function __newPNGImage()
	local pngi = {}
	setmetatable(pngi, PNGImagemetatable)
	return pngi
end

function PNGImage.newFromFile(fn)
	local fh = io.open(fn, 'rb')
	if not fh then
		error("Could not open PNG file")
	end
	return PNGImage.newFromFileHandle(fh)
end

function PNGImage.newFromScratch(width, height, bkcol)
	local pngi = __newPNGImage()
	
	local width = tonumber(width)
	local height = tonumber(height)
	
	if (not width) or (width < 1) or (math.floor(width) ~= width) then
		error("Invalid param #1 (width) to PNGImage.newFromScratch - integer (>=0) expected")
	end
	if (not height) or (height < 1) or (math.floor(height) ~= height) then
		error("Invalid param #2 (height) to PNGImage.newFromScratch - integer (>=0) expected")
	end
	
	local bkg = {0, 0, 0, 0} -- Transparency
	
	if type(bkcol) == "table" then
		if #bkcol == 3 then
			bkg = {bkcol[1], bkcol[2], bkcol[3], 255} -- Opaque colour
		elseif #bkcol == 4 then
			bkg = {bkcol[1], bkcol[2], bkcol[3], bkcol[4]} -- Defined
		else
			error("Invalid format for param #3 (bkcol) to PNGImage.newFromScratch: nil or table expected, but the table must be of format {r, g, b} or {r, g, b, a} -- Invalid table")
		end
	elseif bkcol ~= nil then
		error("Invalid format for param #3 (bkcol) to PNGImage.newFromScratch: nil or table expected, but the table must be of format {r, g, b} or {r, g, b, a} -- Parameter is not nil or table")
	end
	
	bkg[1] = tonumber(bkg[1])
	if bkg[1] == nil then
		error("PNGImage.newFromScratch: bkg[R] is not numeric")
	end
	bkg[2] = tonumber(bkg[2])
	if bkg[2] == nil then
		error("PNGImage.newFromScratch: bkg[G] is not numeric")
	end
	bkg[3] = tonumber(bkg[3])
	if bkg[3] == nil then
		error("PNGImage.newFromScratch: bkg[B] is not numeric")
	end
	bkg[4] = tonumber(bkg[4])
	if bkg[4] == nil then
		error("PNGImage.newFromScratch: bkg[A] is not numeric")
	end
	
	pngi.ihdr = {
		width = width,
		height = height,
		bit_depth = 8,
		color_type = 6,
		compression_method = 0,
		filter_method = 0,
		interlace_method = 0
	}
	
	-- do this for every pixel.. i.e string.rep(str, w*h)
	pngi.data = string.byte(bkg[1], bkg[2], bkg[3], bkg[4]):rep(width * height)
	
	return pngi
end

function PNGImage.newFromFileHandle(fh)
	local pngi = __newPNGImage()
	local expecting = "\137\080\078\071\013\010\026\010"
	if fh:read(8) ~= expecting then -- check the 8-byte PNG header exists
		error("Not a PNG file")
	end
	
	local ihdr
	
	local outss = outssmt.OutStringStream()
	
	while true do
		local len = __read_msb_uint32(fh)
		local stype = fh:read(4)
		
		if stype == 'IHDR' then
			ihdr, msg = __parse_IHDR(fh, len)
		elseif stype == 'IDAT' then
			local res, msg = __parse_IDAT(fh, len, ihdr.compression_method, outss)
		else
			fh:read(len) -- dummy read
		end
		
		local crc = __read_msb_uint32(fh)
		
		-- print("chunk:", "type=", stype, "len=", len, "crc=", crc)
		
		if stype == 'IEND' then
			break
		end
	end
	
	fh:close()
	
	
	if ihdr.filter_method ~= 0 then
		error("Unsupported Filter Method: " .. ihdr.filter_method)
	end
	
	if ihdr.interlace_method ~= 0 then
		error("Unsupported Interlace Method (Interlacing is currently unsupported): " .. ihdr.interlace_method)
	end
	
	if ihdr.color_type ~= PNGImage.ColourTypes.TruecolourAlpha and ihdr.color_type ~= PNGImage.ColourTypes.Truecolour then
		error("Currently, only Truecolour and Truecolour+Alpha images are supported.")
	end
	
	if ihdr.bit_depth ~= 8 then
		error("Currently, only images with a bit depth of 8 are supported.")
	end
	
	--[[
	local oh = io.open('before-decode.dat', 'wb')
	oh:write(outss.str)
	oh:close()
	]]--
	
	-- now parse the IDAT chunks
	local out2 = __parse_IDAT_effective_bytes(outss, ihdr)
	
	if ihdr.color_type == PNGImage.ColourTypes.Truecolour then
		-- add an alpha layer so it effectively becomes RGBA, not RGB
		local inp = out2.str
		out2 = outssmt.OutStringStream()
		
		for i=1, ihdr.width*ihdr.height do
			local b = ((i - 1)*3) + 1
			out2(inp:byte(b)) -- R
			out2(inp:byte(b + 1)) -- G
			out2(inp:byte(b + 2)) -- B
			out2(255) -- A
		end
	end
	
	pngi.ihdr = ihdr
	pngi.data = out2.str
	
	--[[
	local oh = io.open('effective.dat', 'wb')
	oh:write(out2.str)
	oh:close()
	]]--
	
	return pngi
end


-- Warning: Co-ordinates are Zero-based but strings are 1-based
function PNGImage:getByteOffsetForPixel(x, y)
	return (((y * self.ihdr.width) + x) * 4) + 1
end

function PNGImage:getPixel(x, y)
	local off = self:getByteOffsetForPixel(x, y)
	return self.data:byte(off, off + 3)
end

function PNGImage:setPixel(x, y, col)
	local off = self:getByteOffsetForPixel(x, y)
	self.data = table.concat({self.data:sub(1, off - 1), string.char(col[1], col[2], col[3], col[4]), self.data:sub(off + 4)})
end

function PNGImage:lineXAB(ax, y, bx, col)
	for x=ax, bx do
		self:setPixel(x, y, col)
	end
end

function PNGImage:lineYAB(x, ay, by, col)
	for y=ay, by do
		self:setPixel(x, y, col)
	end
end

function PNGImage:lineRectangleAB(ax, ay, bx, by, col)
	self:lineXAB(ax, ay, bx, col)
	self:lineXAB(ax, by, bx, col)
	self:lineYAB(ax, ay, by, col)
	self:lineYAB(bx, ay, by, col)
end

function PNGImage:fillRectangleAB(ax, ay, bx, by, col)
	for x=ax, bx do
		for y=ay, by do
			self:setPixel(x, y, col)
		end
	end
end

function PNGImage:saveToFile(fn)
	local fh = io.open(fn, 'wb')
	if not fh then
		error("Could not open for writing: " .. fn)
	end
	self:saveToFileHandle(fh)
	fh:close()
end

function PNGImage:getSize()
	return self.ihdr.width, self.ihdr.height
end

function PNGImage:generateRawIDATData(outbuf)
	for y = 0, self.ihdr.height - 1 do
		outbuf(0) -- filter type is 0 (Filt(x) = Orig(x))
		for x = 0, self.ihdr.width - 1 do
			local r, g, b, a = self:getPixel(x, y)
			outbuf(r)
			outbuf(g)
			outbuf(b)
			outbuf(a)
		end
	end
end

local ZLIB_LITERAL_LIMIT = 65535

local function __raw_to_literalZLIB(inbuf)
	local outstr = string.char(8, 29) -- zlib headers
	
	while inbuf.str:len() > 0 do
		if inbuf.str:len() > ZLIB_LITERAL_LIMIT then
			outstr = outstr .. string.char(0) -- LITERAL[00] FINAL[0]
		else
			outstr = outstr .. string.char(1) -- LITERAL[00] FINAL[1]
		end
		local min = math.min(ZLIB_LITERAL_LIMIT, inbuf.str:len())
		outstr = table.concat({outstr, __pack_msb_uint16(min), __pack_msb_uint16(bit.bnot(min)), inbuf.str:sub(1, min)})
		inbuf.str = inbuf.str:sub(min + 1)
	end
	
	local adler32 = 1
	
	for i = 1, outstr:len() do
		adler32 = DeflateLua.adler32(outstr:byte(i), adler32)
	end
	
	outstr = table.concat({outstr, string.char(__sep_msb_uint32(adler32))})
	
	return outstr
end

function PNGImage:saveToFileHandle(fh)
	-- basic PNG 'encoder'
	-- most likely temporary
	local expecting = "\137\080\078\071\013\010\026\010"
	fh:write(expecting)
	
	local outbuf = outssmt.OutStringStream()
	
	__wbuf_msb_uint32(outbuf, self.ihdr.width)
	__wbuf_msb_uint32(outbuf, self.ihdr.height)
	
	outbuf(8) -- bit depth
	outbuf(6) -- colour type
	outbuf(0) -- compression method
	outbuf(0) -- filter method
	outbuf(0) -- interlace method
	
	__write_msb_uint32(fh, outbuf.str:len()) -- length field
	fh:write("IHDR") -- name of chunk
	fh:write(outbuf.str) -- chunk data
	__write_msb_uint32(fh, CRC32Lua.crc32_string("IHDR" .. outbuf.str)) -- chunk data CRC32
	outbuf.str = "" -- reset buffer
	
	-- now onto the IDAT
	
	self:generateRawIDATData(outbuf)
	
	local zlibstr = __raw_to_literalZLIB(outbuf)
	
	local tmpstr = ""
	while zlibstr:len() > 0 do
		local min = math.min(ZLIB_LITERAL_LIMIT, zlibstr:len())
		tmpstr = zlibstr:sub(1, min)
		zlibstr = zlibstr:sub(min + 1)
		
		__write_msb_uint32(fh, tmpstr:len()) -- length field
		fh:write("IDAT") -- name of chunk
		fh:write(tmpstr) -- chunk data
		__write_msb_uint32(fh, CRC32Lua.crc32_string("IDAT" .. tmpstr)) -- chunk data CRC32
		tmpstr = "" -- reset
	end
	
	__write_msb_uint32(fh, 0) -- length field
	fh:write("IEND") -- name of chunk
	-- fh:write(tmpstr) -- chunk data
	__write_msb_uint32(fh, CRC32Lua.crc32_string("IEND")) -- chunk data CRC32
end



return PNGImage
Flib/matrix.lua
local matrixLibrary = {}

---------------------------------------------------- Matrix tables creation ----------------------------------------------------------------

function matrixLibrary.newIdentityMatrix(size)
	local matrix = {}

	for y = 1, size do
		matrix[y] = {}
		for x = 1, size do
			matrix[y][x] = (x == y) and 1 or 0
		end
	end

	return matrix
end

function matrixLibrary.newCofactorMatrix(matrix)
	local cofactorMatrix = {}
	for y = 1, #matrix do
		cofactorMatrix[y] = {}
		for x = 1, #matrix[y] do
			cofactorMatrix[y][x] = matrixLibrary.getCofactor(matrix, y, x)
		end
	end

	return cofactorMatrix
end

function matrixLibrary.newAdjugateMatrix(matrix)
	return matrixLibrary.transpose(matrixLibrary.newCofactorMatrix(matrix))
end

function matrixLibrary.newFilledMatrix(width, height, value)
	local matrix = {}

	for y = 1, height do
		matrix[y] = {}
		for x = 1, width do
			matrix[y][x] = value
		end
	end

	return matrix
end

function matrixLibrary.copy(matrix)
	local newMatrix = {}

	for y = 1, #matrix do
		newMatrix[y] = {}
		for x = 1, #matrix[y] do
			newMatrix[y][x] = matrix[y][x]
		end
	end

	return newMatrix
end

function matrixLibrary.print(matrix)
	print("Matrix size: " .. #matrix .. "x" .. #matrix[1])
	for y = 1, #matrix do
		for x = 1, #matrix[y] do
			io.write(tostring((not matrix[y]) and "nil" or matrix[y][x]))
			io.write(' ')
		end
		print("")
	end

	return matrix
end

---------------------------------------------------- Matrix arithmetic operations ----------------------------------------------------------------

function matrixLibrary.multiply(matrix, data)
	local dataType = type(data)
	if dataType == "table" then
		if (#matrix[1] ~= #data) then error("Couldn't multiply matrixes AxB: A[columns] ~= B[rows]") end
		
		local result = {}
		for i = 1, #matrix do
			result[i] = {}
			for j = 1, #data[1] do
				local resultElement = 0
				for k = 1, #matrix[1] do
					resultElement = resultElement + (matrix[i][k] * data[k][j])
				end
				result[i][j] = resultElement
			end
		end

		return result
	elseif dataType == "number" then
		for y = 1, #matrix do
			for x = 1, #matrix[y] do
				matrix[y][x] = matrix[y][x] * data
			end
		end

		return matrix
	else
		error("Unsupported operation data type: " .. tostring(dataType))
	end
end

function matrixLibrary.divide(matrix, data)
	local dataType = type(data)
	if dataType == "table" then
		error("Matrix by matrix division doesn't supported yet")
	elseif dataType == "number" then
		for y = 1, #matrix do
			for x = 1, #matrix[y] do
				matrix[y][x] = matrix[y][x] / data
			end
		end

		return matrix
	else
		error("Unsupported operation data type: " .. tostring(dataType))
	end
end

---------------------------------------------------- Matrix resizing methods ----------------------------------------------------------------

function matrixLibrary.addRow(matrix, row)
	if (#matrix[1] ~= #row) then error("Insertion row size doesn't match matrix row size: " .. #row .. " vs " .. #matrix[1]) end
	
	table.insert(matrix, row)

	return matrix
end

function matrixLibrary.addColumn(matrix, column)
	if (#matrix ~= #column ) then error("Insertion column size doesn't match matrix column size: " .. #column .. " vs " .. #matrix) end
	
	for y = 1, #column do
		table.insert(matrix[y], column[y])
	end

	return matrix
end

function matrixLibrary.removeRow(matrix, row)
	if row > #matrix then error("Can't remove row that is bigger then matrix height") end
	
	table.remove(matrix, row)

	return matrix
end

function matrixLibrary.removeColumn(matrix, column)
	if column > #matrix[1] then error("Can't remove column that is bigger then matrix width") end
	
	for y = 1, #matrix do
		table.remove(matrix[y], column)
	end

	return matrix
end

---------------------------------------------------- Matrix advanced manipulation methods ----------------------------------------------------------------

function matrixLibrary.transpose(matrix)
	local transposedMatrix = {}
	for x = 1, #matrix[1] do
		transposedMatrix[x] = {}
		for y = 1, #matrix do
			transposedMatrix[x][y] = matrix[y][x]
		end
	end
	return transposedMatrix
end

function matrixLibrary.getMinor(matrix, row, column)
	return matrixLibrary.getDeterminant(matrixLibrary.removeColumn(matrixLibrary.removeRow(matrixLibrary.copy(matrix), row), column))
end

function matrixLibrary.getCofactor(matrix, row, column)
	return (-1) ^ (row + column) * matrixLibrary.getMinor(matrix, row, column)
end

function matrixLibrary.getDeterminant(matrix)
	local matrixSize = #matrix
	if matrixSize ~= #matrix[1] then error("Can't find determinant for matrix, row count != column count: " .. #matrix .. "x" .. #matrix[1]) end
	
	if matrixSize == 1 then
		return matrix[1][1]
	elseif matrixSize == 2 then
		return matrix[1][1] * matrix[2][2] - matrix[1][2] * matrix[2][1]
	else
		local determinant = 0
		for j = 1, matrixSize do
			determinant = determinant + matrixLibrary.getCofactor(matrix, 1, j) * matrix[1][j]
		end

		return determinant
	end
end

function matrixLibrary.invert(matrix)
	local determinant = matrixLibrary.getDeterminant(matrix)
	if determinant == 0 then error("Can't invert matrix with determinant equals 0") end

	return matrixLibrary.divide(matrixLibrary.newAdjugateMatrix(matrix), determinant)
end

------------------------------------------------------------------------------------------------------------------------

-- local m = {
-- 	{2, 5, 4},
-- 	{-5, 5, 6},
-- 	{1, 3, 7},
-- }
-- matrixLibrary.print(m)
-- m = matrixLibrary.invert(m)
-- matrixLibrary.print(m)

------------------------------------------------------------------------------------------------------------------------

return matrixLibrary

Flib/modemConnection.luaGi
local event = require("event")
local computer = require("computer")
local component = require("component")
local term = require("term")
local serialization = require("serialization")
local unicode = require("unicode")
local ecs, image
local modem = component.modem
local gpu = component.gpu
local modemConnection = {}

----------------------------------------------------------------------------------------------------------------------------------

modemConnection.port = 322
modemConnection.waitForConnectionAcceptingDelay = 10
modemConnection.receiveMessagesFromRobots = true
modemConnection.receiveMessagesFromTablets = true
modemConnection.receiveMessagesFromComputers = true

local infoMessages = {
	userTriesToConnectNoGUI = "ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ %s Ð¶ÐµÐ»Ð°ÐµÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ñ Ð²Ð°Ð¼Ð¸ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ. Ð Ð°Ð·ÑÐµÑÐ¸ÑÑ? Y/N",
	noModem = "Ð­ÑÐ¾Ð¹ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐµ ÑÑÐµÐ±ÑÐµÑÑÑ ÑÐµÑÐµÐ²Ð°Ñ ÐºÐ°ÑÑÐ° Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ",
}

----------------------------------------------------------------------------------------------------------------------------------

local xSize, ySize = gpu.getResolution()
local computerIcon, robotIcon, tabletIcon
if not component.isAvailable("robot") then
	image = require("image")
	ecs = require("ECSAPI")
	computerIcon = image.load("MineOS/System/OS/Icons/Computer.pic")
	robotIcon = image.load("MineOS/System/OS/Icons/Robot.pic")
	tabletIcon = image.load("MineOS/System/OS/Icons/Tablet.pic")
end

----------------------------------------------------------------------------------------------------------------------------------

local obj = {}
local function newObj(class, name, ...)
	obj[class] = obj[class] or {}
	obj[class][name] = {...}
end

local function sendAcceptingMessage(address)
	modem.send(address, modemConnection.port, "connectionAccepted", modemConnection.dataToSend)
end

local function sendDecliningMessage(address)
	modem.send(address, modemConnection.port, "connectionDeclined", modemConnection.dataToSend)
end

local function tryToConnect(address)
	modem.send(address, modemConnection.port, "iWantToConnect", modemConnection.dataToSend)
end

local function acceptingOrDecliningDialog(address, accepted)
	local text1, text2
	-- if accepted == true then
	-- 	text1 = "Ð£ÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ñ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¼"
	-- 	text2 = "\"" .. ecs.stringLimit("end", address, 18) .. "\""
	-- else
	if accepted == false then
		text1 = "ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ \"" .. ecs.stringLimit("end", address, 12) .. "\" Ð¾ÑÐºÐ°Ð·Ð°Ð»ÑÑ"
		text2 = "ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ñ Ð²Ð°Ð¼Ð¸ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ."
	elseif accepted == nil then
		text1 = "ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ \"" .. ecs.stringLimit("end", address, 12) .. "\" Ð½Ðµ Ð¾ÑÐ²ÐµÑÐ¸Ð»"
		text2 = "Ð½Ð° Ð²Ð°Ñ Ð·Ð°Ð¿ÑÐ¾Ñ"
	end

	ecs.universalWindow("auto", "auto", 36, 0x262626, true,
		{"EmptyLine"},
		{"CenterText", ecs.colors.orange, "WirelessConnection"},
		{"EmptyLine"},
		{"CenterText", 0xffffff, text1 },
		{"CenterText", 0xffffff, text2 },
		{"EmptyLine"},
		{"Button", {ecs.colors.orange, 0x262626, "OK"}}
	)
end

local function askForAcceptConnection(address)
	if not component.isAvailable("robot") then
		local data = ecs.universalWindow("auto", "auto", 36, 0x262626, true,
			{"EmptyLine"},
			{"CenterText", ecs.colors.orange, "WirelessConnection"},
			{"EmptyLine"},
			{"CenterText", 0xffffff, "ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ \"" .. ecs.stringLimit("end", address, 12) .. "\" Ð¶ÐµÐ»Ð°ÐµÑ" },
			{"CenterText", 0xffffff, "ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ñ Ð²Ð°Ð¼Ð¸ Ð±ÐµÑÐ¿ÑÐ¾Ð²Ð¾Ð´Ð½Ð¾Ðµ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ." },
			{"EmptyLine"},
			{"CenterText", 0xffffff, "Ð Ð°Ð·ÑÐµÑÐ¸ÑÑ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½Ð¸Ðµ?" },
			{"EmptyLine"},
			{"Button", {ecs.colors.orange, 0x262626, "ÐÐ°"}, {0x999999, 0xffffff, "ÐÐµÑ"}}
		)

		if data[1] == "ÐÐ°" then
			modemConnection.remoteAddress = address
			sendAcceptingMessage(address)
			computer.pushSignal("connectionEstabilishedExitFromGUI")
		else
			sendDecliningMessage(address)
		end
	else
		term.clear()
		term.setCursor(1, 1)
		print("ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ \"" .. string.sub(address, 1, 12) .. "\" Ð¶ÐµÐ»Ð°ÐµÑ ÑÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ Ñ Ð²Ð°Ð¼Ð¸ Ð±ÐµÑÐ¿ÑÐ¾Ð²Ð¾Ð´Ð½Ð¾Ðµ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ. Ð Ð°Ð·ÑÐµÑÐ¸ÑÑ Ð¿Ð¾Ð´ÐºÐ»ÑÑÐµÐ½Ð¸Ðµ? Y/N")
		local answer = term.read()
		if string.sub(string.lower(answer), 1, 1) == "y" then
			modemConnection.remoteAddress = address
			sendAcceptingMessage(address)
			print(" ")
			print("Ð¡Ð¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾.")
			print(" ")
			-- computer.pushSignal("key_down", component.getPrimary("keyboard").address, 13, 28, "ECS")
		else
			sendDecliningMessage(address)
			term.clear()
			term.setCursor(1, 1)
		end
	end
end

local function infoAboutClient(userData)

	local arguments = {
		"auto", "auto", 36, 0x262626, true, {"EmptyLine"}, {"CenterText", ecs.colors.orange, "ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ðµ"}, {"EmptyLine"},
	}

	if userData.isRobot then
		table.insert(arguments, {"CenterText", 0xffffff, "Ð¢Ð¸Ð¿: ÑÐ¾Ð±Ð¾Ñ"})
	elseif userData.isTablet then
		table.insert(arguments, {"CenterText", 0xffffff, "Ð¢Ð¸Ð¿: Ð¿Ð»Ð°Ð½ÑÐµÑ"})
	elseif not userData.isTablet and not userData.isRobot then
		table.insert(arguments, {"CenterText", 0xffffff, "Ð¢Ð¸Ð¿: ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑ"})
	end

	table.insert(arguments, {"CenterText", 0xffffff, "ÐÐ¼Ñ: " .. userData.name})
	table.insert(arguments, {"CenterText", 0xffffff, "ÐÐ´ÑÐµÑ: " .. ecs.stringLimit("end", userData.address, 12)})
	table.insert(arguments, {"CenterText", 0xffffff, "ÐÐ°Ð¼ÑÑÑ: " .. userData.ram .. " KB"})

	if userData.isTablet or userData.isRobot and userData.hasUpgrades then
		table.insert(arguments, {"EmptyLine"})
		table.insert(arguments, {"CenterText", ecs.colors.orange, "Ð£Ð»ÑÑÑÐµÐ½Ð¸Ñ"})
		table.insert(arguments, {"EmptyLine"})
		if userData.inventoryController then
			table.insert(arguments, {"CenterText", 0xffffff, "ÐÐ¾Ð½ÑÑÐ¾Ð»Ð»ÐµÑ Ð¸Ð½Ð²ÐµÐ½ÑÐ°ÑÑ"})
		end
		if userData.tankController then
			table.insert(arguments, {"CenterText", 0xffffff, "ÐÐ¾Ð½ÑÑÐ¾Ð»Ð»ÐµÑ Ð±Ð°ÐºÐ°"})
		end
		if userData.crafting then
			table.insert(arguments, {"CenterText", 0xffffff, "ÐÑÐ°ÑÑÐ¸Ð½Ð³"})
		end
		if userData.redstone then
			table.insert(arguments, {"CenterText", 0xffffff, "Ð ÐµÐ´ÑÑÐ¾ÑÐ½-Ð¿Ð»Ð°ÑÐ°"})
		end
		if userData.navigation then
			table.insert(arguments, {"CenterText", 0xffffff, "ÐÐ°Ð²Ð¸Ð³Ð°ÑÐ¸Ñ"})
		end
		if userData.piston then
			table.insert(arguments, {"CenterText", 0xffffff, "ÐÐ¾ÑÑÐµÐ½Ñ"})
		end
		if userData.geolyzer then
			table.insert(arguments, {"CenterText", 0xffffff, "ÐÐµÐ¾Ð°Ð½Ð°Ð»Ð¸Ð·Ð°ÑÐ¾Ñ"})
		end
	end

	table.insert(arguments, {"EmptyLine"})
	table.insert(arguments, {"Button", {ecs.colors.orange, 0x262626, "OK"}})
	

	ecs.universalWindow(table.unpack(arguments))
end

local function modemMessageHandler(_, localAddress, remoteAddress, port, distance, ...)
	local messages = {...}
	if #messages > 0 then
		if port == modemConnection.port then
			if messages[1] == "iWantToConnect" and not modemConnection.remoteAddress then
				askForAcceptConnection(remoteAddress)
			elseif messages[1] == "iAmHereAddMePlease" and not modemConnection.remoteAddress then
				if not modemConnection.availableUsers[remoteAddress] then
					local userData = serialization.unserialize(messages[2])
					if 
						(not userData.isRobot and not userData.isTablet and modemConnection.receiveMessagesFromComputers)
						or
						(userData.isRobot and modemConnection.receiveMessagesFromRobots)
						or
						(userData.isTablet and modemConnection.receiveMessagesFromTablets)
					then
						modemConnection.availableUsers[userData.address] = userData
						modem.send(remoteAddress, modemConnection.port, "iAmHereAddMePlease", modemConnection.dataToSend)
						computer.pushSignal("userlistChanged")
					end
				end
			elseif messages[1] == "iAmDisconnecting" then
				if modemConnection.availableUsers[remoteAddress] then
					modemConnection.availableUsers[remoteAddress] = nil
					computer.pushSignal("userlistChanged")
				end
			end
		end
	end
end

local function createSendingArray()
	modemConnection.dataToSend = {}
	modemConnection.dataToSend.address = modemConnection.localAddress
	modemConnection.dataToSend.name = component.filesystem.getLabel()
	modemConnection.dataToSend.ram = math.floor(computer.totalMemory() / 1024)

	if component.isAvailable("robot") then
		modemConnection.dataToSend.isRobot = true
		if component.isAvailable("inventory_controller") then
			modemConnection.dataToSend.inventoryController = true; modemConnection.dataToSend.hasUpgrades = true
		end
	
		if component.isAvailable("tank_controller") then
			modemConnection.dataToSend.tankController = true; modemConnection.dataToSend.hasUpgrades = true
		end
	
		if component.isAvailable("crafting") then
			modemConnection.dataToSend.crafting = true; modemConnection.dataToSend.hasUpgrades = true
		end
	
		if component.isAvailable("redstone") then
			modemConnection.dataToSend.redstone = true; modemConnection.dataToSend.hasUpgrades = true
		end
	end
	
	if component.isAvailable("tablet") then
		modemConnection.dataToSend.isTablet = true
		if component.isAvailable("navigation") then
			modemConnection.dataToSend.navigation = true; modemConnection.dataToSend.hasUpgrades = true
		end
	
		if component.isAvailable("piston") then
			modemConnection.dataToSend.piston = true; modemConnection.dataToSend.hasUpgrades = true
		end
	end
	
	if component.isAvailable("geolyzer") then
		modemConnection.dataToSend.geolyzer = true; modemConnection.dataToSend.hasUpgrades = true
	end
	
	modemConnection.dataToSend = serialization.serialize(modemConnection.dataToSend)
end

--ÐÐ°ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¾ÐºÑÑÐ¶Ð½Ð¾ÑÑÑ, Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼ ÑÐ¿Ð¸Ð·Ð¶ÐµÐ½ Ñ Ð²Ð¸ÐºÐ¸
local function circle(xCenter, yCenter, radius, color)
	gpu.setBackground(color)
	local function insertPoints(x, y)
		gpu.set(xCenter + x * 2, yCenter + y, "  ")
		gpu.set(xCenter + x * 2, yCenter - y, "  ")
		gpu.set(xCenter - x * 2, yCenter + y, "  ")
		gpu.set(xCenter - x * 2, yCenter - y, "  ")

		gpu.set(xCenter + x * 2 + 1, yCenter + y, " ")
		gpu.set(xCenter + x * 2 + 1, yCenter - y, " ")
		gpu.set(xCenter - x * 2 + 1, yCenter + y, " ")
		gpu.set(xCenter - x * 2 + 1, yCenter - y, " ")
	end

	local x = 0
	local y = radius
	local delta = 3 - 2 * radius;
	while (x < y) do
		insertPoints(x, y);
		insertPoints(y, x);
		if (delta < 0) then
			delta = delta + (4 * x + 6)
		else 
			delta = delta + (4 * (x - y) + 10)
			y = y - 1
		end
		x = x + 1
	end

	if x == y then insertPoints(x, y) end
end

local function drawCircles(xCircle, yCircle, minumumRadius, maximumRadius, step, currentRadius)
	for radius = minumumRadius, maximumRadius, step do
		if radius == currentRadius then
			circle(xCircle, yCircle, radius, 0x888888)
		else
			circle(xCircle, yCircle, radius, 0xDDDDDD)
		end
	end
end

local function drawIconAndAddress(x, y, background, foreground, userData)
	if userData.isRobot then
		image.draw(x + 3, y, robotIcon)
	elseif userData.isTablet then
		image.draw(x + 3, y, tabletIcon)
	else
		image.draw(x + 3, y, computerIcon)
	end

	ecs.colorTextWithBack(x, y + 5, foreground, background, ecs.stringLimit("end", userData.address, 14))
	
	return x, y, x + 13, y + 5
end

local function drawHorizontalIcons()
	local height = 8
	local y = math.floor(ySize / 2 - height / 2)
	local background = 0x66A8FF
	ecs.square(1, y, xSize, height, background)

	local iconWidth = 14
	local spaceBetween = 2
	local totalWidth = ecs.getArraySize(modemConnection.availableUsers) * (iconWidth + spaceBetween) - spaceBetween
	local x = math.floor(xSize / 2 - totalWidth / 2) + 1

	obj.Users = {}

	local counter = 0
	local limit = math.floor(xSize / (iconWidth + spaceBetween))
	y = y + 1
	for address in pairs(modemConnection.availableUsers) do
		if counter < limit then
			newObj("Users", address, drawIconAndAddress(x, y, background, 0xFFFFFF, modemConnection.availableUsers[address]))
		end
		x = x + iconWidth + spaceBetween
		counter = counter + 1
	end
end

local function drawSelectedIcon(x, y, background, foreground, userData)
	local selectionWidth = 16
	local skokaOtnat = (selectionWidth - 14) / 2
	local oldPixels = ecs.rememberOldPixels(x - skokaOtnat, y, x + selectionWidth - 2, y + 13)
	ecs.square(x - skokaOtnat, y, selectionWidth, 8, background)
	drawIconAndAddress(x, y + 1, background, foreground, userData)
	obj.CykaKnopkaInfo = { ecs.drawButton(x - skokaOtnat, y + 8, selectionWidth, 3, "ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ", 0xff6699, 0xFFFFFF) }
	obj.CykaKnopkaConnect = { ecs.drawButton(x - skokaOtnat, y + 11, selectionWidth, 3, "ÐÐ¾Ð´ÐºÐ»ÑÑÐ¸ÑÑÑÑ", 0xff3333, 0xFFFFFF) }
	obj.CykaKnopkaConnect.address = userData.address
	return oldPixels
end

local function connectionGUI()
	ecs.square(1, 1, xSize, ySize, 0xEEEEEE)
	
	local xCircle, yCircle = math.floor(xSize / 2), ySize - 3
	local minumumRadius, maximumRadius = 7, xCircle * 0.8
	local step = 4
	local currentRadius = minumumRadius
	local unserializedDataToSend = serialization.unserialize(modemConnection.dataToSend)

	drawIconAndAddress(xCircle - 6, ySize - 6, 0xEEEEEE, 0x262626, unserializedDataToSend)

	while true do
		if ecs.getArraySize(modemConnection.availableUsers) > 0 then
			currentRadius = 0
			drawCircles(xCircle, yCircle, minumumRadius, maximumRadius, step, currentRadius)
			
			drawHorizontalIcons()

			local oldPixels, needToUpdate
			while true do
				if not oldPixels and needToUpdate then
					if ecs.getArraySize(modemConnection.availableUsers) <= 0 then
						ecs.square(1, 1, xSize, ySize, 0xEEEEEE)
						drawIconAndAddress(xCircle - 6, ySize - 6, 0xEEEEEE, 0x262626, unserializedDataToSend)
						currentRadius = minumumRadius
						break
					else
						drawHorizontalIcons()
						needToUpdate = false
					end
				end

				local e = { event.pull() }
				if e[1] == "touch" then
					
					if obj.CykaKnopkaInfo and obj.CykaKnopkaConnect then
						if ecs.clickedAtArea(e[3], e[4], obj.CykaKnopkaInfo[1], obj.CykaKnopkaInfo[2], obj.CykaKnopkaInfo[3], obj.CykaKnopkaInfo[4]) then
							ecs.drawButton(obj.CykaKnopkaInfo[1], obj.CykaKnopkaInfo[2], 16, 3, "ÐÐ½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ", 0x262626, 0xFFFFFF)
							os.sleep(0.2)
							if oldPixels then ecs.drawOldPixels(oldPixels); oldPixels = nil end
							infoAboutClient(modemConnection.availableUsers[obj.CykaKnopkaConnect.address])

						elseif ecs.clickedAtArea(e[3], e[4], obj.CykaKnopkaConnect[1], obj.CykaKnopkaConnect[2], obj.CykaKnopkaConnect[3], obj.CykaKnopkaConnect[4]) then
							ecs.drawButton(obj.CykaKnopkaConnect[1], obj.CykaKnopkaConnect[2], 16, 3, "ÐÐ¾Ð´ÐºÐ»ÑÑÐ¸ÑÑÑÑ", 0x262626, 0xFFFFFF)
							os.sleep(0.2)
							if oldPixels then ecs.drawOldPixels(oldPixels); oldPixels = nil end

							local oldInfoPixels = ecs.info("auto", "auto", "", "ÐÐ¶Ð¸Ð´Ð°Ð½Ð¸Ðµ Ð¾ÑÐ²ÐµÑÐ° Ð¾Ñ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ...")							
							tryToConnect(obj.CykaKnopkaConnect.address)

							local function filter(name, _, remoteAddress)
								if name == "modem_message" and remoteAddress == obj.CykaKnopkaConnect.address then
									return true
								end
							end

							local e2 = { event.pullFiltered(modemConnection.waitForConnectionAcceptingDelay, filter) }
							ecs.drawOldPixels(oldInfoPixels)
						
							if e2[6] == "connectionAccepted" then
								modemConnection.remoteAddress = e2[3]
								-- acceptingOrDecliningDialog(obj.CykaKnopkaConnect.address, true)
								computer.pushSignal("connectionEstabilishedExitFromGUI")
							elseif e2[6] == "connectionDeclined" then
								acceptingOrDecliningDialog(obj.CykaKnopkaConnect.address, false)
							else
								acceptingOrDecliningDialog(obj.CykaKnopkaConnect.address, nil)
							end
						end

						obj.CykaKnopkaInfo, obj.CykaKnopkaConnect = nil, nil
					end

					if oldPixels then ecs.drawOldPixels(oldPixels); oldPixels = nil end

					for address in pairs(obj.Users) do
						if ecs.clickedAtArea(e[3], e[4], obj.Users[address][1], obj.Users[address][2], obj.Users[address][3], obj.Users[address][4]) then
							oldPixels = drawSelectedIcon(obj.Users[address][1], obj.Users[address][2] - 1, 0xCCCCFF, 0x262626, modemConnection.availableUsers[address])
							break
						end
					end
				elseif e[1] == "userlistChanged" then
					needToUpdate = true
				elseif e[1] == "connectionEstabilishedExitFromGUI" then
					ecs.prepareToExit()
					modemConnection.disconnect()
					return
				end
			end
		else
			drawCircles(xCircle, yCircle, minumumRadius, maximumRadius, step, currentRadius)
			currentRadius = currentRadius + step
			if currentRadius > (maximumRadius + step) then currentRadius = minumumRadius end
			os.sleep(0)
		end
	end
end

----------------------------------------------------------------------------------------------------------------------------------

function modemConnection.stopReceivingData()
	event.ignore("modem_message", modemMessageHandler)
end

function modemConnection.startReceivingData()
	modemConnection.stopReceivingData()
	modemConnection.remoteAddress = nil
	event.listen("modem_message", modemMessageHandler)
end

function modemConnection.disconnect()
	modem.broadcast(modemConnection.port, "iAmDisconnecting")
end

function modemConnection.sendPersonalData()
	modem.broadcast(modemConnection.port, "iAmHereAddMePlease", modemConnection.dataToSend)
end

function modemConnection.changePort(newPort)
	modem.close(modemConnection.port)
	modem.open(newPort)
	modemConnection.port = newPort
	modemConnection.remoteAddress = nil
	modemConnection.availableUsers = {}
	modemConnection.localAddress = component.getPrimary("modem").address
	createSendingArray()
end

function modemConnection.search()
	modemConnection.availableUsers = {}
	modemConnection.remoteAddress = nil
	modemConnection.disconnect()
	modemConnection.sendPersonalData()
	connectionGUI()
end

function modemConnection.init()
	if component.isAvailable("modem") then
		modemConnection.changePort(modemConnection.port)
	else
		ecs.error(infoMessages.noModem)
		return
	end
end

----------------------------------------------------------------------------------------------------------------------------------

modemConnection.init()

----------------------------------------------------------------------------------------------------------------------------------

return modemConnection

Flib/note.luaj--Provides all music notes in range of computer.beep in MIDI and frequency form
--Author: Vexatos
local computer = require("computer")

local note = {}
--The table that maps note names to their respective MIDI codes
local notes = {}
--The reversed table "notes"
local reverseNotes = {}

do
  --All the base notes
  local tempNotes = {
    "c",
    "c#",
    "d",
    "d#",
    "e",
    "f",
    "f#",
    "g",
    "g#",
    "a",
    "a#",
    "b"
    }
  --The table containing all the standard notes and # semitones in correct order, temporarily
  local sNotes = {}
  --The table containing all the b semitones
  local bNotes = {}

  --Registers all possible notes in order
  do
    table.insert(sNotes,"a0")
    table.insert(sNotes,"a#0")
    table.insert(bNotes,"bb0")
    table.insert(sNotes,"b0")
    for i = 1,6 do
      for _,v in ipairs(tempNotes) do
        table.insert(sNotes,v..tostring(i))
        if #v == 1 and v ~= "c" and v ~= "f" then
          table.insert(bNotes,v.."b"..tostring(i))
        end
      end
    end
  end
  for i=21,95 do
    notes[sNotes[i-20]]=tostring(i)
  end

  --Reversing the whole table in reverseNotes, used for note.get
  do
    for k,v in pairs(notes) do
      reverseNotes[tonumber(v)]=k
    end
  end

  --This is registered after reverseNotes to avoid conflicts
  for k,v in ipairs(bNotes) do
    notes[v]=tostring(notes[string.gsub(v,"(.)b(.)","%1%2")]-1)
  end
end

--Converts string or frequency into MIDI code
function note.midi(n)
  if type(n) == "string" then
    n = string.lower(n)
    if tonumber(notes[n])~=nil then
      return tonumber(notes[n])
    else
      error("Wrong input "..tostring(n).." given to note.midi, needs to be <note>[semitone sign]<octave>, e.g. A#0 or Gb4")
    end
  elseif type(n) == "number" then
    return math.floor((12*math.log(n/440,2))+69)
  else
    error("Wrong input "..tostring(n).." given to note.midi, needs to be a number or a string")
  end
end

--Converts String or MIDI code into frequency
function note.freq(n)
  if type(n) == "string" then
    n = string.lower(n)
    if tonumber(notes[n])~=nil then
      return math.pow(2,(tonumber(notes[n])-69)/12)*440
    else
      error("Wrong input "..tostring(n).." given to note.freq, needs to be <note>[semitone sign]<octave>, e.g. A#0 or Gb4",2)
    end
  elseif type(n) == "number" then
    return math.pow(2,(n-69)/12)*440
  else
    error("Wrong input "..tostring(n).." given to note.freq, needs to be a number or a string",2)
  end
end

--Converts a MIDI value back into a string
function note.name(n)
  n = tonumber(n)
  if reverseNotes[n] then
    return string.upper(string.match(reverseNotes[n],"^(.)"))..string.gsub(reverseNotes[n],"^.(.*)","%1")
  else
    error("Attempt to get a note for a non-exsisting MIDI code",2)
  end
end

--Converts Note block ticks (0-24) to MIDI code (34-58) and vice-versa
function note.ticks(n)
  if type(n) == "number" then
    if n>=0 and n<=24 then
      return n+34
    elseif n>=34 and n<=58 then
      return n-34
    else
      error("Wrong input "..tostring(n).." given to note.ticks, needs to be a number [0-24 or 34-58]",2)
    end
  else
    error("Wrong input "..tostring(n).." given to note.ticks, needs to be a number",2)
  end
end

--Plays a tone, input is either the note as a string or the MIDI code as well as the duration of the tone
function note.play(tone,duration)
  computer.beep(note.freq(tone),duration)
end

return note
Flib/package.luaWlocal package = {}

package.path = "/lib/?.lua;/usr/lib/?.lua;/home/lib/?.lua;./?.lua;/lib/?/init.lua;/usr/lib/?/init.lua;/home/lib/?/init.lua;./?/init.lua"

local loading = {}

local loaded = {
  ["_G"] = _G,
  ["bit32"] = bit32,
  ["coroutine"] = coroutine,
  ["math"] = math,
  ["os"] = os,
  ["package"] = package,
  ["string"] = string,
  ["table"] = table
}
package.loaded = loaded

local preload = {}
package.preload = preload

local delayed = {}
package.delayed = delayed

package.searchers = {}

function package.searchpath(name, path, sep, rep)
  checkArg(1, name, "string")
  checkArg(2, path, "string")
  sep = sep or '.'
  rep = rep or '/'
  sep, rep = '%' .. sep, rep
  name = string.gsub(name, sep, rep)
  local fs = require("filesystem")
  local errorFiles = {}
  for subPath in string.gmatch(path, "([^;]+)") do
    subPath = string.gsub(subPath, "?", name)
    if subPath:sub(1, 1) ~= "/" and os.getenv then
      subPath = fs.concat(os.getenv("PWD") or "/", subPath)
    end
    if fs.exists(subPath) then
      local file = io.open(subPath, "r")
      if file then
        file:close()
        return subPath
      end
    end
    table.insert(errorFiles, "\tno file '" .. subPath .. "'")
  end
  return nil, table.concat(errorFiles, "\n")
end

local function preloadSearcher(module)
  if preload[module] ~= nil then
    return preload[module]
  else
    return "\tno field package.preload['" .. module .. "']"
  end
end

local delay_data = {}
local delay_tools = setmetatable({},{__mode="v"})

package.delay_data = delay_data

function delay_data.__index(tbl,key)
  local lookup = delay_tools.lookup or loadfile("/lib/tools/delayLookup.lua")
  delay_tools.lookup = lookup
  return lookup(delay_data, tbl, key)
end
delay_data.__pairs = delay_data.__index -- nil key acts like pairs

function delaySearcher(module)
  if not delayed[module] then
    return "\tno field package.delayed['" .. module .. "']"
  end
  local filepath, reason = package.searchpath(module, package.path)
  if not filepath then
    return reason
  end
  local parser = delay_tools.parser or loadfile("/lib/tools/delayParse.lua")
  delay_tools.parser = parser
  local loader, reason = parser(filepath,delay_data)
  return loader, reason
end

local function pathSearcher(module)
  local filepath, reason = package.searchpath(module, package.path)
  if filepath then
    local loader, reason = loadfile(filepath, "bt", _G)
    if loader then
      return loader, filepath
    else
      return reason
    end
  else
    return reason
  end
end

table.insert(package.searchers, preloadSearcher)
table.insert(package.searchers, delaySearcher)
table.insert(package.searchers, pathSearcher)

function require(module)
  checkArg(1, module, "string")
  if loaded[module] ~= nil then
    return loaded[module]
  elseif not loading[module] then
    loading[module] = true
    local loader, value, errorMsg = nil, nil, {"module '" .. module .. "' not found:"}
    for i = 1, #package.searchers do
      -- the pcall is mostly for out of memory errors
      local ok, f, extra = pcall(package.searchers[i], module)
      if not ok then
        table.insert(errorMsg, "\t" .. f)
      elseif f and type(f) ~= "string" then
        loader = f
        value = extra
        break
      elseif f then
        table.insert(errorMsg, f)
      end
    end
    if loader then
      local success, result = pcall(loader, module, value)
      loading[module] = false
      if not success then
        error(result, 2)
      end
      if result then
        loaded[module] = result
      elseif not loaded[module] then
        loaded[module] = true
      end
      return loaded[module]
    else
      loading[module] = false
      error(table.concat(errorMsg, "\n"), 2)
    end
  else
    error("already loading: " .. module .. debug.traceback(), 2)
  end
end

-------------------------------------------------------------------------------

return package
Flib/palette.lua-¥
-- _G.windows, _G.GUI, package.loaded.windows, package.loaded.GUI = nil, nil, nil, nil

local advancedLua = require("advancedLua")
local component = require("component")
local fs = require("filesystem")
local colorlib = require("colorlib")
local image = require("image")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local windows = require("windows")

--------------------------------------------------------------------------------------------------------------

local palette = {}
local window
local currentColor, favourites
local xBigCrest, yBigCrest, yMiniCrest
local favouritesContainer, bigRainbow, miniRainbow, currentColorPanel
local pathToFavouritesConfig = "/MineOS/System/Palette/Favourites.cfg"
local inputs

--------------------------------------------------------------------------------------------------------------

local function switchColorFromHex(hex)
	currentColor = {hsb = {}, rgb = {}, hex = hex}
	currentColor.rgb.red, currentColor.rgb.green, currentColor.rgb.blue = colorlib.HEXtoRGB(hex)
	currentColor.hsb.hue, currentColor.hsb.saturation, currentColor.hsb.brightness = colorlib.RGBtoHSB(currentColor.rgb.red, currentColor.rgb.green, currentColor.rgb.blue)
end

local function switchColorFromHsb(hue, saturation, brightness)
	currentColor = {hsb = {hue = hue, saturation = saturation, brightness = brightness}, rgb = {}, hex = nil}
	currentColor.rgb.red, currentColor.rgb.green, currentColor.rgb.blue = colorlib.HSBtoRGB(hue, saturation, brightness)
	currentColor.hex = colorlib.RGBtoHEX(currentColor.rgb.red, currentColor.rgb.green, currentColor.rgb.blue)
end

local function switchColorFromRgb(red, green, blue)
	currentColor = {hsb = {}, rgb = {red = red, green = green, blue = blue}, hex = nil}
	currentColor.hsb.hue, currentColor.hsb.saturation, currentColor.hsb.brightness = colorlib.RGBtoHSB(red, green, blue)
	currentColor.hex = colorlib.RGBtoHEX(red, green, blue)
end

--------------------------------------------------------------------------------------------------------------

local function randomizeFavourites()
	favourites = {}; for i = 1, 6 do favourites[i] = math.random(0x000000, 0xFFFFFF) end
end

local function saveFavoutites()
	table.toFile(pathToFavouritesConfig, favourites)
end

local function loadFavourites()
	if fs.exists(pathToFavouritesConfig) then
		favourites = table.fromFile(pathToFavouritesConfig)
	else
		randomizeFavourites()
		saveFavoutites()
	end
end

--------------------------------------------------------------------------------------------------------------

local function changeInputsValueToCurrentColor()
	inputs[1].object.text = tostring(currentColor.rgb.red)
	inputs[2].object.text = tostring(currentColor.rgb.green)
	inputs[3].object.text = tostring(currentColor.rgb.blue)
	inputs[4].object.text = tostring(math.floor(currentColor.hsb.hue))
	inputs[5].object.text = tostring(math.floor(currentColor.hsb.saturation))
	inputs[6].object.text = tostring(math.floor(currentColor.hsb.brightness))
	inputs[7].object.text = string.format("%06X", currentColor.hex)
end

--------------------------------------------------------------------------------------------------------------

local function refreshBigRainbow(width, height)
	local saturationStep, brightnessStep, saturation, brightness = 100 / width, 100 / (height * 2), 0, 100
	for j = 1, height do
		for i = 1, width do
			local background = colorlib.HSBtoHEX(currentColor.hsb.hue, saturation, brightness)
			local foreground = colorlib.HSBtoHEX(currentColor.hsb.hue, saturation, brightness - brightnessStep)
			image.set(bigRainbow.image, i, j, background, foreground, 0x0, "â")
			saturation = saturation + saturationStep
		end
		saturation = 0; brightness = brightness - brightnessStep - brightnessStep
	end
end

local function refreshMiniRainbow(width, height)
	local hueStep, hue = 360 / (height * 2), 0
	for j = 1, height do
		for i = 1, width do
			local background = colorlib.HSBtoHEX(hue, 100, 100)
			local foreground = colorlib.HSBtoHEX(hue + hueStep, 100, 100)
			image.set(miniRainbow.image, i, j, background, foreground, 0x0, "â")
		end
		hue = hue + hueStep + hueStep
	end
end

local function refreshRainbows()
	refreshBigRainbow(50, 25)
	refreshMiniRainbow(3, 25)
end

local function betterVisiblePixel(x, y, symbol)
	local background, foreground = buffer.get(x, y)
	if background > 0x888888 then foreground = 0x000000 else foreground = 0xFFFFFF end
	buffer.set(x, y, background, foreground, symbol)
end

local function drawBigCrest()
	local drawLimit = buffer.getDrawLimit(); buffer.setDrawLimit(window.x, window.y, bigRainbow.width + 2, bigRainbow.height)
	betterVisiblePixel(xBigCrest - 2, yBigCrest, "â")
	betterVisiblePixel(xBigCrest - 1, yBigCrest, "â")
	betterVisiblePixel(xBigCrest + 1, yBigCrest, "â")
	betterVisiblePixel(xBigCrest + 2, yBigCrest, "â")
	betterVisiblePixel(xBigCrest, yBigCrest - 1, "â")
	betterVisiblePixel(xBigCrest, yBigCrest + 1, "â")
	buffer.setDrawLimit(drawLimit)
end

local function drawMiniCrest()
	buffer.text(miniRainbow.x - 1, yMiniCrest, 0x000000, ">")
	buffer.text(miniRainbow.x + miniRainbow.width, yMiniCrest, 0x000000, "<")
end

local function drawCrests()
	drawBigCrest()
	drawMiniCrest()
end

local function drawAll()
	currentColorPanel.colors.background = currentColor.hex
	changeInputsValueToCurrentColor()
	window:draw()
	drawCrests()
	buffer.draw()
end

--------------------------------------------------------------------------------------------------------------

local function createCrestsCoordinates()
	local xBigCrestModifyer = (bigRainbow.width - 1) * currentColor.hsb.saturation / 100
	local yBigCrestModifyer = (bigRainbow.height - 1) - (bigRainbow.height - 1) * currentColor.hsb.brightness / 100
	local yMiniCrestModifyer = (miniRainbow.height - 1) - (miniRainbow.height - 1) * currentColor.hsb.hue / 360
	
	xBigCrest, yBigCrest, yMiniCrest = math.floor(window.x + xBigCrestModifyer), math.floor(window.y + yBigCrestModifyer), math.floor(window.y + yMiniCrestModifyer)
end

local function createInputs(x, y)
	local function onAnyInputFinished() refreshRainbows(); createCrestsCoordinates(); drawAll() end
	local function onHexInputFinished(object) switchColorFromHex(tonumber("0x" .. inputs[7].object.text)); onAnyInputFinished() end
	local function onRgbInputFinished(object) switchColorFromRgb(tonumber(inputs[1].object.text), tonumber(inputs[2].object.text), tonumber(inputs[3].object.text)); onAnyInputFinished() end
	local function onHsbInputFinished(object) switchColorFromHsb(tonumber(inputs[4].object.text), tonumber(inputs[5].object.text), tonumber(inputs[6].object.text)); onAnyInputFinished() end

	local function rgbValidaror(text) local num = tonumber(text) if num and num >= 0 and num <= 255 then return true end end
	local function hValidator(text) local num = tonumber(text) if num and num >= 0 and num <= 359 then return true end end
	local function sbValidator(text) local num = tonumber(text) if num and num >= 0 and num <= 100 then return true end end
	local function hexValidator(text) if string.match(text, "^[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]$") then return true end end

	inputs = {
		{ shortcut = "R:", arrayName = "red",        validator = rgbValidaror, onInputFinished = onRgbInputFinished },
		{ shortcut = "G:", arrayName = "green",      validator = rgbValidaror, onInputFinished = onRgbInputFinished },
		{ shortcut = "B:", arrayName = "blue",       validator = rgbValidaror, onInputFinished = onRgbInputFinished },
		{ shortcut = "H:", arrayName = "hue",        validator = hValidator,   onInputFinished = onHsbInputFinished },
		{ shortcut = "S:", arrayName = "saturation", validator = sbValidator,  onInputFinished = onHsbInputFinished },
		{ shortcut = "L:", arrayName = "brightness", validator = sbValidator,  onInputFinished = onHsbInputFinished },
		{ shortcut = "0x", arrayName = "red",        validator = hexValidator, onInputFinished = onHexInputFinished }
	}

	for i = 1, #inputs do
		window:addLabel(x, y, 2, 1, 0x000000, inputs[i].shortcut)
		inputs[i].object = window:addInputTextBox(x + 3, y, 9, 1, 0xFFFFFF, 0x444444, 0xFFFFFF, 0x000000, "", "", true)
		inputs[i].object.validator = inputs[i].validator
		inputs[i].object.onInputFinished = inputs[i].onInputFinished
		y = y + 2
	end

	return y
end

local function createFavourites()
	for i = 1, #favourites do
		local button = favouritesContainer:addButton(i * 2 - 1, 1, 2, 1, favourites[i], 0x0, 0x0, 0x0, " ")
		button.onTouch = function()
			switchColorFromHex(button.colors.default.background)
			refreshRainbows()
			createCrestsCoordinates()
			drawAll()
		end
	end
end

local function createWindow(x, y)
	window = windows.empty(x, y, 71, 25, 71, 25)
	
	x, y = 1, 1
	window:addPanel(x, y, window.width, window.height, 0xEEEEEE)
	
	bigRainbow = window:addImage(x, y, image.create(50, 25))
	bigRainbow.onTouch = function(eventData)
		xBigCrest, yBigCrest = eventData[3], eventData[4]
		local _, _, background = component.gpu.get(eventData[3], eventData[4])
		switchColorFromHex(background)
		drawAll()
	end
	bigRainbow.onDrag = bigRainbow.onTouch

	x = x + bigRainbow.width + 2
	
	miniRainbow = window:addImage(x, y, image.create(3, 25))
	miniRainbow.onTouch = function(eventData)
		yMiniCrest = eventData[4]
		switchColorFromHsb((eventData[4] - miniRainbow.y) * 360 / miniRainbow.height, currentColor.hsb.saturation, currentColor.hsb.brightness)
		refreshRainbows()
		drawAll()
	end
	miniRainbow.onDrag = miniRainbow.onTouch
	x, y = x + 5, y + 1
	
	currentColorPanel = window:addPanel(x, y, 12, 3, currentColor.hex)
	y = y + 4
	
	window.okButton = window:addButton(x, y, 12, 1, 0x444444, 0xFFFFFF, 0x88FF88, 0xFFFFFF, "OK")
	window.okButton.onTouch = function()
		window:returnData(currentColor.hex)
	end
	y = y + 2
	
	window:addButton(x, y, 12, 1, 0xFFFFFF, 0x444444, 0x88FF88, 0xFFFFFF, "Cancel").onTouch = function()
		window:close()
	end
	y = y + 2

	y = createInputs(x, y)
	
	favouritesContainer = window:addContainer(x, y, 12, 1)
	createFavourites()
	y = y + 1
	
	window:addButton(x, y, 12, 1, 0xFFFFFF, 0x444444, 0x88FF88, 0xFFFFFF, "+").onTouch = function()
		local favouriteExists = false; for i = 1, #favourites do if favourites[i] == currentColor.hex then favouriteExists = true; break end end
		if not favouriteExists then
			table.insert(favourites, 1, currentColor.hex); table.remove(favourites, #favourites)
			for i = 1, #favourites do favouritesContainer.children[i].colors.default.background = favourites[i]; favouritesContainer.children[i].colors.pressed.background = 0x0 end
			saveFavoutites()
			drawAll()
		end
	end

	window.onDrawFinished = function()
		drawCrests()
		buffer.draw()
	end

	window.onKeyDown = function(eventData)
		if eventData[4] == 28 then
			window.okButton:press()
			drawAll()
			window:returnData(currentColor.hex)
		end
	end
end

--------------------------------------------------------------------------------------------------------------

function palette.show(x, y, startColor)
	buffer.start()
	loadFavourites()
	switchColorFromHex(startColor or 0x00B6FF)
	createWindow(x or "auto", y or "auto")
	createCrestsCoordinates()
	refreshRainbows()
	
	window.drawShadow = true
	drawAll()
	window.drawShadow = false

	return window:handleEvents()
end

-- ÐÐ¾Ð´Ð´ÐµÑÐ¶Ð¸Ð¼ Ð¾Ð»Ð´ÑÐ°Ð³Ð¾Ð²!
palette.draw = palette.show

--------------------------------------------------------------------------------------------------------------

-- buffer.start()
-- buffer.draw(true)
-- require("ECSAPI").error(palette.show("auto", "auto", 0xFF5555))

--------------------------------------------------------------------------------------------------------------

return palette
Flib/pipes.lua%jlocal tx = require("transforms")
local shell = require("shell")
local sh = require("sh")
local process = require("process")

local plib = {}

plib.internal = {}

local pipeStream = {}
local function bfd() return nil, "bad file descriptor" end
function pipeStream.new(pm)
  local stream = {pm=pm}
  local metatable = {__index = pipeStream}
  return setmetatable(stream, metatable)
end
function pipeStream:resume()
  local yield_args = table.pack(self.pm.pco.resume_all())
  if not yield_args[1] then
    self.pm.dead = true

    if not yield_args[1] and yield_args[2] then
      io.stderr:write(tostring(yield_args[2]) .. "\n")
    end
  end
  return table.unpack(yield_args)
end
function pipeStream:close()
  if self.pm.closed then -- already closed
    return
  end

  self.pm.closed = true

  -- if our pco stack is empty, we've already run fully
  if self.pm.pco.top() == nil then
    return
  end

  -- if a thread aborted we have set dead true
  if self.pm.dead then
    return
  end

  -- run prog until dead
  local co = self.pm.pco.previous_handler
  local pco_root = self.pm.threads[1]
  if co.status(pco_root) == "dead" then
    -- I would have liked the pco stack to unwind itself for dead coroutines
    -- maybe I haven't handled aborts corrects
    return
  end

  return self:resume(true)
end
function pipeStream:read(n)
  local pm = self.pm

  if pm.closed then
    return bfd()
  end

  if pm:buffer() == '' and not pm.dead then
    local result = table.pack(self:resume())
    if not result[1] then
      -- resume can fail if p1 crashes
      self:close()
      return nil, "pipe closed unexpectedly"
    elseif result.n > 1 and not result[2] then
      return result[2], result[3]
    end
  end

  local result = pm:buffer(n)
  if result == '' and pm.dead and n > 0 then
    return nil -- eof
  end

  return result
end
function pipeStream:seek(whence, offset)
  return bfd()
end
function pipeStream:write(v)
  local pm = self.pm
  if pm.closed or pm.dead then
    -- if prog is dead, ignore all writes
    if pm.pco.previous_handler.status(pm.threads[pm.self_id]) ~= "dead" then
      error("attempt to use a closed stream")
    end
    return bfd()
  end

  pm:buffer(pm:buffer() .. v)

  -- allow handler to push write event
  local result = table.pack(self:resume())
  if not result[1] then
    -- resume can fail if p1 crashes
    pm.dead = true
    self:close()
    return nil, "pipe closed unexpectedly"
  end

  return self
end

function plib.internal.redirectRead(pm)
  local reader = {pm=pm}
  function reader:read(n)
    local pm = self.pm
    local pco = pm.pco
    -- if we have any buffer, return it first

    if pm:buffer() == '' and not pm.closed and not pm.dead then
      pco.yield_all()
    end

    if pm.closed or pm.dead then
      return nil
    end

    return pm:buffer(n)
  end

  return reader
end

function plib.internal.create(fp)
  local _co = process.info().data.coroutine_handler

  local pco = setmetatable(
  {
    stack = {},
    next = nil,
    create = _co.create,
    wrap = _co.wrap,
    previous_handler = _co
  }, {__index=_co})

  function pco.top()
    return pco.stack[#pco.stack]
  end
  function pco.yield(...)
    -- pop last
    pco.set_unwind(pco.running())
    return _co.yield(...)
  end
  function pco.index_of(thread)
    for i,t in ipairs(pco.stack) do
      if t == thread then
        return i
      end
    end
  end
  function pco.yield_all(...)
    local current = pco.running()
    local existing_index = pco.index_of(current)
    assert(existing_index, "cannot yield inactive stack")
    pco.next = current
    return _co.yield(...)
  end
  function pco.set_unwind(from)
    pco.next = nil
    if from then
      local index = pco.index_of(from)
      if index then
        pco.stack = tx.sub(pco.stack, 1, index-1)
        pco.next = pco.stack[index-1]
      end
    end
  end
  function pco.resume_all(...)
    local base = pco.stack[1]
    local top = pco.top()
    if type(base) ~= "thread" or _co.status(base) ~= "suspended" or 
       type(top) ~= "thread" or _co.status(top) ~= "suspended" then
      return false
    end

    local status, result = pcall(function(...)
      local _result = table.pack(pco.resume(top, ...))
      return _result
    end,...)

    if not status then
      return nil, result
    end

    return table.unpack(result)
  end
  function pco.resume(thread, ...)
    checkArg(1, thread, "thread")
    local status = pco.status(thread)
    if status ~= "suspended" then
      local msg = string.format("cannot resume %s coroutine", 
        status == "dead" and "dead" or "non-suspended")
      return false, msg
    end

    local current_index = pco.index_of(pco.running())
    local existing_index = pco.index_of(thread)

    if not existing_index then
      assert(current_index, "pco coroutines cannot resume threads outside the stack")
      pco.stack = tx.concat(tx.sub(pco.stack, 1, current_index), {thread})
    end

    if current_index then
      -- current should be waiting for yield
      pco.next = thread
      return true, _co.yield(...) -- pass args to resume next
    else
      -- the stack is not running
      pco.next = nil
      local yield_args = table.pack(_co.resume(thread, ...))
      if #pco.stack > 0 then
        -- thread may have crashed (crash unwinds as well)
        -- or we don't have next lined up (unwind)
        if not pco.next or not yield_args[1] then
          -- unwind from current index, not top
          pco.set_unwind(thread)
        end

          -- if next is current thread, yield_all is active
          -- in such a case, yield out first, then resume where we left off
        if pco.next and pco.next ~= thread then
          local next = pco.next
          pco.next = nil
          return pco.resume(next, table.unpack(yield_args,2,yield_args.n))
        end
      end

      return table.unpack(yield_args)
    end
  end
  function pco.status(thread)
    checkArg(1, thread, "thread")

    local current_index = pco.index_of(pco.running())
    local existing_index = pco.index_of(thread)

    if current_index and existing_index and existing_index < current_index then
      local current = pco.stack[current_index]
      if current and _co.status(current) == "running" then
        return "normal"
      end
    end

    return _co.status(thread)
  end

  if fp then
    pco.stack = {process.load(fp,nil,nil--[[init]],"pco root")}
    process.info(pco.stack[1]).data.coroutine_handler = pco
  end

  return pco
end

local pipeManager = {}
function pipeManager.reader(pm,...)
  while pm.pco.status(pm.threads[pm.prog_id]) ~= "dead" do
    pm.pco.yield_all()

    -- kick back to main thread, true to kick back one further
    if pm.closed then break end

    -- if we are a reader pipe, we leave the buffer alone and yield to previous
    if pm.pco.status(pm.threads[pm.prog_id]) ~= "dead" then
      pm.pco.yield()
    end
  end
  pm.dead = true
end

function pipeManager:buffer(value)
  -- if value but no stream, buffer for buffer

  local s = self and self.pipe and self.pipe.stream
  if not s then
    if type(value) == "string" or self.prewrite then
      self.prewrite = self.prewrite or {}
      s = self.prewrite -- s.buffer will be self.prewrite.buffer
    else
      return ''
    end
  elseif self.prewrite then -- we stored, previously, a prewrite buffer
    s.buffer = self.prewrite.buffer .. s.buffer
    self.prewrite = nil
  end

  if type(value) == "string" then
    s.buffer = value
    return value
  elseif type(value) ~= "number" then
    return s.buffer -- don't truncate
  end

  local result = string.sub(s.buffer, 1, value)
  s.buffer = string.sub(s.buffer, value + 1)
  return result
end

function pipeManager.new(prog, mode, env)
  mode = mode or "r"
  if mode ~= "r" and mode ~= "w" then
    return nil, "bad argument #2: invalid mode " .. tostring(mode) .. " must be r or w"
  end

  local shellPath = os.getenv("SHELL") or "/bin/sh"
  local shellPath, reason = shell.resolve(shellPath, "lua")
  if not shellPath then
    return nil, reason
  end

  local pm = setmetatable(
    {dead=false,closed=false,prog=prog,mode=mode,env=env},
    {__index=pipeManager}
  )
  pm.prog_id = pm.mode == "r" and 1 or 2
  pm.self_id = pm.mode == "r" and 2 or 1
  pm.handler = pm.mode == "r" and 
    function()return pipeManager.reader(pm)end or
    function()pm.dead=true end

  pm.commands = {}
  pm.commands[pm.prog_id] = {shellPath, {}}
  pm.commands[pm.self_id] = {pm.handler, {}}

  pm.root = function()
    local startup_args = {}

    local reason
    pm.threads, reason = sh.internal.createThreads(pm.commands, {}, pm.env)

    if not pm.threads then
      pm.dead = true
      return false, reason
    end

    pm.pipe = process.info(pm.threads[1]).data.io[1]
    process.info(pm.threads[pm.prog_id]).data.args = {pm.env,pm.prog}
    
    -- if we are the writer, we need args to resume prog
    if pm.mode == "w" then
      pm.pipe.stream.redirect[0] = plib.internal.redirectRead(pm)
    end

    return sh.internal.runThreads(pm.threads)
  end

  return pm
end

function plib.popen(prog, mode, env)
  checkArg(1, prog, "string")
  checkArg(2, mode, "string", "nil")
  checkArg(3, env, "table", "nil")

  local pm, reason = pipeManager.new(prog, mode, env)

  if not pm then
    return false, reason
  end

  pm.pco=plib.internal.create(pm.root)
  
  local pfd = require("buffer").new(mode, pipeStream.new(pm))
  pfd:setvbuf("no", nil) -- 2nd are to read chunk size

  -- popen processes start on create (which is LAME :P)
  pfd.stream:resume()

  return pfd
end

return plib
Flib/process.luaJlocal process = {}

-------------------------------------------------------------------------------

--Initialize coroutine library--
process.list = setmetatable({}, {__mode="k"})

function process.findProcess(co)
  co = co or coroutine.running()
  for main, p in pairs(process.list) do
    if main == co then
      return p
    end
    for _, instance in pairs(p.instances) do
      if instance == co then
        return p
      end
    end
  end
end

-------------------------------------------------------------------------------

function process.load(path, env, init, name)
  checkArg(1, path, "string", "function")
  checkArg(2, env, "table", "nil")
  checkArg(3, init, "function", "nil")
  checkArg(4, name, "string", "nil")

  assert(type(path) == "string" or env == nil, "process cannot load function environemnts")

  local p = process.findProcess()
  if p then
    env = env or p.env
  end
  env = setmetatable({}, {__index=env or _G})

  local code = nil
  if type(path) == 'string' then
    local f, reason = io.open(path)
    if not f then
      return nil, reason
    end
    local reason
    if f:read(2) == "#!" then
      local command = f:read()
      if require("text").trim(command) == "" then
        reason = "no exec command"
      else
        code = function()
          local result = table.pack(require("shell").execute(command, env, path))
          if not result[1] then
            error(result[2], 0)
          else
            return table.unpack(result, 1, result.n)
          end
        end
      end
    else
      code, reason = loadfile(path, "t", env)
    end
    f:close()
    if not code then
      return nil, reason
    end
  else -- path is code
    code = path
  end

  local thread = nil
  thread = coroutine.create(function(...)
    if init then
      init()
    end
    -- pcall code so that we can remove it from the process list on exit
    local result = 
    {
      xpcall(code, function(msg)
        if type(msg) == 'table' then return msg end
        local stack = debug.traceback():gsub('^([^\n]*\n)[^\n]*\n[^\n]*\n','%1')
        return string.format('%s:\n%s', msg or '', stack)
      end, ...)
    }
    process.internal.close(thread)
    if not result[1] then
      -- msg can be a custom error object
      local msg = result[2]
      if type(msg) == 'table' then
        if msg.reason~="terminated" then error(msg.reason,2) end
        result={0,msg.code}
      else
        error(msg,2)
      end
    end
    return select(2,table.unpack(result))
  end,true)
  process.list[thread] = {
    path = path,
    command = name,
    env = env,
    data = setmetatable(
    {
      handles = {},
      io = setmetatable({}, {__index=p and p.data and p.data.io or nil}),
      coroutine_handler = setmetatable({}, {__index=p and p.data and p.data.coroutine_handler or nil}),
    }, {__index=p and p.data or nil}),
    parent = p,
    instances = setmetatable({}, {__mode="v"})
  }
  return thread
end

function process.running(level) -- kept for backwards compat, prefer process.info
  local info = process.info(level)
  if info then
    return info.path, info.env, info.command
  end
end

function process.info(levelOrThread)
  local p
  if type(levelOrThread) == "thread" then
    p = process.findProcess(levelOrThread)
  else
    local level = levelOrThread or 1
    p = process.findProcess()
    while level > 1 and p do
      p = p.parent
      level = level - 1
    end
  end
  if p then
    return {path=p.path, env=p.env, command=p.command, data=p.data}
  end
end

--table of undocumented api subject to change and intended for internal use
process.internal = {}
--this is a future stub for a more complete method to kill a process
function process.internal.close(thread)
  checkArg(1,thread,"thread")
  local pdata = process.info(thread).data
  for k,v in pairs(pdata.handles) do
    v:close()
  end
  process.list[thread] = nil
end

return process
Flib/rayEngine.lua9
local component = require("component")
local computer = require("computer")
local advancedLua = require("advancedLua")
local colorlib = require("colorlib")
local image = require("image")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local event = require("event")

---------------------------------------------------- ÐÐ¾Ð½ÑÑÐ°Ð½ÑÑ ------------------------------------------------------------------

local rayEngine = {}

rayEngine.debugInformationEnabled = true
rayEngine.minimapEnabled = true
rayEngine.compassEnabled = false
rayEngine.watchEnabled = false
rayEngine.drawFieldOfViewOnMinimap = false
rayEngine.chatShowTime = 4
rayEngine.chatHistory = {}

---------------------------------------------- Ð Ð°ÑÑÐµÑÐ½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ ------------------------------------------------------------------

-- ÐÐ¾Ð·Ð¸ÑÐ¸Ñ Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°, Ð¾ÑÐ½Ð¾ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ ÐºÐ¾ÑÐ¾ÑÐ¾Ð¹ ÑÐ¸ÑÑÐµÑÑÑ Ð¼Ð¸Ñ
function rayEngine.calculateHorizonPosition()
	rayEngine.horizonPosition = math.floor(buffer.screen.height / 2)
end

-- Ð Ð°Ð·Ð¼ÐµÑ Ð¿Ð°Ð½ÐµÐ»Ð¸ ÑÐ°ÑÐ° Ð¸ Ð»Ð¸Ð¼Ð¸ÑÐ° ÐµÐ³Ð¾ Ð¸ÑÑÐ¾ÑÐ¸Ð¸
function rayEngine.calculateChatSize()
	rayEngine.chatPanelWidth, rayEngine.chatPanelHeight = math.floor(buffer.screen.width * 0.4), math.floor(buffer.screen.height * 0.4)
	rayEngine.chatHistoryLimit = rayEngine.chatPanelHeight
end

-- Ð¨Ð°Ð³, Ñ ÐºÐ¾ÑÐ¾ÑÑÐ¼ Ð±ÑÐ´ÐµÑ Ð¸Ð·Ð¼ÐµÐ½ÑÑÑÑÑ ÑÐ³Ð¾Ð» ÑÐµÐ¹ÐºÐ°ÑÑÐ°
function rayEngine.calculateRaycastStep()
	rayEngine.raycastStep = rayEngine.player.fieldOfView / buffer.screen.width
end

-- ÐÐ¾Ð·Ð¸ÑÐ¸Ñ Ð¾ÑÑÐ¶Ð¸Ñ Ð½Ð° ÑÐºÑÐ°Ð½Ðµ Ð¸ Ð²ÑÐµÑ ÐµÐ³Ð¾ Ð²ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½ÑÑ ÑÐµÐºÑÑÑÑ
function rayEngine.calculateWeaponPosition()
	rayEngine.currentWeapon.xWeapon = buffer.screen.width - rayEngine.currentWeapon.weaponTexture.width + 1
	rayEngine.currentWeapon.yWeapon = buffer.screen.height - rayEngine.currentWeapon.weaponTexture.height + 1
	rayEngine.currentWeapon.xFire = rayEngine.currentWeapon.xWeapon + rayEngine.weapons[rayEngine.currentWeapon.ID].firePosition.x
	rayEngine.currentWeapon.yFire = rayEngine.currentWeapon.yWeapon + rayEngine.weapons[rayEngine.currentWeapon.ID].firePosition.y
	rayEngine.currentWeapon.xCrosshair = math.floor(buffer.screen.width / 2 - rayEngine.currentWeapon.crosshairTexture.width / 2)
	rayEngine.currentWeapon.yCrosshair = math.floor(buffer.screen.height / 2 - rayEngine.currentWeapon.crosshairTexture.height / 2)
end

-- ÐÑÑÐ±Ð¾ Ð³Ð¾Ð²Ð¾ÑÑ, ÑÑÐ¾ ÑÐ°ÑÑÑÐ¾ÑÐ½Ð¸Ðµ Ð¾Ñ ÐºÐ°Ð¼ÐµÑÑ Ð´Ð¾ Ð²Ð¸ÑÑÑÐ°Ð»ÑÐ½Ð¾Ð³Ð¾ ÑÐºÑÐ°Ð½Ð°, Ð½Ð° ÐºÐ¾ÑÐ¾ÑÐ¾Ð¼ ÑÐ¸ÑÑÐµÑÑÑ Ð²ÐµÑÑ Ð½Ð°Ñ Ð¼Ð¸Ñ, Ð²Ð»Ð¸ÑÐµÑ Ð½Ð° ÑÐ°Ð·Ð¼ÐµÑ Ð±Ð»Ð¾ÐºÐ¾Ð²
function rayEngine.calculateDistanceToProjectionPlane()
	rayEngine.distanceToProjectionPlane = (buffer.screen.width / 2) / math.tan(math.rad((rayEngine.player.fieldOfView / 2)))
end

-- ÐÑÑÑÑÑÐ¹ Ð¿ÐµÑÐµÑÐ°ÑÑÐµÑ Ð²ÑÐµÐ³Ð¾, ÑÑÐ¾ Ð½ÑÐ¶Ð½Ð¾
function rayEngine.calculateAllParameters()
	rayEngine.calculateHorizonPosition()
	rayEngine.calculateChatSize()
	rayEngine.calculateRaycastStep()
	rayEngine.calculateDistanceToProjectionPlane()
	if rayEngine.currentWeapon then rayEngine.calculateWeaponPosition() end
end

---------------------------------------------- ÐÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ ------------------------------------------------------------------

local function constrainAngle(value)
	if ( value < 0 ) then
		value = value + 360
	elseif ( value > 360 )  then
		value = value - 360
	end
	return value
end

local function getSkyColorByTime()
	return rayEngine.world.colors.sky[rayEngine.world.dayNightCycle.currentTime > 0 and math.ceil(rayEngine.world.dayNightCycle.currentTime / rayEngine.world.dayNightCycle.length * #rayEngine.world.colors.sky) or 1]
end

local function getBrightnessByTime()
	return rayEngine.properties.shadingTransparencyMap[rayEngine.world.dayNightCycle.currentTime > 0 and math.ceil(rayEngine.world.dayNightCycle.currentTime / rayEngine.world.dayNightCycle.length * #rayEngine.properties.shadingTransparencyMap) or 1]
end

local function getTileColor(basecolor, distance)
	local limitedDistance = math.floor(distance * rayEngine.properties.shadingCascades / rayEngine.properties.shadingDistance)
	local transparency = rayEngine.currentShadingTransparencyMapValue - math.floor(limitedDistance * 255 / rayEngine.properties.shadingCascades)
	transparency = (transparency >= rayEngine.properties.shadingTransparencyMap[1] and transparency <= 255) and transparency or rayEngine.properties.shadingTransparencyMap[1]
	return colorlib.alphaBlend(basecolor, 0x000000, transparency)
end

function rayEngine.refreshTimeDependentColors()
	rayEngine.world.colors.sky.current = getSkyColorByTime()
	rayEngine.currentShadingTransparencyMapValue = getBrightnessByTime()
	rayEngine.world.colors.groundByTime = colorlib.alphaBlend(rayEngine.world.colors.ground, 0x000000, rayEngine.currentShadingTransparencyMapValue)
end

local function doDayNightCycle()
	if rayEngine.world.dayNightCycle.enabled then
		local computerUptime = computer.uptime()
		if (computerUptime - rayEngine.world.dayNightCycle.lastComputerUptime) >= rayEngine.world.dayNightCycle.speed then
			rayEngine.world.dayNightCycle.currentTime = rayEngine.world.dayNightCycle.currentTime + rayEngine.world.dayNightCycle.speed
			if rayEngine.world.dayNightCycle.currentTime > rayEngine.world.dayNightCycle.length then rayEngine.world.dayNightCycle.currentTime = 0 end	
			rayEngine.world.dayNightCycle.lastComputerUptime = computerUptime

			rayEngine.refreshTimeDependentColors()
		end
	end
end

local function convertWorldCoordsToMapCoords(x, y)
	return math.round(x / rayEngine.properties.tileWidth), math.round(y / rayEngine.properties.tileWidth)
end

local function getBlockCoordsByLook(distance)
	local radRotation = math.rad(rayEngine.player.rotation)
	return convertWorldCoordsToMapCoords(rayEngine.player.position.x + distance * math.sin(radRotation) * rayEngine.properties.tileWidth, rayEngine.player.position.y + distance * math.cos(radRotation) * rayEngine.properties.tileWidth)
end

---------------------------------------------------- Ð Ð°Ð±Ð¾ÑÐ° Ñ ÑÐ°Ð¹Ð»Ð°Ð¼Ð¸ ------------------------------------------------------------------

-- ÐÐ°Ð³ÑÑÐ·ÐºÐ° Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÐ¾Ð² Ð´Ð²Ð¸Ð¶ÐºÐ°
function rayEngine.loadEngineProperties(pathToRayEnginePropertiesFile)
	rayEngine.properties = table.fromFile(pathToRayEnginePropertiesFile)
end

-- ÐÐ°Ð³ÑÑÐ·ÐºÐ° ÐºÐ¾Ð½Ð¸ÑÐ³ÑÑÐ°ÑÐ¸Ð¸ Ð¾ÑÑÐ¶Ð¸Ñ
function rayEngine.loadWeapons(pathToWeaponsFolder)
	rayEngine.weaponsFolder = pathToWeaponsFolder
	rayEngine.weapons = table.fromFile(rayEngine.weaponsFolder .. "Weapons.cfg")
	rayEngine.changeWeapon(1)
end

-- ÐÐ°Ð³ÑÑÐ·ÐºÐ° ÐºÐ¾Ð½ÐºÑÐµÑÐ½Ð¾Ð³Ð¾ Ð¼Ð¸ÑÐ°
function rayEngine.loadWorld(pathToWorldFolder)
	rayEngine.world = table.fromFile(pathToWorldFolder .. "/World.cfg")
	rayEngine.map = table.fromFile(pathToWorldFolder .. "/Map.cfg")
	rayEngine.player = table.fromFile(pathToWorldFolder .. "/Player.cfg")
	rayEngine.blocks = table.fromFile(pathToWorldFolder .. "/Blocks.cfg")
	-- ÐÐ¾Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ ÐºÐ°ÑÑÑ ÐµÐµ ÑÐ°Ð·Ð¼ÐµÑÐ°Ð¼Ð¸
	rayEngine.map.width = #rayEngine.map[1]
	rayEngine.map.height = #rayEngine.map
	-- ÐÐ±Ð°ÑÐ¸Ð¼ Ð¿ÑÐ°Ð²Ð¸Ð»ÑÐ½ÑÑ Ð¿Ð¾Ð·Ð¸ÑÐ¸Ñ Ð¸Ð³ÑÐ¾ÐºÐ°, Ð¾ÑÐ½Ð¾Ð²Ð°Ð½Ð½ÑÑ Ð½Ð° ÑÑÐ¾Ð¹ Ð¥Ð£ÐÐÐ, ÐºÐ¾ÑÐ¾ÑÑÑ ÐÐÐÐ ÑÐ°Ðº ÐÐ®ÐÐÐ¢
	rayEngine.player.position.x = rayEngine.properties.tileWidth * rayEngine.player.position.x - rayEngine.properties.tileWidth / 2
	rayEngine.player.position.y = rayEngine.properties.tileWidth * rayEngine.player.position.y - rayEngine.properties.tileWidth / 2
	-- Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ²ÐµÑÐ°, Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼ÑÐµ Ð¾Ñ Ð²ÑÐµÐ¼ÐµÐ½Ð¸ - Ð½ÐµÐ±Ð¾, Ð·ÐµÐ¼Ð»Ñ, ÑÑÐµÐ½Ñ
	rayEngine.refreshTimeDependentColors()
	-- ÐÐ±Ð½ÑÐ»ÑÐµÐ¼ ÑÐµÐºÑÑÐµÐµ Ð²ÑÐµÐ¼Ñ, ÐµÑÐ»Ð¸ Ð¿ÑÐµÐ²ÑÑÐµÐ½ Ð»Ð¸Ð¼Ð¸Ñ, Ð° ÑÐ¾ Ð¼Ð°Ð»Ð¾ Ð»Ð¸ ÐºÐ°ÐºÐ¾Ð¹ Ð¿Ð¸Ð´Ð¾ÑÐ°Ñ Ð½Ð°ÑÐ½ÐµÑ Ð¿ÑÐ°Ð²Ð¸ÑÑ ÐºÐ¾Ð½ÑÐ¸Ð³Ð¸ Ð¼Ð¸ÑÐ°
	rayEngine.world.dayNightCycle.currentTime = rayEngine.world.dayNightCycle.currentTime > rayEngine.world.dayNightCycle.length and 0 or rayEngine.world.dayNightCycle.currentTime
	-- ÐÑÑÑÐµÑÑÐ²Ð»ÑÐµÐ¼ Ð±Ð°Ð·Ð¾Ð²Ð¾Ðµ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ Ð°Ð¿ÑÐ°Ð¹Ð¼Ð° Ð¿ÐµÐºÐ°ÑÐ½Ð¸
	rayEngine.world.dayNightCycle.lastComputerUptime = computer.uptime()
	-- Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÐµ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ Ð´Ð²Ð¸Ð¶ÐºÐ°
	rayEngine.calculateAllParameters()

	-- rayEngine.wallsTexture = image.load("/heart.pic")
	-- rayEngine.wallsTexture = image.transform(rayEngine.wallsTexture, rayEngine.properties.tileWidth, rayEngine.properties.tileWidth / 2)
end

---------------------------------------------------- Ð¤ÑÐ½ÐºÑÐ¸Ð¸, ÑÐ²ÑÐ·Ð°Ð½Ð½ÑÐµ Ñ Ð¸Ð³ÑÐ¾ÐºÐ¾Ð¼ ------------------------------------------------------------------

function rayEngine.changeWeapon(weaponID)
	if rayEngine.weapons[weaponID] then 
		rayEngine.currentWeapon = {
			ID = weaponID,
			damage = rayEngine.weapons[weaponID].damage,
			weaponTexture = image.load(rayEngine.weaponsFolder .. rayEngine.weapons[weaponID].weaponTexture),
			fireTexture = image.load(rayEngine.weaponsFolder .. rayEngine.weapons[weaponID].fireTexture),
			crosshairTexture = image.load(rayEngine.weaponsFolder .. rayEngine.weapons[weaponID].crosshairTexture)
		}
		rayEngine.calculateWeaponPosition()
	else
		rayEngine.currentWeapon = nil
	end
end

function rayEngine.move(distanceForward, distanceRight)
	local forwardRotation = math.rad(rayEngine.player.rotation)
	local rightRotation = math.rad(rayEngine.player.rotation + 90)
	local xNew = rayEngine.player.position.x + distanceForward * math.sin(forwardRotation) + distanceRight * math.sin(rightRotation)
	local yNew = rayEngine.player.position.y + distanceForward * math.cos(forwardRotation) + distanceRight * math.cos(rightRotation)

	local xWorld, yWorld = convertWorldCoordsToMapCoords(xNew, yNew)
	if rayEngine.map[yWorld][xWorld] == nil then
		rayEngine.player.position.x, rayEngine.player.position.y = xNew, yNew
	end
end

function rayEngine.rotate(angle)
	rayEngine.player.rotation = constrainAngle(rayEngine.player.rotation + angle)
end

function rayEngine.turnRight()
	rayEngine.rotate(rayEngine.player.rotationSpeed)
end

function rayEngine.turnLeft()
	rayEngine.rotate(-rayEngine.player.rotationSpeed)
end

function rayEngine.moveForward()
	rayEngine.move(rayEngine.player.moveSpeed, 0)
end

function rayEngine.moveBackward()
	rayEngine.move(-rayEngine.player.moveSpeed, 0)
end

function rayEngine.moveLeft()
	rayEngine.move(0, -rayEngine.player.moveSpeed)
end

function rayEngine.moveRight()
	rayEngine.move(0, rayEngine.player.moveSpeed)
end

function rayEngine.jump()
	if not rayEngine.player.jumpTimer then
		local function onJumpFinished()
			rayEngine.horizonPosition = rayEngine.horizonPosition - rayEngine.player.jumpHeight;
			rayEngine.horizonPosition = rayEngine.horizonPosition - rayEngine.player.jumpHeight;
			rayEngine.player.jumpTimer = nil
		end

		rayEngine.player.jumpTimer = event.timer(1, onJumpFinished)
		rayEngine.horizonPosition = rayEngine.horizonPosition + rayEngine.player.jumpHeight
		rayEngine.horizonPosition = rayEngine.horizonPosition + rayEngine.player.jumpHeight
	end
end

function rayEngine.crouch()
	rayEngine.player.isCrouched = not rayEngine.player.isCrouched
	local heightAdder = rayEngine.player.isCrouched and -rayEngine.player.crouchHeight or rayEngine.player.crouchHeight
	rayEngine.horizonPosition = rayEngine.horizonPosition + heightAdder
	rayEngine.horizonPosition = rayEngine.horizonPosition + heightAdder
end

function rayEngine.destroy(distance)
	local xBlock, yBlock = getBlockCoordsByLook(distance)
	if rayEngine.map[yBlock] and rayEngine.map[yBlock][xBlock] and rayEngine.blocks[rayEngine.map[yBlock][xBlock]] and rayEngine.blocks[rayEngine.map[yBlock][xBlock]].canBeDestroyed then rayEngine.map[yBlock][xBlock] = nil end
end

function rayEngine.place(distance, blockColor)
	local xBlock, yBlock = getBlockCoordsByLook(distance)
	if rayEngine.map[yBlock] and rayEngine.map[yBlock][xBlock] == nil then rayEngine.map[yBlock][xBlock] = blockColor end
end

---------------------------------------------------- Ð¤ÑÐ½ÐºÑÐ¸Ð¸ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ° ------------------------------------------------------------------

function rayEngine.drawDebugInformation(x, y, width, transparency, ...)
	local lines = {...}
	buffer.square(x, y, width, #lines, 0x000000, 0x000000, " ", transparency); x = x + 1
	for line = 1, #lines do buffer.text(x, y, 0xEEEEEE, lines[line]); y = y + 1 end
end

local function drawFieldOfViewAngle(x, y, distance, color)
	local fieldOfViewHalf = rayEngine.player.fieldOfView / 2
	local firstAngle, secondAngle = math.rad(-(rayEngine.player.rotation - fieldOfViewHalf)), math.rad(-(rayEngine.player.rotation + fieldOfViewHalf))
	local xFirst, yFirst = math.floor(x + math.sin(firstAngle) * distance), math.floor(y + math.cos(firstAngle) * distance)
	local xSecond, ySecond = math.floor(x + math.sin(secondAngle) * distance), math.floor(y + math.cos(secondAngle) * distance)
	buffer.semiPixelLine(x, y, xFirst, yFirst, color)
	buffer.semiPixelLine(x, y, xSecond, ySecond, color)
end

function rayEngine.drawMap(x, y, width, height, transparency)
	local xHalf, yHalf = math.floor(width / 2), math.floor(height / 2)
	local xMap, yMap = convertWorldCoordsToMapCoords(rayEngine.player.position.x, rayEngine.player.position.y)

	buffer.square(x, y, width, yHalf, 0x000000, 0x000000, " ", transparency)

	local xPos, yPos = x, y * 2 - 1
	for i = yMap - yHalf + 1, yMap + yHalf do
		for j = xMap + xHalf + 1, xMap - xHalf + 2, -1 do
			if rayEngine.map[i] and rayEngine.map[i][j] then
				buffer.semiPixelSet(xPos, yPos, rayEngine.blocks[rayEngine.map[i][j]].color)
			end
			xPos = xPos + 1
		end
		xPos = x; yPos = yPos + 1
	end

	local xPlayer, yPlayer = x + xHalf, y + yHalf
	--ÐÐ¾Ð»Ðµ Ð·ÑÐµÐ½Ð¸Ñ
	if rayEngine.drawFieldOfViewOnMinimap then drawFieldOfViewAngle(xPlayer, yPlayer, 5, 0xCCFFBF) end
	--ÐÐ³ÑÐ¾Ðº
	buffer.semiPixelSet(xPlayer, yPlayer, 0x66FF40)
end

function rayEngine.intro()
	local logo = image.fromString("17060000FF 0000FF 0000FF 0000FF 007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 007EFFâ007EFFâ007EFFâ0000FF 0000FF 0000FF 0000FF 0053FFâ0053FFâ0053FFâ0053FFâ0053FFâ0000FF 0000FF 0000FF 0000FF 007EFFâ007EFFâ007EFFâ0000FF 0000FF 0000FF 007EFFâ007EFFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 530000 0000FF 0078FFâ0000FF 537800â0078FFâ0078FFâ0078FFâ0078FFâ0078FFâ0078FFâ7E7800â0078FFâ0000FF 0078FFâ0000FF 0000FF 007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ0000FF 0000FF 0053FFâ0053FFâ0053FFâ0000FF 0000FF 007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ007EFFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 007EFFP007EFFo007EFFw007EFFe007EFFr007EFFe007EFFd0000FF 007EFFb007EFFy0000FF 007EFFR007EFFa007EFFy007EFFE007EFFn007EFFg007EFFi007EFFn007EFFe007EFFâ¢0000FF 0000FF ")
	local x, y = math.floor(buffer.screen.width / 2 - logo.width / 2), math.floor(buffer.screen.height / 2 - logo.height / 2)
	local function draw(transparency)
		buffer.clear(0xF0F0F0);
		buffer.image(x, y, logo)
		buffer.square(1, 1, buffer.screen.width, buffer.screen.height, 0x000000, 0x000000, " ", transparency)
		buffer.draw()
		os.sleep(0)
	end
	for i = 0, 100, 20 do draw(i) end
	os.sleep(1.5)
	for i = 100, 0, -20 do draw(i) end
end

function rayEngine.compass(x, y)
	if not rayEngine.compassImage then rayEngine.compassImage = image.fromString("1C190000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 553600â373100â543600â373600â543600â373100â540000 375400â673700â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0055FFâ675400â553700â375500â550000 375500â540000 375400â540000 373600â310000 675500â677E00â375300â365400â373600â540000 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 555400â553700â540000 543700â540000 375300â533100â310B00â310000 310000 360000 543100â375300â553100â533600â543200â313600â372A00â373100â0054FFâ0054FFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 540000 543200â540000 545300â540600â063100â310000 315400â365400â373100â313600â530000 0000FF 0000FF 535400â535400â540000 365300â533100â065300â310000 530600â0054FFâ0000FF 0000FF 0000FF 0000FF 0000FF 530000 365300â543600â310600â312A00â2A5300â365300â543600â540000 365300â315300â530000 0000FF 0000FF 535400â540000 540000 313600â363100â540000 313600â315300â062A00â543100â0000FF 0000FF 0000FF 0000FF 315300â533600â312A00â2A3100â315300â533600â315400â540000 535400â540000 530000 533100â0000FF 0000FF 540000 540000 315400â540000 543100â530000 543100â313600â2A0000 2A2900â540000 0000FF 0000FF 0000FF 533100â315400â530000 062A00â533100â315300â535400â533100â540000 315400â543100â530000 0000FF 0000FF 540000 535400â315300â535400â363100â535400â530000 530000 312A00â2A5300â0054FFâ0000FF 0000FF 0000FF 312A00â530000 553600â2A5500â2A0000 312A00â533600â545300â315400â535400â540000 540000 0053FFâ0053FFâ540000 530000 535400â535400â545300â530000 363100â312A00â313600â545300â0000FF 0000FF 0000FF 0000FF 530000 535400â540000 545300â555400â315500â315400â533100â543100â530000 533100â530000 535400â535500â533100â535400â315300â533100â533600â315300â530000 542A00â312800â0029FFâ0000FF 0000FF 0000FF 0000FF 530000 545500â540000 555300â535400â530000 542A00â545300â365400â530000 543600â2A5400â547E00â550000 545300â533600â540000 530000 530000 542A00â2A0000â0029FFâ0000FF 0000FF 0000FF 0000FF 0000FF 530000 535400â540000 540000 540000 545300â530000 540000 2A5500â545300â292A00â290000 292A00â290000 295400â292A00â292A00â290000 542A00â543600â285400â0054FFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 530000 533100â540000 530000 535400â0053FFâ0053FFâ542800â542800â532800â2A2900â542900â532900â542900â542900â532900â542800â2A2900â2A2800â532900â552800â542800â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 2A5300â530000 535400â540000 530000 532A00â2A5300â2A5500â0029FFâ0028FFâ0028FFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0028FFâ0028FFâ0028FFâ295300â535500â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 535400â545300â530000 545300â530000 2A0000 2A5300â545300â532A00â542900â532900â2A2900â2A2900â2A2800â2A2800â2A2800â2A2900â2A2900â532900â532900â2A2900â542A00â545300â0054FFâ0054FFâ0000FF 0000FF 0000FF 545300â530000 530000 545300â2A5300â532A00â542900â290000 295400â297F00â548100â548100â558100â558100â558100â558100â538100â2A8100â007E00â295400â2A2900â295400â2A2900â290000 542A00â557E00â0000FF 0000FF 530000 2A0000 545300â530000 532900â285400â2A8000â7F8100â810000 810000 810000 810000 810000 810000 812A00N810000 810000 810000 810000 810000 808100â548100â545500â295300â282900â542900â0000FF 0000FF 2A0000 2A0000 545300â2A2900â298000â810000 810000 815500381550018155005810000 810000 810000 810000 810000 810000 810000 810000 81550048155005810000 810000 810000 558100â2A5300â282900â0029FFâ0000FF 532A00â2A0000 545300â547E00â810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 7F8000â290000 292800â0000FF 2A0000 2A0000 2A5300â7E5300â810000 812A00W810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 812A00E810000 807E00â2A2900â292800â0000FF 2A0000 2A2900â2A0000 2A0000 552A00â810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 810000 815500â542900â280000 0028FFâ530000 2A0000 2A0000 290000 2A2900â545300â552A00â815500â810000 815500281550028155005810000 810000 810000 810000 810000 810000 810000 815500181550038155005817F00â552900â292800â280000 282A00â0000FF 530000 2A0000 540000 2A5300â282A00â290000 532900â542A00â542800â552900â7F5300â815500â817F00â817F00â810000 812A00S810000 817F00â815500â815500â555400â532900â292800â280000 282A00â282A00â530000 0000FF 532A00â2A0000 530000 530000 2A5300â290000 282900â002900â280000 280000 280000 290000 292A00â2A2900â542900â532900â2A0000 295300â282900â280000 280000 280000 282900â295300â295300â2A5300â552A00â0000FF 530000 295300â535400â540000 535400â540000 535400â2A5500â282900â280000â280000 280000â290000â2A2800â2A2900â552A00â7E0000â2A0000â280000â280000 280000â280000â002AFFâ002AFFâ002AFFâ002AFFâ0000FF 0000FF 532900â532800â0029FFâ0029FFâ0029FFâ0029FFâ0029FFâ0029FFâ0000FF 2A9800â285500â547E00â7E5400â7F5300â7E2900â7E2900â552A00â542A00â2A5300â282A00â2A7E00â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF ") end	
	buffer.image(x, y, rayEngine.compassImage)

	x, y = x + 15, y + 17
	local distance = 3.4
	local northAngle = -rayEngine.player.rotation
	local xScaleFactor = 2.2
	local southPoint, northPoint = {}, {}
	local northAngleRad = math.rad(northAngle)
	northPoint.x, northPoint.y = math.round(x + math.sin(northAngleRad) * distance * xScaleFactor), math.round(y - math.cos(northAngleRad) * distance)
	northAngleRad = math.rad(northAngle + 180)
	southPoint.x, southPoint.y = math.round(x + math.sin(northAngleRad) * distance * xScaleFactor), math.round(y - math.cos(northAngleRad) * distance)
	
	y = y * 2
	buffer.semiPixelLine(x, y, northPoint.x, northPoint.y * 2, 0xFF5555)
	buffer.semiPixelLine(x, y, southPoint.x, southPoint.y * 2, 0xFFFFFF)
	buffer.semiPixelSet(x, y, 0x000000)
end

function rayEngine.watch(x, y)
	if not rayEngine.watchImage then rayEngine.watchImage = image.fromString("20190000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0053FFâ552900â673100â7E2A00â7E3100â7E2A00â7E3100â672A00â7E2A00â672900â7F3100â7E2A00â0053FFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 313600â290000 290600â062900â290000 062900â290000 062900â290000 290600â062900â2A2900â2A0600â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 313600â012900â2A2900â290000 012900â290000 290000 012A00â290000 290000 312900â293100â310600â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 310000 292800â062A00â290000 290100â062900â290000 290000 2C2900â290600â293100â2A2900â292800â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0054FFâ557F00â012800â290000 290000 292800â290000 012900â292800â290600â290000 292800â290000 012800â807E00â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF AB8100â7F8000â283100â280000 015400â318100â005300â065500â315500â282A00â296700â015500â290000 002900â677E00â81AA00â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 807F00â7F8000â677E00â812900â672800â542800â2A0000â2A0000â815400âACAA00â555400â283100â2A0000 312900â672800â7F5300â7F0000 7F0000 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 007EFFâ817E00â7E2900â2A0000â805300â54AA00â003100â2A0000 310600â532900â312800â532900â360100â552900â672800â7E2A00â315500â678000â555300â540000â805400â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0081FFâ802900â280100â280000 285400â310600â532900â290000 290000 290000 290000 29D700129D7002290000 290000 290000 282900â062900â2A2900â550600â556700â285500â542800â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0080FFâ557E00â28AA00â005500â552900â290000 290000 290000 29D700129D7001290000 290000 290000 290000 290000 290000 290000 29D7001290000 290000 290000 290000 672900â318000â297F00â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 543100â002800â553100â7E2800â290000 29D700129D7000290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 29D7002290000 290000 7E2900â7E6700â282900â808100â0000FF 0000FF 0000FF 0000FF 805500â280000â290000 310600â290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 555400â535400â533100âD58000â0080FFâ0000FF 552900â550000 54AB00â558100â290000 290000 29D7009290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 29D7003290000 315400â548100â067E00â557F00â806700âACAB00â0055FFâ545500âAB3100â815400â290100â290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 545300âAB5500â815300â558000â558000â0000FF 0000FF 538100â002800â290600â290000 290000 290000 29D7008290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 29D7004290000 290000 530000 000000 286700â0080FFâ0000FF 0000FF 0000FF 0000FF 292A00â000100â530000 285400â290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 290000 296700â063100â280000 818000â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 550000 810000â532800â015300â280000 292800â290000 29D7007290000 290000 290000 290000 290000 290000 290000 290000 290000 29D7005290000 290100â292A00â065300â7F0000â802900â81C900â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 549900â002900â292800â312800â290600â283100â290600â292800â290000 290000 290000 29D7006290000 290000 292800â292800â290000 285300â2A0600â362800â280000 285500â0081FFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 7EAA00â317E00â005300â547E00â7F2900â290000â292A00â063100â283100â295500â286200â285500â012A00â292A00â310600â540000â807E00â005500â015500â530000 0081FFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 7E8100â7E8000â557F00â317E00â2A3600â283100â005400â2A5300â817E00âAA7E00â545300â005300â005400â283100â537E00â548100â7F0000 7E8000â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 819800â807F00â280000 002900â312900â7E2800â292800â532800â552900â280000 550100â542800â282900â000100â7E0000 AA9800â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 555300â012800â290000 062900â290000 062900â290000 062900â290000 290000 290000 290600â280000 007EFFâ0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 313600â062900â312900â290000 012900â293100â290000 062900â312900â290600â312900â2A0000 2A2900â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 315400â290600â310000 062900â290000 293100â062900â290000 293100â290000 293100â062900â312A00â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0054FFâ285500â285500â015500â285500â285500â015500â295500â015500â285500â015500â285500â065500â0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF 0000FF ") end
	
	buffer.image(x, y, rayEngine.watchImage)
	x, y = x + 15, y + 12

	local realTimeInSeconds = rayEngine.world.dayNightCycle.currentTime * 86400 / rayEngine.world.dayNightCycle.length
	local hours = realTimeInSeconds / 3600
	local _, minutes = math.modf(hours)
	local hourAngle = math.rad(hours * 360 / 12)
	local minuteAngle = math.rad(minutes * 360)
	local hourArrowLength, minuteArrowLength = 2.8, 4.5
	local xMinute, yMinute = math.round(x + math.sin(minuteAngle) * minuteArrowLength * 2), math.round(y - math.cos(minuteAngle) * minuteArrowLength)
	local xHour, yHour = math.round(x + math.sin(hourAngle) * hourArrowLength * 2), math.round(y - math.cos(hourAngle) * hourArrowLength)

	y = y * 2
	buffer.semiPixelLine(x, y, xMinute, yMinute * 2, 0xEEEEEE)
	buffer.semiPixelLine(x, y, xHour, yHour * 2, 0xEEEEEE)
end	

local function addItemToChatHistory(text, color)
	text = string.wrap({text}, rayEngine.chatPanelWidth - 2)
	table.insert(rayEngine.chatHistory, {color = color, text = text})
	if #rayEngine.chatHistory > rayEngine.chatHistoryLimit then table.remove(rayEngine.chatHistory, 1) end
end

function rayEngine.chat(transparency)
	local x, y = 1, buffer.screen.height - rayEngine.chatPanelHeight - 3
	buffer.square(x, y, rayEngine.chatPanelWidth, rayEngine.chatPanelHeight, 0x000000, 0xFFFFFF, " ", transparency or 50)
	buffer.setDrawLimit(x, y, rayEngine.chatPanelWidth, rayEngine.chatPanelHeight)
	local yMessage = y + rayEngine.chatPanelHeight - 1
	x = x + 1

	for message = #rayEngine.chatHistory, 1, -1 do
		for line = #rayEngine.chatHistory[message].text, 1, -1 do
			buffer.text(x, yMessage, rayEngine.chatHistory[message].color or 0xFFFFFF, rayEngine.chatHistory[message].text[line])
			yMessage = yMessage - 1
			if yMessage < y then buffer.resetDrawLimit(); return end
		end
	end

	buffer.resetDrawLimit()
end

function rayEngine.commandLine(transparency)
	transparency = transparency or 50
	local inputPanelHeight = 3
	local x, y = 1, buffer.screen.height - inputPanelHeight + 1
	--ÐÑÑÐ±Ð°ÐµÐ¼ ÑÐ°Ñ Ð¸ ÑÐ¸ÑÑÐµÐ¼ Ð²ÑÐµ, Ð²ÐºÐ»ÑÑÐ°Ñ ÐµÐ³Ð¾
	rayEngine.chatEnabled = true
	rayEngine.update()
	--Ð Ð¸ÑÑÐµÐ¼ Ð¿Ð°Ð½ÐµÐ»Ñ Ð²Ð²Ð¾Ð´Ð°
	buffer.square(x, y, buffer.screen.width, inputPanelHeight, 0x000000, 0xFFFFFF, " ", transparency)

	--ÐÐ²Ð¾Ð´ Ð´Ð°Ð½Ð½ÑÑ
	local text = GUI.input(x + 2, y + 1, buffer.screen.width - 4, 0xFFFFFF, "")
	local words = {}; for word in string.gmatch(text, "[^%s]+") do table.insert(words, unicode.lower(word)) end
	if #words > 0 then
		if unicode.sub(words[1], 1, 1) == "/" then
			words[1] = unicode.sub(words[1], 2, -1)
			if words[1] == "time" then
				if words[2] == "set" and words[3] and tonumber(words[3]) then
					local newTime = tonumber(words[3])
					if newTime < 0 or newTime > rayEngine.world.dayNightCycle.length then
						addItemToChatHistory("ÐÑÐµÐ¼Ñ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ Ð±ÑÑÑ Ð¾ÑÑÐ¸ÑÐ°ÑÐµÐ»ÑÐ½ÑÐ¼ Ð¸ Ð¿ÑÐµÐ²ÑÑÐ°ÑÑ Ð´Ð»Ð¸Ð½Ñ ÑÑÑÐ¾Ðº (" .. rayEngine.world.dayNightCycle.length .. " ÑÐµÐºÑ)", 0xFF8888)
					else
						rayEngine.world.dayNightCycle.currentTime = math.floor(newTime)
						addItemToChatHistory("ÐÑÐµÐ¼Ñ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¾ Ð½Ð°: " .. newTime, 0xFFDB40)
					end
				elseif words[2] == "get" then
					addItemToChatHistory("Ð¢ÐµÐºÑÑÐµÐµ Ð²ÑÐµÐ¼Ñ: " .. rayEngine.world.dayNightCycle.currentTime, 0xFFDB40)
					addItemToChatHistory("ÐÐ»Ð¸Ð½Ð° ÑÑÑÐ¾Ðº: " .. rayEngine.world.dayNightCycle.length, 0xFFDB40)
				elseif words[2] == "lock" then
					rayEngine.world.dayNightCycle.enabled = not rayEngine.world.dayNightCycle.enabled
					addItemToChatHistory("Ð¡Ð¾ÑÑÐ¾ÑÐ½Ð¸Ðµ ÑÐ¸ÐºÐ»Ð° Ð´Ð½Ñ Ð¸ Ð½Ð¾ÑÐ¸: " .. tostring(rayEngine.world.dayNightCycle.enabled), 0xFFDB40)
				end
			elseif words[1] == "setrenderquality" and tonumber(words[2]) then
				rayEngine.properties.raycastQuality = tonumber(words[2])
				addItemToChatHistory("ÐÐ°ÑÐµÑÑÐ²Ð¾ ÑÐµÐ½Ð´ÐµÑÐ° Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¾ Ð½Ð°: " .. tonumber(words[2]), 0xFFDB40)
			elseif words[1] == "setdrawdistance" and tonumber(words[2]) then
				rayEngine.properties.drawDistance = tonumber(words[2])
				addItemToChatHistory("ÐÐ¸ÑÑÐ°Ð½ÑÐ¸Ñ Ð¿ÑÐ¾ÑÐ¸ÑÐ¾Ð²ÐºÐ¸ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð° Ð½Ð°: " .. tonumber(words[2]), 0xFFDB40)
			elseif words[1] == "setshadingcascades" and tonumber(words[2]) then
				rayEngine.properties.shadingCascades = tonumber(words[2])
				addItemToChatHistory("ÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ ÑÐ²ÐµÑÐ¾Ð² Ð´Ð»Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ Ð±Ð»Ð¾ÐºÐ° Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð¾ Ð½Ð°: " .. tonumber(words[2]), 0xFFDB40)
			elseif words[1] == "setshadingdistance" and tonumber(words[2]) then
				rayEngine.properties.shadingDistance = tonumber(words[2])
				addItemToChatHistory("ÐÐ¸ÑÑÐ°ÑÐ¸Ñ Ð·Ð°ÑÐµÐ½ÐµÐ½Ð¸Ñ Ð±Ð»Ð¾ÐºÐ¾Ð² Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð° Ð½Ð°: " .. tonumber(words[2]), 0xFFDB40)
			elseif words[1] == "help" then
				addItemToChatHistory("ÐÐ¾ÑÑÑÐ¿Ð½ÑÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ:", 0xFFDB40)
				addItemToChatHistory("/time get", 0xFFFFBF)
				addItemToChatHistory("/time set <value>", 0xFFFFBF)
				addItemToChatHistory("/time lock", 0xFFFFBF)
				addItemToChatHistory(" ", 0xFFFFFF)
				addItemToChatHistory("/setRenderQuality <value>", 0xFFFFBF)
				addItemToChatHistory("/setDrawDistance <value>", 0xFFFFBF)
				addItemToChatHistory("/setShadingCascades <value>", 0xFFFFBF)
				addItemToChatHistory("/setShadingDistance <value>", 0xFFFFBF)
			else
				addItemToChatHistory("ÐÐµÐ¸Ð·Ð²ÐµÑÑÐ½Ð°Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°. ÐÐ²ÐµÐ´Ð¸ÑÐµ /help Ð´Ð»Ñ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ñ ÑÐ¿Ð¸ÑÐºÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´", 0xFF8888)
			end
		else
			addItemToChatHistory("> " .. text, 0xFFFFFF)
		end
	end

	--ÐÐºÑÐ¸Ð²Ð¸ÑÑÐµÐ¼ ÑÐ°Ð¹Ð¼ÐµÑ
	if rayEngine.chatTimer then event.cancel(rayEngine.chatTimer) end
	rayEngine.chatEnabled = true
	rayEngine.chatTimer = event.timer(rayEngine.chatShowTime, function() rayEngine.chatEnabled = false; rayEngine.chatTimer = nil; update() end)
end

function rayEngine.toggleMinimap()
	rayEngine.minimapEnabled = not rayEngine.minimapEnabled
end

function rayEngine.toggleDebugInformation()
	rayEngine.debugInformationEnabled = not rayEngine.debugInformationEnabled
end

function rayEngine.toggleCompass()
	rayEngine.compassEnabled = not rayEngine.compassEnabled
	if not rayEngine.compassEnabled then rayEngine.compassImage = nil end
end

function rayEngine.toggleWatch()
	rayEngine.watchEnabled = not rayEngine.watchEnabled
	if not rayEngine.watchEnabled then rayEngine.watchImage = nil end
end

function rayEngine.drawWeapon()
	if rayEngine.currentWeapon.needToFire then buffer.image(rayEngine.currentWeapon.xFire, rayEngine.currentWeapon.yFire, rayEngine.currentWeapon.fireTexture); rayEngine.currentWeapon.needToFire = false end
	buffer.image(rayEngine.currentWeapon.xWeapon, rayEngine.currentWeapon.yWeapon, rayEngine.currentWeapon.weaponTexture)
	buffer.image(rayEngine.currentWeapon.xCrosshair, rayEngine.currentWeapon.yCrosshair, rayEngine.currentWeapon.crosshairTexture)
end

function rayEngine.drawStats()
	local width = math.floor(buffer.screen.width * 0.3)
	local height = 5
	local x, y = buffer.screen.width - width - 1, 2
	buffer.square(x, y, width, height, 0x000000, 0xFFFFFF, " ", 50)

	GUI.progressBar(x + 1, y + 4, width - 2, 1, 0x000000, 0xFF5555, rayEngine.player.health.current, rayEngine.player.health.maximum, true)
end

---------------------------------------------------- Ð¤ÑÐ½ÐºÑÐ¸Ð¸ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ Ð¼Ð¸ÑÐ° ------------------------------------------------------------------

local function raycast(angle)
	angle = math.rad(angle)
	local angleSinDistance, angleCosDistance, currentDistance, xWorld, yWorld, xMap, yMap, tile = math.sin(angle) * rayEngine.properties.raycastQuality, math.cos(angle) * rayEngine.properties.raycastQuality, 0, rayEngine.player.position.x, rayEngine.player.position.y

	while true do
		if currentDistance <= rayEngine.properties.drawDistance then
			xMap, yMap = math.floor(xWorld / rayEngine.properties.tileWidth), math.floor(yWorld / rayEngine.properties.tileWidth)
			if rayEngine.map[yMap] and rayEngine.map[yMap][xMap] then
				return currentDistance, rayEngine.map[yMap][xMap]
			end

			xWorld, yWorld = xWorld + angleSinDistance, yWorld + angleCosDistance
			currentDistance = currentDistance + rayEngine.properties.raycastQuality
		else
			return nil
		end
	end
end

function rayEngine.drawWorld()
	--ÐÐµÐ¼Ð»Ñ
	buffer.clear(rayEngine.world.colors.groundByTime)
	--ÐÐµÐ±Ð¾
	buffer.square(1, 1, buffer.screen.width, rayEngine.horizonPosition, rayEngine.world.colors.sky.current)
	--Ð¡ÑÐµÐ½Ð°
	local startAngle, endAngle, startX, distanceToTile, tileID, height, startY, tileColor = rayEngine.player.rotation - rayEngine.player.fieldOfView / 2, rayEngine.player.rotation + rayEngine.player.fieldOfView / 2, 1
	for angle = startAngle, endAngle, rayEngine.raycastStep do
		distanceToTile, tileID = raycast(angle)
		if distanceToTile then
			-- ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÐ²ÐµÑ ÑÑÐµÐ½ÐºÐ¸
			tileColor = getTileColor(rayEngine.blocks[tileID].color, distanceToTile)
			
			-- ÐÐ¾Ð´Ð´ÐµÑÐ¶ÐºÐ° "Ð²ÑÑÐ¾ÐºÐ¾ÐºÐ°ÑÐµÑÑÐ²ÐµÐ½Ð½Ð¾Ð¹" doubleHeight-Ð³ÑÐ°ÑÐ¸ÐºÐ¸
			if rayEngine.properties.useSimpleRenderer then
				height = rayEngine.properties.tileWidth / distanceToTile * rayEngine.distanceToProjectionPlane
				startY = rayEngine.horizonPosition - height / 2 + 1
				buffer.square(math.floor(startX), math.floor(startY), 1, math.floor(height), tileColor, 0x000000, " ")
			else
				height = rayEngine.properties.tileWidth / distanceToTile * rayEngine.distanceToProjectionPlane * 2
				startY = rayEngine.horizonPosition * 2 - height / 2 + 1
				buffer.semiPixelSquare(math.floor(startX), math.floor(startY), 1, height, tileColor)
			end

			--Ð¢ÐÐÐ¡Ð¢Ð£Ð ÐÐ)))00
			-- local xTexture = startX % rayEngine.properties.tileWidth + 1
			-- if xTexture >= 1 and xTexture <= buffer.screen.width then
			-- 	local column = image.getColumn(rayEngine.wallsTexture, xTexture)
			-- 	column = image.transform(column, 1, height)
			-- 	buffer.image(math.floor(startX), math.floor(startY), column)
			-- end
		end
		startX = startX + 1
	end
end

function rayEngine.update()
	local frameRenderClock = os.clock()
	
	rayEngine.drawWorld()
	if rayEngine.currentWeapon then rayEngine.drawWeapon() end
	if rayEngine.minimapEnabled then rayEngine.drawMap(3, 2, 24, 24, 50) end
	-- rayEngine.drawStats()
	local xTools, yTools = 3, buffer.screen.height - 25
	if rayEngine.compassEnabled then rayEngine.compass(xTools, yTools); xTools = xTools + 30 end
	if rayEngine.watchEnabled then rayEngine.watch(xTools, yTools) end
	if rayEngine.chatEnabled then rayEngine.chat() end
	doDayNightCycle()

	if rayEngine.debugInformationEnabled then
		rayEngine.drawDebugInformation(3, 2 + (rayEngine.minimapEnabled and 12 or 0), 24, 60, 
			"renderTime: " .. math.doubleToString((os.clock() - frameRenderClock) * 1000, 2) .. " ms",
			"freeRAM: " .. math.doubleToString(computer.freeMemory() / 1024, 2) .. " KB",
			"pos: " .. math.doubleToString(rayEngine.player.position.x) .. " x " .. math.doubleToString(rayEngine.player.position.y)
		)
	end

	buffer.draw()
end

----------------------------------------------------------------------------------------------------------------------------------

function rayEngine.changeResolution(width, height)
	component.gpu.setResolution(width, height)
	buffer.start()
	rayEngine.calculateAllParameters()
end

function rayEngine.fire()
	rayEngine.currentWeapon.needToFire = true
	rayEngine.update()
	os.sleep(0.1)
	rayEngine.update()
end

----------------------------------------------------------------------------------------------------------------------------------

return rayEngine
F
lib/rc.lua-- Keeps track of loaded scripts to retain local values between invocation
-- of their command callbacks.
local rc = {}
rc.loaded = {}

return rc

Flib/serialization.luap
require("advancedLua")
local serialization = {}

------------------------------------------------- Public methods -----------------------------------------------------------------

function serialization.serialize(...)
	return table.serialize(...)
end

function serialization.unserialize(...)
	return table.unserialize(...)
end

function serialization.serializeToFile(...)
	table.toFile(...)
end

function serialization.unserializeFromFile(...)
	return table.fromFIle(...)
end

----------------------------------------------------------------------------------------------------------------------

return serialization




F
lib/sh.luakÛlocal event = require("event")
local fs = require("filesystem")
local process = require("process")
local shell = require("shell")
local term = require("term")
local text = require("text")
local tx = require("transforms")
local unicode = require("unicode")

local sh = {}
sh.internal = {}

-- --[[@@]] are not just comments, but custom annotations for delayload methods.
-- See package.lua and the api wiki for more information
function isWordOf(w, vs) return w and #w == 1 and not w[1].qr and tx.first(vs,{{w[1].txt}}) ~= nil end
function isWord(w,v) return isWordOf(w,{v}) end
local local_env = {event=event,fs=fs,process=process,shell=shell,term=term,text=text,tx=tx,unicode=unicode,isWordOf=isWordOf,isWord=isWord}

-------------------------------------------------------------------------------

--SH API

sh.internal.globbers = {{"*",".*"},{"?","."}}
sh.internal.ec = {}
sh.internal.ec.parseCommand = 127
sh.internal.ec.sysError =  128
sh.internal.ec.last = 0

function sh.getLastExitCode()
  return sh.internal.ec.last
end

function sh.internal.command_passed(ec)
  local code = sh.internal.command_result_as_code(ec)
  return code == 0
end

function sh.internal.command_result_as_code(ec)
  -- convert lua result to bash ec
  if ec == false then
    return 1
  elseif ec == nil or ec == true or type(ec) ~= "number" then
    return 0
  else
    return ec
  end
end

function sh.internal.resolveActions(input, resolver, resolved)
  checkArg(1, input, "string")
  checkArg(2, resolver, "function", "nil")
  checkArg(3, resolved, "table", "nil")
  resolver = resolver or shell.getAlias
  resolved = resolved or {}

  local processed = {}

  local prev_was_delim, simple = true, true
  local words, reason = text.internal.tokenize(input)

  if not words then
    return nil, reason
  end

  while #words > 0 do
    local next = table.remove(words,1)
    if isWordOf(next, {";","&&","||","|"}) then
      prev_was_delim,simple = true,false
      resolved = {}
    elseif prev_was_delim then
      prev_was_delim = false
      -- if current is actionable, resolve, else pop until delim
      if next and #next == 1 and not next[1].qr then
        local key = next[1].txt
        if key == "!" then
          prev_was_delim,simple = true,false -- special redo
        elseif not resolved[key] then
          resolved[key] = resolver(key)
          local value = resolved[key]
          if value and key ~= value then
            local replacement_tokens, reason = sh.internal.resolveActions(value, resolver, resolved)
            if not replacement_tokens then
              return replacement_tokens, reason
            end
            simple = simple and reason
            words = tx.concat(replacement_tokens, words)
            next = table.remove(words,1)
          end
        end
      end
    end

    table.insert(processed, next)
  end

  return processed, simple
end

function sh.internal.statements(input)
  checkArg(1, input, "string")

  local words, reason = sh.internal.resolveActions(input)
  if type(words) ~= "table" then
    return words, reason
  elseif #words == 0 then
    return true
  elseif reason and not input:find("[<>]") then
    return {words}, reason
  end

  -- we shall validate pipes before any statement execution
  local statements = sh.internal.splitStatements(words)
  for i=1,#statements do
    local ok, why = sh.internal.hasValidPiping(statements[i])
    if not ok then return nil,why end
  end
  return statements
end

-- returns true if key is a string that represents a valid command line identifier
function sh.internal.isIdentifier(key)
  if type(key) ~= "string" then
    return false
  end

  return key:match("^[%a_][%w_]*$") == key
end

function sh.expand(value)
  local expanded = value
  :gsub("%$([_%w%?]+)", function(key)
    if key == "?" then
      return tostring(sh.getLastExitCode())
    end
    return os.getenv(key) or ''
  end)
  :gsub("%${(.*)}", function(key)
    if sh.internal.isIdentifier(key) then
      return sh.internal.expandKey(key)
    end
    error("${" .. key .. "}: bad substitution")
  end)
  if expanded:find('`') then
    expanded = sh.internal.parse_sub(expanded)
  end
  return expanded
end

function sh.internal.expand(word)
  if #word == 0 then return {} end
  local result = ''
  for i=1,#word do
    local part = word[i]
    -- sh.expand runs command substitution on backticks
    -- if the entire quoted area is backtick quoted, then
    -- we can save some checks by adding them back in
    local q = part.qr and part.qr[1] == '`' and '`' or ''
    result = result .. (not (part.qr and part.qr[3]) and sh.expand(q..part.txt..q) or part.txt)
  end
  return {result}
end

-- expand to files in path, or try key substitution
-- word is a list of metadata-filled word parts
-- note: text.internal.words(string) returns an array of these words
function sh.internal.evaluate(word)
  checkArg(1, word, "table")
  if #word == 0 then
    return {}
  elseif #word == 1 and word[1].qr then
    return sh.internal.expand(word)
  end
  local function make_pattern(seg)
    local result = seg
    for _,glob_rule in ipairs(sh.internal.globbers) do
      result = result:gsub("%%%"..glob_rule[1], glob_rule[2])
      local reduced = result
      repeat
        result = reduced
        reduced = result:gsub(text.escapeMagic(glob_rule[2]):rep(2), glob_rule[2])
      until reduced == result
    end
    return result
  end
  local glob_pattern = ''
  local has_globits = false
  for i=1,#word do local part = word[i]
    local next = part.txt
    if not part.qr then
      local escaped = text.escapeMagic(next)
      next = make_pattern(escaped)
      if next ~= escaped then
        has_globits = true
      end
    end
    glob_pattern = glob_pattern .. next
  end
  if not has_globits then
    return sh.internal.expand(word)
  end
  local globs = sh.internal.glob(glob_pattern)
  return #globs == 0 and sh.internal.expand(word) or globs
end

function sh.hintHandler(full_line, cursor)
  return sh.internal.hintHandlerImpl(full_line, cursor)
end

function sh.internal.parseCommand(words)
  checkArg(1, words, "table")
  if #words == 0 then
    return nil
  end
  local evaluated_words = {}
  for i=1,#words do
    for _, arg in ipairs(sh.internal.evaluate(words[i])) do
      table.insert(evaluated_words, arg)
    end
  end
  local program, reason = shell.resolve(evaluated_words[1], "lua")
  if not program then
    return nil, evaluated_words[1] .. ": " .. reason
  end
  evaluated_words = tx.sub(evaluated_words, 2)
  return program, evaluated_words
end

function sh.internal.createThreads(commands, eargs, env)
  -- Piping data between programs works like so:
  -- program1 gets its output replaced with our custom stream.
  -- program2 gets its input replaced with our custom stream.
  -- repeat for all programs
  -- custom stream triggers execution of "next" program after write.
  -- custom stream triggers yield before read if buffer is empty.
  -- custom stream may have "redirect" entries for fallback/duplication.
  local threads = {}
  for i = 1, #commands do
    local program, args = table.unpack(commands[i])
    local name, thread = tostring(program)
    local thread_env = type(program) == "string" and env or nil
    local thread, reason = process.load(program, thread_env, function()
      os.setenv("_", name)
      -- popen expects each process to first write an empty string
      -- this is required for proper thread order
      io.write('')
    end, name)

    threads[i] = thread
    
    if thread then
      -- smart check if ios should be loaded
      if tx.first(args, function(token) return token == "<" or token:find(">") end) then
        args, reason = sh.internal.buildCommandRedirects(thread, args)
      end
    end
    
    if not args or not thread then
      for i,t in ipairs(threads) do
        process.internal.close(t)
      end
      return nil, reason
    end

    process.info(thread).data.args = tx.concat(args, eargs or {})
  end

  if #threads > 1 then
    sh.internal.buildPipeChain(threads)
  end

  return threads
end

function sh.internal.runThreads(threads)
  local result = {}
  for i = 1, #threads do
    -- Emulate CC behavior by making yields a filtered event.pull()
    local thread, args = threads[i]
    while coroutine.status(thread) ~= "dead" do
      args = args or process.info(thread).data.args
      result = table.pack(coroutine.resume(thread, table.unpack(args)))
      if coroutine.status(thread) ~= "dead" then
        args = sh.internal.handleThreadYield(result)
        -- in case this was the end of the line, args is returned
        result = args
        if table.remove(args, 1) then
          break
        end
      end
    end
    if not result[1] then
      sh.internal.handleThreadCrash(thread, result)
      break
    end
  end
  return table.unpack(result)
end

function sh.internal.executePipes(pipe_parts, eargs, env)
  local commands = {}
  for i=1,#pipe_parts do
    commands[i] = table.pack(sh.internal.parseCommand(pipe_parts[i]))
    if commands[i][1] == nil then
      local err = commands[i][2]
      if type(err) == "string" then
        io.stderr:write(err,"\n")
      end
      return sh.internal.ec.parseCommand
    end
  end
  local threads, reason = sh.internal.createThreads(commands, eargs, env)  
  if not threads then
    io.stderr:write(reason,"\n")
    return false
  end
  local result, cmd_result = sh.internal.runThreads(threads)

  if not result then
    if cmd_result then
      if type(cmd_result) == "string" then
        cmd_result = cmd_result:gsub("^/lib/process%.lua:%d+: /", '/')
      end
      io.stderr:write(tostring(cmd_result),"\n")
    end
    return sh.internal.ec.sysError
  end
  return cmd_result
end

function sh.execute(env, command, ...)
  checkArg(2, command, "string")
  if command:find("^%s*#") then return true, 0 end
  local statements, reason = sh.internal.statements(command)
  if not statements or statements == true then
    return statements, reason
  elseif #statements == 0 then
    return true, 0
  end

  local eargs = {...}

  -- simple
  if reason then
    sh.internal.ec.last = sh.internal.command_result_as_code(sh.internal.executePipes(statements, eargs, env))
    return true
  end

  return sh.internal.execute_complex(statements, eargs, env)
end

function --[[@delayloaded-start@]] sh.internal.handleThreadYield(result)
  local action = result[2]
  if action == nil or type(action) == "number" then
    return table.pack(pcall(event.pull, table.unpack(result, 2, result.n)))
  else
    return table.pack(coroutine.yield(table.unpack(result, 2, result.n)))
  end
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.handleThreadCrash(thread, result)
  if type(result[2]) == "table" and result[2].reason == "terminated" then
    if result[2].code then
      result[1] = true
      result.n = 1
    else
      result[2] = "terminated"
    end
  elseif type(result[2]) == "string" then
    result[2] = debug.traceback(thread, result[2])
  end
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.buildCommandRedirects(thread, args)
  local data = process.info(thread).data
  local tokens, ios, handles = args, data.io, data.handles
  args = {}
  local from_io, to_io, mode
  for i = 1, #tokens do
    local token = tokens[i]
    if token == "<" then
      from_io = 0
      mode = "r"
    else
      local first_index, last_index, from_io_txt, mode_txt, to_io_txt = token:find("(%d*)(>>?)(.*)")
      if mode_txt then
        mode = mode_txt == ">>" and "a" or "w"
        from_io = from_io_txt and tonumber(from_io_txt) or 1
        if to_io_txt ~= "" then
          to_io = tonumber(to_io_txt:sub(2))
          ios[from_io] = ios[to_io]
          mode = nil
        end
      else -- just an arg
        if not mode then
          table.insert(args, token)
        else
          local file, reason = io.open(shell.resolve(token), mode)
          if not file then
            return nil, "could not open '" .. token .. "': " .. reason
          end
          table.insert(handles, file)
          ios[from_io] = file
        end
        mode = nil
      end
    end
  end

  return args
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.buildPipeChain(threads)
  local prev_pipe
  for i=1,#threads do
    local thread = threads[i]
    local data = process.info(thread).data
    local pio = data.io

    local pipe
    if i < #threads then
      pipe = require("buffer").new("rw", sh.internal.newMemoryStream())
      pipe:setvbuf("no")
      pipe.stream.redirect[1] = rawget(pio, 1)
      pio[1] = pipe
      table.insert(data.handles, pipe)
    end

    if prev_pipe then
      prev_pipe.stream.redirect[0] = rawget(pio, 0)
      prev_pipe.stream.next = thread
      pio[0] = prev_pipe
    end

    prev_pipe = pipe
  end

end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.glob(glob_pattern)
  local segments = text.split(glob_pattern, {"/"}, true)
  local hiddens = tx.select(segments,function(e)return e:match("^%%%.")==nil end)
  local function is_visible(s,i) 
    return not hiddens[i] or s:match("^%.") == nil 
  end

  local function magical(s)
    for _,glob_rule in ipairs(sh.internal.globbers) do
      if s:match("[^%%]-"..text.escapeMagic(glob_rule[2])) then
        return true
      end
    end
  end

  local is_abs = glob_pattern:sub(1, 1) == "/"
  local root = is_abs and '' or shell.getWorkingDirectory()
  local paths = {is_abs and "/" or ''}
  local relative_separator = ''

  for i,segment in ipairs(segments) do
    local enclosed_pattern = string.format("^(%s)/?$", segment)
    local next_paths = {}
    for _,path in ipairs(paths) do
      if fs.isDirectory(root..path) then
        if magical(segment) then
          for file in fs.list(root..path) do
            if file:match(enclosed_pattern) and is_visible(file, i) then
              table.insert(next_paths, path..relative_separator..file:gsub("/+$",''))
            end
          end
        else -- not a globbing segment, just use it raw
          local plain = text.removeEscapes(segment)
          local fpath = root..path..relative_separator..plain
          local hit = path..relative_separator..plain:gsub("/+$",'')
          if fs.exists(fpath) then
            table.insert(next_paths, hit)
          end
        end
      end
    end
    paths = next_paths
    if not next(paths) then break end
    relative_separator = "/"
  end
  -- if no next_paths were hit here, the ENTIRE glob value is not a path
  return paths
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] sh.getMatchingPrograms(baseName)
  local result = {}
  local result_keys = {} -- cache for fast value lookup
  -- TODO only matching files with .lua extension for now, might want to
  --      extend this to other extensions at some point? env var? file attrs?
  if not baseName or #baseName == 0 then
    baseName = "^(.*)%.lua$"
  else
    baseName = "^(" .. text.escapeMagic(baseName) .. ".*)%.lua$"
  end
  for basePath in string.gmatch(os.getenv("PATH"), "[^:]+") do
    for file in fs.list(shell.resolve(basePath)) do
      local match = file:match(baseName)
      if match and not result_keys[match] then
        table.insert(result, match)
        result_keys[match] = true
      end
    end
  end
  return result
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] sh.getMatchingFiles(basePath, name)
  local resolvedPath = shell.resolve(basePath)
  local result, baseName = {}

  -- note: we strip the trailing / to make it easier to navigate through
  -- directories using tab completion (since entering the / will then serve
  -- as the intention to go into the currently hinted one).
  -- if we have a directory but no trailing slash there may be alternatives
  -- on the same level, so don't look inside that directory... (cont.)
  if fs.isDirectory(resolvedPath) and name == "" then
    baseName = "^(.-)/?$"
  else
    baseName = "^(" .. text.escapeMagic(name) .. ".-)/?$"
  end

  for file in fs.list(resolvedPath) do
    local match = file:match(baseName)
    if match then
      table.insert(result, basePath ..  match)
    end
  end
  -- (cont.) but if there's only one match and it's a directory, *then* we
  -- do want to add the trailing slash here.
  if #result == 1 and fs.isDirectory(shell.resolve(result[1])) then
    result[1] = result[1] .. "/"
  end
  return result
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] sh.internal.hintHandlerSplit(line)
  if line:sub(-1):find("%s") then
    return '', line
  end
  local splits = text.internal.tokenize(line)
  if not splits then -- parse error, e.g. unclosed quotes
    return nil -- no split, no hints
  end
  local num_splits = #splits
  if num_splits == 1 or not isWordOf(splits[num_splits-1],{";","&&","||","|"}) then
    return '', line
  end
  local l = text.internal.normalize({splits[num_splits]})[1]
  return line:sub(1,-unicode.len(l)-1), l
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] sh.internal.hintHandlerImpl(full_line, cursor)
  -- line: text preceding the cursor: we want to hint this part (expand it)
  local line = unicode.sub(full_line, 1, cursor - 1)
  -- suffix: text following the cursor (if any, else empty string) to append to the hints
  local suffix = unicode.sub(full_line, cursor)
  -- if there is no text to hint, there are no hints
  if not line or #line < 1 then
    return {}
  end
  -- hintHandlerSplit helps make the hints work even after delimiters such as ;
  -- it also catches parse errors such as unclosed quotes
  local prev,line = sh.internal.hintHandlerSplit(line)
  if not prev then -- failed to parse, e.g. unclosed quote, no hints
    return {}
  end
  local result
  -- prefix: text (if any) that will not be expanded (such as a command word preceding a file name that we are expanding)
  -- partial: text that we want to expand
  -- this first match determines if partial comes after redirect symbols such as >
  local prefix, partial = line:match("^(.*[=><]%s*)(.*)$")
  -- if redirection was not found, partial could just be arguments following a command
  if not prefix then prefix, partial = line:match("^(.+%s+)(.*)$") end
  -- partialPrefix: text of the partial that will not be expanded (i.e. a diretory path ending with /)
  -- first, partialPrefix holds the whole text being expanded (we truncate later)
  local partialPrefix = (partial or line)
  -- name: text of the partial file name being expanded
  local name = partialPrefix:gsub("^.*/", "")
  -- here we remove the name text from the partialPrefix
  partialPrefix = partialPrefix:sub(1, -unicode.len(name) - 1)
  -- if no prefix was found and partialPrefix did not specify a closed directory path then we are expanding the first argument
  -- i.e. the command word (a program name)
  local searchInPath = not prefix and not partialPrefix:find("/")
  if searchInPath then
    result = sh.getMatchingPrograms(line)
  else
    result = sh.getMatchingFiles(partialPrefix, name)
  end
  -- in very special cases, the suffix should include a blank space to indicate to the user that the hint is discrete
  local resultSuffix = suffix
  if #result > 0 and unicode.sub(result[1], -1) ~= "/" and
     not suffix:sub(1,1):find('%s') and
     (#result == 1 or searchInPath or not prefix) then 
    resultSuffix  = " " .. resultSuffix 
  end
  -- prefix no longer needs to refer to just the expanding section of the text
  -- here we reintroduce the previous section of the text that hintHandlerSplit cut for us
  prefix = prev .. (prefix or "")
  table.sort(result)
  for i = 1, #result do
    -- the hints define the whole line of text
    result[i] = prefix .. result[i] .. resultSuffix
  end
  return result
end --[[@delayloaded-end@]] 

-- verifies that no pipes are doubled up nor at the start nor end of words
function --[[@delayloaded-start@]] sh.internal.hasValidPiping(words, pipes)
  checkArg(1, words, "table")
  checkArg(2, pipes, "table", "nil")

  if #words == 0 then
    return true
  end

  local semi_split = tx.find(text.syntax, {";"}) -- all symbols before ; in syntax CAN be repeated
  pipes = pipes or tx.sub(text.syntax, semi_split + 1)

  local pies = tx.select(words, function(parts, i)
    return #parts == 1 and #text.split(parts[1].txt, pipes, true) == 0 and true or false
  end)

  local bad_pipe
  local last = 0
  for k,v in ipairs(pies) do
    if v then
      if k-last == 1 then
        bad_pipe = words[k][1].txt
        break
      end
      last=k
    end
  end

  if not bad_pipe and last == #pies then
    bad_pipe = words[last][1].txt
  end

  if bad_pipe then
    return false, "parse error near " .. bad_pipe
  else
    return true
  end
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.boolean_executor(chains, predicator)
  local function not_gate(result)
    return sh.internal.command_passed(result) and 1 or 0
  end

  local last = true
  local boolean_stage = 1
  local negation_stage = 2
  local command_stage = 0
  local stage = negation_stage
  local skip = false

  for ci=1,#chains do
    local next = chains[ci]
    local single = #next == 1 and #next[1] == 1 and not next[1][1].qr and next[1][1].txt

    if single == "||" then
      if stage ~= command_stage or #chains == 0 then
        return nil, "syntax error near unexpected token '"..single.."'"
      end
      if sh.internal.command_passed(last) then
        skip = true
      end
      stage = boolean_stage
    elseif single == "&&" then
      if stage ~= command_stage or #chains == 0 then
        return nil, "syntax error near unexpected token '"..single.."'"
      end
      if not sh.internal.command_passed(last) then
        skip = true
      end
      stage = boolean_stage
    elseif not skip then
      local chomped = #next
      local negate = sh.internal.remove_negation(next)
      chomped = chomped ~= #next
      if negate then
        local prev = predicator
        predicator = function(n,i)
          local result = not_gate(prev(n,i))
          predicator = prev
          return result
        end
      end
      if chomped then
        stage = negation_stage
      end
      if #next > 0 then
        last = predicator(next,ci)
        stage = command_stage
      end
    else
      skip = false
      stage = command_stage
    end
  end

  if stage == negation_stage then
    last = not_gate(last)
  end

  return last
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.splitStatements(words, semicolon)
  checkArg(1, words, "table")
  checkArg(2, semicolon, "string", "nil")
  semicolon = semicolon or ";"
  
  return tx.partition(words, function(g, i, t)
    if isWord(g,semicolon) then
      return i, i
    end
  end, true)
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.splitChains(s,pc)
  checkArg(1, s, "table")
  checkArg(2, pc, "string", "nil")
  pc = pc or "|"
  return tx.partition(s, function(w)
    -- each word has multiple parts due to quotes
    if isWord(w,pc) then
      return true
    end
  end, true) -- drop |s
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.groupChains(s)
  checkArg(1,s,"table")
  return tx.partition(s,function(w)return isWordOf(w,{"&&","||"})end)
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] sh.internal.remove_negation(chain)
  if isWord(chain[1],"!") then
    table.remove(chain, 1)
    return true and not sh.internal.remove_negation(chain)
  end
  return false
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] sh.internal.newMemoryStream()
  local memoryStream = {}

  function memoryStream:close()
    self.closed = true
    self.redirect = {}
  end

  function memoryStream:seek()
    return nil, "bad file descriptor"
  end

  function memoryStream:read(n)
    if self.closed then
      return nil -- eof
    end
    if self.redirect[0] then
      -- popen could be using this code path
      -- if that is the case, it is important to leave stream.buffer alone
      return self.redirect[0]:read(n)
    elseif self.buffer == "" then
      process.info(self.next).data.args = table.pack(coroutine.yield(table.unpack(self.result)))
    end
    local result = string.sub(self.buffer, 1, n)
    self.buffer = string.sub(self.buffer, n + 1)
    return result
  end

  function memoryStream:write(value)
    if not self.redirect[1] and self.closed then
      -- if next is dead, ignore all writes
      if coroutine.status(self.next) ~= "dead" then
        error("attempt to use a closed stream")
      end
    elseif self.redirect[1] then
      return self.redirect[1]:write(value)
    elseif not self.closed then
      self.buffer = self.buffer .. value
      local args = process.info(self.next).data.args
      self.result = table.pack(coroutine.resume(self.next, table.unpack(args)))
      if coroutine.status(self.next) == "dead" then
        self:close()
      end
      if not self.result[1] then
        error(self.result[2], 0)
      end
      table.remove(self.result, 1)
      return self
    end
    return nil, 'stream closed'
  end

  local stream = {closed = false, buffer = "",
                  redirect = {}, result = {}}
  local metatable = {__index = memoryStream,
                     __metatable = "memorystream"}
  return setmetatable(stream, metatable)
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] sh.internal.execute_complex(statements, eargs, env)
  for si=1,#statements do local s = statements[si]
    local chains = sh.internal.groupChains(s)
    local last_code = sh.internal.boolean_executor(chains, function(chain, chain_index)
      local pipe_parts = sh.internal.splitChains(chain)
      local next_args = chain_index == #chains and si == #statements and eargs or {}
      return sh.internal.executePipes(pipe_parts, next_args, env)
    end)
    sh.internal.ec.last = sh.internal.command_result_as_code(last_code)
  end
  return true
end --[[@delayloaded-end@]]


function --[[@delayloaded-start@]] sh.internal.parse_sub(input)
  -- cannot use gsub here becuase it is a [C] call, and io.popen needs to yield at times
  local packed = {}
  -- not using for i... because i can skip ahead
  local i, len = 1, #input

  while i < len do

    local fi, si, capture = input:find("`([^`]*)`", i)

    if not fi then
      table.insert(packed, input:sub(i))
      break
    end

    local sub = io.popen(capture)
    local result = sub:read("*a")
    sub:close()
    -- all whitespace is replaced by single spaces
    -- we requote the result because tokenize will respect this as text
    table.insert(packed, (text.trim(result):gsub("%s+"," ")))

    i = si+1
  end

  return table.concat(packed)
end --[[@delayloaded-end@]]

return sh, local_env
Flib/shell.lua_local fs = require("filesystem")
local text = require("text")
local unicode = require("unicode")
local process = require("process")

local shell = {}

-- Cache loaded shells for command execution. This puts the requirement on
-- shells that they do not keep a global state, since they may be called
-- multiple times, but reduces memory usage a lot.
local shells = setmetatable({}, {__mode="v"})

function shell.getShell()
  local shellPath = os.getenv("SHELL") or "/bin/sh"
  local shellName, reason = shell.resolve(shellPath, "lua")
  if not shellName then
    return nil, "cannot resolve shell `" .. shellPath .. "': " .. reason
  end
  if shells[shellName] then
    return shells[shellName]
  end
  local sh, reason = loadfile(shellName, "t", env)
  if sh then
    shells[shellName] = sh
  end
  return sh, reason
end

local function findFile(name, ext)
  checkArg(1, name, "string")
  local function findIn(dir)
    if dir:sub(1, 1) ~= "/" then
      dir = shell.resolve(dir)
    end
    dir = fs.concat(fs.concat(dir, name), "..")
    local name = fs.name(name)
    local list = fs.list(dir)
    if list and name then
      local files = {}
      for file in list do
        files[file] = true
      end
      if ext and unicode.sub(name, -(1 + unicode.len(ext))) == "." .. ext then
        -- Name already contains extension, prioritize.
        if files[name] then
          return true, fs.concat(dir, name)
        end
      elseif files[name] then
        -- Check exact name.
        return true, fs.concat(dir, name)
      elseif ext then
        -- Check name with automatially added extension.
        local name = name .. "." .. ext
        if files[name] then
          return true, fs.concat(dir, name)
        end
      end
    end
    return false
  end
  if unicode.sub(name, 1, 1) == "/" then
    local found, where = findIn("/")
    if found then return where end
  elseif unicode.sub(name, 1, 2) == "./" then
    local found, where = findIn(shell.getWorkingDirectory())
    if found then return where end
  else
    for path in string.gmatch(shell.getPath(), "[^:]+") do
      local found, where = findIn(path)
      if found then return where end
    end
  end
  return false
end

-------------------------------------------------------------------------------

function shell.prime()
  local data = process.info().data
  for _,key in ipairs({'aliases','vars'}) do
    -- first time get need to populate
    local raw = rawget(data, key)
    if not raw then
      -- current process does not have the key
      local current = data[key]
      data[key] = {}
      if current then
        for k,v in pairs(current) do
          data[key][k] = v
        end
      end
    end
  end
end

function shell.getAlias(alias)
  return process.info().data.aliases[alias]
end

function shell.setAlias(alias, value)
  checkArg(1, alias, "string")
  checkArg(2, value, "string", "nil")
  process.info().data.aliases[alias] = value
end

function shell.aliases()
  return pairs(process.info().data.aliases)
end

function shell.resolveAlias(command, args)
  checkArg(1, command, "string")
  checkArg(2, args, "table", "nil")
  args = args or {}
  local program, lastProgram = command, nil
  while true do
    local tokens = text.tokenize(shell.getAlias(program) or program)
    program = tokens[1]
    if program == lastProgram then
      break
    end
    lastProgram = program
    for i = #tokens, 2, -1 do
      table.insert(args, 1, tokens[i])
    end
  end
  return program, args
end

function shell.getWorkingDirectory()
  return os.getenv("PWD")
end

function shell.setWorkingDirectory(dir)
  checkArg(1, dir, "string")
  dir = fs.canonical(dir) .. "/"
  if dir == "//" then dir = "/" end
  if fs.isDirectory(dir) then
    os.setenv("PWD", dir)
    return true
  else
    return nil, "not a directory"
  end
end

function shell.getPath()
  return os.getenv("PATH")
end

function shell.setPath(value)
  os.setenv("PATH", value)
end

function shell.resolve(path, ext)
  if ext then
    checkArg(2, ext, "string")
    local where = findFile(path, ext)
    if where then
      return where
    else
      return nil, "file not found"
    end
  else
    if unicode.sub(path, 1, 1) == "/" then
      return fs.canonical(path)
    else
      return fs.concat(shell.getWorkingDirectory(), path)
    end
  end
end

function shell.execute(command, env, ...)
  local sh, reason = shell.getShell()
  if not sh then
    return false, reason
  end
  local result = table.pack(pcall(sh, env, command, ...))
  if not result[1] and type(result[2]) == "table" and result[2].reason == "terminated" then
    if result[2].code then
      return true
    else
      return false, "terminated"
    end
  end
  return table.unpack(result, 1, result.n)
end

function shell.parse(...)
  local params = table.pack(...)
  local args = {}
  local options = {}
  local doneWithOptions = false
  for i = 1, params.n do
    local param = params[i]
    if not doneWithOptions and type(param) == "string" then
      if param == "--" then
        doneWithOptions = true -- stop processing options at `--`
      elseif unicode.sub(param, 1, 2) == "--" then
        if param:match("%-%-(.-)=") ~= nil then
          options[param:match("%-%-(.-)=")] = param:match("=(.*)")
        else
          options[unicode.sub(param, 3)] = true
        end
      elseif unicode.sub(param, 1, 1) == "-" and param ~= "-" then
        for j = 2, unicode.len(param) do
          options[unicode.sub(param, j, j)] = true
        end
      else
        table.insert(args, param)
      end
    else
      table.insert(args, param)
    end
  end
  return args, options
end

-------------------------------------------------------------------------------

return shell
Flib/sides.luaølocal sides = {
  [0] = "bottom",
  [1] = "top",
  [2] = "back",
  [3] = "front",
  [4] = "right",
  [5] = "left",
  [6] = "unknown",

  bottom = 0,
  top = 1,
  back = 2,
  front = 3,
  right = 4,
  left = 5,
  unknown = 6,

  down = 0,
  up = 1,
  north = 2,
  south = 3,
  west = 4,
  east = 5,

  negy = 0,
  posy = 1,
  negz = 2,
  posz = 3,
  negx = 4,
  posx = 5,

  forward = 3
}

local metatable = getmetatable(sides) or {}

-- sides[0..5] are mapped to itertable[1..6].
local itertable = {
  sides[0],
  sides[1],
  sides[2],
  sides[3],
  sides[4],
  sides[5]
}

-- Future-proofing against the possible introduction of additional
-- logical sides (e.g. [7] = "all", [8] = "none", etc.).
function metatable.__len(sides)
  return #itertable
end

-- Allow `sides` to be iterated over like a normal (1-based) array.
function metatable.__ipairs(sides)
  return ipairs(itertable)
end

setmetatable(sides, metatable)

-------------------------------------------------------------------------------

return sides
Flib/syntax.lua
require("advancedLua")
local buffer = require("doubleBuffering")
local unicode = require("unicode")

local syntax = {}

----------------------------------------------------------------------------------------------------------------------------------------

syntax.indentationSeparator = "â"

syntax.colorScheme = {
	background = 0x1E1E1E,
	text = 0xffffff,
	strings = 0x99FF80,
	loops = 0xffff98,
	comments = 0x888888,
	boolean = 0xFFDB40,
	logic = 0xffcc66,
	numbers = 0x66DBFF,
	functions = 0xffcc66,
	compares = 0xffff98,
	lineNumbersBackground = 0x2D2D2D,
	lineNumbersText = 0xCCCCCC,
	scrollBarBackground = 0x444444,
	scrollBarForeground = 0x33B6FF,
	selection = 0x555555,
	indentation = 0x3C3C3C,
}

syntax.patterns = {
	-- ÐÐ¾Ð¼Ð¼ÐµÐ½ÑÐ°ÑÐ¸Ð¸
	{ "%-%-.+", "comments", 0, 0 },
	
	-- Ð¡ÑÑÐ¾ÐºÐ¸
	{ "\"[^\"]+\"", "strings", 0, 0 },
	
	-- Ð¦Ð¸ÐºÐ»Ñ, ÑÑÐ»Ð¾Ð²Ð¸Ñ Ð¸ Ð¿ÑÐ¾ÑÐ°Ñ Ð¿Ð¾ÐµÐ±ÐµÐ½Ñ
	{ "while ", "loops", 0, 1 },
	{ "do$", "loops", 0, 0 },
	{ "do ", "loops", 0, 1 },
	{ "end$", "loops", 0, 0 },
	{ "end[%s%;]", "loops", 0, 1 },
	{ "for ", "loops", 0, 1 },
	{ " in ", "loops", 0, 1 },
	{ "repeat ", "loops", 0, 1 },
	{ "if ", "loops", 0, 1 },
	{ "then", "loops", 0, 0 },
	{ "until ", "loops", 0, 1 },
	{ "return", "loops", 0, 0 },
	{ "local ", "loops", 0, 1 },
	{ "function ", "loops", 0, 1 },
	{ "else$", "loops", 0, 0 },
	{ "else[%s%;]", "loops", 0, 1 },
	{ "elseif ", "loops", 0, 1 },
	{ " break$", "loops", 0, 0 },
	{ " break ", "loops", 0, 0 },

	-- ÐÑÑÐ¸Ð½Ð°, Ð»Ð¾Ð¶Ñ, Ð½ÑÐ»Ð»
	{ "true", "boolean", 0, 0 },
	{ "false", "boolean", 0, 0 },
	{ "nil", "boolean", 0, 0 },
			
	--Ð¤ÑÐ½ÐºÑÐ¸Ð¸
	{ "[%s%=%{%(][^%s%(%)%{%}%[%]]+%(", "functions", 1, 1 },
	{ "^[^%s%(%)%{%}%[%]]+%(", "functions", 0, 1 },
	
	-- ÐÐ¾Ð³Ð¸ÑÐµÑÐºÐ¸Ðµ Ð²ÑÑÐ°Ð¶ÐµÐ½Ð¸Ñ
	{ " and ", "logic", 0, 1 },
	{ " or ", "logic", 0, 1 },
	{ " not ", "logic", 0, 1 },

	-- ÐÐ¾Ð½ÐºÐ°ÑÐµÐ½Ð°ÑÐ¸Ñ ÑÑÑÐ¾Ðº
	{ "[^%d]%.+[^%d]", "logic", 1, 1 },

	-- Ð¡ÑÐ°Ð²Ð½ÐµÐ½Ð¸Ñ Ð¸ Ð¼Ð°Ñ. Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¸
	{ "[%>%<%=%~%+%-%*%/%^%#%%]", "compares", 0, 0 },

	-- Ð§Ð¸ÑÐ»Ð°
	{ "0x%w+", "numbers", 0, 0 },
	{ "[^%a%d][%.%d]+$", "numbers", 1, 0 },
	{ "[^%a%d][%.%d]+[^%a%d]", "numbers", 1, 1 },
}

----------------------------------------------------------------------------------------------------------------------------------------

-- ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° ÑÑÑÐ¾ÐºÐ¸ Ñ Ð¿Ð¾Ð´ÑÐ²ÐµÑÐµÐ½Ð½ÑÐ¼ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ¾Ð¼
function syntax.highlightString(x, y, str, indentationWidth)
	if y >= buffer.drawLimit.y and y <= buffer.drawLimit.y2 then
		local stringLength, symbols, colors, searchFrom, starting, ending, bufferIndex = unicode.len(str), {}, {}

		for symbol = 1, stringLength do
			symbols[symbol] = unicode.sub(str, symbol, symbol)
		end

		for patternIndex = #syntax.patterns, 1, -1 do
			searchFrom = 1
			while true do
				starting, ending = string.unicodeFind(str, syntax.patterns[patternIndex][1], searchFrom)
				if starting then
					for symbol = starting + syntax.patterns[patternIndex][3], ending - syntax.patterns[patternIndex][4] do
						colors[symbol] = syntax.colorScheme[syntax.patterns[patternIndex][2]]
					end
				else
					break
				end	
				searchFrom = ending + 1 - syntax.patterns[patternIndex][4]
			end
		end

		local notSpaceNotFound, indentationSymbolCounter = true, 1

		for symbol = 1, stringLength do
			if notSpaceNotFound then
				if symbols[symbol] == " " then
					colors[symbol] = syntax.colorScheme.indentation
					if indentationSymbolCounter == 1 then
						symbols[symbol] = syntax.indentationSeparator
						indentationSymbolCounter = indentationWidth + 1
					end
				else
					notSpaceNotFound = false
				end
				indentationSymbolCounter = indentationSymbolCounter - 1
			end

			if x > buffer.drawLimit.x2 then
				break
			elseif x >= buffer.drawLimit.x then
				bufferIndex = bufferIndex or buffer.getBufferIndexByCoordinates(x, y)
				buffer.screen.new[bufferIndex + 1] = colors[symbol] or syntax.colorScheme.text
				buffer.screen.new[bufferIndex + 2] = symbols[symbol]
				bufferIndex = bufferIndex + 3
			end
			
			x = x + 1
		end
	end
end

----------------------------------------------------------------------------------------------------------------

-- buffer.start()
-- buffer.clear(0x1b1b1b)

-- buffer.square(5, 5, 30, 3, syntax.colorScheme.background, 0x0, " ")
-- -- buffer.setDrawLimit(5, 5, 30, 3)
-- -- syntax.highlightString(5, 6, "if not fs.exists(path) then error(\"File \\\"\"..path..\"\\\" doesnt't exsists.\\n\") end")
-- syntax.highlightString(5, 6, "for i = 1, 10 do", 2)
-- syntax.highlightString(5, 7, "  local abc = print(123)", 2)
-- syntax.highlightString(5, 8, "    local abc = print(123)", 2)
-- syntax.highlightString(5, 9, "end", 2)
-- -- buffer.resetDrawLimit()

-- buffer.draw(true)

----------------------------------------------------------------------------------------------------------------

return syntax




Flib/term.lua@«local unicode = require("unicode")
local event = require("event")
local process = require("process")
local kb = require("keyboard")
local keys = kb.keys

local term = {}
term.internal = {}

function term.internal.window()
  return process.info().data.window
end

local W = term.internal.window

local local_env = {unicode=unicode,event=event,process=process,W=W,kb=kb}

function term.internal.open(...)
  local dx, dy, w, h = ...
  local window = {x=1,y=1,fullscreen=select("#",...)==0,dx=dx or 0,dy=dy or 0,w=w,h=h,blink=true}
  return window
end

function term.getViewport(window)
  window = window or W()
  return window.w, window.h, window.dx, window.dy, window.x, window.y
end

function term.setViewport(w,h,dx,dy,x,y,window)
  window = window or W()

  local gw,gh = window.gpu.getViewport()
  w,h,dx,dy,x,y = w or gw,h or gh,dx or 0,dy or 0,x or 1,y or 1

  window.w,window.h,window.dx,window.dy,window.x,window.y,window.gw,window.gh=
    w,h,dx,dy,x,y, gw, gh
end

function term.gpu(window)
  window = window or W()
  return window.gpu
end

function term.clear()
  local w = W()
  local gpu = w.gpu
  if not gpu then return end
  gpu.fill(1+w.dx,1+w.dy,w.w,w.h," ")
  w.x,w.y=1,1
end

function term.isAvailable(w)
  w = w or W()
  return w and not not (w.gpu and w.screen)
end

function term.internal.pull(input, c, off, t, ...)
  t=t or math.huge
  if t < 0 then return end
  local w,unpack=W(),table.unpack
  local d,h,dx,dy,x,y=term.getViewport(w)
  local out = (x<1 or x>d or y<1 or y>h)
  if input and out then
    input:move(0)
    y=w.y
    input:scroll()
  end
  x,y=w.x+dx,w.y+dy
  local gpu

  if input or not out then
    gpu=w.gpu
    local sf,sb=gpu.setForeground,gpu.setBackground
    c=c or {{gpu.getBackground()},{gpu.getForeground()},gpu.get(x,y)}
    local c11,c12 = unpack(c[1])
    local c21,c22 = unpack(c[2])
    if not off then
      sf(c11,c12)
      sb(c21,c22)
    end
    gpu.set(x,y,c[3])
    sb(c11,c12)
    sf(c21,c22)
  end

  local a={pcall(event.pull,math.min(t,0.5),...)}

  if #a>1 or t<.5 then
    if gpu then
      gpu.set(x,y,c[3])
    end
    return select(2,unpack(a))
  end
  local blinking = w.blink
  if input then blinking = input.blink end
  return term.internal.pull(input,c,blinking and not off,t-0.5,...)
end

function term.pull(p,...)
  local a,t = {p,...}
  if type(p) == "number" then t = table.remove(a,1) end
  return term.internal.pull(nil,nil,nil,t,table.unpack(a))
end

function term.read(history,dobreak,hintHandler,pwchar,filter)
  if not io.stdin.tty then return io.read() end
  local ops = history or {}
  ops.dobreak = ops.dobreak
  if ops.dobreak==nil then ops.dobreak = dobreak end
  ops.hintHandler = ops.hintHandler or hintHandler
  ops.pwchar = ops.pwchar or pwchar
  ops.filter = ops.filter or filter
  return term.readKeyboard(ops)
end

function term.internal.split(input)
  local data,index=input.data,input.index
  local dlen = unicode.len(data)
  index=math.max(0,math.min(index,dlen))
  local tail=dlen-index
  return unicode.sub(data,1,index),tail==0 and""or unicode.sub(data,-tail)
end

function term.internal.build_vertical_reader(input)
  input.sy = 0
  input.scroll = function(_)
    _.sy = _.sy + term.internal.scroll(_.w)
    _.w.y = math.min(_.w.y,_.w.h)
  end
  input.move = function(_,n)
    local w=_.w
    _.index = math.min(math.max(0,_.index+n),unicode.len(_.data))
    local s1,s2 = term.internal.split(_)
    s2 = unicode.sub(s2.." ",1,1)
    local data_remaining = ("_"):rep(_.promptx-1)..s1..s2
    w.y = _.prompty - _.sy
    while true do
      local wlen_remaining = unicode.wlen(data_remaining)
      if wlen_remaining > w.w then
        local line_cut = unicode.wtrunc(data_remaining, w.w+1)
        data_remaining = unicode.sub(data_remaining,unicode.len(line_cut)+1)
        w.y=w.y+1
      else
        w.x = wlen_remaining-unicode.wlen(s2)+1
        break
      end
    end
  end
  input.clear_tail = function(_)
    local win=_.w
    local oi,w,h,dx,dy,ox,oy = _.index,term.getViewport(win)
    _:move(math.huge)
    _:move(-1)
    local ex,ey=win.x,win.y
    win.x,win.y,_.index=ox,oy,oi
    x=oy==ey and ox or 1
    win.gpu.fill(x+dx,ey+dy,w-x+1,1," ")
  end
  input.update = function(_,arg)
    local w,cursor,suffix=_.w
    local s1,s2=term.internal.split(_)
    if type(arg) == "number" then
      local ndata
      if arg < 0 then if _.index<=0 then return end
        _:move(-1)
        ndata=unicode.sub(s1,1,-2)..s2
      else if _.index>=unicode.len(_.data) then return end
        s2=unicode.sub(s2,2)
        ndata=s1..s2
      end
      suffix=s2
      input:clear_tail()
      _.data = ndata
    else
      _.data=s1..arg..s2
      _.index=_.index+unicode.len(arg)
      cursor,suffix=arg,s2
    end
    if cursor then _:draw(_.mask(cursor)) end
    if suffix and suffix~="" then
      local px,py,ps=w.x,w.y,_.sy
      _:draw(_.mask(suffix))
      w.x,w.y=px,py-(_.sy-ps)
    end
  end
  input.clear = function(_)
    _:move(-math.huge)
    _:draw((" "):rep(unicode.wlen(_.data)))
    _:move(-math.huge)
    _.index=0
    _.data=""
  end
  input.draw = function(_,text)
    _.sy = _.sy + term.drawText(text,true)
  end
end

function term.internal.read_history(history,input,change)
  if not change then
    if unicode.wlen(input.data) > 0 then
      table.insert(history.list,1,input.data)
      history.list[(tonumber(os.getenv("HISTSIZE")) or 10)+1]=nil
      history.list[0]=nil
    end
  else
    local ni = history.index + change
    if ni >= 0 and ni <= #history.list then
      history.list[history.index]=input.data
      history.index = ni
      input:clear()
      input:update(history.list[ni])
    end
  end
end

function term.readKeyboard(ops)
  checkArg(1,ops,"table")
  local filter = ops.filter and function(i) return term.internal.filter(ops.filter,i) end or term.internal.nop
  local pwchar = ops.pwchar and function(i) return term.internal.mask(ops.pwchar,i) end or term.internal.nop
  local history,db,hints={list=ops,index=0},ops.dobreak,{handler=ops.hintHandler}
  local w=W()
  local draw=io.stdin.tty and term.drawText or term.internal.nop
  local input={w=w,promptx=w.x,prompty=w.y,index=0,data="",mask=pwchar}
  input.blink = ops.blink
  if input.blink == nil then input.blink = w.blink end
  if ops.nowrap then
    term.internal.build_horizontal_reader(input)
  else
    term.internal.build_vertical_reader(input)
  end
  while true do
    local name, address, char, code = term.internal.pull(input)
    local c = nil
    local backup_cache = hints.cache
    if name =="interrupted" then draw("^C\n",true) return ""
    elseif name=="touch" or name=="drag" then term.internal.onTouch(input,char,code)
    elseif name=="clipboard" then c=char hints.cache = nil
    elseif name=="key_down" then
      hints.cache = nil
      local ctrl = kb.isControlDown(address)
      if ctrl and code == keys.d then return
      elseif char==9 then hints.cache = backup_cache term.internal.tab(input,hints)
      elseif char==13 and filter(input) then
        input:move(math.huge)
        if db ~= false then draw("\n") end
        term.internal.read_history(history,input)
        return input.data.."\n"
      elseif code==keys.back then
        input:update(-1)
      elseif code==keys.left then
        input:move(ctrl and term.internal.ctrl_movement(input, -1) or -1)
      elseif code==keys.right then
        input:move(ctrl and term.internal.ctrl_movement(input, 1) or 1)
      elseif code==keys.up then
        term.internal.read_history(history,input,1)
      elseif code==keys.down then
        term.internal.read_history(history,input,-1)
      elseif code==keys.home then
        input:move(-math.huge)
      elseif code==keys["end"] then
        input:move(math.huge)
      elseif code==keys.delete then
        input:update(0)
      elseif char>=32 then
        c=unicode.char(char)
      else
        hints.cache = backup_cache
      end
    end
    if c then input:update(c) end
  end
end

-- cannot use term.write = io.write because io.write invokes metatable
function term.write(value,wrap)
  local stdout = io.output()
  local stream = stdout and stdout.stream
  local previous_wrap = stream.wrap
  stream.wrap = wrap == nil and true or wrap
  stdout:write(value)
  stdout:flush()
  stream.wrap = previous_wrap
end

function term.getCursor()
  local w = W()
  return w.x,w.y
end

function term.setCursor(x,y)
  local w = W()
  w.x,w.y=x,y
end

function term.drawText(value, wrap, window)
  window = window or W()
  if not window then return end
  local gpu = window.gpu
  if not gpu then return end
  local w,h,dx,dy,x,y = term.getViewport(window)
  local sy = 0
  local vlen = #value
  local index = 1
  local cr_last,beeped = false,false
  local function scroll(_sy,_y)
    return _sy + term.internal.scroll(window,_y-h), math.min(_y,h)
  end
  while index <= vlen do
    local si,ei = value:find("[\t\r\n\a]", index)
    si = si or vlen+1
    if index==si then
      local delim = value:sub(index, index)
      if delim=="\t" then
        x=((x-1)-((x-1)%8))+9
      elseif delim=="\r" or (delim=="\n" and not cr_last) then
        x,y=1,y+1
        sy,y = scroll(sy,y)
      elseif delim=="\a" and not beeped then
        require("computer").beep()
        beeped = true
      end
      cr_last = delim == "\r"
    else
      sy,y = scroll(sy,y)
      si = si - 1
      local next = value:sub(index, si)
      local wlen_needed = unicode.wlen(next)
      local slen = #next
      local wlen_remaining = w - x + 1
      local clean_end = ""
      if wlen_remaining < wlen_needed then
        next = unicode.wtrunc(next, wlen_remaining + 1)
        wlen_needed = unicode.wlen(next)
        clean_end = (" "):rep(wlen_remaining-wlen_needed)
        if not wrap then
          si = math.huge
        end
      end
      gpu.set(x+dx,y+dy,next..clean_end)
      x = x + wlen_needed
      if wrap and slen ~= #next then
        si = si - (slen - #next)
        x = 1
        y = y + 1
      end
    end
    index = si + 1
  end

  window.x,window.y = x,y
  return sy
end

function term.internal.scroll(w,n)
  w = w or W()
  local gpu,d,h,dx,dy,x,y = w.gpu,term.getViewport(w)
  n = n or (y-h)
  if n <= 0 then return 0 end
  gpu.copy(dx+1,dy+n+1,d,h-n,0,-n)
  gpu.fill(dx+1,dy+h-n+1,d,n," ")
  return n
end

function term.internal.nop(...)
  return ...
end

function term.setCursorBlink(enabled)
  W().blink=enabled
end

function term.getCursorBlink()
  return W().blink
end

function term.bind(gpu, screen, kb, window)
  window = window or W()
  window.gpu = gpu or window.gpu
  window.screen = screen or window.screen
  window.keyboard = kb or window.keyboard
  if window.fullscreen then
    term.setViewport(nil,nil,nil,nil,window.x,window.y,window)
  end
end

function --[[@delayloaded-start@]] term.internal.ctrl_movement(input, dir)
  local index, data = input.index, input.data

  local function isEdge(char)
    return char == "" or not not char:find("%s")
  end

  local last=dir<0 and 0 or unicode.len(data)
  local start=index+dir+1
  for i=start,last,dir do
    local a,b = unicode.sub(data, i-1, i-1), unicode.sub(data, i, i)
    if isEdge(a) and not isEdge(b) then return i-(index+1) end
  end
  return last - index
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] term.internal.onTouch(input,gx,gy)
  if input.data == "" then return end
  input:move(-math.huge)
  local w = W()
  gx,gy=gx-w.dx,gy-w.dy
  local x2,y2,d = input.w.x,input.w.y,input.w.w
  local char_width_to_move = ((gy*d+gx)-(y2*d+x2))
  if char_width_to_move <= 0 then return end
  local total_wlen = unicode.wlen(input.data)
  if char_width_to_move >= total_wlen then
    input:move(math.huge)
  else
    local chars_to_move = unicode.wtrunc(input.data, char_width_to_move + 1)
    input:move(unicode.len(chars_to_move))
  end
  -- fake white space can make the index off, redo adjustment for alignment
  x2,y2,d = input.w.x,input.w.y,input.w.w
  char_width_to_move = ((gy*d+gx)-(y2*d+x2))
  if (char_width_to_move < 0) then
    -- using char_width_to_move as a type of index is wrong, but large enough and helps to speed this up
    local up_to_cursor = unicode.sub(input.data, input.index+char_width_to_move, input.index)
    local full_wlen = unicode.wlen(up_to_cursor)
    local without_tail = unicode.wtrunc(up_to_cursor, full_wlen + char_width_to_move + 1)
    local chars_cut = unicode.len(up_to_cursor) - unicode.len(without_tail)
    input:move(-chars_cut)
  end
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] term.internal.build_horizontal_reader(input)
  term.internal.build_vertical_reader(input)
  input.clear_tail = function(_)
    local w,h,dx,dy,x,y = term.getViewport(_.w)
    local s1,s2=term.internal.split(_)
    local wlen = math.min(unicode.wlen(s2),w-x+1)
    _.w.gpu.fill(x+dx,y+dy,wlen,1," ")
  end
  input.move = function(_,n)
    local win = _.w
    local a = _.index
    local b = math.max(0,math.min(unicode.len(_.data),_.index+n))
    _.index = b
    a,b = a<b and a or b,a<b and b or a
    local wlen_moved = unicode.wlen(unicode.sub(_.data,a+1,b))
    win.x = win.x + wlen_moved * (n<0 and -1 or 1)
    _:scroll()
  end
  input.draw = function(_,text)
    term.drawText(text,false)
  end
  input.scroll = function(_)
    local win = _.w
    local gpu,data,px,i = win.gpu,_.data,_.promptx,_.index
    local w,h,dx,dy,x,y = term.getViewport(win)
    win.x = math.max(_.promptx, math.min(w, x))
    local len = unicode.len(data)
    local available,sx,sy,last = w-px+1,px+dx,y+dy,i==len
    if x > w then
      local blank
      if i == unicode.len(data) then
        available,blank=available-1," "
      else
        i,blank=i+1,""
      end
      data = unicode.sub(data,1,i)
      local rev = unicode.reverse(data)
      local ending = unicode.wtrunc(rev, available+1)
      data = unicode.reverse(ending)
      gpu.set(sx,sy,data..blank)
      win.x=math.min(w,_.promptx+unicode.wlen(data))
    elseif x < _.promptx then
      data = unicode.sub(data,_.index+1)
      if unicode.wlen(data) > available then
        data = unicode.wtrunc(data,available+1)
      end
      gpu.set(sx,sy,data)
    end
  end
  input.clear = function(_)
    local win = _.w
    local gpu,data,px=win.gpu,_.data,_.promptx
    local w,h,dx,dy,x,y = term.getViewport(win)
    _.index,_.data,win.x=0,"",px
    gpu.fill(px+dx,y+dy,w-px+1-dx,1," ")
  end
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] term.clearLine(window)
  window = window or W()
  local w,h,dx,dy,x,y = term.getViewport(window)
  window.gpu.fill(dx+1,dy+math.max(1,math.min(y,h)),w,1," ")
  window.x=1
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] term.internal.mask(mask,input)
  if not mask then return input end
  if type(mask) == "function" then return mask(input) end
  return mask:rep(unicode.wlen(input))
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] term.internal.filter(filter,input)
  if not filter then return true
  elseif type(filter) == "string" then return input.data:match(filter)
  elseif filter(input.data) then return true
  else require("computer").beep(2000, 0.1) end
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] term.internal.tab(input,hints)
  if not hints.handler then return end
  if not hints.cache then
    hints.cache = type(hints.handler)=="table" and hints.handler
      or hints.handler(input.data,input.index + 1) or {}
    hints.cache.i=-1
  end
  local c=hints.cache
  local change = kb.isShiftDown(term.keyboard().address) and -1 or 1
  c.i=(c.i+change)%math.max(#c,1)
  local next=c[c.i+1]
  if next then
    local tail = unicode.len(input.data) - input.index
    input:clear()
    input:update(next)
    input:move(-tail)
  end
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] term.getGlobalArea(window)
  local w,h,dx,dy = term.getViewport(window)
  return dx+1,dy+1,w,h
end --[[@delayloaded-end@]] 

function --[[@delayloaded-start@]] term.screen(window)
  return (window or W()).screen
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] term.keyboard(window)
  window = window or W()
  local kba = window.keyboard and window.keyboard.address
  if kba and kb.pressedCodes[kba] then return window.keyboard end
  window.keyboard=nil
  local component = require("component")
  if not window.screen or not component.proxy(window.screen.address) then window.screen = nil return end
  local kba = window.screen.getKeyboards()[1]
  if not kba then return end
  window.keyboard = component.proxy(kba)
  return window.keyboard
end --[[@delayloaded-end@]]

return term, local_env
Flib/text.lua!local unicode = require("unicode")
local tx = require("transforms")

-- --[[@@]] are not just comments, but custom annotations for delayload methods.
-- See package.lua and the api wiki for more information

local text = {}
local local_env = {tx=tx,unicode=unicode}

text.internal = {}

text.syntax = {"^%d*>>?&%d+$",";","&&","||?","^%d*>>?",">>?","<"}

function --[[@delayloaded-start@]] text.detab(value, tabWidth)
  checkArg(1, value, "string")
  checkArg(2, tabWidth, "number", "nil")
  tabWidth = tabWidth or 8
  local function rep(match)
    local spaces = tabWidth - match:len() % tabWidth
    return match .. string.rep(" ", spaces)
  end
  local result = value:gsub("([^\n]-)\t", rep) -- truncate results
  return result
end --[[@delayloaded-end@]]

-- used in motd
function text.padRight(value, length)
  checkArg(1, value, "string", "nil")
  checkArg(2, length, "number")
  if not value or unicode.wlen(value) == 0 then
    return string.rep(" ", length)
  else
    return value .. string.rep(" ", length - unicode.wlen(value))
  end
end

function --[[@delayloaded-start@]] text.padLeft(value, length)
  checkArg(1, value, "string", "nil")
  checkArg(2, length, "number")
  if not value or unicode.wlen(value) == 0 then
    return string.rep(" ", length)
  else
    return string.rep(" ", length - unicode.wlen(value)) .. value
  end
end --[[@delayloaded-end@]]

function text.trim(value) -- from http://lua-users.org/wiki/StringTrim
  local from = string.match(value, "^%s*()")
  return from > #value and "" or string.match(value, ".*%S", from)
end

function text.wrap(value, width, maxWidth)
  checkArg(1, value, "string")
  checkArg(2, width, "number")
  checkArg(3, maxWidth, "number")
  local line, nl = value:match("([^\r\n]*)(\r?\n?)") -- read until newline
  if unicode.wlen(line) > width then -- do we even need to wrap?
    local partial = unicode.wtrunc(line, width)
    local wrapped = partial:match("(.*[^a-zA-Z0-9._()'`=])")
    if wrapped or unicode.wlen(line) > maxWidth then
      partial = wrapped or partial
      return partial, unicode.sub(value, unicode.len(partial) + 1), true
    else
      return "", value, true -- write in new line.
    end
  end
  local start = unicode.len(line) + unicode.len(nl) + 1
  return line, start <= unicode.len(value) and unicode.sub(value, start) or nil, unicode.len(nl) > 0
end

function text.wrappedLines(value, width, maxWidth)
  local line, nl
  return function()
    if value then
      line, value, nl = text.wrap(value, width, maxWidth)
      return line
    end
  end
end

-------------------------------------------------------------------------------

-- tokenize allows nil for delimiters, quotes, and doNotNormalize
-- always separates by whitespace
-- default quote rules: '' and ""
-- default delimiters: all
-- default is to normalize, that is, no metadata is returned, just a list of tokens
function text.tokenize(value, doNotNormalize, quotes, delimiters)
  checkArg(1, value, "string")
  checkArg(2, doNotNormalize, "boolean", "nil")
  checkArg(3, quotes, "table", "nil")
  checkArg(4, delimiters, "table", "nil")

  local tokens, reason = text.internal.tokenize(value, quotes, delimiters)

  if type(tokens) ~= "table" then
    return nil, reason
  end

  if doNotNormalize then
    return tokens
  end

  return text.internal.normalize(tokens)
end

function text.escapeMagic(txt)
  return txt:gsub('[%(%)%.%%%+%-%*%?%[%^%$]', '%%%1')
end

function text.removeEscapes(txt)
  return txt:gsub("%%([%(%)%.%%%+%-%*%?%[%^%$])","%1")
end

-------------------------------------------------------------------------------
function --[[@delayloaded-start@]] text.split(input, delimiters, dropDelims, di)
  checkArg(1, input, "string")
  checkArg(2, delimiters, "table")
  checkArg(3, dropDelims, "boolean", "nil")
  checkArg(4, di, "number", "nil")

  if #input == 0 then return {} end
  di = di or 1
  local result = {input}
  if di > #delimiters then return result end

  local function add(part, index, r, s, e)
    local sub = part:sub(s,e)
    if #sub == 0 then return index end
    local subs = r and text.split(sub,delimiters,dropDelims,r) or {sub}
    for i=1,#subs do
      table.insert(result, index+i-1, subs[i])
    end
    return index+#subs
  end

  local i,d=1,delimiters[di]
  while true do
    local next = table.remove(result,i)
    if not next then break end
    local si,ei = next:find(d)
    if si and ei and ei~=0 then -- delim found
      i=add(next, i, di+1, 1, si-1)
      i=dropDelims and i or add(next, i, false, si, ei)
      i=add(next, i, di, ei+1)
    else
      i=add(next, i, di+1, 1, #next)
    end
  end
  
  return result
end --[[@delayloaded-end@]]

-----------------------------------------------------------------------------

function text.internal.tokenize(value, quotes, delimiters)
  checkArg(1, value, "string")
  checkArg(2, quotes, "table", "nil")
  checkArg(3, delimiters, "table", "nil")
  local custom = not not delimiters
  delimiters = delimiters or text.syntax

  local words, reason = text.internal.words(value, quotes)

  local splitter = text.escapeMagic(custom and table.concat(delimiters) or "<>|;&")
  if type(words) ~= "table" or 
    #splitter == 0 or
    not value:find("["..splitter.."]") then
    return words, reason
  end

  return text.internal.splitWords(words, delimiters)
end

-- tokenize input by quotes and whitespace
function text.internal.words(input, quotes)
  checkArg(1, input, "string")
  checkArg(2, quotes, "table", "nil")
  local qr = nil
  quotes = quotes or {{"'","'",true},{'"','"'},{'`','`'}}
  local function append(dst, txt, qr)
    local size = #dst
    if size == 0 or dst[size].qr ~= qr then
      dst[size+1] = {txt=txt, qr=qr}
    else
      dst[size].txt = dst[size].txt..txt
    end
  end
  -- token meta is {string,quote rule}
  local tokens, token = {}, {}
  local escaped, start = false, -1
  for i = 1, unicode.len(input) do
    local char = unicode.sub(input, i, i)
    if escaped then -- escaped character
      escaped = false
      -- include escape char if
      -- 1. qr active
      -- 2. the char escaped is NOT the qr closure
      -- 3. qr is not literal
      if qr and not qr[3] and qr[2] ~= char then
        append(token, '\\', qr)
      end
      append(token, char, qr)
    elseif char == "\\" and (not qr or not qr[3]) then
        escaped = true
    elseif qr and qr[2] == char then -- end of quoted string
      -- if string is empty, we can still capture a quoted empty arg
      if #token == 0 or #token[#token] == 0 then
        append(token, '', qr)
      end
      qr = nil
    elseif not qr and tx.first(quotes,function(Q)
      qr=Q[1]==char and Q or nil return qr end) then
      start = i
    elseif not qr and string.find(char, "%s") then
      if #token > 0 then
        table.insert(tokens, token)
      end
      token = {}
    else -- normal char
      append(token, char, qr)
    end
  end
  if qr then
    return nil, "unclosed quote at index " .. start
  end

  if #token > 0 then
    table.insert(tokens, token)
  end

  return tokens
end

-- splits each word into words at delimiters
-- delimiters are kept as their own words
-- quoted word parts are not split
function --[[@delayloaded-start@]] text.internal.splitWords(words, delimiters)
  checkArg(1,words,"table")
  checkArg(2,delimiters,"table")

  local split_words = {}
  local next_word
  local function add_part(part)
    if next_word then
      split_words[#split_words+1] = {}
    end
    table.insert(split_words[#split_words], part)
    next_word = false
  end
  for wi=1,#words do local word = words[wi]
    next_word = true
    for pi=1,#word do local part = word[pi]
      local qr = part.qr
      if qr then
        add_part(part)
      else
        local part_text_splits = text.split(part.txt, delimiters)
        tx.foreach(part_text_splits, function(sub_txt, spi)
          local delim = #text.split(sub_txt, delimiters, true) == 0
          next_word = next_word or delim
          add_part({txt=sub_txt,qr=qr})
          next_word = delim
        end)
      end
    end
  end

  return split_words
end --[[@delayloaded-end@]]

function --[[@delayloaded-start@]] text.internal.normalize(words, omitQuotes)
  checkArg(1, words, "table")
  checkArg(2, omitQuotes, "boolean", "nil")
  local norms = {}
  for _,word in ipairs(words) do
    local norm = {}
    for _,part in ipairs(word) do
      norm = tx.concat(norm, not omitQuotes and part.qr and {part.qr[1], part.txt, part.qr[2]} or {part.txt})
    end
    norms[#norms+1]=table.concat(norm)
  end
  return norms
end --[[@delayloaded-end@]]

return text, local_env
D
lib/tools/Flib/tools/delayLookup.lualocal data,tbl,key = ...
local z = data[tbl]

if key then -- index
  local method = z.methods[key]
  local cache = z.cache[key]
  if method and not cache then
    local file = io.open(z.path,"r")
    if file then
      file:seek("set", method[1])
      local loaded = load("return function"..file:read(method[2]), "=delayed-"..key,"t",z.env)
      file:close()
      assert(loaded,"failed to load "..key)
      cache = loaded()
      --lazy_protect(key, cache)
      z.cache[key] = cache
    end
  end
  return cache
else -- pairs
  local set,k,v = {}
  while true do
    k,v = next(tbl,k)
    if not k then break end
    set[k] = v
  end
  for k in pairs(z.methods) do
    if not set[k] then
      set[k] = function(...)return tbl[k](...)end
    end
  end
  return pairs(set)
end
Flib/tools/delayParse.luaòlocal filepath,delay_data = ...
local file, reason = io.open(filepath, "r")
if not file then
  return reason
end

local methods = {}
local delay_start_pattern = "^%s*function%s*%-%-%[%[@delayloaded%-start@%]%]%s*(.*)$"
local delay_end_pattern = "^%s*end%s*%-%-%[%[@delayloaded%-end@%]%]%s*$"
local n,buffer,lib_name,current_method,open = 0,{}

while true do
  local line = file:read("*L")
  if current_method then
    local closed = not line or line:match(delay_end_pattern)
    if closed then
      local path,method_name,args = open:match("^(.-)([^%.]+)(%(.*)$")
      current_method = current_method-#args
      methods[path] = methods[path] or {}
      methods[path][method_name] = {current_method,n+#line-current_method}
      current_method=nil
    end
  elseif line then
    open = line:match(delay_start_pattern)
    if open then
      lib_name,open = open:match("^([^%.]+)%.(.*)$")
      current_method = n+#line
    else
      buffer[#buffer+1] = line
    end
  else
    file:close()
    break
  end
  n = n + #line
end

if not next(methods) or current_method or not lib_name then
  return "no methods found or unclosed marker for delayed load"
end

buffer = table.concat(buffer)
local loader, reason = load(buffer, "="..filepath, "t", _G)
local library, local_env = loader()
if library then
  local_env = local_env or {}
  local_env[lib_name] = library

  local env = setmetatable(local_env, {__index=_G})
  
  for path,pack in pairs(methods) do
    local target = library
    for name in path:gmatch("[^%.]+") do target = target[name] end
    delay_data[target] =
    {
      methods = pack,
      cache = {},
      env = env,
      path = filepath
    }
    setmetatable(target, delay_data)
  end

  return function()return library end, filepath
end

return reason
Flib/tools/keyboard_full.luaõkeyboard.keys["1"]           = 0x02
keyboard.keys["2"]           = 0x03
keyboard.keys["3"]           = 0x04
keyboard.keys["4"]           = 0x05
keyboard.keys["5"]           = 0x06
keyboard.keys["6"]           = 0x07
keyboard.keys["7"]           = 0x08
keyboard.keys["8"]           = 0x09
keyboard.keys["9"]           = 0x0A
keyboard.keys["0"]           = 0x0B
keyboard.keys.a               = 0x1E
keyboard.keys.b               = 0x30
keyboard.keys.c               = 0x2E
keyboard.keys.d               = 0x20
keyboard.keys.e               = 0x12
keyboard.keys.f               = 0x21
keyboard.keys.g               = 0x22
keyboard.keys.h               = 0x23
keyboard.keys.i               = 0x17
keyboard.keys.j               = 0x24
keyboard.keys.k               = 0x25
keyboard.keys.l               = 0x26
keyboard.keys.m               = 0x32
keyboard.keys.n               = 0x31
keyboard.keys.o               = 0x18
keyboard.keys.p               = 0x19
keyboard.keys.q               = 0x10
keyboard.keys.r               = 0x13
keyboard.keys.s               = 0x1F
keyboard.keys.t               = 0x14
keyboard.keys.u               = 0x16
keyboard.keys.v               = 0x2F
keyboard.keys.w               = 0x11
keyboard.keys.x               = 0x2D
keyboard.keys.y               = 0x15
keyboard.keys.z               = 0x2C

keyboard.keys.apostrophe      = 0x28
keyboard.keys.at              = 0x91
keyboard.keys.back            = 0x0E -- backspace
keyboard.keys.backslash       = 0x2B
keyboard.keys.capital         = 0x3A -- capslock
keyboard.keys.colon           = 0x92
keyboard.keys.comma           = 0x33
keyboard.keys.enter           = 0x1C
keyboard.keys.equals          = 0x0D
keyboard.keys.grave           = 0x29 -- accent grave
keyboard.keys.lbracket        = 0x1A
keyboard.keys.lcontrol        = 0x1D
keyboard.keys.lmenu           = 0x38 -- left Alt
keyboard.keys.lshift          = 0x2A
keyboard.keys.minus           = 0x0C
keyboard.keys.numlock         = 0x45
keyboard.keys.pause           = 0xC5
keyboard.keys.period          = 0x34
keyboard.keys.rbracket        = 0x1B
keyboard.keys.rcontrol        = 0x9D
keyboard.keys.rmenu           = 0xB8 -- right Alt
keyboard.keys.rshift          = 0x36
keyboard.keys.scroll          = 0x46 -- Scroll Lock
keyboard.keys.semicolon       = 0x27
keyboard.keys.slash           = 0x35 -- / on main keyboard
keyboard.keys.space           = 0x39
keyboard.keys.stop            = 0x95
keyboard.keys.tab             = 0x0F
keyboard.keys.underline       = 0x93

-- Keypad (and numpad with numlock off)
keyboard.keys.up              = 0xC8
keyboard.keys.down            = 0xD0
keyboard.keys.left            = 0xCB
keyboard.keys.right           = 0xCD
keyboard.keys.home            = 0xC7
keyboard.keys["end"]         = 0xCF
keyboard.keys.pageUp          = 0xC9
keyboard.keys.pageDown        = 0xD1
keyboard.keys.insert          = 0xD2
keyboard.keys.delete          = 0xD3

-- Function keys
keyboard.keys.f1              = 0x3B
keyboard.keys.f2              = 0x3C
keyboard.keys.f3              = 0x3D
keyboard.keys.f4              = 0x3E
keyboard.keys.f5              = 0x3F
keyboard.keys.f6              = 0x40
keyboard.keys.f7              = 0x41
keyboard.keys.f8              = 0x42
keyboard.keys.f9              = 0x43
keyboard.keys.f10             = 0x44
keyboard.keys.f11             = 0x57
keyboard.keys.f12             = 0x58
keyboard.keys.f13             = 0x64
keyboard.keys.f14             = 0x65
keyboard.keys.f15             = 0x66
keyboard.keys.f16             = 0x67
keyboard.keys.f17             = 0x68
keyboard.keys.f18             = 0x69
keyboard.keys.f19             = 0x71

-- Japanese keyboards
keyboard.keys.kana            = 0x70
keyboard.keys.kanji           = 0x94
keyboard.keys.convert         = 0x79
keyboard.keys.noconvert       = 0x7B
keyboard.keys.yen             = 0x7D
keyboard.keys.circumflex      = 0x90
keyboard.keys.ax              = 0x96

-- Numpad
keyboard.keys.numpad0         = 0x52
keyboard.keys.numpad1         = 0x4F
keyboard.keys.numpad2         = 0x50
keyboard.keys.numpad3         = 0x51
keyboard.keys.numpad4         = 0x4B
keyboard.keys.numpad5         = 0x4C
keyboard.keys.numpad6         = 0x4D
keyboard.keys.numpad7         = 0x47
keyboard.keys.numpad8         = 0x48
keyboard.keys.numpad9         = 0x49
keyboard.keys.numpadmul       = 0x37
keyboard.keys.numpaddiv       = 0xB5
keyboard.keys.numpadsub       = 0x4A
keyboard.keys.numpadadd       = 0x4E
keyboard.keys.numpaddecimal   = 0x53
keyboard.keys.numpadcomma     = 0xB3
keyboard.keys.numpadenter     = 0x9C
keyboard.keys.numpadequals    = 0x8D

-- Create inverse mapping for name lookup.
setmetatable(keyboard.keys,
{
  __index = function(tbl, k)
    if type(k) ~= "number" then return end
    for name,value in pairs(keyboard.keys) do
      if value == k then
        return name
      end
    end
  end
})
Flib/transforms.lua]local lib={}
lib.internal={}
function lib.internal.range_adjust(f,l,s)
  checkArg(1,f,'number','nil')
  checkArg(2,l,'number','nil')
  checkArg(3,s,'number')
  if f==nil then f=1 elseif f<0 then f=s+f+1 end
  if l==nil then l=s elseif l<0 then l=s+l+1 end
  return f,l
end
function lib.internal.table_view(tbl,f,l)
  return setmetatable({},
  {
    __index=function(b,k)return(type(k)~='number'or(k>=f and k<=l))and tbl[k]or nil end,
    __len=function(b)return#tbl end,
  })
end
local adjust=lib.internal.range_adjust
local view=lib.internal.table_view

-- works like string.sub but on elements of an indexed table
function lib.sub(tbl,f,l)
  checkArg(1,tbl,'table')
  local r,s={},#tbl
  f,l=adjust(f,l,s)
  l=math.min(l,s)
  for i=math.max(f,1),l do
    r[#r+1]=tbl[i]
  end
  return r
end

-- first(p1,p2) searches for the first range in p1 that satisfies p2
function lib.first(tbl,pred,f,l)
  checkArg(1,tbl,'table')
  checkArg(2,pred,'function','table')
  if type(pred)=='table'then
    local set;set,pred=pred,function(e,fi,tbl)
      for vi=1,#set do
        local v=set[vi]
        if lib.begins(tbl,v,fi) then return true,#v end
      end
    end
  end
  local s=#tbl
  f,l=adjust(f,l,s)
  tbl=view(tbl,f,l)
  for i=f,l do
    local si,ei=pred(tbl[i],i,tbl)
    if si then
      return i,i+(ei or 1)-1
    end
  end
end

-- if value was made by lib.sub then find can find from whence
function --[[@delayloaded-start@]] lib.find(tbl,v,f,l)
  checkArg(1,tbl,'table')
  checkArg(2,v,'table')
  local s=#v
  return lib.first(tbl,function(e,i,tbl)
    for n=0,s-1 do
      if tbl[n+i]~=v[n+1] then return nil end
    end
    return 1,s
  end,f,l)
end --[[@delayloaded-end@]] 

-- Returns a list of subsets of tbl where partitioner acts as a delimiter.
function --[[@delayloaded-start@]] lib.partition(tbl,partitioner,dropEnds,f,l)
  checkArg(1,tbl,'table')
  checkArg(2,partitioner,'function','table')
  checkArg(3,dropEnds,'boolean','nil')
  if type(partitioner)=='table'then
    return lib.partition(tbl,function(e,i,tbl)
      return lib.first(tbl,partitioner,i)
    end,dropEnds,f,l)
  end
  local s=#tbl
  f,l=adjust(f,l,s)
  local cut=view(tbl,f,l)
  local result={}
  local need=true
  local exp=function()if need then result[#result+1]={}need=false end end
  local i=f
  while i<=l do
    local e=cut[i]
    local ds,de=partitioner(e,i,cut)
    -- true==partition here
    if ds==true then ds,de=i,i
    elseif ds==false then ds,de=nil,nil end
    if ds~=nil then
      ds,de=adjust(ds,de,l)
      ds=ds>=i and ds--no more
    end
    if not ds then -- false or nil
      exp()
      table.insert(result[#result],e)
    else
      local sub=lib.sub(cut,i,not dropEnds and de or (ds-1))
      if #sub>0 then
        exp()
        result[#result+math.min(#result[#result],1)]=sub
      end
      -- ensure i moves forward
      local ensured=math.max(math.max(de or ds,ds),i)
      if de and ds and de<ds and ensured==i then
        if #result==0 then result[1]={} end
        table.insert(result[#result],e)
      end
      i=ensured
      need=true
    end
    i=i+1
  end

  return result
end --[[@delayloaded-end@]] 

-- returns true if p1 at first p3 equals element for element p2
function lib.begins(tbl,v,f,l)
  checkArg(1,tbl,'table')
  checkArg(2,v,'table')
  local vs=#v
  f,l=adjust(f,l,#tbl)
  if vs>(l-f+1)then return end
  for i=1,vs do
    if tbl[f+i-1]~=v[i] then return end
  end
  return true
end

-- calls callback(e,i,tbl) for each ith element e in table tbl from first
function lib.foreach(tbl,c,f,l)
  checkArg(1,tbl,'table')
  checkArg(2,c,'function','string')
  local ck=c
  c=type(c)=="string" and function(e) return e[ck] end or c
  local s=#tbl
  f,l=adjust(f,l,s)
  tbl=view(tbl,f,l)
  local r={}
  for i=f,l do
    local n,k=c(tbl[i],i,tbl)
    if n~=nil then
      if k then r[k]=n
      else r[#r+1]=n end
    end
  end
  return r
end
lib.select=lib.foreach
function  --[[@delayloaded-start@]] lib.where(tbl,p,f,l)
  return lib.foreach(tbl,
    function(e,i,tbl)
      return p(e,i,tbl)and e or nil
    end,f,l)
end --[[@delayloaded-end@]] 
function lib.concat(...)
  local r,rn,k={},0
  for _,tbl in ipairs({...})do
    if type(tbl)~='table'then
      return nil,'parameter '..tostring(_)..' to concat is not a table'
    end
    local n=tbl.n or #tbl
    k=k or tbl.n
    for i=1,n do
      rn=rn+1;r[rn]=tbl[i]
    end
  end
  r.n=k and rn or nil
  return r
end

return lib,{adjust=adjust,view=view}
Flib/vector.lua
local vectorLibrary = {}

------------------------------------------------------------------------------------------------------------------------

function vectorLibrary.newVector2(x, y)
	-- checkArg(1, x, "number")
	-- checkArg(2, y, "number")
	return { x, y }
end

function vectorLibrary.newVector3(x, y, z)
	-- checkArg(1, x, "number")
	-- checkArg(2, y, "number")
	-- checkArg(3, z, "number")
	return { x, y, z }
end

function vectorLibrary.newVector4(x, y, z, w)
	-- checkArg(1, x, "number")
	-- checkArg(2, y, "number")
	-- checkArg(3, z, "number")
	-- checkArg(4, w, "number")
	return { x, y, z, w }
end

------------------------------------------------------------------------------------------------------------------------

return vectorLibrary

Flib/windows.lua0ö
----------------------------------------- Libraries -----------------------------------------

-- _G.GUI, package.loaded.GUI = nil, nil

local computer = require("computer")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local unicode = require("unicode")
local event = require("event")

----------------------------------------- Main variables -----------------------------------------

local windows = {}

windows.alignment = GUI.alignment

windows.colors = {
	background = 0xEEEEEE,
	title = {
		background = 0xDDDDDD,
		text = 0x262626,
	},
	tabBar = {
		background = 0xDDDDDD,
		text = 0x262626,
		selectedTab = {
			background = 0xCCCCCC,
			text = 0x262626,
		}
	},
}

----------------------------------------- Universal window event handlers -----------------------------------------

local function executeObjectMethod(method, ...)
	if method then method(...) end
end

local function buttonHandler(window, object, objectIndex, eventData)
	if object.switchMode then
		object.pressed = not object.pressed
		window:draw()
		buffer.draw()
		executeObjectMethod(object.onTouch, eventData)
	else
		object.pressed = true
		window:draw()
		buffer.draw()
		os.sleep(0.2)
		object.pressed = false
		window:draw()
		buffer.draw()
		executeObjectMethod(object.onTouch, eventData)
	end
end

local function tabBarTabHandler(window, object, objectIndex, eventData)
	object.parent.parent.selectedTab = objectIndex
	window:draw()
	buffer.draw()
	executeObjectMethod(object.parent.parent.onTabSwitched, eventData)
end

local function inputTextBoxHandler(window, object, objectIndex, eventData)
	object:input()
	window:draw()
	buffer.draw()
	executeObjectMethod(object.onInputFinished, eventData)
end

local function textBoxScrollHandler(window, object, objectIndex, eventData)
	if eventData[5] == 1 then
		object:scrollUp()
		window:draw()
		buffer.draw()
	else
		object:scrollDown()
		window:draw()
		buffer.draw()
	end
end

local function horizontalSliderHandler(window, object, objectIndex, eventData)
	local clickPosition = eventData[3] - object.x + 1
	object.value = object.minimumValue + (clickPosition * (object.maximumValue - object.minimumValue) / object.width)
	window:draw()
	buffer.draw()
	executeObjectMethod(object.onValueChanged, eventData)
end

local function switchHandler(window, object, objectIndex, eventData)
	object.state = not object.state
	window:draw()
	buffer.draw()
	executeObjectMethod(object.onStateChanged, eventData)
end

local function comboBoxHandler(window, object, objectIndex, eventData)
	object:selectItem()
	executeObjectMethod(object.onItemSelected, eventData)
end

local function menuItemHandler(window, object, objectIndex, eventData)
	object.pressed = true
	window:draw()
	buffer.draw()
	executeObjectMethod(object.onTouch, eventData)
	object.pressed = false
	window:draw()
	buffer.draw()
end

local function scrollBarHandler(window, object, objectIndex, eventData)
	local newValue = object.value

	if eventData[1] == "touch" or eventData[1] == "drag" then
		local delta = object.maximumValue - object.minimumValue + 1
		if object.height > object.width then
			newValue = math.floor((eventData[4] - object.y + 1) / object.height * delta)
		else
			newValue = math.floor((eventData[3] - object.x + 1) / object.width * delta)
		end
	elseif eventData[1] == "scroll" then
		if eventData[5] == 1 then
			if object.value >= object.minimumValue + object.onScrollValueIncrement then
				newValue = object.value - object.onScrollValueIncrement
			else
				newValue = object.minimumValue
			end
		else
			if object.value <= object.maximumValue - object.onScrollValueIncrement then
				newValue = object.value + object.onScrollValueIncrement
			else
				newValue = object.maximumValue
			end
		end
	end
	window:draw()
	buffer.draw()
	object.value = newValue
	executeObjectMethod(object.onTouch, eventData)
end

local function treeViewHandler(window, object, objectIndex, eventData)
	if eventData[1] == "touch" then
		local fileIndex = eventData[4] - object.y + object.fromFile - 1
		if object.fileList[fileIndex] then
			if object.fileList[fileIndex].isDirectory then
				if object.directoriesToShowContent[object.fileList[fileIndex].path] then
					object.directoriesToShowContent[object.fileList[fileIndex].path] = nil
				else
					object.directoriesToShowContent[object.fileList[fileIndex].path] = true
				end
				object:updateFileList()
				object:draw(); buffer.draw()
			else
				object.currentFile = object.fileList[fileIndex].path
				object:draw(); buffer.draw()
				executeObjectMethod(object.onFileSelected, object.currentFile)
			end
		end
	elseif eventData[1] == "scroll" then
		if eventData[5] == 1 then
			if object.fromFile > 1 then
				object.fromFile = object.fromFile - 1
				object:draw(); buffer.draw()
			end
		else
			if object.fromFile < #object.fileList then
				object.fromFile = object.fromFile + 1
				object:draw(); buffer.draw()
			end
		end
	end
end

local function colorSelectorHandler(window, object, objectIndex, eventData)
	object.pressed = true; object:draw(); buffer.draw()
	object.color = require("palette").show("auto", "auto", object.color) or object.color
	object.pressed = false; object:draw(); buffer.draw()
	executeObjectMethod(object.onTouch)
end

function windows.handleEventData(window, eventData)
	if eventData[1] == "touch" then
		local object, objectIndex = window:getClickedObject(eventData[3], eventData[4])
		
		if object then
			if object.type == GUI.objectTypes.button then
				buttonHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.tabBarTab then
				tabBarTabHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.inputTextBox then
				inputTextBoxHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.horizontalSlider then
				horizontalSliderHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.switch then
				switchHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.comboBox then
				comboBoxHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.menuItem then
				menuItemHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.scrollBar then
				scrollBarHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.treeView then
				treeViewHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.colorSelector then
				colorSelectorHandler(window, object, objectIndex, eventData)
			elseif object.onTouch then
				executeObjectMethod(object.onTouch, eventData)
			end
		else
			executeObjectMethod(window.onTouch, eventData)
		end
	elseif eventData[1] == "scroll" then
		local object, objectIndex = window:getClickedObject(eventData[3], eventData[4])
		
		if object then
			if object.type == GUI.objectTypes.textBox then
				textBoxScrollHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.scrollBar then
				scrollBarHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.treeView then
				treeViewHandler(window, object, objectIndex, eventData)
			elseif object.onScroll then
				executeObjectMethod(object.onScroll, eventData)
			end
		else
			executeObjectMethod(window.onScroll, eventData)
		end
	elseif eventData[1] == "drag" then
		local object, objectIndex = window:getClickedObject(eventData[3], eventData[4])
		if object then
			if object.type == GUI.objectTypes.horizontalSlider then
				horizontalSliderHandler(window, object, objectIndex, eventData)
			elseif object.type == GUI.objectTypes.scrollBar then
				scrollBarHandler(window, object, objectIndex, eventData)
			elseif object.onDrag then
				executeObjectMethod(object.onDrag, eventData)
			end
		else
			executeObjectMethod(window.onDrag, eventData)
		end
	elseif eventData[1] == "drop" then
		local object, objectIndex = window:getClickedObject(eventData[3], eventData[4])
		if object then
			if object.onDrag then
				executeObjectMethod(object.onDrop, eventData)
			end
		else
			executeObjectMethod(window.onDrop, eventData)
		end
	elseif eventData[1] == "key_down" then
		executeObjectMethod(window.onKeyDown, eventData)
	elseif eventData[1] == "key_up" then
		executeObjectMethod(window.onKeyUp, eventData)
	end

	executeObjectMethod(window.onAnyEvent, eventData)
end

function windows.handleEvents(window, pullTime)
	while true do
		window:handleEventData({event.pull(pullTime)})
		if window.dataToReturn then
			local data = window.dataToReturn
			window = nil
			return table.unpack(data)
		end
	end
end

----------------------------------------- Window actions -----------------------------------------

function windows.returnData(window, ...)
	window.dataToReturn = {...}
	computer.pushSignal("windowAction")
end

function windows.close(window)
	windows.returnData(window, nil)
end

----------------------------------------- Window creation -----------------------------------------

function windows.correctWindowCoordinates(x, y, width, height, minimumWidth, minimumHeight)
	width = minimumWidth and math.max(width, minimumWidth) or width
	height = minimumHeight and math.max(height, minimumHeight) or height
	x = (x == "auto" and math.floor(buffer.screen.width / 2 - width / 2)) or x
	y = (y == "auto" and math.floor(buffer.screen.height / 2 - height / 2)) or y

	return x, y, width, height
end

local function drawWindow(window)
	if window.onDrawStarted then window.onDrawStarted() end
	window:drawMethodOutOfWindowsLibrary()
	if window.drawShadow then GUI.windowShadow(window.x, window.y, window.width, window.height, 50) end
	if window.onDrawFinished then window.onDrawFinished() end
end

local function newWindow(x, y, width, height, minimumWidth, minimumHeight)
	x, y, width, height = windows.correctWindowCoordinates(x, y, width, height, minimumWidth, minimumHeight)

	local window = GUI.container(x, y, width, height)
	window.minimumWidth = minimumWidth
	window.minimumHeight = minimumHeight
	window.drawShadow = false
	window.drawMethodOutOfWindowsLibrary = window.draw
	window.draw = drawWindow
	window.handleEventData = windows.handleEventData
	window.handleEvents = windows.handleEvents
	window.close = windows.close
	window.returnData = windows.returnData

	return window
end

----------------------------------------- Window patterns -----------------------------------------

function windows.empty(x, y, width, height, minimumWidth, minimumHeight)
	return newWindow(x, y, width, height, minimumWidth, minimumHeight)
end

function windows.fullScreen()
	return newWindow(1, 1, buffer.screen.width, buffer.screen.height)
end

function windows.tabbed(x, y, width, height, minimumWidth, minimumHeight, ...)
	local tabs = {...}
	local window = newWindow(x, y, width, height, minimumWidth, minimumHeight)
	window:addPanel(1, 1, window.width, window.height, 0xEEEEEE).disabled = true
	window:addTabBar(1, 1, window.width, 3, 1, 0xDDDDDD, 0x262626, 0xCCCCCC, 0x262626, ...)
	window:addWindowActionButtons(2, 1, false)
	
	return window
end

----------------------------------------- Playground -----------------------------------------

-- buffer.start()
-- buffer.clear(0xFF8888)
-- buffer.draw(true)

-- local myWindow = windows.empty(2, 2, 60, 30, 60, 30)
-- myWindow:addColorSelector(2, 2, 30, 3, 0xFF00FF, "Text")
-- myWindow:draw()
-- buffer.draw()
-- myWindow:handleEvents()

-- local myWindow = windows.empty(2, 2, 20, 40, 20, 40)
-- myWindow:addTreeView(1, 1, myWindow.width, myWindow.height, 0xDDDDDD, 0x2D2D2D, 0x2D2D2D, 0xEEEEEE, 0x555555, 0x444444, 0x00DBFF, "/")
-- myWindow:draw()
-- buffer.draw()
-- myWindow:handleEvents()


-- local myWindow = windows.empty(2, 2, 60, 20, 60, 20)
-- local scrollBar = myWindow:addScrollBar(1, 1, 20, 1, 0x444444, 0x00DBFF, 1, 100, 50, 20, 4, true)
-- scrollBar.onTouch = function()
-- 	buffer.text(4, 1, 0xFFFFFF, "Value: " .. scrollBar.value)
-- end
-- myWindow:draw()
-- buffer.draw()
-- myWindow:handleEvents()

----------------------------------------- End of shit -----------------------------------------

return windows
Flib/xmlParser.luaH
local xml = {}

------------------------------------------------------------------------------------------------------------

function xml.parseargs(s)
  local arg = {}
  string.gsub(s, "([%-%w]+)=([\"'])(.-)%2", function (w, _, a)
    arg[w] = a
  end)
  return arg
end
    
function xml.collect(s)
  local stack = {}
  local top = {}
  table.insert(stack, top)
  local ni,c,label,xarg, empty
  local i, j = 1, 1
  while true do
    ni,j,c,label,xarg, empty = string.find(s, "<(%/?)([%w:]+)(.-)(%/?)>", i)
    if not ni then break end
    local text = string.sub(s, i, ni-1)
    if not string.find(text, "^%s*$") then
      table.insert(top, text)
    end
    if empty == "/" then  -- empty element tag
      table.insert(top, {label=label, xarg=xml.parseargs(xarg), empty=1})
    elseif c == "" then   -- start tag
      top = {label=label, xarg=xml.parseargs(xarg)}
      table.insert(stack, top)   -- new level
    else  -- end tag
      local toclose = table.remove(stack)  -- remove top
      top = stack[#stack]
      if #stack < 1 then
        error("nothing to close with "..label)
      end
      if toclose.label ~= label then
        error("trying to close "..toclose.label.." with "..label)
      end
      table.insert(top, toclose)
    end
    i = j+1
  end
  local text = string.sub(s, i)
  if not string.find(text, "^%s*$") then
    table.insert(stack[#stack], text)
  end
  if #stack > 1 then
    error("unclosed "..stack[#stack].label)
  end
  return stack[1]
end

------------------------------------------------------------------------------------------------------------

return xml


Dbin/Fbin/address.luaGlocal computer = require("computer")
io.write(computer.address(),"\n")
Fbin/alias.lualocal shell = require("shell")
local args, options = shell.parse(...)

local ec, error_prefix = 0, "alias:"

if options.help then
  print(string.format("Usage: alias: [name[=value] ... ]", cmd_name))
  return
end

local function validAliasName(k)
  return k:match("[/%$`=|&;%(%)<> \t]") == nil
end

local function setAlias(k, v)
  if not validAliasName(k) then
    io.stderr:write(string.format("%s `%s': invalid alias name\n", error_prefix, k))
  else
    shell.setAlias(k, v)
  end
end

local function printAlias(k)
  local v = shell.getAlias(k)
  if not v then
    io.stderr:write(string.format("%s %s: not found\n", error_prefix, k))
    ec = 1
  else
    io.write(string.format("alias %s='%s'\n", k, v))
  end
end

local function splitPair(arg)
  local matchBegin, matchEnd = arg:find("=")
  if matchBegin == nil or matchBegin == 1 then
    return arg
  else
    return arg:sub(1, matchBegin - 1), arg:sub(matchEnd + 1)
  end
end

local function handlePair(k, v)
  if v then
    return setAlias(k, v)
  else
    return printAlias(k)
  end
end

if not next(args) then -- no args
  -- print all aliases
  for k,v in shell.aliases() do
    print(string.format("alias %s='%s'", k, v))
  end
else
  for k,v in pairs(args) do
    checkArg(1,v,"string")
    handlePair(splitPair(v))
  end
end

return ec
Fbin/cat.lua:local shell = require("shell")
local fs = require("filesystem")

local args = shell.parse(...)
local ec = 0
if #args == 0 then
  repeat
    local read = io.read("*L")
    if read then
      io.write(read)
    end
  until not read
else
  for i = 1, #args do
    local arg = args[i]
    if fs.isDirectory(arg) then
      io.stderr:write(string.format('cat %s: Is a directory\n', arg))
      ec = 1
    else
      local file, reason = args[i] == "-" and io.stdin or io.open(shell.resolve(args[i]))
      if not file then
        io.stderr:write(string.format("cat: %s: %s\n",args[i],tostring(reason)))
        ec = 1
      else
        repeat
          local line = file:read("*L")
          if line then
            io.write(line)
          end
        until not line
        file:close()
      end
    end
  end
end

return ec
F
bin/cd.luaÝlocal shell = require("shell")
local fs = require("filesystem")

local args, ops = shell.parse(...)
local path = nil
local verbose = false

if ops.help then
  print(
[[Usage cd [dir]
For more options, run: man cd]])
  return
end

if #args == 0 then
  local home = os.getenv("HOME")
  if not home then
    io.stderr:write("cd: HOME not set\n")
    return 1
  end
  path = home
elseif args[1] == '-' then
  verbose = true
  local oldpwd = os.getenv("OLDPWD");
  if not oldpwd then
    io.stderr:write("cd: OLDPWD not set\n")
    return 1
  end
  path = oldpwd
else
  path = args[1]
end

local resolved = shell.resolve(path)
if not fs.exists(resolved) then
  io.stderr:write("cd: ",path,": No such file or directory\n")
  return 1
end

path = resolved
local oldpwd = shell.getWorkingDirectory()
local result, reason = shell.setWorkingDirectory(path)
if not result then
  io.stderr:write("cd: ",reason)
  return 1
else
  os.setenv("OLDPWD", oldpwd)
end
if verbose then
  os.execute("pwd")
end
Fbin/clear.luaHlocal component = require("component")
local term = require("term")
component.gpu.setBackground(_G.OSSettings.shellBackground or 0x1B1B1B)
component.gpu.setForeground(_G.OSSettings.shellBackground or 0xEEEEEE)

local width, height = component.gpu.getResolution()
component.gpu.fill(1, 1, width, height, " ")
term.setCursor(1, 1)Fbin/components.luaílocal component = require("component")
local shell = require("shell")
local text = require("text")

local args, options = shell.parse(...)
local count = tonumber(options.limit) or math.huge

local components = {}
local padTo = 1

if #args == 0 then -- get all components if no filters given.
  args[1] = ""
end
for _, filter in ipairs(args) do
  for address, name in component.list(filter) do
    if name:len() > padTo then
      padTo = name:len() + 2
    end
    components[address] = name
  end
end

padTo = padTo + 8 - padTo % 8
for address, name in pairs(components) do
  io.write(text.padRight(name, padTo) .. address .. '\n')

  if options.l then
    local proxy = component.proxy(address)
    local padTo = 1
    local methods = {}
    for name, member in pairs(proxy) do
      if type(member) == "table" or type(member) == "function" then
        if name:len() > padTo then
          padTo = name:len() + 2
        end
        table.insert(methods, name)
      end
    end
    table.sort(methods)
    padTo = padTo + 8 - padTo % 8

    for _, name in ipairs(methods) do
      local doc = tostring(proxy[name])
      io.write("  " .. text.padRight(name, padTo) .. doc .. '\n')
    end
  end

  count = count - 1
  if count <= 0 then
    break
  end
end
F
bin/cp.lua¡local fs = require("filesystem")
local shell = require("shell")

local args, options = shell.parse(...)
if #args < 2 then
  io.write("Usage: cp [-inrv] <from...> <to>\n")
  io.write(" -i: prompt before overwrite (overrides -n option).\n")
  io.write(" -n: do not overwrite an existing file.\n")
  io.write(" -r: copy directories recursively.\n")
  io.write(" -u: copy only when the SOURCE file differs from the destination\n")
  io.write("     file or when the destination file is missing.\n")
  io.write(" -P: preserve attributes, e.g. symbolic links.\n")
  io.write(" -v: verbose output.\n")
  io.write(" -x: stay on original source file system.\n")
  return 1
end

options.P = options.P or options.r

local from = {}
for i = 1, #args - 1 do
  table.insert(from, shell.resolve(args[i]))
end
local to = shell.resolve(args[#args])

local function status(from, to)
  if options.v then
    io.write(from .. " -> " .. to .. "\n")
  end
  os.sleep(0) -- allow interrupting
end

local result, reason

local function prompt(message)
  io.write(message .. " [Y/n] ")
  local result = io.read()
  return result and (result == "" or result:sub(1, 1):lower() == "y")
end

local function areEqual(path1, path2)
  local f1 = io.open(path1, "rb")
  if not f1 then
    return nil, "could not open `" .. path1 .. "' for update test"
  end
  local f2 = io.open(path2, "rb")
  if not f2 then
    f1:close()
    return nil, "could not open `" .. path2 .. "' for update test"
  end
  local result = true
  local chunkSize = 4 * 1024
  repeat
    local s1, s2 = f1:read(chunkSize), f2:read(chunkSize)
    if s1 ~= s2 then
      result = false
      break
    end
  until not s1 or not s2
  f1:close()
  f2:close()
  return result
end

local mounts = {}
for dev,path in fs.mounts() do
  mounts[fs.canonical(path)] = dev
end

local function recurse(fromPath, toPath, origin)
  status(fromPath, toPath)
  local isLink, target = fs.isLink(fromPath)
  if isLink and options.P then
    return fs.link(target, toPath)
  end
  if fs.isDirectory(fromPath) then
    if not options.r then
      io.write("omitting directory `" .. fromPath .. "'\n")
      return true
    end
    if fs.exists(toPath) and not fs.isDirectory(toPath) then
      -- my real cp always does this, even with -f, -n or -i.
      return nil, "cannot overwrite non-directory `" .. toPath .. "' with directory `" .. fromPath .. "'"
    end
    if options.x and origin and mounts[fs.canonical(fromPath)] then
      return true
    end
    if fs.get(fromPath) == fs.get(toPath) and fs.canonical(fs.path(toPath)):find(fs.canonical(fromPath),1,true)  then
      return nil, "cannot copy a directory, `" .. fromPath .. "', into itself, `" .. toPath .. "'"
    end
    fs.makeDirectory(toPath)
    for file in fs.list(fromPath) do
      local result, reason = recurse(fs.concat(fromPath, file), fs.concat(toPath, file), origin or fs.get(fromPath))
      if not result then
        return nil, reason
      end
    end
    return true
  else
    if fs.exists(toPath) then
      if fs.canonical(fromPath) == fs.canonical(toPath) then
        return nil, "`" .. fromPath .. "' and `" .. toPath .. "' are the same file"
      end
      if fs.isDirectory(toPath) then
        if options.i then
          if not prompt("overwrite `" .. toPath .. "'?") then
            return true
          end
        elseif options.n then
          return true
        else -- yes, even for -f
          return nil, "cannot overwrite directory `" .. toPath .. "' with non-directory"
        end
      else
        if options.u then
          if areEqual(fromPath, toPath) then
            return true
          end
        end
        if options.i then
          if not prompt("overwrite `" .. toPath .. "'?") then
            return true
          end
        elseif options.n then
          return true
        end
        -- else: default to overwriting
      end
      fs.remove(toPath)
    end
    return fs.copy(fromPath, toPath)
  end
end
for _, fromPath in ipairs(from) do
  local toPath = to
  if fs.isDirectory(toPath) then
    toPath = fs.concat(toPath, fs.name(fromPath))
  end
  result, reason = recurse(fromPath, toPath)
  if not result then
    if reason then
      io.stderr:write(reason..'\n')
    end
    return 1
  end
end
Fbin/date.lua"io.write(os.date("%F %T").."\n")
F
bin/df.luaïlocal fs = require("filesystem")
local shell = require("shell")
local text = require("text")

local args, options = shell.parse(...)

local function formatSize(size)
  if not options.h then
    return tostring(size)
  elseif type(size) == "string" then
    return size
  end
  local sizes = {"", "K", "M", "G"}
  local unit = 1
  local power = options.si and 1000 or 1024
  while size > power and unit < #sizes do
    unit = unit + 1
    size = size / power
  end
  return math.floor(size * 10) / 10 .. sizes[unit]
end

local mounts = {}
if #args == 0 then
  for proxy, path in fs.mounts() do
    mounts[path] = proxy
  end
else
  for i = 1, #args do
    local proxy, path = fs.get(args[i])
    if not proxy then
      io.stderr:write(args[i], ": no such file or directory\n")
    else
      mounts[path] = proxy
    end
  end
end

local result = {{"Filesystem", "Used", "Available", "Use%", "Mounted on"}}
for path, proxy in pairs(mounts) do
  local label = proxy.getLabel() or proxy.address
  local used, total = proxy.spaceUsed(), proxy.spaceTotal()
  local available, percent
  if total == math.huge then
    used = used or "N/A"
    available = "unlimited"
    percent = "0%"
  else
    available = total - used
    percent = used / total
    if percent ~= percent then -- NaN
      available = "N/A"
      percent = "N/A"
    else
      percent = math.ceil(percent * 100) .. "%"
    end
  end
  table.insert(result, {label, formatSize(used), formatSize(available), tostring(percent), path})
end

local m = {}
for _, row in ipairs(result) do
  for col, value in ipairs(row) do
    m[col] = math.max(m[col] or 1, value:len())
  end
end

for _, row in ipairs(result) do
  for col, value in ipairs(row) do
    io.write(text.padRight(value, m[col] + 2))
  end
  print()
end
Fbin/dmesg.luaLlocal event = require "event"
local term = require "term"

local args = {...}
local gpu = term.gpu()
local interactive = io.output().tty
local color, isPal, evt
if interactive then
  color, isPal = gpu.getForeground()
end
io.write("Press 'Ctrl-C' to exit\n")
pcall(function()
  repeat
    if #args > 0 then
      evt = table.pack(event.pullMultiple("interrupted", table.unpack(args)))
    else
      evt = table.pack(event.pull())
    end
    if interactive then gpu.setForeground(0xCC2200) end
    io.write("[" .. os.date("%T") .. "] ")
    if interactive then gpu.setForeground(0x44CC00) end
    io.write(tostring(evt[1]) .. string.rep(" ", math.max(10 - #tostring(evt[1]), 0) + 1))
    if interactive then gpu.setForeground(0xB0B00F) end
    io.write(tostring(evt[2]) .. string.rep(" ", 37 - #tostring(evt[2])))
    if interactive then gpu.setForeground(0xFFFFFF) end
    if evt.n > 2 then
      for i = 3, evt.n do
        io.write("  " .. tostring(evt[i]))
      end
    end
    
    io.write("\n")
  until evt[1] == "interrupted"
end)
if interactive then
  gpu.setForeground(color, isPal)
end

F
bin/du.lua[local shell = require("shell")
local fs = require("filesystem")

local args, options, reason = shell.parse(...)
if #args == 0 then
  args[1] = '.'
end

local TRY=[[
Try 'du --help' for more information.]]

local VERSION=[[
du (OpenOS bin) 1.0
Written by payonel, patterned after GNU coreutils du]]

local HELP=[[
Usage: du [OPTION]... [FILE]...
Summarize disk usage of each FILE, recursively for directories.

  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)
  -s, --summarize       display only a total for each argument
      --help     display this help and exit
      --version  output version information and exit]]

if options.help then
  print(HELP)
  return true
end

if options.version then
  print(VERSION)
  return true
end

local function addTrailingSlash(path)
  if path:sub(-1) ~= '/' then
    return path .. '/'
  else
    return path
  end
end

local function opCheck(shortName, longName)
  local enabled = options[shortName] or options[longName]
  options[shortName] = nil
  options[longName] = nil
  return enabled
end

local bHuman = opCheck('h', 'human-readable')
local bSummary = opCheck('s', 'summarize')

if next(options) then
  for op,v in pairs(options) do
    io.stderr:write(string.format("du: invalid option -- '%s'\n", op))
  end
  io.stderr:write(TRY..'\n')
  return 1
end

local function formatSize(size)
  if not bHuman then
      return tostring(size)
  end
  local sizes = {"", "K", "M", "G"}
  local unit = 1
  local power = options.si and 1000 or 1024
  while size > power and unit < #sizes do
    unit = unit + 1
    size = size / power
  end
    
  return math.floor(size * 10) / 10 .. sizes[unit]
end

local function printSize(size, rpath)
  local displaySize = formatSize(size)
  io.write(string.format("%s%s\n", string.format("%-12s", displaySize), rpath))
end

local function visitor(rpath)
  local subtotal = 0
  local dirs = 0
  local spath = shell.resolve(rpath)

  if fs.isDirectory(spath) then
    local list_result = fs.list(spath)
    for list_item in list_result do
      local vtotal, vdirs = visitor(addTrailingSlash(rpath) .. list_item)
      subtotal = subtotal + vtotal
      dirs = dirs + vdirs
    end
        
    if dirs == 0 then -- no child dirs
      if not bSummary then
        printSize(subtotal, rpath)
      end
    end

  elseif not fs.isLink(spath) then
    subtotal = fs.size(spath)
  end

  return subtotal, dirs
end

for i,arg in ipairs(args) do
  local path = shell.resolve(arg)

  if not fs.exists(path) then
    io.stderr:write(string.format("du: cannot access '%s': no such file or directory\n", arg))
    return 1
  else
    if fs.isDirectory(path) then
      local total = visitor(arg)
                
      if bSummary then
        printSize(total, arg)
      end
    elseif fs.isLink(path) then
      printSize(0, arg)
    else
      printSize(fs.size(path), arg)
    end
  end
end

return true
Fbin/echo.lua5local args, options = require("shell").parse(...)
if options.help then
  print([[`echo` writes the provided string(s) to the standard output.
  -n      do not output the trialing newline
  --help  display this help and exit]])
  return
end
io.write(table.concat(args," "))
if not options.n then
  print()
end
Fbin/edit.luaF²local event = require("event")
local fs = require("filesystem")
local keyboard = require("keyboard")
local shell = require("shell")
local term = require("term")
local text = require("text")
local unicode = require("unicode")

if not term.isAvailable() then
  return
end
local gpu = term.gpu()
local args, options = shell.parse(...)
if #args == 0 then
  io.write("Usage: edit <filename>")
  return
end

local filename = shell.resolve(args[1])

local readonly = options.r or fs.get(filename) == nil or fs.get(filename).isReadOnly()

if not fs.exists(filename) then
  if fs.isDirectory(filename) then
    io.stderr:write("file is a directory\n")
    return 1
  elseif readonly then
    io.stderr:write("file system is read only\n")
    return 1
  end
end

local function loadConfig()
  -- Try to load user settings.
  local env = {}
  local config = loadfile("/etc/edit.cfg", nil, env)
  if config then
    pcall(config)
  end
  -- Fill in defaults.
  env.keybinds = env.keybinds or {
    left = {{"left"}},
    right = {{"right"}},
    up = {{"up"}},
    down = {{"down"}},
    home = {{"home"}},
    eol = {{"end"}},
    pageUp = {{"pageUp"}},
    pageDown = {{"pageDown"}},

    backspace = {{"back"}},
    delete = {{"delete"}},
    deleteLine = {{"control", "delete"}, {"shift", "delete"}},
    newline = {{"enter"}},

    save = {{"control", "s"}},
    close = {{"control", "w"}},
    find = {{"control", "f"}},
    findnext = {{"control", "g"}, {"control", "n"}, {"f3"}}
  }
  -- Generate config file if it didn't exist.
  if not config then
    local root = fs.get("/")
    if root and not root.isReadOnly() then
      fs.makeDirectory("/etc")
      local f = io.open("/etc/edit.cfg", "w")
      if f then
        local serialization = require("serialization")
        for k, v in pairs(env) do
          f:write(k.."="..tostring(serialization.serialize(v, math.huge)).."\n")
        end
        f:close()
      end
    end
  end
  return env
end

term.clear()
term.setCursorBlink(true)

local running = true
local buffer = {}
local scrollX, scrollY = 0, 0
local config = loadConfig()

local getKeyBindHandler -- forward declaration for refind()

local function helpStatusText()
  local function prettifyKeybind(label, command)
    local keybind = type(config.keybinds) == "table" and config.keybinds[command]
    if type(keybind) ~= "table" or type(keybind[1]) ~= "table" then return "" end
    local alt, control, shift, key
    for _, value in ipairs(keybind[1]) do
      if value == "alt" then alt = true
      elseif value == "control" then control = true
      elseif value == "shift" then shift = true
      else key = value end
    end
    if not key then return "" end
    return label .. ": [" ..
           (control and "Ctrl+" or "") ..
           (alt and "Alt+" or "") ..
           (shift and "Shift+" or "") ..
           unicode.upper(key) ..
           "] "
  end
  return prettifyKeybind("Save", "save") ..
         prettifyKeybind("Close", "close") ..
         prettifyKeybind("Find", "find")
end

-------------------------------------------------------------------------------

local function setStatus(value)
  local x, y, w, h = term.getGlobalArea()
  value = unicode.wlen(value) > w - 10 and unicode.wtrunc(value, w - 9) or value
  value = text.padRight(value, w - 10)
  gpu.set(x, y + h - 1, value)
end

local function getArea()
  local x, y, w, h = term.getGlobalArea()
  return x, y, w, h - 1
end

local function removePrefix(line, length)
  if length >= unicode.wlen(line) then
    return ""
  else
    local prefix = unicode.wtrunc(line, length + 1)
    local suffix = unicode.sub(line, unicode.len(prefix) + 1)
    length = length - unicode.wlen(prefix)
    if length > 0 then
      suffix = (" "):rep(unicode.charWidth(suffix) - length) .. unicode.sub(suffix, 2)
    end
    return suffix
  end
end

local function lengthToChars(line, length)
  if length > unicode.wlen(line) then
    return unicode.len(line) + 1
  else
    local prefix = unicode.wtrunc(line, length)
    return unicode.len(prefix) + 1
  end
end


local function isWideAtPosition(line, x)
  local index = lengthToChars(line, x)
  if index > unicode.len(line) then
    return false, false
  end
  local prefix = unicode.sub(line, 1, index)
  local char = unicode.sub(line, index, index)
  --isWide, isRight
  return unicode.isWide(char), unicode.wlen(prefix) == x
end

local function drawLine(x, y, w, h, lineNr)
  local yLocal = lineNr - scrollY
  if yLocal > 0 and yLocal <= h then
    local str = removePrefix(buffer[lineNr] or "", scrollX)
    str = unicode.wlen(str) > w and unicode.wtrunc(str, w + 1) or str
    str = text.padRight(str, w)
    gpu.set(x, y - 1 + lineNr - scrollY, str)
  end
end

local function getCursor()
  local cx, cy = term.getCursor()
  return cx + scrollX, cy + scrollY
end

local function line()
  local cbx, cby = getCursor()
  return buffer[cby]
end

local function getNormalizedCursor()
  local cbx, cby = getCursor()
  local wide, right = isWideAtPosition(buffer[cby], cbx)
  if wide and right then
    cbx = cbx - 1
  end
  return cbx, cby
end

local function setCursor(nbx, nby)
  local x, y, w, h = getArea()
  nby = math.max(1, math.min(#buffer, nby))

  local ncy = nby - scrollY
  if ncy > h then
    term.setCursorBlink(false)
    local sy = nby - h
    local dy = math.abs(scrollY - sy)
    scrollY = sy
    if h > dy then
      gpu.copy(x, y + dy, w, h - dy, 0, -dy)
    end
    for lineNr = nby - (math.min(dy, h) - 1), nby do
      drawLine(x, y, w, h, lineNr)
    end
  elseif ncy < 1 then
    term.setCursorBlink(false)
    local sy = nby - 1
    local dy = math.abs(scrollY - sy)
    scrollY = sy
    if h > dy then
      gpu.copy(x, y, w, h - dy, 0, dy)
    end
    for lineNr = nby, nby + (math.min(dy, h) - 1) do
      drawLine(x, y, w, h, lineNr)
    end
  end
  term.setCursor(term.getCursor(), nby - scrollY)

  nbx = math.max(1, math.min(unicode.wlen(line()) + 1, nbx))
  local wide, right = isWideAtPosition(line(), nbx)
  local ncx = nbx - scrollX
  if ncx > w or (ncx + 1 > w and wide and not right) then
    term.setCursorBlink(false)
    scrollX = nbx - w + ((wide and not right) and 1 or 0)
    for lineNr = 1 + scrollY, math.min(h + scrollY, #buffer) do
      drawLine(x, y, w, h, lineNr)
    end
  elseif ncx < 1 or (ncx - 1 < 1 and wide and right) then
    term.setCursorBlink(false)
    scrollX = nbx - 1 - ((wide and right) and 1 or 0)
    for lineNr = 1 + scrollY, math.min(h + scrollY, #buffer) do
      drawLine(x, y, w, h, lineNr)
    end
  end
  term.setCursor(nbx - scrollX, nby - scrollY)
  --update with term lib
  nbx, nby = getCursor()
  gpu.set(x + w - 10, y + h, text.padLeft(string.format("%d,%d", nby, nbx), 10))
end

local function highlight(bx, by, length, enabled)
  local x, y, w, h = getArea()
  local cx, cy = bx - scrollX, by - scrollY
  cx = math.max(1, math.min(w, cx))
  cy = math.max(1, math.min(h, cy))
  length = math.max(1, math.min(w - cx, length))

  local fg, fgp = gpu.getForeground()
  local bg, bgp = gpu.getBackground()
  if enabled then
    gpu.setForeground(bg, bgp)
    gpu.setBackground(fg, fgp)
  end
  local indexFrom = lengthToChars(buffer[by], bx)
  local value = unicode.sub(buffer[by], indexFrom)
  if unicode.wlen(value) > length then
    value = unicode.wtrunc(value, length + 1)
  end
  gpu.set(x - 1 + cx, y - 1 + cy, value)
  if enabled then
    gpu.setForeground(fg, fgp)
    gpu.setBackground(bg, bgp)
  end
end

local function home()
  local cbx, cby = getCursor()
  setCursor(1, cby)
end

local function ende()
  local cbx, cby = getCursor()
  setCursor(unicode.wlen(line()) + 1, cby)
end

local function left()
  local cbx, cby = getNormalizedCursor()
  if cbx > 1 then
    local wideTarget, rightTarget = isWideAtPosition(line(), cbx - 1)
    if wideTarget and rightTarget then
      setCursor(cbx - 2, cby)
    else
      setCursor(cbx - 1, cby)
    end
    return true -- for backspace
  elseif cby > 1 then
    setCursor(cbx, cby - 1)
    ende()
    return true -- again, for backspace
  end
end

local function right(n)
  n = n or 1
  local cbx, cby = getNormalizedCursor()
  local be = unicode.wlen(line()) + 1
  local wide, right = isWideAtPosition(line(), cbx + n)
  if wide and right then
    n = n + 1
  end
  if cbx + n <= be then
    setCursor(cbx + n, cby)
  elseif cby < #buffer then
    setCursor(1, cby + 1)
  end
end

local function up(n)
  n = n or 1
  local cbx, cby = getCursor()
  if cby > 1 then
    setCursor(cbx, cby - n)
  end
end

local function down(n)
  n = n or 1
  local cbx, cby = getCursor()
  if cby < #buffer then
    setCursor(cbx, cby + n)
  end
end

local function delete(fullRow)
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local x, y, w, h = getArea()
  local function deleteRow(row)
    local content = table.remove(buffer, row)
    local rcy = cy + (row - cby)
    if rcy <= h then
      gpu.copy(x, y + rcy, w, h - rcy, 0, -1)
      drawLine(x, y, w, h, row + (h - rcy))
    end
    return content
  end
  if fullRow then
    term.setCursorBlink(false)
    if #buffer > 1 then
      deleteRow(cby)
    else
      buffer[cby] = ""
      gpu.fill(x, y - 1 + cy, w, 1, " ")
    end
    setCursor(1, cby)
  elseif cbx <= unicode.wlen(line()) then
    term.setCursorBlink(false)
    local index = lengthToChars(line(), cbx)
    buffer[cby] = unicode.sub(line(), 1, index - 1) ..
                  unicode.sub(line(), index + 1)
    drawLine(x, y, w, h, cby)
  elseif cby < #buffer then
    term.setCursorBlink(false)
    local append = deleteRow(cby + 1)
    buffer[cby] = buffer[cby] .. append
    drawLine(x, y, w, h, cby)
  else
    return
  end
  setStatus(helpStatusText())
end

local function insert(value)
  if not value or unicode.len(value) < 1 then
    return
  end
  term.setCursorBlink(false)
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local x, y, w, h = getArea()
  local index = lengthToChars(line(), cbx)
  buffer[cby] = unicode.sub(line(), 1, index - 1) ..
                value ..
                unicode.sub(line(), index)
  drawLine(x, y, w, h, cby)
  right(unicode.wlen(value))
  setStatus(helpStatusText())
end

local function enter()
  term.setCursorBlink(false)
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local x, y, w, h = getArea()
  local index = lengthToChars(line(), cbx)
  table.insert(buffer, cby + 1, unicode.sub(buffer[cby], index))
  buffer[cby] = unicode.sub(buffer[cby], 1, index - 1)
  drawLine(x, y, w, h, cby)
  if cy < h then
    if cy < h - 1 then
      gpu.copy(x, y + cy, w, h - (cy + 1), 0, 1)
    end
    drawLine(x, y, w, h, cby + 1)
  end
  setCursor(1, cby + 1)
  setStatus(helpStatusText())
end

local findText = ""

local function find()
  local x, y, w, h = getArea()
  local cx, cy = term.getCursor()
  local cbx, cby = getCursor()
  local ibx, iby = cbx, cby
  while running do
    if unicode.len(findText) > 0 then
      local sx, sy
      for syo = 1, #buffer do -- iterate lines with wraparound
        sy = (iby + syo - 1 + #buffer - 1) % #buffer + 1
        sx = string.find(buffer[sy], findText, syo == 1 and ibx or 1, true)
        if sx and (sx >= ibx or syo > 1) then
          break
        end
      end
      if not sx then -- special case for single matches
        sy = iby
        sx = string.find(buffer[sy], findText, nil, true)
      end
      if sx then
        sx = unicode.wlen(string.sub(buffer[sy], 1, sx - 1)) + 1
        cbx, cby = sx, sy
        setCursor(cbx, cby)
        highlight(cbx, cby, unicode.wlen(findText), true)
      end
    end
    term.setCursor(7 + unicode.wlen(findText), h + 1)
    setStatus("Find: " .. findText)

    local _, address, char, code = term.pull("key_down")
    if address == term.keyboard().address then
      local handler, name = getKeyBindHandler(code)
      highlight(cbx, cby, unicode.wlen(findText), false)
      if name == "newline" then
        break
      elseif name == "close" then
        handler()
      elseif name == "backspace" then
        findText = unicode.sub(findText, 1, -2)
      elseif name == "find" or name == "findnext" then
        ibx = cbx + 1
        iby = cby
      elseif not keyboard.isControl(char) then
        findText = findText .. unicode.char(char)
      end
    end
  end
  setCursor(cbx, cby)
  setStatus(helpStatusText())
end

-------------------------------------------------------------------------------

local keyBindHandlers = {
  left = left,
  right = right,
  up = up,
  down = down,
  home = home,
  eol = ende,
  pageUp = function()
    local x, y, w, h = getArea()
    up(h - 1)
  end,
  pageDown = function()
    local x, y, w, h = getArea()
    down(h - 1)
  end,

  backspace = function()
    if not readonly and left() then
      delete()
    end
  end,
  delete = function()
    if not readonly then
      delete()
    end
  end,
  deleteLine = function()
    if not readonly then
      delete(true)
    end
  end,
  newline = function()
    if not readonly then
      enter()
    end
  end,

  save = function()
    if readonly then return end
    local new = not fs.exists(filename)
    local backup
    if not new then
      backup = filename .. "~"
      for i = 1, math.huge do
        if not fs.exists(backup) then
          break
        end
        backup = filename .. "~" .. i
      end
      fs.copy(filename, backup)
    end
    local f, reason = io.open(filename, "w")
    if f then
      local chars, firstLine = 0, true
      for _, line in ipairs(buffer) do
        if not firstLine then
          line = "\n" .. line
        end
        firstLine = false
        f:write(line)
        chars = chars + unicode.len(line)
      end
      f:close()
      local format
      if new then
        format = [["%s" [New] %dL,%dC written]]
      else
        format = [["%s" %dL,%dC written]]
      end
      setStatus(string.format(format, fs.name(filename), #buffer, chars))
    else
      setStatus(reason)
    end
    if not new then
      fs.remove(backup)
    end
  end,
  close = function()
    -- TODO ask to save if changed
    running = false
  end,
  find = function()
    findText = ""
    find()
  end,
  findnext = find
}

getKeyBindHandler = function(code)
  if type(config.keybinds) ~= "table" then return end
  -- Look for matches, prefer more 'precise' keybinds, e.g. prefer
  -- ctrl+del over del.
  local result, resultName, resultWeight = nil, nil, 0
  for command, keybinds in pairs(config.keybinds) do
    if type(keybinds) == "table" and keyBindHandlers[command] then
      for _, keybind in ipairs(keybinds) do
        if type(keybind) == "table" then
          local alt, control, shift, key
          for _, value in ipairs(keybind) do
            if value == "alt" then alt = true
            elseif value == "control" then control = true
            elseif value == "shift" then shift = true
            else key = value end
          end
          local keyboardAddress = term.keyboard().address
          if (not alt or keyboard.isAltDown(keyboardAddress)) and
             (not control or keyboard.isControlDown(keyboardAddress)) and
             (not shift or keyboard.isShiftDown(keyboardAddress)) and
             code == keyboard.keys[key] and
             #keybind > resultWeight
          then
            resultWeight = #keybind
            resultName = command
            result = keyBindHandlers[command]
          end
        end
      end
    end
  end
  return result, resultName
end

-------------------------------------------------------------------------------

local function onKeyDown(char, code)
  local handler = getKeyBindHandler(code)
  if handler then
    handler()
  elseif readonly and code == keyboard.keys.q then
    running = false
  elseif not readonly then
    if not keyboard.isControl(char) then
      insert(unicode.char(char))
    elseif unicode.char(char) == "\t" then
      insert("  ")
    end
  end
end

local function onClipboard(value)
  value = value:gsub("\r\n", "\n")
  local cbx, cby = getCursor()
  local start = 1
  local l = value:find("\n", 1, true)
  if l then
    repeat
      local line = string.sub(value, start, l - 1)
      line = text.detab(line, 2)
      insert(line)
      enter()
      start = l + 1
      l = value:find("\n", start, true)
    until not l
  end
  insert(string.sub(value, start))
end

local function onClick(x, y)
  setCursor(x + scrollX, y + scrollY)
end

local function onScroll(direction)
  local cbx, cby = getCursor()
  setCursor(cbx, cby - direction * 12)
end

-------------------------------------------------------------------------------

do
  local f = io.open(filename)
  if f then
    local x, y, w, h = getArea()
    local chars = 0
    for line in f:lines() do
      if line:sub(-1) == "\r" then
        line = line:sub(1, -2)
      end
      table.insert(buffer, line)
      chars = chars + unicode.len(line)
      if #buffer <= h then
        drawLine(x, y, w, h, #buffer)
      end
    end
    f:close()
    if #buffer == 0 then
      table.insert(buffer, "")
    end
    local format
    if readonly then
      format = [["%s" [readonly] %dL,%dC]]
    else
      format = [["%s" %dL,%dC]]
    end
    setStatus(string.format(format, fs.name(filename), #buffer, chars))
  else
    table.insert(buffer, "")
    setStatus(string.format([["%s" [New File] ]], fs.name(filename)))
  end
  setCursor(1, 1)
end

while running do
  local event, address, arg1, arg2, arg3 = term.pull()
  if address == term.keyboard().address or address == term.screen().address then
    local blink = true
    if event == "key_down" then
      onKeyDown(arg1, arg2)
    elseif event == "clipboard" and not readonly then
      onClipboard(arg1)
    elseif event == "touch" or event == "drag" then
      local x, y, w, h = getArea()
      arg1 = arg1 - x + 1
      arg2 = arg2 - y + 1
      if arg1 >= 1 and arg2 >= 1 and arg1 <= w and arg2 <= h then
        onClick(arg1, arg2)
      end
    elseif event == "scroll" then
      onScroll(arg3)
    else
      blink = false
    end
    if blink then
      term.setCursorBlink(true)
    end
  end
end

term.clear()
term.setCursorBlink(false)
Fbin/find.lualocal shell = require("shell")
local fs = require("filesystem")
local text = require("text")

local USAGE = 
[===[Usage: find [path] [--type=[dfs]] [--[i]name=EXPR]
  --path  if not specified, path is assumed to be current working directory
  --type  returns results of a given type, d:directory, f:file, and s:symlinks
  --name  specify the file name pattern. Use quote to include *. iname is 
          case insensitive
  --help  display this help and exit]===]

local args, options = shell.parse(...)

if (not args or not options) or options.help then
  print(USAGE)
  if not options.help then
    return 1
  else
    return -- nil return, meaning no error
  end
end

if #args > 1 then
  io.stderr:write(USAGE..'\n')
  return 1
end

local path = #args == 1 and args[1] or "."

local bDirs = true
local bFiles = true
local bSyms = true

local fileNamePattern = ""
local bCaseSensitive = true

if options.iname and options.name then
  io.stderr:write("find cannot define both iname and name\n")
  return 1
end

if options.type then
  bDirs = false
  bFiles = false
  bSyms = false

  if options.type == "f" then
    bFiles = true
  elseif options.type == "d" then
    bDirs = true
  elseif options.type == "s" then
    bSyms = true
  else
    io.stderr:write(string.format("find: Unknown argument to type: %s\n", options.type))
    io.stderr:write(USAGE..'\n')
    return 1
  end
end

if options.iname or options.name then
  bCaseSensitive = options.iname ~= nil
  fileNamePattern = options.iname or options.name

  if type(fileNamePattern) ~= "string" then
    io.stderr:write('find: missing argument to `name\'\n')
    return 1
  end

  if not bCaseSensitive then
    fileNamePattern = fileNamePattern:lower()
  end

  -- prefix any * with . for gnu find glob matching
  fileNamePattern = text.escapeMagic(fileNamePattern)
  fileNamePattern = fileNamePattern:gsub("%%%*", ".*")
end  

local function isValidType(spath)
  if not fs.exists(spath) then
    return false
  end
    
  if fileNamePattern:len() > 0 then
    local fileName = spath:gsub('.*/','')
        
    if fileName:len() == 0 then
      return false
    end
        
    local caseFileName = fileName
        
    if not bCaseSensitive then
      caseFileName = caseFileName:lower()
    end
        
    local s, e = caseFileName:find(fileNamePattern)
    if not s or not e then
      return false
    end
        
    if s ~= 1 or e ~= caseFileName:len() then
      return false
    end
  end

  if fs.isDirectory(spath) then
    return bDirs
  elseif fs.isLink(spath) then
    return bSyms
  else
    return bFiles
  end
end

local function visit(rpath)
  local spath = shell.resolve(rpath)

  if isValidType(spath) then
    local result = rpath:gsub('/+$','')
    print(result)
  end

  if fs.isDirectory(spath) then
    local list_result = fs.list(spath)
    for list_item in list_result do
      visit(rpath:gsub('/+$', '') .. '/' .. list_item)
    end
  end
end

visit(path)
Fbin/flash.lua	plocal component = require("component")
local shell = require("shell")
local fs = require("filesystem")

local args, options = shell.parse(...)

if #args < 1 and not options.l then
  io.write("Usage: flash [-qlr] [<bios.lua>] [label]\n")
  io.write(" q: quiet mode, don't ask questions.\n")
  io.write(" l: print current contents of installed EEPROM.\n")
  io.write(" r: save the current contents of installed EEPROM to file.\n")
  return
end

local function printRom()
  local eeprom = component.eeprom
  io.write(eeprom.get())
end

local function readRom()
  local eeprom = component.eeprom
  fileName = shell.resolve(args[1])
  if not options.q then
    if fs.exists(fileName) then
      io.write("Are you sure you want to overwrite " .. fileName .. "?\n")
      io.write("Type `y` to confirm.\n")
      repeat
        local response = io.read()
      until response and response:lower():sub(1, 1) == "y"
    end
    io.write("Reading EEPROM " .. eeprom.address .. ".\n" )
  end
  local bios = eeprom.get()
  local file = assert(io.open(fileName, "wb"))
  file:write(bios)
  file:close()
  if not options.q then
    io.write("All done!\nThe label is '" .. eeprom.getLabel() .. "'.\n")
  end
end

local function writeRom()
  local file = assert(io.open(args[1], "rb"))
  local bios = file:read("*a")
  file:close()

  if not options.q then
    io.write("Insert the EEPROM you would like to flash.\n")
    io.write("When ready to write, type `y` to confirm.\n")
    repeat
      local response = io.read()
    until response and response:lower():sub(1, 1) == "y"
    io.write("Beginning to flash EEPROM.\n")
  end

  local eeprom = component.eeprom

  if not options.q then
    io.write("Flashing EEPROM " .. eeprom.address .. ".\n")
    io.write("Please do NOT power down or restart your computer during this operation!\n")
  end

  eeprom.set(bios)

  local label = args[2]
  if not options.q and not label then
    io.write("Enter new label for this EEPROM. Leave input blank to leave the label unchanged.\n")
    label = io.read()
  end
  if label and #label > 0 then
    eeprom.setLabel(label)
    if not options.q then
      io.write("Set label to '" .. eeprom.getLabel() .. "'.\n")
    end
  end

  if not options.q then
    io.write("All done! You can remove the EEPROM and re-insert the previous one now.\n")
  end
end

if options.l then
  printRom()
elseif options.r then
  readRom()
else
  writeRom()
end
Fbin/grep.lua!Ã--[[
An adaptation of Wobbo's grep
https://raw.githubusercontent.com/OpenPrograms/Wobbo-Programs/master/grep/grep.lua
]]--

-- POSIX grep for OpenComputers
-- one difference is that this version uses Lua regex, not POSIX regex.

local fs = require("filesystem")
local shell = require("shell")
local term = require("term")

-- Process the command line arguments

local args, options = shell.parse(...)

local gpu = term.gpu()

local function printUsage(ostream, msg)
  local s = ostream or io.stdout
  if msg then
    s:write(msg,'\n')
  end
  s:write([[Usage: grep [OPTION]... PATTERN [FILE]...
Example: grep -i "hello world" menu.lua main.lua
for more information, run: man grep
]])
end

local PATTERNS = {args[1]}
local FILES = {select(2, table.unpack(args))}

local LABEL_COLOR = 0xb000b0
local LINE_NUM_COLOR = 0x00FF00
local MATCH_COLOR = 0xFF0000
local COLON_COLOR = 0x00FFFF

local function pop(...)
  local result
  for _,key in ipairs({...}) do
    result = options[key] or result
    options[key] = nil
  end
  return result
end

-- Specify the variables for the options
local plain = pop('F','fixed-strings')
      plain = not pop('e','--lua-regexp') and plain
local pattern_file = pop('file')
local match_whole_word = pop('w','word-regexp')
local match_whole_line = pop('x','line-regexp')
local ignore_case = pop('i','ignore-case')
local stdin_label = pop('label') or '(standard input)'
local stderr = pop('s','no-messages') and {write=function()end} or io.stderr
local invert_match = not not pop('v','invert-match')

-- no version output, just help
if pop('V','version','help') then
  printUsage()
  return 0
end

local max_matches = tonumber(pop('max-count')) or math.huge
local print_line_num = pop('n','line-number')
local search_recursively = pop('r','recursive')

-- Table with patterns to check for
if pattern_file then
  local pattern_file_path = shell.resolve(pattern_file)
  if not fs.exists(pattern_file_path) then
    stderr:write('grep: ',pattern_file,': file not found')
    return 2
  end
  table.insert(FILES, 1, PATTERNS[1])
  PATTERNS = {}
  for line in io.lines(pattern_file_path) do
    PATTERNS[#PATTERNS+1] = line
  end
end

if #PATTERNS == 0 then
  printUsage(stderr)
  return 2
end

if #FILES == 0 then
  FILES = search_recursively and {'.'} or {'-'}
end

if not options.h and search_recursively then
  options.H = true
end

if #FILES < 2 then
  options.h = true
end

local f_only = pop('l','files-with-matches')
local no_only = pop('L','files-without-match') and not f_only

local include_filename = pop('H','with-filename')
  include_filename = not pop('h','no-filename') or include_filename

local m_only = pop('o','only-matching')
local quiet = pop('q','quiet','silent')

local print_count = pop('c','count')
local colorize = pop('color','colour') and io.output().tty and term.isAvailable()

local noop = function(...)return ...;end
local setc = colorize and gpu.setForeground or noop
local getc = colorize and gpu.getForeground or noop

local trim = pop('t','trim')
local trim_front = trim and function(s)return s:gsub('^%s+','')end or noop
local trim_back  = trim and function(s)return s:gsub('%s+$','')end or noop

if next(options) then
  if not quiet then
    printUsage(stderr, 'unexpected option: '..next(options))
    return 2
  end
  return 0
end
-- Resolve the location of a file, without searching the path
local function resolve(file)
  if file:sub(1,1) == '/' then
    return fs.canonical(file)
  else
    if file:sub(1,2) == './' then
      file = file:sub(3, -1)
    end
    return fs.canonical(fs.concat(shell.getWorkingDirectory(), file))
  end
end

--- Builds a case insensitive patterns, code from stackoverflow
--- (questions/11401890/case-insensitive-lua-pattern-matching)
if ignore_case then
  for i=1,#PATTERNS do
    -- find an optional '%' (group 1) followed by any character (group 2)
    PATTERNS[i] = PATTERNS[i]:gsub("(%%?)(.)", function(percent, letter)
      if percent ~= "" or not letter:match("%a") then
        -- if the '%' matched, or `letter` is not a letter, return "as is"
        return percent .. letter
      else -- case-insensitive
        return string.format("[%s%s]", letter:lower(), letter:upper())
      end
    end)
  end
end

local function getAllFiles(dir, file_list)
  for node in fs.list(shell.resolve(dir)) do
    local rel_path = dir:gsub("/+$","") .. '/' .. node
    local resolved_path = shell.resolve(rel_path)
    if fs.isDirectory(resolved_path) then
      getAllFiles(rel_path, file_list)
    else
      file_list[#file_list+1] = rel_path
    end
  end
end

if search_recursively then
  local files = {}
  for i,arg in ipairs(FILES) do
    if fs.isDirectory(arg) then
      getAllFiles(arg, files)
    else
      files[#files+1]=arg
    end
  end
  FILES=files
end

-- Prepare an iterator for reading files
local function readLines()
  local curHand = nil
  local curFile = nil
  local meta = nil
  return function()
    if not curFile then
      local file = table.remove(FILES, 1)
      if not file then
        return
      end
      meta = {line_num=0,hits=0}
      if file == "-" then
        curFile = file
        meta.label = stdin_label
        curHand = io.input()
      else
        meta.label = file
        local file, reason = resolve(file)
        if fs.exists(file) then
          curHand = io.open(file, 'r')
          if not curHand then
            local msg = string.format("failed to read from %s: %s", meta.label, reason)
            stderr:write("grep: ",msg,"\n")
            return false, 2
          else
            curFile = meta.label
          end
        else
          stderr:write("grep: ",file,": file not found\n")
          return false, 2
        end
      end
    end
    meta.line = nil
    if not meta.close and curHand then
      meta.line_num = meta.line_num + 1
      meta.line = curHand:read("*l")
    end
    if not meta.line then
      curFile = nil
      if curHand then
        curHand:close()
      end
      return false, meta
    else
      return meta, curFile
    end
  end
end

local function write(part, color)
  local prev_color = color and getc()
  if color then setc(color) end
  io.write(part)
  if color then setc(prev_color) end
end
local flush=(f_only or no_only or print_count) and function(m)
  if no_only and m.hits == 0 or f_only and m.hits ~= 0 then
    write(m.label, LABEL_COLOR)
    write('\n')
  elseif print_count then
    if include_filename then
      write(m.label, LABEL_COLOR)
      write(':', COLON_COLOR)
    end
    write(m.hits)
    write('\n')
  end
end
local ec = nil
local any_hit_ec = 1
local function test(m,p)
  local empty_line = true
  local last_index, slen = 1, #m.line
  local needs_filename, needs_line_num = include_filename, print_line_num
  local hit_value = 1
  while last_index <= slen and not m.close do
    local i, j = m.line:find(p, last_index, plain)
    local word_fail, line_fail =
      match_whole_word and not (i and not (m.line:sub(i-1,i-1)..m.line:sub(j+1,j+1)):find("[%a_]")),
      match_whole_line and not (i==1 and j==slen)
    local matched = not ((m_only or last_index==1) and not i)
    if (hit_value == 1 and word_fail) or line_fail then
      matched,i,j = false
    end
    if invert_match == matched then break end
    if max_matches == 0 then os.exit(1) end
    any_hit_ec = 0
    m.hits, hit_value = m.hits + hit_value, 0
    if max_matches == m.hits or f_only or no_only then
      m.close = true
    end
    if flush or quiet then return end
    if needs_filename then
      write(m.label, LABEL_COLOR)
      write(':', COLON_COLOR)
      needs_filename = nil
    end
    if needs_line_num then
      write(m.line_num, LINE_NUM_COLOR)
      write(':', COLON_COLOR)
      needs_line_num = nil
    end
    local s=m_only and '' or m.line:sub(last_index,(i or 0)-1)
    local g=i and m.line:sub(i,j) or ''
    if i==1 then g=trim_front(g) elseif last_index==1 then s=trim_front(s) end
    if j==slen then g=trim_back(g) elseif not i then s=trim_back(s) end
    write(s)
    write(g, MATCH_COLOR)
    empty_line = false
    last_index = (j or slen)+1
    if m_only or last_index>slen then
      write("\n")
      empty_line = true
      needs_filename, needs_line_num = include_filename, print_line_num
    elseif p:find("^^") then break end
  end
  if not empty_line then write("\n") end
end
for meta,status in readLines() do
  if not meta then
    if type(status) == 'table' then if flush then
      flush(status) end -- this was the last object, closing out
    elseif status then
      ec = status or ec
    end
  else
    for _,p in ipairs(PATTERNS) do
      test(meta,p)
    end
  end
end

return ec or any_hit_ec
Fbin/head.lualocal shell = require("shell")
local fs = require("filesystem")

local args, options = shell.parse(...)

local function pop(key, convert)
  local result = options[key]
  options[key] = nil
  if result and convert then
    local c = convert(result)
    if not c then
      error('invalid ' .. key .. ': could not convert ' .. result)
    end
    result = c
  end
  return result
end

local bytes = pop('bytes', tonumber)
local lines = pop('lines', tonumber)
local quiet = {pop('q'), pop('quiet'), pop('silent')}
quiet = quiet[1] or quiet[2] or quiet[3]
local verbose = {pop('v'), pop('verbose')}
verbose = verbose[1] or verbose[2]
local help = pop('help')
local invalid_key = next(options)

if bytes and lines then
  invalid_key = 'bytes and lines both specified'
end

if help or next(options) then
  local invalid_key = next(options)
  if invalid_key then
    invalid_key = string.format('invalid option: %s\n', invalid_key)
  else
    invalid_key = ''
  end
  print(invalid_key .. [[Usage: head [--lines=n] file
Print the first 10 lines of each FILE to stdout.
For more info run: man head]])
  os.exit()
end

if #args == 0 then
  args = {'-'}
end

if quiet and verbose then
  quiet = false
end

local function new_stream()
  return
  {
    open=true,
    capacity=math.abs(lines or bytes or 10),
    bytes=bytes,
    buffer=(lines and lines < 0 and {}) or (bytes and bytes < 0 and '')
  }
end

local function close(stream)
  if stream.buffer then
    if type(stream.buffer) == 'table' then
      stream.buffer = table.concat(stream.buffer)
    end
    io.stdout:write(stream.buffer)
    stream.buffer = nil
  end
  stream.open = false
end

local function push(stream, line)
  if not line then
    return close(stream)
  end

  local cost = stream.bytes and line:len() or 1
  stream.capacity = stream.capacity - cost

  if not stream.buffer then
    if stream.bytes and stream.capacity < 0 then
      line = line:sub(1,stream.capacity-1)
    end
    io.write(line)
    if stream.capacity <= 0 then
      return close(stream)
    end
  else
    if type(stream.buffer) == 'table' then -- line storage
      stream.buffer[#stream.buffer+1] = line
      if stream.capacity < 0 then
        table.remove(stream.buffer, 1)
        stream.capacity = 0 -- zero out
      end
    else -- byte storage
      stream.buffer = stream.buffer .. line
      if stream.capacity < 0 then
        stream.buffer = stream.buffer:sub(-stream.capacity+1)
        stream.capacity = 0 -- zero out
      end
    end
  end

end

for i=1,#args do
  local arg = args[i]
  local file
  if arg == '-' then
    arg = 'standard input'
    file = setmetatable({close=function()end},{__index=io.stdin})
  else
    file, reason = io.open(arg, 'r')
    if not file then
      io.stderr:write(string.format([[head: cannot open '%s' for reading: %s]], arg, reason))
    end
  end
  if file then
    if verbose or #args > 1 then
      io.write(string.format('==> %s <==', arg))
    end

    local stream = new_stream()

    while stream.open do
      push(stream, file:read('*L'))
    end

    file:close()
  end
end
Fbin/hostname.lua×local args = {...}
if args[1] then
  local file, reason = io.open("/etc/hostname", "w")
  if not file then
    io.stderr:write(reason .. "\n")
    return 1
  else
    file:write(args[1])
    file:close()
    os.setenv("HOSTNAME", args[1])
    os.setenv("PS1", "$HOSTNAME:$PWD# ")
  end
else
  local file = io.open("/etc/hostname")
  if file then
    io.write(file:read("*l"), "\n")
    file:close()
  else
    io.stderr:write("Hostname not set\n")
    return 1
  end
end
Fbin/install.lua
alocal component = require("component")
local computer = require("computer")
local event = require("event")
local filesystem = require("filesystem")
local unicode = require("unicode")
local shell = require("shell")

local args, options = shell.parse(...)

local fromAddress = options.from and component.get(options.from) or filesystem.get(os.getenv("_")).address
local candidates = {}
for address in component.list("filesystem", true) do
  local dev = component.proxy(address)
  if not dev.isReadOnly() and dev.address ~= computer.tmpAddress() and dev.address ~= fromAddress then
    table.insert(candidates, dev)
  end
end

if #candidates == 0 then
  io.stderr:write("No writable disks found, aborting.\n")
  return 1
end

for i = 1, #candidates do
  local label = candidates[i].getLabel()
  if label then
    label = label .. " (" .. candidates[i].address:sub(1, 8) .. "...)"
  else
    label = candidates[i].address
  end
  io.write(i .. ") " .. label .. "\n")
end

io.write("To select the device to install to, please enter a number between 1 and " .. #candidates .. ".\n")
io.write("Press 'q' to cancel the installation.\n")
local choice
while not choice do
  result = io.read()
  if result:sub(1, 1):lower() == "q" then
    os.exit()
  end
  local number = tonumber(result)
  if number and number > 0 and number <= #candidates then
    choice = candidates[number]
  else
    io.write("Invalid input, please try again.\n")
  end
end

local function findMount(address)
  for fs, path in filesystem.mounts() do
    if fs.address == component.get(address) then
      return path
    end
  end
end

local name = options.name or "OpenOS"
io.write("Installing " .. name .." to device " .. (choice.getLabel() or choice.address) .. "\n")
os.sleep(0.25)
local cpPath = filesystem.concat(findMount(filesystem.get(os.getenv("_")).address), "bin/cp")
local cpOptions = "-vrx" .. (options.u and "ui " or "")
local cpSource = filesystem.concat(findMount(fromAddress), options.fromDir or "/")
local cpDest = findMount(choice.address) .. "/"
local result, reason = os.execute(cpPath .. " " .. cpOptions .. " " .. cpSource .. " " .. cpDest)
if not result then
  error(reason, 0)
end
if not options.nolabelset then pcall(choice.setLabel, name) end

if not options.noreboot then
  io.write("All done! " .. ((not options.noboot) and "Set as boot device and r" or "R") .. "eboot now? [Y/n]\n")
  local result = io.read()
  if not result or result == "" or result:sub(1, 1):lower() == "y" then
    if not options.noboot then computer.setBootAddress(choice.address)end
    io.write("\nRebooting now!\n")
    computer.shutdown(true)
  end
end
io.write("Returning to shell.\n")
Fbin/label.luaølocal fs = require("filesystem")
local shell = require("shell")

local args, options = shell.parse(...)
if #args < 1 then
  io.write("Usage: label [-a] <fs> [<label>]\n")
  io.write(" -a  File system is specified via label or address instead of by path.\n")
  return 1
end

local proxy, reason
if options.a then
  proxy, reason = fs.proxy(args[1])
else
  proxy, reason = fs.get(args[1])
end
if not proxy then
  io.stderr:write(reason..'\n')
  return 1
end

if #args < 2 then
  local label = proxy.getLabel()
  if label then
    print(label)
  else
    io.stderr:write("no label\n")
    return 1
  end
else
  local result, reason = proxy.setLabel(args[2])
  if not result then
    io.stderr:write((reason or "could not set label")..'\n')
    return 1
  end
end
F
bin/ln.lualocal component = require("component")
local fs = require("filesystem")
local shell = require("shell")

local dirs = shell.parse(...)
if #dirs == 0 then
  io.write("Usage: ln <target> [<name>]\n")
  return 1
end

local target = shell.resolve(dirs[1])
local linkpath
if #dirs > 1 then
  linkpath = shell.resolve(dirs[2])
else
  linkpath = fs.concat(shell.getWorkingDirectory(), fs.name(target))
end

local result, reason = fs.link(target, linkpath)
if not result then
  io.stderr:write(reason..'\n')
  return 1
end
F
bin/ls.lua&Glocal fs = require("filesystem")
local shell = require("shell")
local term = require("term")

local dirsArg, ops = shell.parse(...)
if #dirsArg == 0 then
  table.insert(dirsArg, ".")
end

if ops.help then
  print([[Usage: ls [OPTION]... [FILE]...
  -a, --all                  do not ignore entries starting with .
      --full-time            with -l, print time in full iso format
  -h, --human-readable       with -l and/or -s, print human readable sizes
      --si                   likewise, but use powers of 1000 not 1024
  -l                         use a long listing format
  -r, --reverse              reverse order while sorting
  -R, --recursive            list subdirectories recursively
  -S                         sort by file size
  -t                         sort by modification time, newest first
  -X                         sort alphabetically by entry extension
  -1                         list one file per line
  -p                         append / indicator to directories
  -M                         display Microsoft-style file and directory count after listing
      --no-color             Do not colorize the output (default colorized)
      --help                 display this help and exit
For more info run: man ls]])
  return 0
end

local ec = 0
local gpu = term.gpu()
local fOut = term.isAvailable() and io.output().tty
local function perr(msg) io.stderr:write(msg,"\n") ec = 2 end
local function _path(n,i) return n[i]:sub(1, 1) == '/' and "" or n.path end
local function _name(n,i) return ops.p and n[i] or n[i]:gsub("/+$", "") end
local function _sort_name(n,i) return _name(n,i):gsub("^%.","") end
local function _fullPath(n,i) return fs.concat(_path(n,i),_name(n,i)) end
local function _isLink(n,i) return (fs.isLink(_fullPath(n,i))) end
local function _linkPath(n,i) return select(2,fs.isLink(_fullPath(n,i))) end
local function _isDir(n,i) return fs.isDirectory(_fullPath(n,i)) end
local function _size(n,i) return _isLink(n,i) and 0 or fs.size(_fullPath(n,i)) end
local function _time(n,i) return fs.lastModified(_fullPath(n,i)) end
local function _ext(n,i) return _name(n,i):match("(%.[^.]+)$") or "" end
local function toArray(i) local r={} for n in i do r[#r+1]=n end return r end
local restore_color = function() end
local set_color = function() end
local prev_color
local function colorize(n,i) return prev_color end
if fOut and not ops["no-color"] then
  local LSC = os.getenv("LS_COLORS")
  if type(LSC) == "string" then
    LSC = require("serialization").unserialize(LSC)
  end
  if not LSC then
    perr("ls: unparsable value for LS_COLORS environment variable")
  else
    prev_color = gpu.getForeground()
    restore_color = function() gpu.setForeground(prev_color) end
    colorize=function(n,i) return
      _isLink(n,i) and LSC.LINK or
      _isDir(n,i) and LSC.DIR or
      LSC['*'.._ext(n,i)] or LSC.FILE or prev_color
    end
    set_color=function(c)
      if gpu.getForeground() ~= c then
        io.stdout:flush()
        gpu.setForeground(c)
      end
    end
  end
end
local msft={reports=0,proxies={}}
function msft.report(files, dirs, used, proxy)
  local free = proxy.spaceTotal() - proxy.spaceUsed()
  restore_color()
  local pattern = "%5i File(s) %11i bytes\n%5i Dir(s)  %11s bytes free\n"
  io.write(string.format(pattern, files, used, dirs, tostring(free)))
end
function msft.tail(n)
  local x = fs.get(n.path)
  if not x then return end
  local u,f,d=0,0,0
  for i=1,#n do
    if _isDir(n,i) then d=d+1
    else f=f+1;u=u+_size(n,i) end
  end
  msft.report(f,d,u,x)
  local ps=msft.proxies
  ps[x]=ps[x]or{files=0,dirs=0,used=0}
  local p=ps[x]
  p.files=p.files+f
  p.dirs=p.dirs+d
  p.used=p.used+u
  msft.reports=msft.reports+1
end
function msft.final()
  if msft.reports < 2 then return end
  local g = {}
  for p,r in pairs(msft.proxies) do g[#g+1]={proxy=p,report=r} end
  restore_color()
  print("Total Files Listed:")
  for _,p in ipairs(g) do
    if #g>1 then print("As pertaining to: "..p.proxy.address) end
    msft.report(p.report.files, p.report.dirs, p.report.used, p.proxy)
  end
end

if not ops.M then
  msft.tail=function()end
  msft.final=function()end
end

local function nod(n)
  return n and (tostring(n):gsub("(%.[0-9]+)0+$","%1")) or "0"
end

local function formatSize(size)
  if not ops.h and not ops['human-readable'] and not ops.si then
    return tostring(size)
  end
  local sizes = {"", "K", "M", "G"}
  local unit = 1
  local power = ops.si and 1000 or 1024
  while size > power and unit < #sizes do
    unit = unit + 1
    size = size / power
  end
  return nod(math.floor(size*10)/10)..sizes[unit]
end

local function pad(txt)
  txt = tostring(txt)
  return #txt >= 2 and txt or "0"..txt
end
local day_names={"Sunday","Monday","Tuesday","Wednesday","Thursday","Friday",
  "Saturday"}
local month_names={"January","February","March","April","May","June","July",
  "August","September","October","November","December"}
local function formatDate(epochms)
  local d = os.date("*t", epochms)
  return ops['full-time'] and
    string.format("%s-%s-%s %s:%s:%s",d.year,pad(nod(d.month)),pad(nod(d.day)),pad(nod(d.hour)),pad(nod(d.min)),pad(nod(d.sec))) or
    string.format("%s %+2s %+2s:%+2s",month_names[d.month]:sub(1,3),nod(d.day),pad(nod(d.hour)),pad(nod(d.min)))
end
local function filter(n)
  if ops.a then return n end
  local s = {path=n.path}
  for i,x in ipairs(n) do
    if fs.name(_name(n,i)):sub(1,1) ~= "." then s[#s+1]=x end
  end
  return s
end
local function sort(n)
  local once=false
  local function ni(v) for i=1,#n do if n[i]==v then return i end end end
  local function sorter(_fp)
    once=true table.sort(n,function(a,b)return _fp(n,ni(a))>_fp(n,ni(b))end)
  end
  local rev = ops.r or ops.reverse
  if ops.t then sorter(_time) end
  if ops.X then sorter(_ext) end
  if ops.S then sorter(_size) end
  if not once then sorter(_sort_name) rev=not rev end
  if rev then
    for i=1,#n/2 do n[i],n[#n-i+1]=n[#n-i+1],n[i] end
  end
  return n
end
local function dig(n, dirs, dir)
  if ops.R then
    local di = 1
    for i=1,#n do
      if _isDir(n,i) then
        local p=dir..(dir:sub(-1) == "/" and "" or "/")
        table.insert(dirs,di,p.._name(n,i))
        di=di+1
      end
    end
  end
  return n
end
local function wide(n,i)
  local t = _isLink(n,i) and 'l' or _isDir(n,i) and 'd' or 'f'
  local link_target = _isLink(n,i) and
    string.format(" -> %s",_linkPath(n,i)..(_isDir(n,i)and"/"or""))or""
  local w = fs.get(_fullPath(n,i)).isReadOnly() and '-' or 'w'
  local size = formatSize(_size(n,i))
  local modDate = formatDate(_time(n,i))
  return string.format("%s-r%s %+7s %s ",t,w,size,modDate),_name(n,i)..link_target
end

local first_display = true
local function display(n)
  local mt={}
  local lines=setmetatable({},mt)
  if ops.l then
    lines.n=#n
    mt.__index=function(tbl,index)local m,l=wide(n,index)return{{color=prev_color,name=m},{color=colorize(n,index),name=l}}end
  elseif ops["1"] or not fOut then
    lines.n=#n
    mt.__index=function(tbl,index)local m,l=wide(n,index)return{{color=colorize(n,index),name=_name(n,index)}}end
  else -- columns
    local cols,d,w=0,0,select(3,term.getGlobalArea())-1
    local function real(x, y)
      local index = y + ((x-1) * d)
      return index <= #n and index or nil
    end
    local function max_name(ci)
      local max=0 -- return the width of the max element in ci
      for r=1,d do
        local ri=real(ci,r)
        if not ri then break end
        max=math.max(max,_name(n,ri):len())
      end
      return max
    end
    local function measure(_cols)
      local t=0
      for c=1,_cols do t=t+max_name(c)+(c>1 and 2 or 0) end
      return t
    end
    while d<#n do d=d+1 cols=math.ceil(#n/d) if measure(cols)<w then break end end
    lines.n=d
    mt.__index=function(tbl,di)return setmetatable({},{
      __len=function()return cols end,
      __index=function(tbl,ci)
        local ri=real(ci, di)
        if not ri then return end
        local nm=_name(n,ri)
        return{
          color=colorize(n,ri),
          name=nm..string.rep(' ',max_name(ci)-#nm+(ci<cols and 2 or 0))
    }end})end
  end
  for li=1,lines.n do
    local l=lines[li]
    for ei=1,#l do
      local e=l[ei]
      if not e then break end
      first_display = false
      set_color(e.color)
      io.write(e.name)
    end
    print()
  end
  msft.tail(n)
end
local header = function() end
if #dirsArg > 1 or ops.R then
  header = function(path)
    if not first_display then print() end
    restore_color()
    io.write(path,":\n")
  end
end
local function splitDirsFromFileArgs(dirs)
  local trimmed = {}
  local files = {}
  for _,dir in ipairs(dirs) do
    local path = shell.resolve(dir)
    if not fs.exists(path) then
      perr("cannot access " .. tostring(path) .. ": No such file or directory")
    elseif fs.isDirectory(path) then
      table.insert(trimmed, dir)
    else -- file or link
      table.insert(files, dir)
    end
  end
  return files, trimmed
end
local function displayDirList(dirs)
  while #dirs > 0 do
    local dir = table.remove(dirs, 1)
    header(dir)
    local path = shell.resolve(dir)
    local list, reason = fs.list(path)
    if not list then
      perr(reason)
    else
      local n=toArray(list)
      n.path=path
      display(dig(sort(filter(n)),dirs,dir))
    end
  end
end
local tr,cp={},{path=os.getenv("PWD")}
for _,dir in ipairs(dirsArg) do
  local path = shell.resolve(dir)
  if not fs.exists(path) then
    perr("cannot access " .. tostring(path) .. ": No such file or directory")
  elseif fs.isDirectory(path) then
    tr[#tr+1]=dir
  else -- file or link
    cp[#cp+1]=dir
  end
end
io.output():setvbuf("line")
if #cp > 0 then display(sort(cp)) end
displayDirList(tr)
msft.final()
io.output():flush()
io.output():setvbuf("no")
restore_color()
return ec
Fbin/lshw.luaºlocal computer = require("computer")
local shell = require("shell")
local text = require("text")

local args, options = shell.parse(...)

local devices = computer.getDeviceInfo()
local columns = {}

if not next(options, nil) then
  options.t = true
  options.d = true
  options.p = true
end
if options.t then table.insert(columns, "Class") end
if options.d then table.insert(columns, "Description") end
if options.p then table.insert(columns, "Product") end
if options.v then table.insert(columns, "Vendor") end
if options.c then table.insert(columns, "Capacity") end
if options.w then table.insert(columns, "Width") end
if options.s then table.insert(columns, "Clock") end

local m = {}
for address, info in pairs(devices) do
  for col, name in ipairs(columns) do
    m[col] = math.max(m[col] or 1, (info[name:lower()] or ""):len())
  end
end

io.write(text.padRight("Address", 10))
for col, name in ipairs(columns) do
  io.write(text.padRight(name, m[col] + 2))
end
io.write("\n")

for address, info in pairs(devices) do
  io.write(text.padRight(address:sub(1, 5).."...", 10))
  for col, name in ipairs(columns) do
    io.write(text.padRight(info[name:lower()] or "", m[col] + 2))
  end
  io.write("\n")
end
Fbin/lua.lua¸local package = require("package")
local term = require("term")
local shell = require("shell")

local gpu = term.gpu()
local args, options = shell.parse(...)
local env = setmetatable({}, {__index = _ENV})

if #args > 0 then
  local script, reason = loadfile(args[1], nil, env)
  if not script then
    io.stderr:write(tostring(reason) .. "\n")
    os.exit(false)
  end
  local result, reason = pcall(script, table.unpack(args, 2))
  if not result then
    io.stderr:write(reason, "\n")
    os.exit(false)
  end
end

if #args == 0 or options.i then
  local function optrequire(...)
    local success, module = pcall(require, ...)
    if success then
      return module
    end
  end
  setmetatable(env, {
    __index = function(t, k)
      _ENV[k] = _ENV[k] or optrequire(k)
      return _ENV[k]
    end,
    __pairs = function(self)
      local t = self
      return function(_, key)
        local k, v = next(t, key)
        if not k and t == env then
          t = _ENV
          k, v = next(t)
        end
        if not k and t == _ENV then
          t = package.loaded
          k, v = next(t)
        end
        return k, v
      end
    end
  })

  local history = {}

  local function findTable(t, path)
    if type(t) ~= "table" then return nil end
    if not path or #path == 0 then return t end
    local name = string.match(path, "[^.]+")
    for k, v in pairs(t) do
      if k == name then
        return findTable(v, string.sub(path, #name + 2))
      end
    end
    local mt = getmetatable(t)
    if t == env then mt = {__index=_ENV} end
    if mt then
      return findTable(mt.__index, path)
    end
    return nil
  end
  local function findKeys(t, r, prefix, name)
    if type(t) ~= "table" then return end
    for k, v in pairs(t) do
      if type(k) == "string" and string.match(k, "^"..name) then
        local postfix = ""
        if type(v) == "function" then postfix = "()"
        elseif type(v) == "table" and getmetatable(v) and getmetatable(v).__call then postfix = "()"
        elseif type(v) == "table" then postfix = "."
        end
        r[prefix..k..postfix] = true
      end
    end
    local mt = getmetatable(t)
    if t == env then mt = {__index=_ENV} end
    if mt then
      return findKeys(mt.__index, r, prefix, name)
    end
  end
  local function hint(line, index)
    line = (line or "")
    local tail = line:sub(index)
    line = line:sub(1, index - 1)
    local path = string.match(line, "[a-zA-Z_][a-zA-Z0-9_.]*$")
    if not path then return nil end
    local suffix = string.match(path, "[^.]+$") or ""
    local prefix = string.sub(path, 1, #path - #suffix)
    local t = findTable(env, prefix)
    if not t then return nil end
    local r1, r2 = {}, {}
    findKeys(t, r1, string.sub(line, 1, #line - #suffix), suffix)
    for k in pairs(r1) do
      table.insert(r2, k .. tail)
    end
    table.sort(r2)
    if #r2 == 1 then
      setmetatable(r2, {
        __index=function(tbl, key)
          if key==2 then
            local prev=tbl[1]
            local next = hint(prev,#prev+1)
            if next then
              for i,v in ipairs(next) do
                tbl[i] = v
              end
            end
            setmetatable(tbl,getmetatable(next))
            return tbl[1]
          end
        end,
        __len=function()return 2 end})
    end
    return r2
  end

  gpu.setForeground(0xFFFFFF)
  term.write(_VERSION .. " Copyright (C) 1994-2015 Lua.org, PUC-Rio\n")
  gpu.setForeground(0xFFFF00)
  term.write("Enter a statement and hit enter to evaluate it.\n")
  term.write("Prefix an expression with '=' to show its value.\n")
  term.write("Press Ctrl+D to exit the interpreter.\n")
  gpu.setForeground(0xFFFFFF)

  while term.isAvailable() do
    local foreground = gpu.setForeground(0x00FF00)
    term.write(tostring(env._PROMPT or "lua> "))
    gpu.setForeground(foreground)
    local command = term.read(history, nil, hint)
    if command == nil or command == "" then -- eof
      return
    end
    local code, reason
    if string.sub(command, 1, 1) == "=" then
      code, reason = load("return " .. string.sub(command, 2), "=stdin", "t", env)
    else
      code, reason = load(command, "=stdin", "t", env)
    end
    if code then
      local result = table.pack(xpcall(code, debug.traceback))
      if not result[1] then
        if type(result[2]) == "table" and result[2].reason == "terminated" then
          os.exit(result[2].code)
        end
        io.stderr:write(tostring(result[2]) .. "\n")
      else
        for i = 2, result.n do
          term.write(require("serialization").serialize(result[i], true) .. "\t", true)
        end
        if term.getCursor() > 1 then
          term.write("\n")
        end
      end
    else
      io.stderr:write(tostring(reason) .. "\n")
    end
  end
end
Fbin/man.luaIlocal fs = require("filesystem")
local shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: man <topic>\n")
  io.write("Where `topic` will usually be the name of a program or library.\n")
  return 1
end

local topic = args[1]
for path in string.gmatch(os.getenv("MANPATH"), "[^:]+") do
  path = shell.resolve(fs.concat(path, topic), "man")
  if path and fs.exists(path) and not fs.isDirectory(path) then
    os.execute(os.getenv("PAGER") .. " " .. path)
    os.exit()
  end
end
io.stderr:write("No manual entry for " .. topic .. '\n')
return 1
Fbin/mkdir.luaQlocal fs = require("filesystem")
local shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: mkdir <dirname1> [<dirname2> [...]]\n")
  return 1
end

local ec = 0
for i = 1, #args do
  local path = shell.resolve(args[i])
  local result, reason = fs.makeDirectory(path)
  if not result then
    if not reason then
      if fs.exists(path) then
        reason = "file or folder with that name already exists"
      else
        reason = "unknown reason"
      end
    end
    io.stderr:write(path .. ": " .. reason .. "\n")
    ec = 1
  end
end

return ec
Fbin/mktmp.luaHlocal fs = require("filesystem")
local guid = require("guid")
local shell = require("shell")
local sh = require("sh")

local touch = loadfile(shell.resolve("touch", "lua"))
local mkdir = loadfile(shell.resolve("mkdir", "lua"))

if not guid or not touch then
  local errorMessage = "missing tools for mktmp"
  io.stderr:write(errorMessage .. '\n')
  return false, errorMessage
end

local args, ops = shell.parse(...)

local function pop(key)
  local result = ops[key]
  ops[key] = nil
  return result
end

local directory = pop('d')
local verbose = pop('v')
verbose = pop('verbose') or verbose
local quiet = pop('q') or quiet
quiet = pop('quiet') or quiet

if pop('help') or #args > 1 or next(ops) then
  print([[Usage: mktmp [OPTION] [PATH]
Create a new file with a random name in $TMPDIR or PATH argument if given
  -d              create a directory instead of a file
  -v, --verbose   print result to stdout, even if no tty
  -q, --quiet     do not print results to stdout, even if tty (verbose overrides)
      --help      print this help message]])
  if next(ops) then
    io.stderr:write("invalid option: " .. (next(ops)) .. '\n')
    return 1
  end
  return
end

if not verbose then
  if not quiet then
    if io.stdout.tty then
      verbose = true
    end
  end
end

local prefix = args[1] or os.getenv("TMPDIR") .. '/'
if not fs.exists(prefix) then
  io.stderr:write(
    string.format(
      "cannot create tmp file or directory at %s, it does not exist\n", 
      prefix))
  return 1
end

while true do
  local tmp = prefix .. guid.next()
  if not fs.exists(tmp) then

    local ok, reason
    if directory then
      ok, reason = mkdir(tmp)
    else
      ok, reason = touch(tmp)
    end

    if sh.internal.command_passed(ok) then
      if verbose then
        print(tmp)
      end
      return tmp
    else
      return ok, reason
    end
  end
end
Fbin/more.lualocal keyboard = require("keyboard")
local shell = require("shell")
local term = require("term")
local text = require("text")
local unicode = require("unicode")

local args = shell.parse(...)
if #args > 1 then
  io.write("Usage: more <filename>\n")
  io.write("- or no args reads stdin\n")
  return 1
end
local arg = args[1] or "-"
local file, reason
if arg == "-" then
  file, reason = io.stdin, "this process has no stdin"
else
  file, reason = io.open(shell.resolve(arg))
end
if not file then
  io.stderr:write(reason,'\n')
  return 1
end

local line = nil
local function readlines(num)
  local x, y, w, h = term.getGlobalArea()
  num = num or (h - 1)
  for _ = 1, num do
    if not line then
      line = file:read("*l")
      if not line then -- eof
        return nil
      end
    end
    local wrapped
    wrapped, line = text.wrap(text.detab(line), w, w)
    io.write(wrapped,"\n")
  end
  term.setCursor(1, h)
  term.write(":")
  return true
end

while true do
  term.clear()
  if not readlines() then
    return
  end
  while true do
    local event, address, char, code = term.pull("key_down")
    if code == keyboard.keys.q then
      term.clearLine()
      return
    elseif code == keyboard.keys.space or code == keyboard.keys.pageDown then
      break
    elseif code == keyboard.keys.enter or code == keyboard.keys.down then
      term.clearLine()
      if not readlines(1) then
        return
      end
    end
  end
end
Fbin/mount.luaflocal fs = require("filesystem")
local shell = require("shell")

local args = shell.parse(...)
local argc = #args
    
if argc == 0 then 
  -- for each mount
  local mounts = {}
    
  for proxy,path in fs.mounts() do
    local device = {}

    device.dev_path = proxy.address
    device.mount_path = path
    device.rw_ro = proxy.isReadOnly() and "ro" or "rw"
    device.fs_label = proxy.getLabel() or proxy.address

    mounts[device.dev_path] = mounts[device.dev_path] or {}
    local dev_mounts = mounts[device.dev_path]
    table.insert(dev_mounts, device)
  end
    
  table.sort(mounts)
    
  for dev_path, dev_mounts in pairs(mounts) do
    for _,device in ipairs(dev_mounts) do
      local rw_ro = "(" .. device.rw_ro .. ")"
      local fs_label = "\"" .. device.fs_label .. "\""
            
      io.write(string.format("%s on %-10s %s %s\n",
        dev_path:sub(1,8),
        device.mount_path,
        rw_ro,
        fs_label))
    end
  end
elseif argc ~= 2 then
  print("Usage: mount [<label|address> <path>]")
  print("Note that the address may be abbreviated.")
  return 1 -- error code
else
  local proxy, reason = fs.proxy(args[1])
  if not proxy then
    io.stderr:write(reason,"\n")
    return 1
  end

  local result, reason = fs.mount(proxy, shell.resolve(args[2]))
  if not result then
    io.stderr:write(reason,"\n")
    return 2 -- error code
  end
end
F
bin/mv.lualocal fs = require("filesystem")
local shell = require("shell")
local sh = require("sh")

local args, options = shell.parse(...)
if #args < 2 then
  io.write("Usage: mv [-f] <from> <to>\n")
  io.write(" -f: overwrite file if it already exists.\n")
  return 1
end

local from = shell.resolve(args[1])
local to = shell.resolve(args[2])
if fs.isDirectory(to) then
  to = to .. "/" .. fs.name(from)
end
if fs.exists(to) then
  if not options.f then
    io.stderr:write("target file exists\n")
    return 1
  end
  fs.remove(to)
end

local result, reason
if fs.get(from) == fs.get(to) then -- same filesystem
  result, reason = os.rename(from, to)
else
  result, reason = sh.execute(nil, shell.resolve("cp","lua"), "-r", from, to)
  if result then
    result, reason = sh.execute(nil, shell.resolve("rm","lua"), "-r", from)
  end
end

if not result then
  io.stderr:write((reason or "unknown error")..'\n')
  return 1
end
Fbin/pastebin.lua--[[ This program allows downloading and uploading from and to pastebin.com.
     Authors: Sangar, Vexatos ]]
local component = require("component")
local fs = require("filesystem")
local internet = require("internet")
local shell = require("shell")

if not component.isAvailable("internet") then
  io.stderr:write("This program requires an internet card to run.")
  return
end

local args, options = shell.parse(...)

-- This gets code from the website and stores it in the specified file.
local function get(pasteId, filename)
  local f, reason = io.open(filename, "w")
  if not f then
    io.stderr:write("Failed opening file for writing: " .. reason)
    return
  end

  io.write("Downloading from pastebin.com... ")
  local url = "http://pastebin.com/raw.php?i=" .. pasteId
  local result, response = pcall(internet.request, url)
  if result then
    io.write("success.\n")
    for chunk in response do
      if not options.k then
        string.gsub(chunk, "\r\n", "\n")
      end
      f:write(chunk)
    end

    f:close()
    io.write("Saved data to " .. filename .. "\n")
  else
    io.write("failed.\n")
    f:close()
    fs.remove(filename)
    io.stderr:write("HTTP request failed: " .. response .. "\n")
  end
end

-- This makes a string safe for being used in a URL.
function encode(code)
  if code then
    code = string.gsub(code, "([^%w ])", function (c)
      return string.format("%%%02X", string.byte(c))
    end)
    code = string.gsub(code, " ", "+")
  end
  return code 
end

-- This stores the program in a temporary file, which it will
-- delete after the program was executed.
function run(pasteId, ...)
  local tmpFile = os.tmpname()
  get(pasteId, tmpFile)
  io.write("Running...\n")

  local success, reason = shell.execute(tmpFile, nil, ...)
  if not success then
    io.stderr:write(reason)
  end
  fs.remove(tmpFile)
end

-- Uploads the specified file as a new paste to pastebin.com.
function put(path)
  local config = {}
  local configFile = loadfile("/etc/pastebin.conf", "t", config)
  if configFile then
    local result, reason = pcall(configFile)
    if not result then
      io.stderr:write("Failed loading config: " .. reason)
    end
  end
  config.key = config.key or "fd92bd40a84c127eeb6804b146793c97"
  local file, reason = io.open(path, "r")

  if not file then
    io.stderr:write("Failed opening file for reading: " .. reason)
    return
  end

  local data = file:read("*a")
  file:close()

  io.write("Uploading to pastebin.com... ")
  local result, response = pcall(internet.request,
        "http://pastebin.com/api/api_post.php", 
        "api_option=paste&" ..
        "api_dev_key=" .. config.key .. "&" ..
        "api_paste_format=lua&" ..
        "api_paste_expire_date=N&" ..
        "api_paste_name=" .. encode(fs.name(path)) .. "&" ..
        "api_paste_code=" .. encode(data))

  if result then
    local info = ""
    for chunk in response do
      info = info .. chunk
    end
    if string.match(info, "^Bad API request, ") then
      io.write("failed.\n")
      io.write(info)
    else
      io.write("success.\n")
      local pasteId = string.match(info, "[^/]+$")
      io.write("Uploaded as " .. info .. "\n")
      io.write('Run "pastebin get ' .. pasteId .. '" to download anywhere.')
    end
  else
    io.write("failed.\n")
    io.stderr:write(response)
  end
end

local command = args[1]
if command == "put" then
  if #args == 2 then
    put(shell.resolve(args[2]))
    return
  end
elseif command == "get" then
  if #args == 3 then
    local path = shell.resolve(args[3])
    if fs.exists(path) then
      if not options.f or not os.remove(path) then
        io.stderr:write("file already exists")
        return
      end
    end
    get(args[2], path)
    return
  end
elseif command == "run" then
  if #args >= 2 then
    run(args[2], table.unpack(args, 3))
    return
  end
end

-- If we come here there was some invalid input.
io.write("Usages:\n")
io.write("pastebin put [-f] <file>\n")
io.write("pastebin get [-f] <id> <file>\n")
io.write("pastebin run [-f] <id> [<arguments...>]\n")
io.write(" -f: Force overwriting existing files.\n")
io.write(" -k: keep line endings as-is (will convert\n")
io.write("     Windows line endings to Unix otherwise).")Fbin/primary.lua×local component = require("component")
local shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: primary <type> [<address>]\n")
  io.write("Note that the address may be abbreviated.\n")
  return 1
end

local componentType = args[1]

if #args > 1 then
  local address = args[2]
  if not component.get(address) then
    io.stderr:write("no component with this address\n")
    return 1
  else
    component.setPrimary(componentType, address)
    os.sleep(0.1) -- allow signals to be processed
  end
end
if component.isAvailable(componentType) then
  io.write(component.getPrimary(componentType).address, "\n")
else
  io.stderr:write("no primary component for this type\n")
  return 1
end
Fbin/pwd.luaLlocal shell = require("shell")

io.write(shell.getWorkingDirectory(), "\n")
F
bin/rc.lua\local rc = require("rc")
local fs = require("filesystem")
local shell = require("shell")

local function loadConfig()
  local env = {}
  local result, reason = loadfile('/etc/rc.cfg', 't', env)
  if result then
    result, reason = xpcall(result, debug.traceback)
    if result then
      return env
    end
  end
  return nil, reason
end

local function saveConfig(conf)
  local file, reason = io.open('/etc/rc.cfg', 'w')
  if not file then
    return nil, reason
  end
  for key, value in pairs(conf) do
    file:write(tostring(key) .. " = " .. require("serialization").serialize(value) .. "\n")
  end
  
  file:close()
  return true
end

local function load(name, args)
  if rc.loaded[name] then
    return rc.loaded[name]
  end
  local fileName = fs.concat('/etc/rc.d/', name .. '.lua')
  local env = setmetatable({args = args}, {__index = _G})
  local result, reason = loadfile(fileName, 't', env)
  if result then
    result, reason = xpcall(result, debug.traceback)
    if result then
      rc.loaded[name] = env
      return env
    end
  end
  return nil, reason
end

function unload(name)
  rc.loaded[name] = nil
end

local function rawRunCommand(conf, name, cmd, args, ...)
  local result, what = load(name, args)
  if result then
    if not cmd then
      io.output():write("Commands for service " .. name .. "\n")
      for command, val in pairs(result) do
        if type(val) == "function" then
          io.output():write(tostring(command) .. " ")
        end
      end
      return true
    elseif type(result[cmd]) == "function" then
      res, what = xpcall(result[cmd], debug.traceback, ...)
      if res then
        return true
      end
    elseif cmd == "restart" and type(result["stop"]) == "function" and type(result["start"]) == "function" then
      res, what = xpcall(result["stop"], debug.traceback, ...)
      if res then
        res, what = xpcall(result["start"], debug.traceback, ...)
        if res then
          return true
        end
      end
    elseif cmd == "enable" then
      conf.enabled = conf.enabled or {}
      for _, _name in ipairs(conf.enabled) do
        if name == _name then
          return nil, "Service already enabled"
        end
      end
      conf.enabled[#conf.enabled + 1] = name
      return saveConfig(conf)
    elseif cmd == "disable" then
      conf.enabled = conf.enabled or {}
      for n, _name in ipairs(conf.enabled) do
        if name == _name then
          table.remove(conf.enabled, n)
        end
      end
      return saveConfig(conf)
    else
      what = "Command '" .. cmd .. "' not found in daemon '" .. name .. "'"
    end
  end
  return nil, what
end

local function runCommand(name, cmd, ...)
  local conf, reason = loadConfig()
  if not conf then
    return nil, reason
  end
  return rawRunCommand(conf, name, cmd, conf[name], ...)
end

local function allRunCommand(cmd, ...)
  local conf, reason = loadConfig()
  if not conf then
    return nil, reason
  end
  local results = {}
  for _, name in ipairs(conf.enabled or {}) do
    results[name] = table.pack(rawRunCommand(conf, name, cmd, conf[name], ...))
  end
  return results
end

local args = table.pack(...)

if #args == 0 then  
  local results,reason = allRunCommand("start")
  if not results then
    local msg = "rc failed to start:"..tostring(reason)
    io.stderr:write(msg)
    require("event").onError(msg)
    return
  end
  for name, result in pairs(results) do
    local ok, reason = table.unpack(result)
    if not ok then
      io.stderr:write(reason .. "\n")
    end
  end
else
  local result, reason = runCommand(table.unpack(args))
  if not result then
    io.stderr:write(reason .. "\n")
    return 1
  end
end
Fbin/reboot.luaVlocal computer = require("computer")

io.write("Rebooting...")
computer.shutdown(true)Fbin/redstone.lua,local colors = require("colors")
local component = require("component")
local shell = require("shell")
local sides = require("sides")

if not component.isAvailable("redstone") then
  io.stderr:write("This program requires a redstone card or redstone I/O block.\n")
  return 1
end
local rs = component.redstone

local args, options = shell.parse(...)
if #args == 0 and not options.w and not options.f then
  io.write("Usage:\n")
  io.write("  redstone <side> [<value>]\n")
  if rs.setBundledOutput then
    io.write("  redstone -b <side> <color> [<value>]\n")
  end
  if rs.setWirelessOutput then
    io.write("  redstone -w [<value>]\n")
    io.write("  redstone -f [<frequency>]\n")
  end
  return
end

if options.w then
  if not rs.setWirelessOutput then
    io.stderr:write("wireless redstone not available\n")
    return 1
  end
  if #args > 0 then
    local value = args[1]
    if tonumber(value) then
      value = tonumber(value) > 0
    else
      value = ({["true"]=true,["on"]=true,["yes"]=true})[value] ~= nil
    end
    rs.setWirelessOutput(value)
  end
  io.write("in: " .. tostring(rs.getWirelessInput()) .. "\n")
  io.write("out: " .. tostring(rs.getWirelessOutput()) .. "\n")
elseif options.f then
  if not rs.setWirelessOutput then
    io.stderr:write("wireless redstone not available\n")
    return 1
  end
  if #args > 0 then
    local value = args[1]
    if not tonumber(value) then
      io.stderr:write("invalid frequency\n")
      return 1
    end
    rs.setWirelessFrequency(tonumber(value))
  end
  io.write("freq: " .. tostring(rs.getWirelessFrequency()) .. "\n")
else
  local side = sides[args[1]]
  if not side then
    io.stderr:write("invalid side\n")
    return 1
  end
  if type(side) == "string" then
    side = sides[side]
  end

  if options.b then
    if not rs.setBundledOutput then
      io.stderr:write("bundled redstone not available\n")
      return 1
    end
    local color = colors[args[2]]
    if not color then
      io.stderr:write("invalid color\n")
      return 1
    end
    if type(color) == "string" then
      color = colors[color]
    end
    if #args > 2 then
      local value = args[3]
      if tonumber(value) then
        value = tonumber(value)
      else
        value = ({["true"]=true,["on"]=true,["yes"]=true})[value] and 255 or 0
      end
      rs.setBundledOutput(side, color, value)
    end
    io.write("in: " .. rs.getBundledInput(side, color) .. "\n")
    io.write("out: " .. rs.getBundledOutput(side, color) .. "\n")
  else
    if #args > 1 then
      local value = args[2]
      if tonumber(value) then
        value = tonumber(value)
      else
        value = ({["true"]=true,["on"]=true,["yes"]=true})[value] and 15 or 0
      end
      rs.setOutput(side, value)
    end
    io.write("in: " .. rs.getInput(side) .. "\n")
    io.write("out: " .. rs.getOutput(side) .. "\n")
  end
end
Fbin/resolution.luaklocal shell = require("shell")
local term = require("term")

local args = shell.parse(...)
local gpu = term.gpu()

if #args == 0 then
  local w, h = gpu.getViewport()
  io.write(w," ",h,"\n")
  return
end

if #args ~= 2 then
  print("Usage: resolution [<width> <height>]")
  return
end

local w = tonumber(args[1])
local h = tonumber(args[2])
if not w or not h then
  io.stderr:write("invalid width or height\n")
  return 1
end

local result, reason = gpu.setResolution(w, h)
if not result then
  if reason then -- otherwise we didn't change anything
    io.stderr:write(reason..'\n')
  end
  return 1
end
term.clear()
F
bin/rm.luaölocal fs = require("filesystem")
local shell = require("shell")

local function usage()
  print("Usage: rm [options] <filename1> [<filename2> [...]]"..[[

  -f          ignore nonexistent files and arguments, never prompt
  -r          remove directories and their contents recursively
  -v          explain what is being done
      --help  display this help and exit

For complete documentation and more options, run: man rm]])
end

local args, options = shell.parse(...)
if #args == 0 or options.help then
  usage()
  return 1
end

local bRec = options.r or options.R or options.recursive
local bForce = options.f or options.force
local bVerbose = options.v or options.verbose
local bEmptyDirs = options.d or options.dir
local promptLevel = (options.I and 3) or (options.i and 1) or 0

local metas = {}

-- promptLevel 3 done before fs.exists
-- promptLevel 1 asks for each, displaying fs.exists on hit as it visits

local function _path(m) return shell.resolve(m.rel) end
local function _link(m) return fs.isLink(_path(m)) end
local function _exists(m) return _link(m) or fs.exists(_path(m)) end
local function _dir(m) return fs.isDirectory(_path(m)) end
local function _readonly(m) return not _exists(m) or fs.get(_path(m)).isReadOnly() end
local function _empty(m) return _exists(m) and _dir(m) and (fs.list(_path(m))==nil) end

local function createMeta(origin, rel)
  local m = {origin=origin,rel=rel:gsub("/+$", "")}
  if _dir(m) then
    m.rel = m.rel .. '/'
  end
  return m
end

local function unlink(path)
  os.remove(path)
  return true
end

local function confirm()
  local r = io.read("*l")
  return r == 'y' or r == 'yes'
end

local function remove_all(parent)
  if parent == nil or not _dir(parent) or _empty(parent) then
    return true
  end

  local all_ok = true
  if bRec and promptLevel == 1 then
    io.stdout:write(string.format("rm: descend into directory `%s'? ", parent.rel))
    if not confirm() then
      return false
    end

    for file in fs.list(_path(parent)) do
      local child = createMeta(parent.origin, parent.rel .. file)
      all_ok = remove(child) and all_ok
    end
  end

  return all_ok
end

local function remove(meta)
  if not remove_all(meta) then
    return false
  end

  if not _exists(meta) then
    io.stderr:write(
      string.format("rm: cannot remove `%s': No such file or directory\n", meta.rel))
    return false
  elseif _dir(meta) and not bRec and not (_empty(meta) and bEmptyDirs) then
    if not bEmptyDirs then
      io.stderr:write(
        string.format("rm: cannot remove `%s': Is a directory\n", meta.rel))
    else
      io.stderr:write(
        string.format("rm: cannot remove `%s': Directory not empty\n", meta.rel))
    end
    return false
  end

  local ok = true
  if promptLevel == 1 then
    if _dir(meta) then
      io.stdout:write(string.format("rm: remove directory `%s'? ", meta.rel))
    elseif meta.link then
      io.stdout:write(string.format("rm: remove symbolic link `%s'? ", meta.rel))
    else -- file
      io.stdout:write(string.format("rm: remove regular file `%s'? ", meta.rel))
    end

    ok = confirm()
  end

  if ok then
    if _readonly(meta) then
      io.stderr:write(
        string.format("rm: cannot remove `%s': Is read only\n", meta.rel))
      return false
    elseif not unlink(_path(meta)) then
      io.stderr:write(meta.rel .. ": failed to be removed\n")
      ok = false
    elseif bVerbose then
      io.write("removed '" .. meta.rel .. "'\n");
    end
  end

  return ok
end

for _,arg in ipairs(args) do
  metas[#metas+1] = createMeta(arg, arg)
end

if promptLevel == 3 and #metas > 3 then
  io.stdout:write(string.format("rm: remove %i arguments? ", #metas))
  if not confirm() then
    return
  end
end

local ok = true
for _,meta in ipairs(metas) do
  local result = remove(meta)
  ok = ok and result
end
Fbin/rmdir.lua
mlocal shell = require("shell")
local fs =  require("filesystem")
local text = require("text")

local args, options = shell.parse(...)

local function usage()
  print(
[[Usage: rmdir [OPTION]... DIRECTORY...
Removes the DIRECTORY(ies), if they are empty.

  -q, --ignore-fail-on-non-empty
                  ignore failures due solely to non-empty directories
  -p, --parents   remove DIRECTORY and its empty ancestors
                  e.g. 'rmdir -p a/b/c' is similar to 'rmdir a/b/c a/b a'
  -v, --verbose   output a diagnostic for every directory processed
      --help      display this help and exit]])
end

if options.help then
  usage()
  return 0
end

if #args == 0 then
  io.stderr:write("rmdir: missing operand\n")
  return 1
end

options.p = options.p or options.parents
options.v = options.v or options.verbose
options.q = options.q or options['ignore-fail-on-non-empty']

local ec = 0
local function ec_bump()
  ec = 1
  return 1
end

local function remove(path, ...)
  -- check to end recursion
  if path == nil then
    return true
  end

  if options.v then
    print(string.format('rmdir: removing directory, %s', path))
  end

  local rpath = shell.resolve(path)
  if path == '.' then
    io.stderr:write('rmdir: failed to remove directory \'.\': Invalid argument\n')
    return ec_bump()
  elseif not fs.exists(rpath) then
    io.stderr:write("rmdir: cannot remove " .. path .. ": path does not exist\n")
    return ec_bump()
  elseif fs.isLink(rpath) or not fs.isDirectory(rpath) then
    io.stderr:write("rmdir: cannot remove " .. path .. ": not a directory\n")
    return ec_bump()
  else
    local list, reason = fs.list(rpath)
        
    if not list then
      io.stderr:write(tostring(reason)..'\n')
      return ec_bump()
    else
      if list() then
        if not options.q then
          io.stderr:write("rmdir: failed to remove " .. path .. ": Directory not empty\n")
        end
        return ec_bump()
      else
        -- path exists and is empty?
        local ok, reason = fs.remove(rpath)
        if not ok then
          io.stderr:write(tostring(reason)..'\n')
          return ec_bump(), reason
        end
        return remove(...) -- the final return of all else
      end
    end
  end
end

for _,path in ipairs(args) do
  -- clean up the input
  path = path:gsub('/+', '/')

  local segments = {}
  if options.p and path:len() > 1 and path:find('/') then
    chain = text.split(path, {'/'}, true)
    local prefix = ''
    for _,e in ipairs(chain) do
      table.insert(segments, 1, prefix .. e)
      prefix = prefix .. e .. '/'
    end
  else
    segments = {path}
  end

  remove(table.unpack(segments))
end

return ec
Fbin/scale.lua.local ecs = require("ECSAPI")
local gpu = require("component").gpu

local arg = {...}
if arg[1] == "get" or arg[1] == "show" or arg[1] == "print" or arg[1] == "write" or arg[1] == "info" or arg[1] == "help" then
  local max1, max2 = gpu.maxResolution()
  local cur1, cur2 = gpu.getResolution()
  local scale = cur1 / max1 * 100
  print(" ")
  print("Maximum resolution: " .. max1 .. "x".. max2)
  print("Current resolution: " .. cur1 .. "x" .. cur2)
  print(" ")
  print("Scale: " .. scale .. "%")
  print(" ")
else
  ecs.setScale(tonumber(arg[1]) or 1)
end
Fbin/set.lualocal text = require("text")

local args = {...}

if #args < 1 then
  for k,v in pairs(os.getenv()) do
    io.write(k .. "='" .. string.gsub(v, "'", [['"'"']]) .. "'\n")
  end
else
  local count = 0 
  for _, expr in ipairs(args) do
    local e = expr:find('=')
    if e then
      os.setenv(expr:sub(1,e-1), expr:sub(e+1))
    else
      if count == 0 then
        for i = 1, os.getenv('#') do
          os.setenv(i, nil)
        end
      end
      count = count + 1
      os.setenv(count, expr)
    end
  end
end
F
bin/sh.lualocal event = require("event")
local shell = require("shell")
local term = require("term")
local text = require("text")
local sh = require("sh")

local input = table.pack(...)
local args, options = shell.parse(select(3,table.unpack(input)))
if input[2] then
  table.insert(args, 1, input[2])
end

local history = {}
shell.prime()

if #args == 0 and (io.stdin.tty or options.i) and not options.c then
  -- interactive shell.
  -- source profile
  if not term.isAvailable() then event.pull("term_available") end
  loadfile(shell.resolve("source","lua"))("/etc/profile")
  while true do
    if not term.isAvailable() then -- don't clear unless we lost the term
      while not term.isAvailable() do
        event.pull("term_available")
      end
      term.clear()
    end
    local gpu = term.gpu()
    while term.isAvailable() do
      local foreground = gpu.setForeground(0xFF0000)
      term.write(sh.expand(os.getenv("PS1") or "$ "))
      gpu.setForeground(foreground)
      term.setCursorBlink(true)
      local command = term.read(history, nil, sh.hintHandler)
      if not command then
        io.write("exit\n")
        return -- eof
      end
      command = text.trim(command)
      if command == "exit" then
        return
      elseif command ~= "" then
        local result, reason = os.execute(command)
        if term.getCursor() > 1 then
          print()
        end
        if not result then
          io.stderr:write((reason and tostring(reason) or "unknown error") .. "\n")
        end
      end
    end
  end
elseif #args == 0 and not io.stdin.tty then
  while true do
    io.write(sh.expand(os.getenv("PS1") or "$ "))
    local command = io.read("*l")
    if not command then
      command = "exit"
      io.write(command,"\n")
    end
    command = text.trim(command)
    if command == "exit" then
      return
    elseif command ~= "" then
      local result, reason = os.execute(command)
      if not result then
        io.stderr:write((reason and tostring(reason) or "unknown error") .. "\n")
      end
    end
  end
else
  -- execute command.
  local result = table.pack(sh.execute(...))
  if not result[1] then
    error(result[2], 0)
  end
  return table.unpack(result, 2)
end
Fbin/shutdown.luaclocal computer = require("computer")
local term = require("term")

term.clear()
computer.shutdown()Fbin/sleep.lua8local shell = require('shell')
local args, options = shell.parse(...)

if options.help then
  print([[Usage: sleep NUMBER[SUFFIX]...
Pause for NUMBER seconds.  SUFFIX may be 's' for seconds (the default),
'm' for minutes, 'h' for hours or 'd' for days.  Unlike most implementations
that require NUMBER be an integer, here NUMBER may be an arbitrary floating
point number.  Given two or more arguments, pause for the amount of time
specified by the sum of their values.]])
end

local function help(bad_arg)
  print("sleep: invalid option -- '"..tostring(bad_arg).."'")
  print("Try 'sleep --help' for more information.")
end

local function time_type_multiplier(time_type)
  if not time_type or #time_type == 0 or time_type == 's' then
    return 1
  elseif time_type == 'm' then
    return 60
  elseif time_type == 'h' then
    return 60 * 60
  elseif time_type == 'd' then
    return 60 * 60 * 24
  end

  -- weird error, my bad
  assert(false,'bug parsing parameter:'..tostring(time_type))
end

options.help = nil
if next(options) then
  help(next(options))
  return 1
end

local total_time = 0

for _,v in ipairs(args) do
  local interval = v:match('^%d+%.?%d*[smhd]?$')
  if not interval then
    help(v)
    return 1
  end

  local time_type = interval:match('[smhd]') or ''
  interval = interval:sub(1, -#time_type-1)
  interval = tonumber(interval)

  if interval < 0 then
    help(v)
    return 1
  end

  interval = time_type_multiplier(time_type) * interval
  total_time = total_time + interval
end

os.sleep(total_time)
Fbin/source.luaûlocal shell = require("shell")
local fs = require("filesystem")
local sh = require("sh")

local args, options = shell.parse(...)

if #args ~= 1 then
  io.stderr:write("specify a single file to source\n");
  return 1
end

local file, reason = io.open(args[1], "r")

if not file then
  if not options.q then
    io.stderr:write(string.format("could not source %s because: %s\n", args[1], reason));
  end
  return 1
else
  local status, reason = xpcall(function()
    repeat
      local line = file:read("*L")
      if line then
        sh.execute(nil, line)
      end
    until not line
  end, function(msg) return {msg, debug.traceback()} end)

  file:close()
  if not status and reason then assert(false, tostring(reason[1]) .."\n".. tostring(reason[2])) end
end
Fbin/time.lualocal computer = require('computer')
local sh = require('sh')

local real_before, cpu_before = computer.uptime(), os.clock()
local cmd_result = 0
if ... then
  sh.execute(nil, ...) 
  cmd_result = sh.getLastExitCode()
end
local real_after, cpu_after = computer.uptime(), os.clock()

local real_diff = real_after - real_before
local cpu_diff = cpu_after - cpu_before

print(string.format('real%5dm%.3fs', math.floor(real_diff/60), real_diff%60))
print(string.format('cpu %5dm%.3fs', math.floor(cpu_diff/60), cpu_diff%60))

return cmd_result
Fbin/touch.luaX--[[Lua implementation of the UN*X touch command--]]
local shell = require("shell")
local fs =  require("filesystem")

local args, options = shell.parse(...)

local function usage()
  print(
[[Usage: touch [OPTION]... FILE...
Update the modification times of each FILE to the current time.
A FILE argument that does not exist is created empty, unless -c is supplied.

  -c, --no-create    do not create any files
      --help         display this help and exit]])
end

if options.help then
  usage()
  return 0
elseif #args == 0 then
  io.stderr:write("touch: missing operand\n")
  return 1
end

options.c = options.c or options["no-create"]
local errors = 0

for _,arg in ipairs(args) do
  local path = shell.resolve(arg)

  if fs.isDirectory(path) then
    io.stderr:write(string.format("`%s' ignored: directories not supported\n", arg))
  elseif fs.exists(path) or not options.c then
    local f, reason = io.open(path, "w")
    if not f then
      io.stderr:write(string.format("touch: cannot touch `%s': permission denied\n", arg))
      errors = 1
    else
      f:close()
    end
  end
end

return errors
Fbin/umount.lua;local fs = require("filesystem")
local shell = require("shell")

local args, options = shell.parse(...)

if #args < 1 then
  io.write("Usage: umount [-a] <mount>\n")
  io.write(" -a  Remove any mounts by file system label or address instead of by path. Note that the address may be abbreviated.\n")
  return 1
end

local proxy, reason
if options.a then
  proxy, reason = fs.proxy(args[1])
  if proxy then
    proxy = proxy.address
  end
else
  local path = shell.resolve(args[1])
  proxy, reason = fs.get(path)
  if proxy then
    proxy = reason -- = path
    if proxy ~= path then
      io.stderr:write("not a mount point\n")
      return 1
    end
  end
end
if not proxy then
  io.stderr:write(tostring(reason)..'\n')
  return 1
end

if not fs.umount(proxy) then
  io.stderr:write("nothing to unmount here\n")
  return 1
end
Fbin/unalias.luaqlocal shell = require("shell")

local args = shell.parse(...)
if #args < 1 then
  io.write("Usage: unalias <name>...\n")
  return 2
end
local e = 0

for _,arg in ipairs(args) do
  local result = shell.getAlias(arg)
  if not result then
    io.stderr:write(string.format("unalias: %s: not found\n", arg))
    e = 1
  else
    shell.setAlias(arg, nil)
  end
end
return e
Fbin/unset.lua£local args = {...}

if #args < 1 then
  io.write("Usage: unset <varname>[ <varname2> [...]]\n")
else
  for _, k in ipairs(args) do
    os.setenv(k, nil)
  end
end
Fbin/uptime.luaclocal computer = require("computer")

local seconds = math.floor(computer.uptime())
local minutes, hours = 0, 0
if seconds >= 60 then
  minutes = math.floor(seconds / 60)
  seconds = seconds % 60
end
if minutes >= 60 then
  hours = math.floor(minutes / 60)
  minutes = minutes % 60
end
io.write(string.format("%02d:%02d:%02d\n", hours, minutes, seconds))
Fbin/useradd.lualocal computer = require("computer")
local shell = require("shell")

local args = shell.parse(...)
if #args ~= 1 then
  io.write("Usage: useradd <name>\n")
  return 1
end

local result, reason = computer.addUser(args[1])
if not result then
  io.stderr:write(reason..'\n')
  return 1
end
Fbin/userdel.lualocal computer = require("computer")
local shell = require("shell")

local args = shell.parse(...)
if #args ~= 1 then
  io.write("Usage: userdel <name>\n")
  return 1
end

if not computer.removeUser(args[1]) then
  io.stderr:write("no such user\n")
  return 1
end
Fbin/wget.lualocal component = require("component")
local fs = require("filesystem")
local internet = require("internet")
local shell = require("shell")
local text = require("text")

if not component.isAvailable("internet") then
  io.stderr:write("This program requires an internet card to run.")
  return
end

local args, options = shell.parse(...)
options.q = options.q or options.Q

if #args < 1 then
  io.write("Usage: wget [-fq] <url> [<filename>]\n")
  io.write(" -f: Force overwriting existing files.\n")
  io.write(" -q: Quiet mode - no status messages.\n")
  io.write(" -Q: Superquiet mode - no error messages.")
  return
end

local url = text.trim(args[1])
local filename = args[2]
if not filename then
  filename = url
  local index = string.find(filename, "/[^/]*$")
  if index then
    filename = string.sub(filename, index + 1)
  end
  index = string.find(filename, "?", 1, true)
  if index then
    filename = string.sub(filename, 1, index - 1)
  end
end
filename = text.trim(filename)
if filename == "" then
  if not options.Q then
    io.stderr:write("could not infer filename, please specify one")
  end
  return nil, "missing target filename" -- for programs using wget as a function
end
filename = shell.resolve(filename)

local preexisted
if fs.exists(filename) then
  preexisted = true
  if not options.f then
    if not options.Q then
      io.stderr:write("file already exists")
    end
    return nil, "file already exists" -- for programs using wget as a function
  end
end

local f, reason = io.open(filename, "a")
if not f then
  if not options.Q then
    io.stderr:write("failed opening file for writing: " .. reason)
  end
  return nil, "failed opening file for writing: " .. reason -- for programs using wget as a function
end
f:close()
f = nil

if not options.q then
  io.write("Downloading... ")
end
local result, response = pcall(internet.request, url)
if result then
  local result, reason = pcall(function()
    for chunk in response do
      if not f then
        f, reason = io.open(filename, "wb")
        assert(f, "failed opening file for writing: " .. tostring(reason))
      end
      f:write(chunk)
    end
  end)
  if not result then
    if not options.q then
      io.stderr:write("failed.\n")
    end
    if f then
      f:close()
      if not preexisted then
        fs.remove(filename)
      end
    end
    if not options.Q then
      io.stderr:write("HTTP request failed: " .. reason .. "\n")
    end
    return nil, reason -- for programs using wget as a function
  end
  if not options.q then
    io.write("success.\n")
  end
  
  if f then
    f:close()
  end

  if not options.q then
    io.write("Saved data to " .. filename .. "\n")
  end
else
  if not options.q then
    io.write("failed.\n")
  end
  if not options.Q then
    io.stderr:write("HTTP request failed: " .. response .. "\n")
  end
  return nil, response -- for programs using wget as a function
end
return true -- for programs using wget as a function
Fbin/which.luaàlocal shell = require("shell")

local args = shell.parse(...)
if #args == 0 then
  io.write("Usage: which <program>\n")
  return 255
end

for i = 1, #args do
  local result, reason = shell.resolve(args[i], "lua")
  
  if not result then
    result = shell.getAlias(args[i])
    if result then
      result = args[i] .. ": aliased to " .. result
    end
  end

  if result then
    print(result)
  else
    io.stderr:write(args[i] .. ": " .. reason .. "\n")
    return 1
  end
end
Fbin/yes.lua--[[Lua implementation of the UN*X yes command--]]
local shell = require("shell")

local args, options = shell.parse(...)

if options.V or options.version then
  io.write("yes v:1.0-3\n")
  io.write("Inspired by functionality of yes from GNU coreutils\n")
  return 0
end

if options.h or options.help then
  io.write("Usage: yes [string]...\n")
  io.write("OR:    yes [-V/h]\n")
  io.write("\n")
  io.write("yes prints the command line arguments, or 'y', until is killed.\n")
  io.write("\n")
  io.write("Options:\n")
  io.write("	-V, --version	Version\n")
  io.write("	-h, --help  	This help\n")
  return 0
end

local msg = #args == 0 and 'y' or table.concat(args, ' ')
msg = msg .. '\n'

while io.write(msg) do
  if io.stdout.tty then
    os.sleep(0)
  end
end
return 0
Dusr/Dusr/man/Fusr/man/address¢NAME
  address - display the computer's address

SYNOPSIS
  address

DESCRIPTION
  `address` allows printing the computer's component address. This can be useful to quickly look up a computer's address without an Analyzer. Knowing a computer's address can be useful if you wish to directly send network messages between two computers.

EXAMPLES
  address
    Displays the address of the computer the program is run on.Fusr/man/alias¡NAME
  alias - displays and manipulates aliases for programs

SYNOPSIS
  alias
  alias name
  alias name=value

DESCRIPTION
  `alias` allows listing and editing aliases for programs. An alias is an alternative name that can be used to start a program. A program can have multiple aliases. Aliases can also contain parameters and options to pass to the actual program. An alias can also, in turn, have aliases.

EXAMPLES
  alias
    Displays the list of all current aliases.

  alias name
    Displays the value the specified alias, i.e. what the specified alias stands for.

  alias name=value
  alias name='value with arguments'
    Sets the value of the alias with the specified name. Note that white space separates arguments to a command, thus to have an alias whose value has whitespace, quote the value

  alias name1 name2 name3=value
    You can also return the value, or set the value, of an arbitrary number of aliases.Fusr/man/cat!NAME
  cat - concatenate files and print on the standard output

SYNOPSIS
  cat [FILE]...

DESCRIPTION
  `cat` allows concatenating files or standard input to standard output.

EXAMPLES
  cat
    Copy standard input to standard output.

  cat test.txt
    Output contents of file test.txt.F
usr/man/cd³NAME
  cd - change the current working directory

SYNOPSIS
  cd [directory]
  cd -

DESCRIPTION
  `cd` allows changing the current working directory, i.e the directory based on which relative paths are resolved.

  If no operand is given then HOME environment variable is used.
  
  If the operand is - (just a single dash) then OLDPWD environment variable is used.
  
  Relative path components ./ and ../ may be used to denote the working directory and the parent directory, respectively. An operand starting with ./ is equivalent to PWD environment variable. See examples for illustrations.
  
  Lastly, cd will attempt to change the current directory to the path defined by the operand, reporting errors if any.
  
  If cd is successful, OLDPWD environment variable will also be set to the previous value of PWD (that is the current working directory immediately prior to the call to cd).

ENVIRONMENT VARIABLES
  PWD
    Parent Working Directory, the current working directory

  OLDPWD
    Old PWD, set each time the PWD is changed by calling the cd utility

  HOME
    Represents the path of the user's home directory

EXAMPLES
  cd a
    Changes to directory `a` in the current working directory

  cd /bin
    Changes to directory `/bin`, using the specified absolute path

  cd ../
    Changes to the parent directory of the current working directory

  cd -
    Changes to the previos directory, defined by OLDPWD, and set each time cd changes PWD
Fusr/man/clearñNAME
  clear - clears the terminal

SYNOPSIS
  clear

DESCRIPTION
  Clears any text from the screen, using the current background and foreground (text) colors and resets the cursor position to (1, 1).

EXAMPLES
  clear
    Clears the screen/F
usr/man/cp?NAME
  cp - copy files

SYNOPSIS
  cp SOURCE DEST
  cp SOURCE DIRECTORY

DESCRIPTION
  `cp` allows copying single files on a filesystem and across filesystems.

EXAMPLES
  cp a b
    Copy file `a` to new file `b` in the same directory.

  cp /home/a.txt /home/d/
    Copy file `/home/a.txt` to new file `/home/d/a.txt`.Fusr/man/dateCNAME
  date - get the current time and date

SYNOPSIS
  date

DESCRIPTION
  Writes the current time and date to the standard output. Note that the time is measured in in-game time, with the date starting on the 1st of January 1970 as the time the world was created.

EXAMPLES
  date
    Displays the current date and time.
F
usr/man/dfNAME
  df - report file system disk space usage

SYNOPSIS
  df [FILE]...

DESCRIPTION
  `df` outputs disk space information for the file systems containing the specified files. If no file names are given it returns the information for all currently mounted file systems.

EXAMPLES
  df
    Show global file system disk usage.

  df /home /var
    Show disk usage of file systems mounted at `/home` and `/var`.Fusr/man/dmesgNAME
  dmesg - display messages(events)
    
SYNOPIS
  dmesg [EVENT]...

EXAMPLES
  dmesg
    Shows all events.

  dmesg touch
    Shows only "touch" events.

Fusr/man/echooNAME
  echo - display a line of text

SYNOPSIS
  echo [STRING]...

DESCRIPTION
  `echo` writes the provided string(s) to the standard output.

  -n      do not output the trialing newline

  --help  display this help and exit

EXAMPLES
  echo test
    Print `test` to the standard output (which is usually the terminal).

  echo "a   b"
    Writes the string `a   b`.Fusr/man/editNAME
  edit - primitive file editor

SYNOPSIS
  edit FILE

DESCRIPTION
  A very simple text file editor. To create new files with `edit`, open a file in a writable file system that doesn't exist and save.

OPTIONS
  -r
    opens file as read only

EXAMPLES
  edit /tmp/test.txt
    Opens the file `/tmp/test.txt` for editing. If it doesn't exists, it will be created upon saving.

  edit /bin/ls.lua
    Opens the file `/bin/ls.lua`, which will be opened in read-only mode, assuming `/bin` is the default as provided by the read-only-memory.Fusr/man/grepnNAME
  grep - Search for PATTERN in each FILE or standard input. PATTERN is, by default, a Lua regular expression
  Example: grep -i 'hello world' menu.lua main.lua

OPTIONS
Regexp selection and interpretation:
  -e, --lua-regexp          PATTERN is a Lua regexp (default)
  -F, --fixed-strings       PATTERN is a plain string
      --file=FILE           use newline separated PATTERNs from FILE
  -w, --word-regexp         force PATTERN to match only whole words
  -x, --line-regexp         force PATTERN to match only whole lines
  -i, --ignore-case         ignore case distinctions

Miscellaneous:
      --label=LABEL         use LABEL instead of (standard input) for stdin prefix
  -s, --no-messages         suppress error messages
  -v, --invert-match        select non-matching lines
      --help                display help message and exit

Output control:
      --max-count=NUM       stop after NUM matches
  -n, --line-number         print line number with output lines
  -H, --with-filename       print the file name for each match
  -h, --no-filename         suppress the file name prefix on output
  -o, --only-matching       show only the part of a line matching PATTERN
  -q, --quiet, --silent     suppress all normal output
  -r, --recursive           search directories in FILEs recursively
  -L, --files-without-match print only names of FILEs containing no match
  -l, --files-with-matches  print only names of FILEs containing matches
  -c, --count               print only a count of matching lines per FILE
      --color, --colour     user markers to highlight the matching strings
  -t, --trim                trim whitespace off results

When FILE is -, read stdin. With no FILE, read - or ./ if a command line -r. If fewer than two FILEs are given, assume -h. Exit status is 0 if any line is selected, 1 otherwise. If any error occurs and -q is not given, the exit status is 2.
Fusr/man/headNAME
  head - Print the first 10 lines of each FILE to stdout.

SYNOPSIS
  head [OPTION]... [FILE]...

DESCRIPTION
  Print the first 10 lines of each FILE to stdout.
  With no FILE, or when FILE is -, read stdin.

      --bytes=[-]n        print the first n bytes of each file'
                            with the leading '-', print all but the last
                            n bytes of each file
      --lines=[-]n        print the first n lines instead of the first 10;
                            with the leading '-', print all but the last
                            n lines of each file
  -q, --quiet, --silent   never print headers giving file names
  -v, --verbose           always print headers giving file names
      --help              print help message

EXAMPLES
  head
  head -
    Read next 10 lines from standard in and print to standard out, then close.

  head file.txt
    Print first 10 lines of file.txt and print to stdout

  head -n 32 file.txt
    Print first 32 lines of file.txt and print to stdout

Fusr/man/hostnameÀNAME
  hostname - Display and modify hostname

SYNOPIS
  hostname [NEW NAME]

EXAMPLES
  hostname
    Prints currently set hostname

  hostname test
    Sets hostname of this computer to test
Fusr/man/labelòNAME
  label - show or change the label of file systems

SYNOPSIS
  label FILE [STRING]
  label -a ADDRESS [STRING]

DESCRIPTION
  `label` allows reading and writing the label of file systems. The file system can either be specified by a path to or into a mount, or by its address.

EXAMPLES
  label /home
    Write the label of the file system mounted at `/home` to the standard output.

  label -a 93f test
    Change the label of the file system of which the address starts with `93f` to `test`.F
usr/man/lnóNAME
  ln - creates symbolic links

SYNOPSIS
  ln FILE [TARGET]

DESCRIPTION
  `ln` allows creating virtual symbolic links. A symbolic link is a reference in the file system that can be used to point to other nodes in the file system. For example, a symbolic link to a file will behave like that file: it can be opened and changed, where in reality the file the link references is changed. A symbolic link to a directory will behave as such.

  Note that symbolic links can lead to cycles (recursion) in the file system structure.

  Symbolic links in OpenOS are 'virtual'. They are not stored on any file system, and as such will not persist across a reboot of the computer. This also means that the can be created in virtual folders, and even on read-only file systems.

EXAMPLES
  ln /bin/ls.lua
    Creates a symbolic link `ls.lua` to the file `/bin/ls.lua` in the current working directory.

  ln /home/magic.lua /bin/magic.lua
    Creates a symbolic link to file `/home/magic.lua` in the `/bin` directory.F
usr/man/lsANAME
  ls - list directory contents

SYNOPSIS
  ls [OPTION]... [FILE]...

DESCRIPTION
  List information about the specified files, or the current working directory by default.

OPTIONS
  -a, --all
    do not ignore entries starting with .

  --full-time
    with -l, print time in full iso format

  -h, --human-readable
    with -l and/or -s, print human readable sizes

  --si
    likewise, but use powers of 1000 not 1024

  -l
    use a long listing format

  -r, --reverse
    reverse order while sorting

  -R, --recursive
    list subdirectories recursively

  -S
    sort by file size

  -t
    sort by modification time, newest first

  -X
    sort alphabetically by entry extension

  -1
    list one file per line

  --no-color
    Do not colorize the output (default colorized)

  --help
    display this help and exit]])

  -p
    append / indicator to directories

  -M
    display Microsoft-style file and directory count after listing

ENVIRONMENT VARIABLES

  LS_COLORS
    A serialized table listing colors to use for listing filesystem elements.

    FILE
      Coloring to use when listing a regular file

    DIR
      Coloring to use when listing a directory

    LINK
      Coloring to use when listing a symbolic link

    *.<extension>
      Coloring to use for regular files with an extension <extension>

    The default LS_COLORS string is "{FILE=0xFFFFFF,DIR=0x66CCFF,LINK=0xFFAA00,["*.lua"]=0x00FF00}"

EXAMPLES
  ls
    Displays the contents of the current directory.

  ls /bin /mnt
    Displays the contents of the `/bin`/ and `/mnt` directories, one after the other.Fusr/man/luaNAME
  lua - a simple Lua interpreter

SYNOPSIS
  lua

DESCRIPTION
  Launches a command line that can be used to evaluate Lua statements and expressions. This can be very useful for testing out commands. Note that the interpreter will automatically try to resolve undefined globals using `require`, i.e. it will try to load a package with the specified name.

EXAMPLES
  lua
    Launches the Lua interpreter.Fusr/man/man×NAME
  man - help program, providing help on various programs and topics

SYNOPSIS
  man topic

DESCRIPTION
  `man` is the system's help viewer. Each help topic is normally the name of a program or library. Topics are stored as individual text files in the `/usr/man` folder. Additional help topics can be provided by creating a symbolic link to a file. 

EXAMPLES
  man man
    Display the help for the `man` program.

  man ls
    Display the help for the `ls` program.Fusr/man/mkdirkNAME
  mkdir - make directories

SYNOPSIS
  mkdir DIRECTORY...

DESCRIPTION
  Create the specified directories, if they don't already exist.

EXAMPLES
  mkdir a
    Create directory `a` in the current directory.

  mkdir /a/b c
    Create directory `/a` if it doesn't already exists, then create directory `/a/b` and create directory `c` in the current directory.Fusr/man/moreÞNAME
  more - primitive file viewer

SYNOPSIS
  more FILE

DESCRIPTION
  `more` allows viewing the contents of a file one screen full at a time.

EXAMPLES
  more /home/a.txt
    Displays the contents of file `/home/a.txt`
Fusr/man/mount1NAME
  mount - mount a file system

SYNOPSIS
  mount
  mount LABEL PATH
  mount ADDRESS PATH

DESCRIPTION
  All files accessible in OpenOS are arranged in one big tree, starting with the root node, '/'. The files are the leaves of the tree, directories are inner nodes of the tree. Files can be distributed across several devices (file system components, such as hard drives and floppies). The `mount` command is used to attach a file system to this tree. The `umount` command can be used to remove a mounted file system from the tree (note that `rm` works for this, too).

EXAMPLES
  mount
    Display a list of all currently mounted file systems.

  mount test /home
    Mounts the file system labeled `test` at `/home`.

  mount 56f /var
    Mounts the file system of which the address starts with `56f` at `/var`.F
usr/man/mvNAME
  mv - move (rename) files

SYNOPSIS
  mv SOURCE DEST

DESCRIPTION
  Renames files - and folders, as long they remain on the same file system. Files that are 'renamed' to another file system will actually be copied, then deleted.

OPTIONS
  -f
    do not prompt before overwriting

EXAMPLES
  mv a b
    Renames file `a` to `b`.

  mv /home/a /var/b
    Moves file from `/home/a` to `/var/b`.Fusr/man/pastebinNAME
  pastebin - download and upload programs from and to pastebin

SYNOPSIS
  pastebin get PASTID FILE
  pastebin put FILE
  pastebin run PASTEID [ARGUMENT]...

DESCRIPTION
  The pastebin program allows downloading programs from pastebin, identified by their paste ID. I can also be used to upload programs to pastebin.

  The pastebin program requires an internet card and internet access to be enabled in the mod's configuration.

OPTIONS
  -f
    do not prompt before overwriting

EXAMPLES
  pastebin get AbCdEfGh test
    Downloads the paste with ID `AbCdEfGh` and writes it to file `test`.

  pastebin put prog.lua
    Uploads the program `prog.lua` to pastebin.Fusr/man/primary NAME
  primary - get or set primary components

SYNOPSIS
  primary TYPE
  primary TYPE ADDRESS

DESCRIPTION
  This program allows reading the address of the current primary component of the specified type. It also allows changing the current primary component for a specified type by providing the (abbreviated) address of the new primary component.

EXAMPLES
  primary gpu
    Writes the address of the current primary GPU to the standard output.

  primary gpu 24a
    Makes the GPU of which the address starts with `24a` the new primary GPU.Fusr/man/pwdãNAME
  pwd - print name of current/working directory

SYNOPSIS
  pwd

DESCRIPTION
  `pwd` writes the name of the current working directory to the standard output.

EXAMPLES
  pwd
    Write the current directory to the terminal.F
usr/man/rcNAME
  rc - Manage services

SYNOPSIS
  rc SERVICE COMMAND [ARGS...]

DESCRIPTION
  Controls services in /etc/rc.d/
  Common commands are start/stop/restart, there are also special commands enable/disable. A command is global function in executable file that is stored in /etc/rc.d/ directory. Services can define their own commands.

COMMANDS
  start
    This command starts specified service, executed automatically for all enabled services when system boots.

  stop
    This command stops specified service.

  restart
    This command restarts specified service. This command doesn't have to be implemented by services when start and stop commands are present.

  enable
    This command enables specified service. Executing this command won't start the service. It's implemented by the rc library, but can be overridden by service.

  disable
    This command disables specified service. Executing this command won't stop the service. It's implemented by the rc library, but can be overridden by service.

EXAMPLES
  rc example
    Lists commands of example service.

  rc example start
    Starts example service.

  rc example enable
    Makes example start on system boot.
Fusr/man/rebootÙNAME
  reboot - restarts the computer

SYNOPSIS
  reboot

DESCRIPTION
  `reboot` will immediately issue a reboot of the computer, shutting it down then starting it back up.

EXAMPLES
  reboot
    Reboots the computer.Fusr/man/redstonezNAME
  redstone - access to redstone input and output

SYNOPSIS
  redstone SIDE
  redstone SIDE VALUE
  redstone SIDE -b COLOR
  redstone SIDE -b COLOR VALUE

DESCRIPTION
  This program allows manipulating redstone output of the computer via the shell, if it has a built-in redstone card or is connected to a redstone I/O block. It can also be used to just display the current in- and output. If another mod is installed that provides bundled redstone logic, such as RedLogic, MineFactory Reloaded (Rednet Cables) or Project: Red, it can also be used to interact with bundled signals by passing the `-b` flag.

OPTIONS
  -b
    interact with bundled signals

EXAMPLES
  redstone front
    Displays the simple in- and output on the front face of a computer with a redstone card.

  redstone north -b lime 200
    Sets the bundled `lime` output of a redstone I/O block's northern side to 200.Fusr/man/resolutionNAME
  resolution - get or set screen resolution

SYNOPSIS
  resolution
  resolution WIDTH HEIGHT

DESCRIPTION
  The `resolution` program is used to write the resolution of the current primary screen to the standard output, or to change the resolution to a new value.

EXAMPLES
  resolution
    Displays the current screen resolution.

  resolution 30 10
    Sets the screen's resolution to 30 by 10 characters.
F
usr/man/rmCNAME
  rm - remove files or directories

SYNOPSIS
  rm [OPTION]... FILE...

DESCRIPTION
  Removes all of the specified files, one by one. By default, it does not remove directories. To remove a mount, please use umount.

  If the -I option is given, and there are more than three files or the -r, -R, or --recursive are given, the rm prompts the user for whether to proceed with the entire operation. If the response is not affirmative, the entire command is aborted.

  Otherwise, if a file is unwritablle, standard input is a terminal, and the -f or --force option is not given, or the -i option is given, rm prompts the user for whether to remove the file. If the response is not affirmative, the file is skipped.

OPTIONS
  Remove (unlink) the FILE(s).

  -f, --force
         ignore nonexistent files and arguments, never prompt
  
  -i     prompt before every removal
  
  -I     prompt once before removing more than three files, or when removing recursively; less intrusive than -i, while still giving protection against most mistakes
  
  --one-file-system
         when removing a hierarchy recursively, skip any directory that is on a file system different from that of the corresponding command line argument

  --no-preserve-root
         do not treat '/' specially

  --preserve-root
         do not remove '/' (default)

  -r, -R, --recursive
         remove directories and their contents recursively

  -d, --dir
         remove empty directories

  -v, --verbose
         explain what is being done

  --help
         display this help and exit.

By default, rm does not remove directories.  Use the --recursive (-r or -R) option to remove each listed directory, too, along with all of its contents.

To remove a file whose name starts with a '-', for example '-foo', use this command:
  rm ./-foo

EXAMPLES
  rm a
    Deletes the file `a`.
F
usr/man/sh=NAME
  sh - command interpreter (shell)

SYNOPSIS
  sh

DESCRIPTION
  This is the basic, built-in standard shell of OpenOS. It provides basic functionality and does the job for getting started. To run a command, enter it and press enter. The first token in a command will usually be a program. Any additional parameters will be passed along to the program.

  Arguments to programs can be quoted, to provide strings with multiple spaces in them, for example:
    echo "a   b"
  will print the string `a   b` to the screen. It is also possible to use single quotes (echo 'a b').

  Single quotes also suppress variable expansion. Per default, expressions like `$NAME` and `${NAME}` are expanded using environment variables (also accessible via the `os.getenv` method).

  Basic globbing is supported, i.e. '*' and '?' are expanded approriately. For example:
    ls b?n/
  will list all files in `/bin/` (and, if it exists `/ban` and so on).
    cp /bin/* /usr/bin/
  will copy all files from `/bin` to `/usr/bin`.

  The shell provides basic redirects and piping:
    cat f > f2
  copies the contents of file `f` to `f2`, for example.
    echo 'this  is  a  "test"' >> f2
  will append the string 'this is a "test"' to the file `f2`.

  Redirects can be combined:
    cat < f >> f2
  will feed the contents of file `f` to cat, which will then output it (in append mode) to file `f2`.

  Finally, pipes can be used to pass data between programs:
    ls | cat > f
  will enumerate the files and directories in the working directory, write them to its output stream, which is cat's input stream, which will in turn write the data to file `f`.

  The shell also supports aliases, which can be created using `alias` and removed using `unalias` (or using the `shell` API). For example, `dir` is a standard alias for `ls`.

EXAMPLES
  sh
    Starts a new shell.Fusr/man/shutdownNAME
  shutdown - shut down the computer

SYNOPSIS
  shutdown

DESCRIPTION
  Immediately shuts down the computer.

EXAMPLES
  shutdown
    Stops the computer.Fusr/man/umountáNAME
  umount - remove a file system mount

SYNOPSIS
  umount PATH
  umount -a LABEL
  umount -a ADDRESS

DESCRIPTION
  Removes either a single mount point if given the path into a mount, or all mount points for a specified file system if given the label or address of the file system.

EXAMPLES
  umount /mnt/82f
    Unmounts the automatically generated mountpoint at `/mnt/82f`.

  umount -a 82f
    Removes all mounts of the file system for which the address starts with `82f`.
Fusr/man/unaliasâNAME
  unalias - removes aliases for programs

SYNOPSIS
  unalias name

DESCRIPTION
  Allows removal of aliases created with the `alias` command.

EXAMPLES
  unalias dir
    Removes the `dir` alias (usually an alias for `ls`).Fusr/man/uptimeNAME
  uptime - how long has the computer been running

SYNOPSIS
  uptime

DESCRIPTION
  Writes the time in real time hours, minutes and seconds the computer has been running to the standard output.

EXAMPLES
  uptime
    Displays the time the computer has been running.Fusr/man/useraddNAME
  useradd - adds a player to the list of authorized users

SYNOPSIS
  useradd NAME

DESCRIPTION
  Adds a player to the list of users that can use the computer. To add a player, he has to be logged in when the command is run. Note that the names are case sensitive. Users can be removed again using `userdel`.

  As long as the list of players registered on a computer is empty, the computer can be used by all players. Once there is at least one entry in the list of users, only the players in the list can use the computer. This includes modifying its inventory, performing keyboard and mouse input as well as breaking the computer block.

  Computer ownership can be disabled in the configuration.

EXAMPLES
  useradd Steve
    Adds the player named `Steve` to the list of users.Fusr/man/userdelNAME
  userdel - removes a player from the list of authorized users

SYNOPSIS
  userdel NAME

DESCRIPTION
  Removes a player from the list of users authorized to use this computer. See `useradd`.

EXAMPLES
  userdel Steve
    Removes the player named `Steve` from the userlist.Fusr/man/wgetUNAME
  wget - download files via http

SYNOPSIS
  wget URL [FILE]

DESCRIPTION
  The wget program allows downloading programs from the interwebs, given the URL to download from.

  The wget program requires an internet card and internet access to be enabled in the mod's configuration.

OPTIONS
  -f
    do not prompt before overwriting
  -q
    only print errors, no status messages

EXAMPLES
  wget http://example.com/data.zip
    Downloads the file `data.zip` and saves it as `data.zip`.

  wget http://example.com/data.zip blah.zip
    Downloads the file `data.zip` and saves it as `blah.zip`.Fusr/man/which NAME
  which - locate a command

SYNOPSIS
  which COMMAND

DESCRIPTION
  This program writes the full path to each of the specified programs to the standard output. If a program is an alias, this is indicated. If a program cannot be found and error message will be written.

EXAMPLES
  which ls
    Displays `/bin/ls.lua`.

  which doesntexist dir
    Displays `doesntexist: file not found` and `dir: aliased to ls`.Fusr/man/yesæNAME
  yes - Automatically answers yes to every question.

SYNOPSIS
  yes [string]...
  yes [-V/h]

DESCRIPTION
  Prints strings in command line arguments, if there is none, prints 'y'.
  Followed by newline, until it is killed.

  This might be used for programs which don't have force (-f) option
  and require user interaction.

EXAMPLES
  yes
    Says y on every line.

  yes no
    Says no on every line.

  yes "yes: I'm great servant, but an evil master."
    Repeats sentence.

D	usr/misc/Fusr/misc/greetings.txt	Tier 2 and 3 screens can act as touch screens - don't attach a keyboard or sneak-activate them.
You can change the text size on screens by changing their resolution - run `resolution 40 16` in the shell.
Firing arrows on touch capable screens can trigger touch events.
Item colors indicate their tier - white is tier one, yellow is tier two and cyan is tier three.
Use an Analyzer to get more information on blocks - for example, to find out why a computer crashed.
Keyboards have to be attached to or placed next to a screen to work.
You can install OpenOS on a writable medium by running the `install` program.
Internet Cards can be used to make HTTP requests and open raw TCP connections.
If you crafted something by mistake or don't need it any longer, throw it into a disassembler.
Have a look at the code of the built-in programs for examples on how to use the APIs.
Most programs can be interrupted by pressing Ctrl+Alt+C.
Paste the contents of the clipboard using the middle mouse button or a configurable key (default: insert).
Computers will consume less power while idling - i.e. when os.sleep(n > 0.05) is called.
Screens will consume more power the more lit characters they display.
Most blocks act as 'cables' - use relays and power distributors to create separate networks.
Welcome to the dark side - here, have some cookies.
Screens can display Unicode - paste the special chars or use unicode.char.
Run `help` or `man programname` for ingame help on programs shipped with OpenOS - start with `man man`.
For more help, there's a wiki at http://ocdoc.cil.li/ - or find the IRC loot disk and join #oc.
Computers have a very basic, built-in speaker - control it using computer.beep().
Many component methods have a short documentation - use `=component.componentName.methodName` in the Lua interpreter to see it.
You can get a list of all attached components using the `components` program.
If you encounter out of memory errors, throw more RAM at your computer.
Have you tried turning it off and on again?
To disable this greeting, install OpenOS to a writeable medium and delete `/etc/motd`.
Did you know OpenComputers has a forum? No? Well, it's at https://oc.cil.li/.
Please report bugs on the Github issue tracker, thank you!
Beware of cycles when building networks, or you may get duplicate messages!
Dusr/misc/greetings/Fusr/misc/greetings/English.txt	Tier 2 and 3 screens can act as touch screens - don't attach a keyboard or sneak-activate them.
You can change the text size on screens by changing their resolution - run `resolution 40 16` in the shell.
Firing arrows on touch capable screens can trigger touch events.
Item colors indicate their tier - white is tier one, yellow is tier two and cyan is tier three.
Use an Analyzer to get more information on blocks - for example, to find out why a computer crashed.
Keyboards have to be attached to or placed next to a screen to work.
You can install OpenOS on a writable medium by running the `install` program.
Internet Cards can be used to make HTTP requests and open raw TCP connections.
If you crafted something by mistake or don't need it any longer, throw it into a disassembler.
Have a look at the code of the built-in programs for examples on how to use the APIs.
Most programs can be interrupted by pressing Ctrl+Alt+C.
Paste the contents of the clipboard using the middle mouse button or a configurable key (default: insert).
Computers will consume less power while idling - i.e. when os.sleep(n > 0.05) is called.
Screens will consume more power the more lit characters they display.
Most blocks act as 'cables' - use switches and power distributers to create separate networks.
Welcome to the dark side - here, have some cookies.
Screens can display Unicode - paste the special chars or use unicode.char.
Run `help` or `man programname` for ingame help on programs shipped with OpenOS - start with `man man`.
For more help, there's a wiki at http://ocdoc.cil.li/ - or find the IRC loot disk and join #oc.
Computers have a very basic, built-in speaker - control it using computer.beep().
Many component methods have a short documentation - use `=component.componentName.methodName` in the Lua interpreter to see it.
You can get a list of all attached components using the `components` program.
If you encounter out of memory errors, throw more RAM at your computer.
Have you tried turning it off and on again?
To disable this greeting, install OpenOS to a writeable medium and delete `/etc/motd`.
Did you know OpenComputers has a forum? No? Well, it's at http://oc.cil.li/.
Please report bugs on the Github issue tracker, thank you!
Beware of cycles when building networks, or you may get duplicate messages!
Fusr/misc/greetings/Russian.txtÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ ÑÐ°Ð·Ð¼ÐµÑ ÑÐµÐºÑÑÐ° Ð½Ð° ÑÐºÑÐ°Ð½Ðµ, Ð¸Ð·Ð¼ÐµÐ½ÑÑ ÐµÐ³Ð¾ ÑÐ°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ - Ð²Ð²ÐµÐ´Ð¸ÑÐµ resolution 40 16 Ð² ÐºÐ¾Ð¼Ð¼Ð°Ð½Ð´Ð½ÑÑ ÑÑÑÐ¾ÐºÑ
Ð¡ÑÑÐµÐ»ÑÐ±Ð° ÑÑÑÐµÐ»Ð°Ð¼Ð¸ Ð½Ð° ÑÐµÐ½ÑÐ¾ÑÐ½ÑÐ¹ ÑÐºÑÐ°Ð½ Ð°ÐºÑÐ¸Ð²Ð¸ÑÑÐµÑ Ð¸Ð²ÐµÐ½Ñ touch
ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¸Ð·Ð¼ÐµÐ½Ð¸ÑÑ ÑÐ²ÐµÑ Ð²Ð°ÑÐµÐ³Ð¾ ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑÐ°, Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ° Ð¸Ð»Ð¸ ÐºÐ°Ð±ÐµÐ»Ñ Ñ Ð¿Ð¾Ð¼Ð¾ÑÑÑ Ð¾Ð±ÑÑÐ½ÑÑ ÐºÑÐ°ÑÐ¸ÑÐµÐ»ÐµÐ¹
ÐÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ ÐÐ½Ð°Ð»Ð¸Ð·Ð°ÑÐ¾Ñ, ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð»ÑÑÐ¸ÑÑ Ð±Ð¾Ð»ÑÑÐµ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð±Ð»Ð¾ÐºÐ°Ñ - Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ, ÑÑÐ¾Ð±Ñ Ð¿Ð¾Ð½ÑÑÑ, ÐºÐ°ÐºÐ¾Ð³Ð¾ ÑÑÑ ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑ Ð²ÑÐ»ÐµÑÐµÐ» Ñ Ð¾ÑÐ¸Ð±ÐºÐ¾Ð¹
Ð§ÑÐ¾Ð±Ñ Ð²ÑÑÐ°Ð²Ð¸ÑÑ ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ð¼Ð¾Ðµ Ð±ÑÑÐµÑÐ° Ð¾Ð±Ð¼ÐµÐ½Ð°, Ð½Ð°Ð¶Ð¼Ð¸ÑÐµ ÑÑÐµÐ´Ð½ÑÑ ÐºÐ½Ð¾Ð¿ÐºÑ Ð¼ÑÑÐ¸ Ð¸Ð»Ð¸ ÑÐ¿ÐµÑÐ¸Ð°Ð»ÑÐ½ÑÑ ÐºÐ¾Ð½ÑÐ¸Ð³ÑÑÐ¸ÑÑÐµÐ¼ÑÑ ÐºÐ»Ð°Ð²Ð¸ÑÑ, Ð¿Ð¾ ÑÐ¼Ð¾Ð»ÑÐ°Ð½Ð¸Ñ insert
ÐÐ¾Ð»ÑÑÐ¸Ð½ÑÑÐ²Ð¾ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼ Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑ, Ð½Ð°Ð¶Ð°Ð² Ctrl+Alt+C
Ð­ÐºÑÐ°Ð½Ñ Ð¼Ð¾Ð³ÑÑ Ð¾ÑÐ¾Ð±ÑÐ°Ð¶Ð°ÑÑ Ð®Ð½Ð¸ÐºÐ¾Ð´ - Ð²ÑÑÐ°Ð²Ð»ÑÐ¹ÑÐµ Ð½ÑÐ¶Ð½ÑÐµ ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ Ð² ÐºÐ¾Ð´ Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÐ¹ÑÐµ unicode.char()
ÐÑÐ¸ÑÐ¸Ð°Ð»ÑÐ½Ð°Ñ Ð²Ð¸ÐºÐ¸ Ð¼Ð¾Ð´Ð° Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð¿Ð¾ Ð°Ð´ÑÐµÑÑ http://ocdoc.cil.li/
Ð£ ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑÐ¾Ð² ÐµÑÑÑ Ð¿ÑÐ¾ÑÑÐµÐ½ÑÐºÐ¸Ð¹ Ð´Ð¸Ð½Ð°Ð¼Ð¸Ðº, ÐºÐ¾Ð½ÑÑÐ¾Ð»Ð¸ÑÑÐ¹ÑÐµ ÐµÐ³Ð¾ ÑÐµÑÐµÐ· computer.beep()
Ð§ÑÐ¾Ð±Ñ Ð¸Ð·Ð±Ð°Ð²Ð¸ÑÑÑÑ Ð¾Ñ ÑÑÐ¸Ñ Ð¿Ð¾Ð´ÑÐºÐ°Ð·Ð¾Ðº, ÑÐ´Ð°Ð»Ð¸ÑÐµ ÑÐ°Ð¹Ð» /etc/motd
ÐÐ·Ð±ÐµÐ³Ð°Ð¹ÑÐµ ÑÐ¸ÐºÐ»Ð¾Ð², ÑÐ¾Ð·Ð´Ð°Ð²Ð°Ñ ÑÐµÑÐ¸, Ð¸Ð½Ð°ÑÐµ Ð²Ð°ÑÐ¸ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ Ð¼Ð¾Ð³ÑÑ Ð´ÑÐ±Ð»Ð¸ÑÐ¾Ð²Ð°ÑÑÑÑ!
Dhome/F
home/.shrcSalias l="ls -lh"
alias ..="cd .."
alias df="df -h"

alias grep="grep --color"
Detc/Fetc/filesystem.cfgautorun=trueFetc/motdp#!/bin/lua

local component = require("component")
local computer = require("computer")
local text = require("text")
local unicode = require("unicode")

if not component.isAvailable("gpu") then
	return
end

local gpu = component.gpu
local xSize, ySize = gpu.getResolution()
local oldBackground = gpu.getBackground()
local oldForeground = gpu.getForeground()

local lines = { "OpenOS (customized by ECS), " .. math.floor(computer.totalMemory() / 1024) .. "KB RAM"}
local maxWidth = unicode.len(lines[1])
local f = io.open("/usr/misc/greetings/" .. _G.OSSettings.language .. ".txt")
if f then
	local greetings = {}
	pcall(function()
		for line in f:lines() do table.insert(greetings, line) end
	end)
	f:close()
	local greeting = greetings[math.random(1, #greetings)]
	if greeting then
		local width = math.max(10, component.gpu.getResolution())
		for line in text.wrappedLines(greeting, width - 4, width - 4) do
			table.insert(lines, line)
			maxWidth = math.max(maxWidth, unicode.len(line))
		end
	end
end
local borders = {{unicode.char(0x2552), unicode.char(0x2550), unicode.char(0x2555)},
								 {unicode.char(0x2502), nil, unicode.char(0x2502)},
								 {unicode.char(0x2514), unicode.char(0x2500), unicode.char(0x2518)}}


gpu.setBackground(0xcccccc)
gpu.fill(1, 1, xSize, #lines + 2, " ")

io.write(" \n")
io.write("")
gpu.setForeground(0x000000)
io.write("  " .. text.padRight(lines[1], maxWidth) .. "  \n")
table.remove(lines, 1)
gpu.setForeground(0x555555)
for _, line in ipairs(lines) do
	io.write("  " .. text.padRight(line, maxWidth) .. "  \n")
end
io.write(" \n\n")

gpu.setBackground(oldBackground)
gpu.setForeground(oldForeground)
Fetc/profileÛalias dir=ls
alias list=ls
alias move=mv
alias rename=mv
alias copy=cp
alias del=rm
alias md=mkdir
alias cls=clear
alias less=more
alias rs=redstone
alias view=edit\ -r
alias help=man
alias cp=cp\ -i

set EDITOR=/bin/edit
set HISTSIZE=10
set HOME=/
set IFS=\ 
set MANPATH=/usr/man:.
set PAGER=/bin/more
set PS1='$PWD# '
set PWD=/
set SHELL=/bin/sh 
set LS_COLORS="{FILE=0xFFFFFF,DIR=0x66CCFF,LINK=0xFFAA00,['*.lua']=0x00FF00}"

cd $HOME
clear
/etc/motd
source $HOME/.shrc -q
F
etc/rc.cfg'enabled = {}

example = "Hello World!"
D	etc/rc.d/Fetc/rc.d/example.luahlocal count = 0

function start(msg)
  print("This script displays a welcome message and counts the number " ..
  "of times it has been called. The welcome message can be set in the " ..
  "config file /etc/rc.cfg")
  print(args)
  if msg then
    print(msg)
  end
  print(count)
  print("runlevel: " .. require("computer").runlevel())
  count = count + 1
end
DMineOS/DMineOS/Applications/D"MineOS/Applications/AppMarket.app/F/MineOS/Applications/AppMarket.app/AppMarket.lua8o
-- package.loaded.GUI = nil
-- _G.GUI = nil

local advancedLua = require("advancedLua")
local buffer = require("doubleBuffering")
local MineOSCore = require("MineOSCore")
local image = require("image")
local GUI = require("GUI")
local fs = require("filesystem")
local component = require("component")
local unicode = require("unicode")
local event = require("event")
local ecs = require("ECSAPI")

------------------------------------------------------------------------------------------------------------------

local obj = {}
local sizes = {}
local colors = {
	main = 0xFFFFFF,
	topBar = 0xDDDDDD,
	topBarText = 0x555555,
	topBarElement = 0xCCCCCC,
	topBarElementText = 0x555555,
	statusBar = 0xDDDDDD,
	statusBarText = 0x888888,
	appName = 0x262626,
	version = 0x555555,
	description = 0x888888,
	downloadButton = 0xAAAAAA,
	downloadButtonText = 0xFFFFFF,
	downloading = 0x009240,
	downloadingText = 0xFFFFFF,
	downloaded = 0xCCCCCC,
	downloadedText = 0xFFFFFF,
}

local typeFilters = {
	"Application",
	"Library",
	"Wallpaper",
	"Script",
}

local localization = table.fromFile("MineOS/Applications/AppMarket.app/Resources/Localization/" .. _G.OSSettings.language .. ".lang")
local appMarketConfigPath = "MineOS/System/AppMarket/"
local pathToApplications = "MineOS/System/OS/Applications.txt"
local pathToNewApplications = appMarketConfigPath .. "NewApplications.txt"
local updateImage = image.load(MineOSCore.paths.icons .. "Update.pic")
local topBarElements = {localization.applications, localization.libraries, localization.wallpapers, localization.other, localization.updates}
local oldApplications, newApplications, currentApps, changes = {}, {}, {}, {}

local currentTopBarElement = 1
local from, limit, fromY = 1, 8

------------------------------------------------------------------------------------------------------------------

local function correctDouble(number)
	return string.format("%.2f", number)
end

local function status(text)
	text = unicode.sub(text, 1, sizes.width - 2)
	local y = sizes.y + sizes.height - 1
	buffer.square(sizes.x, y, sizes.width, 1, colors.statusBar, colors.statusBarText, " ")
	buffer.text(sizes.x + 1, y, colors.statusBarText, text)
	buffer.draw()
end

local function calculateSizes()
	sizes.width, sizes.height = math.floor(buffer.screen.width * 0.6), math.floor(buffer.screen.height * 0.7)
	sizes.x, sizes.y = math.floor(buffer.screen.width / 2 - sizes.width / 2), math.floor(buffer.screen.height / 2 - sizes.height / 2)
	sizes.topBarHeight = 3
	obj.main = GUI.object(sizes.x, sizes.y + sizes.topBarHeight, sizes.width, sizes.height - sizes.topBarHeight)
	sizes.downloadButtonWidth = 17
	sizes.descriptionTruncateSize = sizes.width - 6 - MineOSCore.iconWidth - sizes.downloadButtonWidth
	sizes.searchFieldWidth = math.floor(sizes.width * 0.3)
	obj.searchTextField = GUI.inputTextBox(math.floor(sizes.x + sizes.width / 2 - sizes.searchFieldWidth / 2), 1, sizes.searchFieldWidth, 1, 0xEEEEEE, 0x555555, 0xEEEEEE, 0x262626, "", localization.search, true)
end

local function drawTopBar()
	obj.topBarButtons = GUI.tabBar(sizes.x, sizes.y, sizes.width, sizes.topBarHeight, 2, colors.topBar, colors.topBarText, colors.topBarElement, colors.topBarElementText, table.unpack(topBarElements))
	obj.topBarButtons.selectedTab = currentTopBarElement
	obj.topBarButtons:draw()
	obj.windowActionButtons = GUI.windowActionButtons(sizes.x + 1, sizes.y):draw()
end

local function getIcon(url)
	local success, response = ecs.internetRequest(url)
	local path = appMarketConfigPath .. "TempIcon.pic"
	if success then
		local file = io.open(path, "w")
		file:write(response)
		file:close()
	else
		GUI.error(tostring(response), {title = {color = 0xFFDB40, text = localization.errorWhileLoadingIcon}})
	end
	return image.load(path)
end

local function getDescription(url)
	local success, response = ecs.internetRequest(url)
	if success then
		return response
	else
		GUI.error(tostring(response), {title = {color = 0xFFDB40, text = localization.errorWhileLoadingDescription}})
	end
end

local function getApplication(i)
	currentApps[i] = {}
	currentApps[i].name = fs.name(newApplications[i].name)

	if newApplications[i].icon then
		currentApps[i].icon = getIcon(newApplications.GitHubUserURL .. newApplications[i].icon)
	else
		if newApplications[i].type == "Application" then
			currentApps[i].icon = failureIcon
		elseif newApplications[i].type == "Wallpaper" then
			currentApps[i].icon = MineOSCore.icons.image
		elseif newApplications[i].type == "Library" then
			currentApps[i].icon = MineOSCore.icons.lua
		else
			currentApps[i].icon = MineOSCore.icons.script
		end
	end

	if newApplications[i].about then
		currentApps[i].description = getDescription(newApplications.GitHubUserURL .. newApplications[i].about .. _G.OSSettings.language .. ".txt")
		currentApps[i].description = string.wrap({currentApps[i].description}, sizes.descriptionTruncateSize )
	else
		currentApps[i].description = {localization.descriptionNotAvailable}
	end

	if newApplications[i].version then
		currentApps[i].version = localization.version .. correctDouble(newApplications[i].version)
	else
		currentApps[i].version = localization.versionNotAvailable
	end
end

local function checkAppExists(name, type)
	if type == "Application" then
		name = name .. ".app"
	end
	return fs.exists(name)
end

local function drawApplication(x, y, i, doNotDrawButton)
	buffer.image(x, y, currentApps[i].icon)
	buffer.text(x + 10, y, colors.appName, currentApps[i].name)
	buffer.text(x + 10, y + 1, colors.version, currentApps[i].version)
	local appExists = checkAppExists(newApplications[i].name, newApplications[i].type)
	local text = appExists and localization.update or localization.download
	
	if not doNotDrawButton then
		local xButton, yButton = sizes.x + sizes.width - sizes.downloadButtonWidth - 2, y + 1
		if currentApps[i].buttonObject then
			currentApps[i].buttonObject.x, currentApps[i].buttonObject.y = xButton, yButton
			currentApps[i].buttonObject:draw()
		else
			currentApps[i].buttonObject = GUI.button(xButton, yButton, sizes.downloadButtonWidth, 1, colors.downloadButton, colors.downloadButtonText, 0x555555, 0xFFFFFF, text):draw()
		end
	end

	for j = 1, #currentApps[i].description do
		buffer.text(x + 10, y + j + 1, colors.description, currentApps[i].description[j])
	end
	y = y + (#currentApps[i].description > 2 and #currentApps[i].description - 2 or 0)
	y = y + 5

	return x, y
end

local function drawPageSwitchButtons(y)
	local text = localization.applicationsFrom .. from .. localization.applicationsTo .. from + limit - 1
	local textLength = unicode.len(text)
	local buttonWidth = 5
	local width = buttonWidth * 2 + textLength + 2
	local x = math.floor(sizes.x + sizes.width / 2 - width / 2)
	obj.prevPageButton = GUI.button(x, y, buttonWidth, 1, colors.downloadButton, colors.downloadButtonText, 0x262626, 0xFFFFFF, "<"):draw()
	x = x + obj.prevPageButton.width + 1
	buffer.text(x, y, colors.version, text)
	x = x + textLength + 1
	obj.nextPageButton = GUI.button(x, y, buttonWidth, 1, colors.downloadButton, colors.downloadButtonText, 0x262626, 0xFFFFFF, ">"):draw()
end

local function clearMainZone()
	buffer.square(sizes.x, obj.main.y, sizes.width, obj.main.height, 0xFFFFFF)
end

local function drawMain(refreshData)
	clearMainZone()
	local x, y = sizes.x + 2, fromY

	buffer.setDrawLimit(sizes.x, obj.main.y, sizes.width, obj.main.height)

	obj.searchTextField.y, obj.searchTextField.isHidden = y, false
	obj.searchTextField:draw()
	y = y + 2

	local matchCount = 1
	for i = 1, #newApplications do
		if newApplications[i].type == typeFilters[currentTopBarElement] then
			if obj.searchTextField.text == "" or (string.find(unicode.lower(fs.name(newApplications[i].name)), unicode.lower(obj.searchTextField.text))) then
				if matchCount >= from and matchCount <= from + limit - 1 then
					if refreshData and not currentApps[i] then
						status(localization.downloadingInfoAboutApplication .. " \"" .. newApplications[i].name .. "\"")
						getApplication(i)
					end
					x, y = drawApplication(x, y, i)
				end
				matchCount = matchCount + 1
			end
		end
	end

	if matchCount > limit then
		drawPageSwitchButtons(y)
	end

	buffer.resetDrawLimit()
end

local function getNewApplications()
	ecs.getFileFromUrl(oldApplications.GitHubApplicationListURL, pathToNewApplications)
	newApplications = table.fromFile(pathToNewApplications)
end

local function getChanges()
	changes = {}
	for j = 1, #newApplications do
		local matchFound = false
		for i = 1, #oldApplications do	
			if oldApplications[i].name == newApplications[j].name then
				if oldApplications[i].version < newApplications[j].version then table.insert(changes, j) end
				matchFound = true
				break
			end
		end
		if not matchFound then table.insert(changes, j) end
	end
end

local function updates()
	clearMainZone()

	obj.searchTextField.isHidden = true

	if #changes > 0 then
		buffer.setDrawLimit(sizes.x, obj.main.y, sizes.width, obj.main.height)
		local x, y = sizes.x + 2, fromY
		obj.updateAllButton = GUI.button(math.floor(sizes.x + sizes.width / 2 - sizes.downloadButtonWidth / 2), y, 20, 1, colors.downloadButton, colors.downloadButtonText, 0x555555, 0xFFFFFF, "ÐÐ±Ð½Ð¾Ð²Ð¸ÑÑ Ð²ÑÐµ"):draw()
		y = y + 2

		for i = from, (from + limit) do
			if not changes[i] then break end
			if not currentApps[changes[i]] then
				status(localization.downloadingInfoAboutApplication .. " \"" .. fs.name(newApplications[changes[i]].name) .. "\"")
				getApplication(changes[i])
			end
			x, y = drawApplication(x, y, changes[i], true)
		end

		if #changes > limit then
			drawPageSwitchButtons(y)
		end
		buffer.resetDrawLimit()
	else
		local text = localization.youHaveNewestApps
		buffer.text(math.floor(sizes.x + sizes.width / 2 - unicode.len(text) / 2), math.floor(obj.main.y + obj.main.height / 2 - 1), colors.description, text)
	end
end

local function flush()
	fromY = obj.main.y + 1
	from = 1
	currentApps = {}
end

local function loadOldApplications()
	oldApplications = table.fromFile(pathToApplications)
end

local function saveOldApplications()
	table.toFile(pathToApplications, oldApplications)
end

local function drawAll(refreshIcons, force)
	drawTopBar()
	if currentTopBarElement == 5 then
		updates()
	else
		drawMain(refreshIcons)
	end
	buffer.draw(force)
end

local function updateImageWindow()
	clearMainZone()
	local x, y = math.floor(sizes.x + sizes.width / 2 - updateImage.width / 2), math.floor(obj.main.y + obj.main.height / 2 - updateImage.height / 2 - 2)
	buffer.image(x, y, updateImage)
	return y + updateImage.height
end

local function updateImageWindowWithText(text)
	local y = updateImageWindow() + 2
	local x = math.floor(sizes.x + sizes.width / 2 - unicode.len(text) / 2)
	buffer.text(x, y, colors.description, text)
end

local function updateAll()
	local y = updateImageWindow()
	local barWidth = math.floor(sizes.width * 0.6)
	local xBar = math.floor(sizes.x + sizes.width / 2 - barWidth / 2)
	y = y + 2
	for i = 1, #changes do
		local text = localization.updating .. " " .. fs.name(newApplications[changes[i]].name)
		local xText = math.floor(sizes.x + sizes.width / 2 - unicode.len(text) / 2)
		buffer.square(sizes.x, y + 1, sizes.width, 1, 0xFFFFFF)
		buffer.text(xText, y + 1, colors.description, text)
		GUI.progressBar(xBar, y, barWidth, 0x0092FF, 0xCCCCCC, 0x0, math.ceil(i / #changes * 100), true, false):draw()
		buffer.draw()
		ecs.getOSApplication(newApplications[changes[i]], true)
	end
	changes = {}
	oldApplications = newApplications
	saveOldApplications()
	fs.remove(pathToNewApplications)
	require("computer").shutdown(true)
end

------------------------------------------------------------------------------------------------------------------

-- buffer.start()
-- buffer.clear(0xFF8888)

local args = {...}
if args[1] == "updateCheck" then
	currentTopBarElement = 5
end

fs.makeDirectory(appMarketConfigPath)
calculateSizes()
flush()
loadOldApplications()
drawTopBar()
GUI.windowShadow(sizes.x, sizes.y, sizes.width, sizes.height, 50)
updateImageWindowWithText(localization.downloadingApplicationsList)
buffer.draw()
getNewApplications()
getChanges()
drawAll(true, false)

while true do
	local e = {event.pull()}
	if e[1] == "touch" then

		if obj.main:isClicked(e[3], e[4]) then
			if obj.searchTextField:isClicked(e[3], e[4]) then
				obj.searchTextField:input()
				flush()
				drawAll(true, false)
			end

			if currentTopBarElement < 5 then
				for appIndex, app in pairs(currentApps) do
					if app.buttonObject:isClicked(e[3], e[4]) then
						app.buttonObject:pressAndRelease(0.3)
						if app.buttonObject.text == localization.update or app.buttonObject.text == localization.download then
							app.buttonObject.text = localization.downloading
							app.buttonObject.disabled = true
							app.buttonObject.colors.disabled.button, app.buttonObject.colors.disabled.text = colors.downloading, colors.downloadingText
							app.buttonObject:draw()
							buffer.draw()
							ecs.getOSApplication(newApplications[appIndex], true)
							app.buttonObject.text = localization.downloaded
							app.buttonObject.colors.disabled.button, app.buttonObject.colors.disabled.text = colors.downloaded, colors.downloadedText
							app.buttonObject:draw()
							buffer.draw()
						end
						break
					end	
				end
			else
				if obj.updateAllButton and obj.updateAllButton:isClicked(e[3], e[4]) then
					obj.updateAllButton:pressAndRelease()
					updateAll()
					flush()
					drawAll()
				end
			end

			if obj.nextPageButton then
				if obj.nextPageButton:isClicked(e[3], e[4]) then
					obj.nextPageButton:pressAndRelease()
					fromY = obj.main.y + 1
					from = from + limit
					currentApps = {}
					drawAll(true, false)
				elseif obj.prevPageButton:isClicked(e[3], e[4]) then
					if from > limit then
						fromY = obj.main.y + 1
						from = from - limit
						currentApps = {}
						drawAll(true, false)
					end
				end
			end
		end


		if obj.windowActionButtons.close:isClicked(e[3], e[4]) then
			obj.windowActionButtons.close:pressAndRelease()
			return
		end

		for key, button in pairs(obj.topBarButtons.tabs.children) do
			if button:isClicked(e[3], e[4]) then
				currentTopBarElement = key
				flush()
				drawAll(true, false)
				break
			end
		end
	elseif e[1] == "scroll" then
		if e[5] == 1 then
			if (fromY < obj.main.y) then
				fromY = fromY + 2
				drawAll(false, false)
			end
		else
			fromY = fromY - 2
			drawAll(false, false)
		end
	end
end








D,MineOS/Applications/AppMarket.app/Resources/D2MineOS/Applications/AppMarket.app/Resources/About/F=MineOS/Applications/AppMarket.app/Resources/About/Russian.txt.ÐÐ´Ð½Ð¾ Ð¸Ð· Ð³Ð»Ð°Ð²Ð½ÑÑ ÑÐ¸ÑÑÐµÐ¼Ð½ÑÑ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑÐµÐµ Ð¿ÑÐ¾Ð²ÐµÑÑÑÑ Ð½Ð°Ð»Ð¸ÑÐ¸Ðµ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÑ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹, Ð° ÑÐ°ÐºÐ¶Ðµ Ð·Ð°Ð³ÑÑÐ¶Ð°ÑÑ ÐºÑÐ°ÑÐ¸Ð²ÐµÐ¹ÑÐ¸Ðµ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ, ÑÐ¾Ð·Ð´Ð°Ð½Ð½ÑÐµ ÑÐ¿ÐµÑÐ¸Ð°Ð»ÑÐ½Ð¾ Ð´Ð»Ñ MineOS.F4MineOS/Applications/AppMarket.app/Resources/Icon.pic§OCIFAÿSâF¬B  YSâFÖB  YFÕB  YS F B  YYYSâF×B  YSâFÖB  YFÕB  YSâ¬FÖB  YFÕB  YD9MineOS/Applications/AppMarket.app/Resources/Localization/FEMineOS/Applications/AppMarket.app/Resources/Localization/English.langü{
	applications = "Applications",
	libraries = "Libraries",
	wallpapers = "Wallpapers",
	other = "Other",
	updates = "Updates",
	downloadingApplicationsList = "Downloading applications list",
	version = "Version: ",
	descriptionNotAvailable = "No description",
	versionNotAvailable = "No version",
	update = "Update",
	download = "Install",
	downloading = "Installing",
	downloaded = "Installed",
	search = "Search",
	errorWhileLoadingIcon = "Error while downloading icon",
	errorWhileLoadingDescription = "Error while downloading description",
	applicationsFrom = "Application from ",
	applicationsTo = " to ",
	youHaveNewestApps = "You have no updates.",
	downloadingInfoAboutApplication = "Downloading information about application",
	updating = "Installing",
}FEMineOS/Applications/AppMarket.app/Resources/Localization/Russian.lang{
	applications = "ÐÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ",
	libraries = "ÐÐ¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸",
	wallpapers = "ÐÐ±Ð¾Ð¸",
	other = "ÐÑÑÐ³Ð¾Ðµ",
	updates = "ÐÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ",
	downloadingApplicationsList = "ÐÐ°Ð³ÑÑÐ·ÐºÐ° ÑÐ¿Ð¸ÑÐºÐ° Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹",
	version = "ÐÐµÑÑÐ¸Ñ: ",
	descriptionNotAvailable = "ÐÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¾ÑÑÑÑÑÑÐ²ÑÐµÑ",
	versionNotAvailable = "ÐÐµÑÑÐ¸Ñ Ð½Ðµ ÑÐºÐ°Ð·Ð°Ð½Ð°",
	update = "ÐÐ±Ð½Ð¾Ð²Ð¸ÑÑ",
	download = "ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ",
	downloading = "ÐÐ°Ð³ÑÑÐ·ÐºÐ°",
	downloaded = "Ð£ÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾",
	search = "ÐÐ¾Ð¸ÑÐº",
	errorWhileLoadingIcon = "ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð·Ð°Ð³ÑÑÐ·ÐºÐµ Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ",
	errorWhileLoadingDescription = "ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð·Ð°Ð³ÑÑÐ·ÐºÐµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ñ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ",
	applicationsFrom = "ÐÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ Ñ ",
	applicationsTo = " Ð¿Ð¾ ",
	youHaveNewestApps = "Ð£ Ð²Ð°Ñ ÑÐ°Ð¼Ð¾Ðµ Ð½Ð¾Ð²Ð¾Ðµ ÐÐ",
	downloadingInfoAboutApplication = "ÐÐ°Ð³ÑÑÐ·ÐºÐ° Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¸",
	updating = "ÐÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ",
}D%MineOS/Applications/MineCode IDE.app/F5MineOS/Applications/MineCode IDE.app/MineCode IDE.luaå
---------------------------------------------------- Libraries ----------------------------------------------------

-- "/MineOS/Applications/MineCode IDE.app/MineCode IDE.lua" open OS.lua

-- package.loaded.syntax = nil
-- package.loaded.ECSAPI = nil
-- package.loaded.GUI = nil
-- package.loaded.windows = nil
-- package.loaded.MineOSCore = nil

require("advancedLua")
local computer = require("computer")
local component = require("component")
local fs = require("filesystem")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local windows = require("windows")
local MineOSCore = require("MineOSCore")
local event = require("event")
local syntax = require("syntax")
local unicode = require("unicode")
local ecs = require("ECSAPI")
local image = require("image")
local keyboard = require("keyboard")
local palette = require("palette")
local term = require("term")

---------------------------------------------------- Constants ----------------------------------------------------

local args = {...}

local about = {
	"MineCode IDE",
	"Copyright Â© 2014-2017 ECS Inc.",
	" ",
	"Developers:",
	" ",
	"Timofeev Igor, vk.com/id7799889",
	"Trifonov Gleb, vk.com/id88323331",
	" ",
	"Testers:",
	" ",
	"Semyonov Semyon, vk.com/id92656626",
	"Prosin Mihail, vk.com/id75667079",
	"Shestakov Timofey, vk.com/id113499693",
	"Bogushevich Victoria, vk.com/id171497518",
	"Vitvitskaya Yana, vk.com/id183425349",
	"Golovanova Polina, vk.com/id226251826",
}

local config = {
	syntaxColorScheme = syntax.colorScheme,
	scrollSpeed = 8,
	cursorColor = 0x00A8FF,
	cursorSymbol = "â",
	cursorBlinkDelay = 0.5,
	doubleClickDelay = 0.4,
	screenScale = 1,
	enableAutoBrackets = true,
	highlightLuaSyntax = true,
}

local colors = {
	topToolBar = 0xDDDDDD,
	bottomToolBar = {
		background = 0x3C3C3C,
		buttons = 0x2D2D2D,
		buttonsText = 0xFFFFFF,
	},
	topMenu = {
		backgroundColor = 0xEEEEEE,
		textColor = 0x444444,
		backgroundPressedColor = 0x3366CC,
		textPressedColor = 0xFFFFFF,
	},
	title = {
		default = {
			sides = 0x555555,
			background = 0x3C3C3C,
			text = 0xEEEEEE,
		},
		onError = {
			sides = 0xCC4940,
			background = 0x880000,
			text = 0xEEEEEE,
		},
	},
	leftTreeView = {
		background = 0xCCCCCC,
	},
	highlights = {
		onError = 0xFF4940,
		onBreakpoint = 0x990000,
	}
}

local possibleBrackets = {
	openers = {
		["{"] = "}",
		["["] = "]",
		["("] = ")",
		["\""] = "\"",
		["\'"] = "\'"
	},
	closers = {
		["}"] = "{",
		["]"] = "[",
		[")"] = "(",
		["\""] = "\"",
		["\'"] = "\'"
	}
}

local cursor = {
	position = {
		symbol = 1,
		line = 1
	},
	blinkState = false
}

local resourcesPath = MineOSCore.getCurrentApplicationResourcesDirectory() 
local configPath = resourcesPath .. "Config.cfg"
local localization = MineOSCore.getLocalization(resourcesPath .. "Localization/")
local findStartFrom
local clipboard
local lastErrorLine
local breakpointLine = 5
local lastClickUptime = computer.uptime()
local mainWindow = {}

---------------------------------------------------- Functions ----------------------------------------------------

local function saveConfig()
	table.toFile(configPath, config)
end

local function loadConfig()
	if fs.exists(configPath) then
		config = table.fromFile(configPath)
		syntax.colorScheme = config.syntaxColorScheme
	else
		saveConfig()
	end
end

local function calculateSizes()
	mainWindow.width, mainWindow.height = buffer.screen.width, buffer.screen.height
	mainWindow.leftTreeView.width = math.floor(mainWindow.width * 0.16)

	if mainWindow.leftTreeView.isHidden then
		mainWindow.codeView.localPosition.x, mainWindow.codeView.width = 1, mainWindow.width
		mainWindow.bottomToolBar.localPosition.x, mainWindow.bottomToolBar.width = mainWindow.codeView.localPosition.x, mainWindow.codeView.width
	else
		mainWindow.codeView.localPosition.x, mainWindow.codeView.width = mainWindow.leftTreeView.width + 1, mainWindow.width - mainWindow.leftTreeView.width
		mainWindow.bottomToolBar.localPosition.x, mainWindow.bottomToolBar.width = mainWindow.codeView.localPosition.x, mainWindow.codeView.width
	end

	if mainWindow.topToolBar.isHidden then
		mainWindow.leftTreeView.localPosition.y, mainWindow.leftTreeView.height = 2, mainWindow.height - 1
		mainWindow.codeView.localPosition.y, mainWindow.codeView.height = 2, mainWindow.height - 1
		mainWindow.errorMessage.localPosition.y = 2
	else
		mainWindow.leftTreeView.localPosition.y, mainWindow.leftTreeView.height = 5, mainWindow.height - 4
		mainWindow.codeView.localPosition.y, mainWindow.codeView.height = 5, mainWindow.height - 4
		mainWindow.errorMessage.localPosition.y = 5
	end

	if mainWindow.bottomToolBar.isHidden then

	else
		mainWindow.codeView.height = mainWindow.codeView.height - 3
	end

	mainWindow.settingsContainer.width, mainWindow.settingsContainer.height = mainWindow.width, mainWindow.height
	mainWindow.settingsContainer.backgroundPanel.width, mainWindow.settingsContainer.backgroundPanel.height = mainWindow.settingsContainer.width, mainWindow.settingsContainer.height

	mainWindow.bottomToolBar.localPosition.y = mainWindow.height - 2
	mainWindow.bottomToolBar.findButton.localPosition.x = mainWindow.bottomToolBar.width - mainWindow.bottomToolBar.findButton.width + 1
	mainWindow.bottomToolBar.inputTextBox.width = mainWindow.bottomToolBar.width - mainWindow.bottomToolBar.inputTextBox.localPosition.x - mainWindow.bottomToolBar.findButton.width + 1

	mainWindow.topToolBar.width, mainWindow.topToolBar.backgroundPanel.width = mainWindow.width, mainWindow.width
	mainWindow.titleTextBox.width = math.floor(mainWindow.topToolBar.width * 0.32)
	mainWindow.titleTextBox.localPosition.x = math.floor(mainWindow.topToolBar.width / 2 - mainWindow.titleTextBox.width / 2)
	mainWindow.runButton.localPosition.x = mainWindow.titleTextBox.localPosition.x - mainWindow.runButton.width - 2
	mainWindow.toggleSyntaxHighlightingButton.localPosition.x = mainWindow.runButton.localPosition.x - mainWindow.toggleSyntaxHighlightingButton.width - 2
	mainWindow.addBreakpointButton.localPosition.x = mainWindow.toggleSyntaxHighlightingButton.localPosition.x - mainWindow.addBreakpointButton.width - 2
	mainWindow.toggleLeftToolBarButton.localPosition.x = mainWindow.titleTextBox.localPosition.x + mainWindow.titleTextBox.width + 2
	mainWindow.toggleBottomToolBarButton.localPosition.x = mainWindow.toggleLeftToolBarButton.localPosition.x + mainWindow.toggleLeftToolBarButton.width + 2
	mainWindow.toggleTopToolBarButton.localPosition.x = mainWindow.toggleBottomToolBarButton.localPosition.x + mainWindow.toggleBottomToolBarButton.width + 2

	mainWindow.RAMUsageProgressBar.localPosition.x = mainWindow.toggleTopToolBarButton.localPosition.x + mainWindow.toggleTopToolBarButton.width + 3
	mainWindow.RAMUsageProgressBar.width = mainWindow.topToolBar.width - mainWindow.RAMUsageProgressBar.localPosition.x - 3

	mainWindow.errorMessage.localPosition.x, mainWindow.errorMessage.width = mainWindow.titleTextBox.localPosition.x, mainWindow.titleTextBox.width
	mainWindow.errorMessage.backgroundPanel.width, mainWindow.errorMessage.errorTextBox.width = mainWindow.errorMessage.width, mainWindow.errorMessage.width - 4

	mainWindow.topMenu.width = mainWindow.width
end

local function changeScale(newScale)
	buffer.changeResolution(ecs.getScaledResolution(newScale))
	calculateSizes()
	mainWindow:draw()
	buffer.draw()
	config.screenScale = newScale
end

local function scalePlus()
	if config.screenScale > 0.3 then changeScale(config.screenScale - 0.1); saveConfig() end
end

local function scaleMinus()
	if config.screenScale < 1 then changeScale(config.screenScale + 0.1); saveConfig() end
end

local function updateTitle()
	if not mainWindow.topToolBar.isHidden then
		if mainWindow.errorMessage.isHidden then
			mainWindow.titleTextBox.lines[1] = string.limit(localization.file .. ": " .. (mainWindow.leftTreeView.currentFile or localization.none), mainWindow.titleTextBox.width - 4)
			mainWindow.titleTextBox.lines[2] = string.limit(localization.cursor .. cursor.position.line .. localization.line .. cursor.position.symbol .. localization.symbol, mainWindow.titleTextBox.width - 4)
			if mainWindow.codeView.selections[1] then
				local countOfSelectedLines = mainWindow.codeView.selections[1].to.line - mainWindow.codeView.selections[1].from.line + 1
				local countOfSelectedSymbols
				if mainWindow.codeView.selections[1].from.line == mainWindow.codeView.selections[1].to.line then
					countOfSelectedSymbols = unicode.len(unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol))
				else
					countOfSelectedSymbols = unicode.len(unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, -1))
					for line = mainWindow.codeView.selections[1].from.line + 1, mainWindow.codeView.selections[1].to.line - 1 do
						countOfSelectedSymbols = countOfSelectedSymbols + unicode.len(mainWindow.codeView.lines[line])
					end
					countOfSelectedSymbols = countOfSelectedSymbols + unicode.len(unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], 1, mainWindow.codeView.selections[1].to.symbol))
				end
				mainWindow.titleTextBox.lines[3] = string.limit(localization.selection .. countOfSelectedLines .. localization.lines .. countOfSelectedSymbols .. localization.symbols, mainWindow.titleTextBox.width - 4)
			else
				mainWindow.titleTextBox.lines[3] = string.limit(localization.selection .. localization.none, mainWindow.titleTextBox.width - 4)
			end
		else
			mainWindow.titleTextBox.lines[1], mainWindow.titleTextBox.lines[3] = " ", " "
			if breakpointLine then
				mainWindow.titleTextBox.lines[2] = localization.debugging .. cursor.position.line
			else
				mainWindow.titleTextBox.lines[2] = localization.runtimeError
			end
		end
	end
end

local function calculateErrorMessageSizeAndBeep()
	mainWindow.errorMessage.height = 2 + #mainWindow.errorMessage.errorTextBox.lines
	mainWindow.errorMessage.backgroundPanel.height = mainWindow.errorMessage.height
	mainWindow.errorMessage.errorTextBox.height = mainWindow.errorMessage.height - 2

	updateTitle()
	mainWindow:draw()
	buffer.draw()

	for i = 1, 3 do component.computer.beep(1500, 0.08) end
end

local function showBreakpointMessage(variables)
	mainWindow.titleTextBox.colors.background, mainWindow.titleTextBox.colors.text = colors.title.onError.background, colors.title.onError.text
	mainWindow.errorMessage.isHidden = false

	mainWindow.errorMessage.errorTextBox:setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
	mainWindow.errorMessage.errorTextBox.lines = {}

	for variable, value in pairs(variables) do
		table.insert(mainWindow.errorMessage.errorTextBox.lines, variable .. " = " .. value)
	end

	if #mainWindow.errorMessage.errorTextBox.lines > 0 then
		table.insert(mainWindow.errorMessage.errorTextBox.lines, 1, " ")
		table.insert(mainWindow.errorMessage.errorTextBox.lines, 1, {text = localization.variables, color = 0x0})
	else
		table.insert(mainWindow.errorMessage.errorTextBox.lines, 1, {text = localization.variablesNotAvailable, color = 0x0})
	end

	calculateErrorMessageSizeAndBeep()
end

local function showErrorMessage(text)
	mainWindow.titleTextBox.colors.background, mainWindow.titleTextBox.colors.text = colors.title.onError.background, colors.title.onError.text
	mainWindow.errorMessage.isHidden = false

	mainWindow.errorMessage.errorTextBox:setAlignment(GUI.alignment.horizontal.left, GUI.alignment.vertical.top)
	mainWindow.errorMessage.errorTextBox.lines = string.wrap({text}, mainWindow.errorMessage.errorTextBox.width)	
	
	calculateErrorMessageSizeAndBeep()
end

local function hideErrorMessage()
	mainWindow.titleTextBox.colors.background, mainWindow.titleTextBox.colors.text = colors.title.default.background, colors.title.default.text
	mainWindow.errorMessage.isHidden = true
end

local function hideSettingsContainer()
	for childIndex = 2, #mainWindow.settingsContainer.children do mainWindow.settingsContainer.children[childIndex] = nil end
	mainWindow.settingsContainer.isHidden = true
	mainWindow:draw()
	buffer.draw()
end

local function clearHighlights()
	if lastErrorLine then
		mainWindow.codeView.highlights[lastErrorLine] = nil
		lastErrorLine = nil
	end

	if breakpointLine then
		mainWindow.codeView.highlights[breakpointLine] = nil
		breakpointLine = nil
	end
end

local function clearSelection()
	mainWindow.codeView.selections[1] = nil
end

local function fixFromLineByCursorPosition()
	if mainWindow.codeView.fromLine > cursor.position.line then
		mainWindow.codeView.fromLine = cursor.position.line
	elseif mainWindow.codeView.fromLine + mainWindow.codeView.height - 2 < cursor.position.line then
		mainWindow.codeView.fromLine = cursor.position.line - mainWindow.codeView.height + 2
	end
end

local function fixFromSymbolByCursorPosition()
	if mainWindow.codeView.fromSymbol > cursor.position.symbol then
		mainWindow.codeView.fromSymbol = cursor.position.symbol
	elseif mainWindow.codeView.fromSymbol + mainWindow.codeView.codeAreaWidth - 3 < cursor.position.symbol then
		mainWindow.codeView.fromSymbol = cursor.position.symbol - mainWindow.codeView.codeAreaWidth + 3
	end
end

local function fixCursorPosition(symbol, line)
	if line < 1 then
		line = 1
	elseif line > #mainWindow.codeView.lines then
		line = #mainWindow.codeView.lines
	end

	local lineLength = unicode.len(mainWindow.codeView.lines[line])
	if symbol < 1 or lineLength == 0 then
		symbol = 1
	elseif symbol > lineLength then
		symbol = lineLength + 1
	end

	return symbol, line
end

local function setCursorPosition(symbol, line)
	cursor.position.symbol, cursor.position.line = fixCursorPosition(symbol, line)
	fixFromLineByCursorPosition()
	fixFromSymbolByCursorPosition()
	clearHighlights()
	hideErrorMessage()
end

local function setCursorPositionAndClearSelection(symbol, line)
	setCursorPosition(symbol, line)
	clearSelection()
end

local function convertScreenCoordinatesToCursorPosition(x, y)
	return x - mainWindow.codeView.codeAreaPosition + mainWindow.codeView.fromSymbol - 1, y - mainWindow.codeView.y + mainWindow.codeView.fromLine
end

local function isClickedOnCodeArea(x, y)
	return
		x >= mainWindow.codeView.codeAreaPosition and
		y >= mainWindow.codeView.y and
		x < mainWindow.width and
		y < mainWindow.codeView.y + mainWindow.codeView.height - 1
end

local function moveCursor(symbolOffset, lineOffset)
	if mainWindow.codeView.selections[1] then
		if symbolOffset < 0 or lineOffset < 0 then
			setCursorPositionAndClearSelection(mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].from.line)
		else
			setCursorPositionAndClearSelection(mainWindow.codeView.selections[1].to.symbol, mainWindow.codeView.selections[1].to.line)
		end
	else
		local newSymbol, newLine = cursor.position.symbol + symbolOffset, cursor.position.line + lineOffset
		
		if symbolOffset < 0 and newSymbol < 1 then
			newLine, newSymbol = newLine - 1, math.huge
		elseif symbolOffset > 0 and newSymbol > unicode.len(mainWindow.codeView.lines[newLine] or "") + 1 then
			newLine, newSymbol = newLine + 1, 1
		end

		setCursorPositionAndClearSelection(newSymbol, newLine)
	end
end

local function setCursorPositionToHome()
	setCursorPositionAndClearSelection(1, 1)
end

local function setCursorPositionToEnd()
	setCursorPositionAndClearSelection(unicode.len(mainWindow.codeView.lines[#mainWindow.codeView.lines]) + 1, #mainWindow.codeView.lines)
end

local function scroll(direction, speed)
	if direction == 1 then
		if mainWindow.codeView.fromLine > speed then
			mainWindow.codeView.fromLine = mainWindow.codeView.fromLine - speed
		else
			mainWindow.codeView.fromLine = 1
		end
	else
		if mainWindow.codeView.fromLine < #mainWindow.codeView.lines - speed then
			mainWindow.codeView.fromLine = mainWindow.codeView.fromLine + speed
		else
			mainWindow.codeView.fromLine = #mainWindow.codeView.lines
		end
	end
end

local function pageUp()
	scroll(1, mainWindow.codeView.height - 2)
end

local function pageDown()
	scroll(-1, mainWindow.codeView.height - 2)
end

local function gotoLine(line)
	mainWindow.codeView.fromLine = math.floor(line - mainWindow.codeView.height / 2) + 1
	if mainWindow.codeView.fromLine < 1 then
		mainWindow.codeView.fromLine = 1
	elseif mainWindow.codeView.fromLine > #mainWindow.codeView.lines then
		mainWindow.codeView.fromLine = #mainWindow.codeView.lines
	end
end

local function selectWord()
	local shittySymbolsRegexp, from, to = "[%s%c%p]"

	for i = cursor.position.symbol, 1, -1 do
		if unicode.sub(mainWindow.codeView.lines[cursor.position.line], i, i):match(shittySymbolsRegexp) then break end
		from = i
	end

	for i = cursor.position.symbol, unicode.len(mainWindow.codeView.lines[cursor.position.line]) do
		if unicode.sub(mainWindow.codeView.lines[cursor.position.line], i, i):match(shittySymbolsRegexp) then break end
		to = i
	end

	if from and to then
		mainWindow.codeView.selections[1] = {
			from = {symbol = from, line = cursor.position.line},
			to = {symbol = to, line = cursor.position.line},
		}
		cursor.position.symbol = to
	end
end

------------------------------------------------------------------------------------------------------------------

local function removeTabs(text)
	local result = text:gsub("\t", string.rep(" ", mainWindow.codeView.indentationWidth))
	return result
end

local function removeWindowsLineEndings(text)
	local result = text:gsub("\r\n", "\n")
	return result
end

local function createInputTextBoxForSettingsWindow(title, placeholder)
	mainWindow.settingsContainer.isHidden = false
	local elementWidth = math.floor(mainWindow.width * 0.3)
	local x, y = math.floor(mainWindow.width / 2 - elementWidth / 2), math.floor(mainWindow.height / 2) - 3
	mainWindow.settingsContainer:addLabel(1, y, mainWindow.settingsContainer.width, 1, 0xFFFFFF, title):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top); y = y + 3
	return mainWindow.settingsContainer:addInputTextBox(x, y, elementWidth, 3, 0xCCCCCC, 0x777777, 0xCCCCCC, 0x2D2D2D, "", placeholder)
end

local function newFile()
	mainWindow.codeView.lines = {""}
	mainWindow.codeView.maximumLineLength = 1
	mainWindow.leftTreeView.currentFile = nil
	setCursorPositionAndClearSelection(1, 1)
end

local function loadFile(path)
	newFile()
	local file = io.open(path, "r")
	for line in file:lines() do
		line = removeWindowsLineEndings(removeTabs(line))
		table.insert(mainWindow.codeView.lines, line)
		mainWindow.codeView.maximumLineLength = math.max(mainWindow.codeView.maximumLineLength, unicode.len(line))
	end
	file:close()
	mainWindow.leftTreeView.currentFile = path
end

local function saveFile(path)
	fs.makeDirectory(fs.path(path))
	local file = io.open(path, "w")
	for line = 1, #mainWindow.codeView.lines do
		file:write(mainWindow.codeView.lines[line], "\n")
	end
	file:close()
end

local function open()
	local inputTextBox = createInputTextBoxForSettingsWindow(localization.openFile, localization.pathToFile)
	inputTextBox.validator = function(text)
		if fs.exists(text) then return true end
	end
	inputTextBox.onInputFinished = function()
		loadFile(inputTextBox.text)
		hideSettingsContainer()
	end
end

local function saveAs()
	local inputTextBox = createInputTextBoxForSettingsWindow(localization.saveAs, localization.pathToFile)
	inputTextBox.onInputFinished = function()
		saveFile(inputTextBox.text)
		mainWindow.leftTreeView.currentFile = inputTextBox.text
		mainWindow.leftTreeView:updateFileList()
		hideSettingsContainer()
	end
end

local function save()
	saveFile(mainWindow.leftTreeView.currentFile)
end

local function splitStringIntoLines(s)
	s = removeWindowsLineEndings(removeTabs(s))

	local lines, searchLineEndingFrom, maximumLineLength, lineEndingFoundAt, line = {}, 1, 0
	repeat
		lineEndingFoundAt = string.unicodeFind(s, "\n", searchLineEndingFrom)
		if lineEndingFoundAt then
			line = unicode.sub(s, searchLineEndingFrom, lineEndingFoundAt - 1)
			searchLineEndingFrom = lineEndingFoundAt + 1
		else
			line = unicode.sub(s, searchLineEndingFrom, -1)
		end

		table.insert(lines, line)
		maximumLineLength = math.max(maximumLineLength, unicode.len(line))
	until not lineEndingFoundAt

	return lines, maximumLineLength
end

local function downloadFromWeb()
	local inputTextBox = createInputTextBoxForSettingsWindow(localization.getFromWeb, localization.url)
	inputTextBox.onInputFinished = function()
		local success, reason = ecs.internetRequest(inputTextBox.text)
		if success then
			newFile()
			mainWindow.codeView.lines, mainWindow.codeView.maximumLineLength = splitStringIntoLines(reason)
		else
			GUI.error(reason, {title = {color = 0xFFDB40, text = "Failed to connect to URL"}})
		end
		hideSettingsContainer()
	end
end

------------------------------------------------------------------------------------------------------------------

local function addErrorLine(line)
	lastErrorLine = line
	mainWindow.codeView.highlights[line] = colors.highlights.onError
end

local function addBreakpoint()
	clearHighlights()
	breakpointLine = cursor.position.line
	mainWindow.codeView.highlights[breakpointLine] = colors.highlights.onBreakpoint
end

local function getVariables(codePart)
	local variables = {}
	-- Ð¡Ð½Ð°ÑÐ°Ð»Ð° Ð¼Ñ Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼ ÑÑÐ°ÑÑÐ¾Ðº ÐºÐ¾Ð´Ð° Ð½Ð° Ð½Ð°Ð»Ð¸ÑÐ¸Ðµ ÐºÐ¾Ð¼Ð¼ÐµÐ½ÑÐ°ÑÐ¸ÐµÐ²
	if
		not codePart:match("^%-%-") and
		not codePart:match("^[\t%s]+%-%-")
	then
		-- ÐÐ°ÑÐµÐ¼ Ð·Ð°Ð¼ÐµÐ½ÑÐµÐ¼ Ð²ÑÐµ ÑÑÑÐ¾ÐºÐ¾Ð²ÑÐµ ÐºÑÑÐºÐ¸ Ð² ÑÑÐ°ÑÑÐºÐµ ÐºÐ¾Ð´Ð° Ð½Ð° "Ð½Ð¸ÑÐµÐ³Ð¾", ÑÑÐ¾Ð±Ñ Ð½Ð°Ñ "Ð¿ÑÐµÐºÑÐ°ÑÐ½ÑÐ¹" Ð¿Ð°ÑÑÐµÑ Ð½Ðµ Ð¸ÑÐºÐ°Ð» Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÑ Ð² ÑÑÑÐ¾ÐºÐ°Ñ
		codePart = codePart:gsub("\"[^\"]+\"", "")
		-- ÐÐ¾ÑÐ¾Ð¼ ÑÐ°Ð·Ð±Ð¸Ð²Ð°ÐµÐ¼ ÐºÐ¾Ð´ Ð½Ð° Ð¾ÑÐ´ÐµÐ»ÑÐ½ÑÐµ Ð±ÑÐºÐ²ÐµÐ½Ð½Ð¾-ÑÐ¸ÑÑÐ¾Ð²ÑÐµ ÑÐ»Ð¾Ð²Ð°, Ð½Ðµ Ð·Ð°Ð±ÑÐ² ÑÐ¾ÑÐµÑÐºÑ Ñ Ð´Ð²Ð¾ÐµÑÐ¾ÑÐ¸ÐµÐ¼
		for word in codePart:gmatch("[%a%d%.%:%_]+") do
			-- ÐÐ°Ð»ÐµÐµ Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼, Ð½Ðµ ÑÐ¾Ð²Ð¿Ð°Ð´Ð°ÐµÑ Ð»Ð¸ ÑÑÐ¾ ÑÐ»Ð¾Ð²Ð¾ Ñ Ð¾Ð´Ð½Ð¸Ð¼ Ð¸Ð· Ð»ÑÐ°-ÑÐ°Ð±Ð»Ð¾Ð½Ð¾Ð², ÑÐ¾ Ð±Ð¸ÑÑ, Ð½Ðµ ÑÐ²Ð»ÑÐµÑÑÑ Ð»Ð¸ Ð¾Ð½Ð¾ ÑÐ°ÑÑÑÑ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ°
			if
				word ~= "local" and
				word ~= "return" and
				word ~= "while" and
				word ~= "repeat" and
				word ~= "until" and
				word ~= "for" and
				word ~= "in" and
				word ~= "do" and
				word ~= "if" and
				word ~= "then" and
				word ~= "else" and
				word ~= "elseif" and
				word ~= "end" and
				word ~= "function" and
				word ~= "true" and
				word ~= "false" and
				word ~= "nil" and
				word ~= "not" and
				word ~= "and" and
				word ~= "or"  and
				-- Ð¢Ð°ÐºÐ¶Ðµ Ð¿ÑÐ¾Ð²ÐµÑÑÐµÐ¼, Ð½Ðµ ÑÐ¸ÑÐ»Ð¾ Ð»Ð¸ ÑÑÐ¾ Ð² ÑÐ¸ÑÑÐ¾Ð¼ Ð²Ð¸Ð´Ðµ
				not word:match("^%d+$") and
				not word:match("^0x%x+$") and
				-- ÐÐ»Ð¸ ÑÐ¸Ð¼Ð²Ð¾Ð» ÐºÐ¾Ð½ÐºÐ°ÑÐµÐ½Ð°ÑÐ¸Ð¸, Ð½Ð°Ð¿ÑÐ¸Ð¼ÐµÑ
				not word:match("^%.+$")
			then
				variables[word] = true
			end
		end
	end

	return variables
end

local function createBreakpointError(variables)
	local errorMessage = "error({variables={"

	for variable in pairs(variables) do
		errorMessage = errorMessage .. "[\"" .. variable .. "\"] = type(" .. variable .. ") == \"string\" and \"\\\"\" .. " .. variable .. " .. \"\\\"\" or tostring(" .. variable .. "),"
	end

	return errorMessage .. "}})"
end

local function run()
	if breakpointLine then
		table.insert(mainWindow.codeView.lines, breakpointLine, createBreakpointError(getVariables(mainWindow.codeView.lines[breakpointLine])))
	end

	local loadSuccess, loadReason = load(table.concat(mainWindow.codeView.lines, "\n"))
	if loadSuccess then
		local oldResolutionX, oldResolutionY = component.gpu.getResolution()
		component.gpu.setBackground(0x1B1B1B)
		component.gpu.setForeground(0xFFFFFF)
		component.gpu.fill(1, 1, oldResolutionX, oldResolutionY, " ")
		term.setCursor(1, 1)
		
		local xpcallSuccess, xpcallReason = xpcall(loadSuccess, debug.traceback)
		local xpcallReasonType = type(xpcallReason)

		if breakpointLine then
			table.remove(mainWindow.codeView.lines, breakpointLine)
		end

		if xpcallSuccess or (xpcallReasonType == "table" and xpcallReason.terminated == true) then
			MineOSCore.waitForPressingAnyKey()
		end

		buffer.changeResolution(oldResolutionX, oldResolutionY)	

		if not xpcallSuccess then
			if xpcallReasonType == "table" then
				if xpcallReason.variables then
					gotoLine(breakpointLine)
					showBreakpointMessage(xpcallReason.variables)
				end
			else
				showErrorMessage(xpcallReason)
			end
		end

		mainWindow:draw()
		buffer:draw()		
	else
		addErrorLine(tonumber(loadReason:match("^%[.+%]%:(%d+)%:")))
		gotoLine(lastErrorLine)
		showErrorMessage(loadReason)
	end
end

local function deleteLine(line)
	if #mainWindow.codeView.lines > 1 then
		table.remove(mainWindow.codeView.lines, line)
		setCursorPositionAndClearSelection(1, cursor.position.line)
	end
end

local function deleteSpecifiedData(fromSymbol, fromLine, toSymbol, toLine)
	local upperLine = unicode.sub(mainWindow.codeView.lines[fromLine], 1, fromSymbol - 1)
	local lowerLine = unicode.sub(mainWindow.codeView.lines[toLine], toSymbol + 1, -1)
	for line = fromLine + 1, toLine do
		table.remove(mainWindow.codeView.lines, fromLine + 1)
	end
	mainWindow.codeView.lines[fromLine] = upperLine .. lowerLine
	setCursorPositionAndClearSelection(fromSymbol, fromLine)
end

local function deleteSelectedData()
	if mainWindow.codeView.selections[1] then
		deleteSpecifiedData(
			mainWindow.codeView.selections[1].from.symbol,
			mainWindow.codeView.selections[1].from.line,
			mainWindow.codeView.selections[1].to.symbol,
			mainWindow.codeView.selections[1].to.line
		)
		clearSelection()
	end
end

local function copy()
	if mainWindow.codeView.selections[1] then
		if mainWindow.codeView.selections[1].to.line == mainWindow.codeView.selections[1].from.line then
			clipboard = { unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol) }
		else
			clipboard = { unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, -1) }
			for line = mainWindow.codeView.selections[1].from.line + 1, mainWindow.codeView.selections[1].to.line - 1 do
				table.insert(clipboard, mainWindow.codeView.lines[line])
			end
			table.insert(clipboard, unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], 1, mainWindow.codeView.selections[1].to.symbol))
		end
	end
end

local function cut()
	if mainWindow.codeView.selections[1] then
		copy()
		deleteSelectedData()
	end
end

local function paste(pasteLines)
	if pasteLines then
		if mainWindow.codeView.selections[1] then
			deleteSelectedData()
		end

		local firstPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], 1, cursor.position.symbol - 1)
		local secondPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, -1)

		if #pasteLines == 1 then
			mainWindow.codeView.lines[cursor.position.line] = firstPart .. pasteLines[1] .. secondPart
			setCursorPositionAndClearSelection(cursor.position.symbol + unicode.len(pasteLines[1]), cursor.position.line)
		else
			mainWindow.codeView.lines[cursor.position.line] = firstPart .. pasteLines[1]
			for pasteLine = #pasteLines - 1, 2, -1 do
				table.insert(mainWindow.codeView.lines, cursor.position.line + 1, pasteLines[pasteLine])
			end
			table.insert(mainWindow.codeView.lines, cursor.position.line + #pasteLines - 1, pasteLines[#pasteLines] .. secondPart)
			setCursorPositionAndClearSelection(unicode.len(pasteLines[#pasteLines]) + 1, cursor.position.line + #pasteLines - 1)
		end
	end
end

local function pasteRegularChar(unicodeByte, char)
	if not keyboard.isControl(unicodeByte) then
		deleteSelectedData()
		paste({char})
	end
end

local function pasteAutoBrackets(unicodeByte)
	local char = unicode.char(unicodeByte)
	local currentSymbol = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, cursor.position.symbol)

	-- ÐÑÐ»Ð¸ Ñ Ð½Ð°Ñ Ð²Ð¾Ð¾Ð±ÑÐµ Ð²ÑÑÐ±Ð»ÐµÐ½ ÑÐµÐ¶Ð¸Ð¼ Ð°Ð²ÑÐ¾ÑÐºÐ¾Ð±Ð¾Ðº, ÑÐ¾ ÑÐµÐºÐ°ÐµÐ¼ Ð¸Ñ
	if config.enableAutoBrackets then
		-- Ð¡Ð¸ÑÑÐ°ÑÐ¸Ñ, ÐºÐ¾Ð³Ð´Ð° ÐºÑÑÑÐ¾Ñ Ð½Ð°ÑÐ¾Ð´Ð¸ÑÑÑ Ð½Ð° Ð·Ð°ÐºÑÑÐ²Ð°ÑÑÐµÐ¹ ÑÐºÐ¾Ð±ÐºÐµ, Ð¸ Ð½ÐµÑÑÐ¹ ÐµÐµ ÐµÑÐµ ÑÐ°Ð· Ð²ÑÑÐ°Ð²Ð»ÑÑÑ
		if possibleBrackets.closers[char] and currentSymbol == char then
			deleteSelectedData()
			setCursorPosition(cursor.position.symbol + 1, cursor.position.line)
		-- ÐÑÐ»Ð¸ Ð½Ð°Ð¶Ð°ÑÐ° Ð¾ÑÐºÑÑÐ²Ð°ÑÑÐ°Ñ ÑÐºÐ¾Ð±ÐºÐ°
		elseif possibleBrackets.openers[char] then
			-- Ð Ð²Ð¾Ñ ÑÑÑ Ð¼Ñ Ð±ÐµÑÐµÐ¼ Ð² ÑÐºÐ¾Ð±Ð¾ÑÐºÐ¸ ÑÐ¶Ðµ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð½ÑÐ¹ ÑÐµÐºÑÑ
			if mainWindow.codeView.selections[1] then
				local firstPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], 1, mainWindow.codeView.selections[1].from.symbol - 1)
				local secondPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line], mainWindow.codeView.selections[1].from.symbol, -1)
				mainWindow.codeView.lines[mainWindow.codeView.selections[1].from.line] = firstPart .. char .. secondPart
				mainWindow.codeView.selections[1].from.symbol = mainWindow.codeView.selections[1].from.symbol + 1

				if mainWindow.codeView.selections[1].to.line == mainWindow.codeView.selections[1].from.line then
					mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].to.symbol + 1
				end

				firstPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], 1, mainWindow.codeView.selections[1].to.symbol)
				secondPart = unicode.sub(mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line], mainWindow.codeView.selections[1].to.symbol + 1, -1)
				mainWindow.codeView.lines[mainWindow.codeView.selections[1].to.line] = firstPart .. possibleBrackets.openers[char] .. secondPart
				cursor.position.symbol = cursor.position.symbol + 2
			-- Ð ÑÑÑ Ð¼Ñ Ð´ÐµÐ»Ð°ÐµÐ¼ Ð´Ð²Ð¾Ð¹Ð½ÑÑ Ð°Ð²ÑÐ¾ÑÐºÐ¾Ð±ÐºÑ, ÐµÑÐ»Ð¸ Ð¼Ð¾Ð¶ÐµÐ¼
			elseif possibleBrackets.openers[char] and not currentSymbol:match("[%a%d%_]") then
				paste({char .. possibleBrackets.openers[char]})
				setCursorPosition(cursor.position.symbol - 1, cursor.position.line)
				cursor.blinkState = false
			-- ÐÑ, Ð¸ ÐµÑÐ»Ð¸ Ð½ÐµÑ Ð½Ð¸ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ð¹, Ð½Ð¸ Ð¼Ð¾Ð¶ÐµÐ¼ ÐµÐ±Ð°Ð½ÑÑÑ Ð°Ð²ÑÐ¾ÑÐºÐ¾Ð±Ð¾ÑÐºÑ Ð¿Ð¾ ÑÐµÐ³ÑÐ»ÑÑÐºÐµ
			else
				pasteRegularChar(unicodeByte, char)
			end
		-- ÐÑÐ»Ð¸ Ð¼Ñ Ð²Ð¾Ð¾Ð±ÑÐµ Ð½Ð° ÑÐºÐ¾Ð±ÐºÑ Ð½Ðµ Ð½Ð°Ð¶Ð¸Ð¼Ð°Ð»Ð¸
		else
			pasteRegularChar(unicodeByte, char)
		end
	-- ÐÑÐ»Ð¸ Ð¾ÑÑÐ½ÑÑÑ Ð°ÑÑÐ¾ÑÐºÐ¾Ð±ÐºÐ¸
	else
		pasteRegularChar(unicodeByte, char)
	end
end

local function backspaceAutoBrackets()	
	local previousSymbol = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol - 1, cursor.position.symbol - 1)
	local currentSymbol = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, cursor.position.symbol)
	if config.enableAutoBrackets and possibleBrackets.openers[previousSymbol] and possibleBrackets.openers[previousSymbol] == currentSymbol then
		deleteSpecifiedData(cursor.position.symbol, cursor.position.line, cursor.position.symbol, cursor.position.line)
	end
end

local function delete()
	if mainWindow.codeView.selections[1] then
		deleteSelectedData()
	else
		if cursor.position.symbol < unicode.len(mainWindow.codeView.lines[cursor.position.line]) + 1 then
			deleteSpecifiedData(cursor.position.symbol, cursor.position.line, cursor.position.symbol, cursor.position.line)
		else
			if cursor.position.line > 1 then
				deleteSpecifiedData(unicode.len(mainWindow.codeView.lines[cursor.position.line]) + 1, cursor.position.line, 0, cursor.position.line + 1)
			end
		end
	end
end

local function backspace()
	if mainWindow.codeView.selections[1] then
		deleteSelectedData()
	else
		if cursor.position.symbol > 1 then
			backspaceAutoBrackets()
			deleteSpecifiedData(cursor.position.symbol - 1, cursor.position.line, cursor.position.symbol - 1, cursor.position.line)
		else
			if cursor.position.line > 1 then
				deleteSpecifiedData(unicode.len(mainWindow.codeView.lines[cursor.position.line - 1]) + 1, cursor.position.line - 1, 0, cursor.position.line)
			end
		end
	end
end

local function enter()
	local firstPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], 1, cursor.position.symbol - 1)
	local secondPart = unicode.sub(mainWindow.codeView.lines[cursor.position.line], cursor.position.symbol, -1)
	mainWindow.codeView.lines[cursor.position.line] = firstPart
	table.insert(mainWindow.codeView.lines, cursor.position.line + 1, secondPart)
	setCursorPositionAndClearSelection(1, cursor.position.line + 1)
end

local function selectAll()
	mainWindow.codeView.selections[1] = {
		from = {
			symbol = 1, line = 1
		},
		to = {
			symbol = unicode.len(mainWindow.codeView.lines[#mainWindow.codeView.lines]), line = #mainWindow.codeView.lines
		}
	}
end

local function isLineCommented(line)
	return mainWindow.codeView.lines[line]:match("%-%-[^%-]")
end

local function commentLine(line)
	mainWindow.codeView.lines[line] = "-- " .. mainWindow.codeView.lines[line]
end

local function uncommentLine(line)
	mainWindow.codeView.lines[line], countOfReplaces = mainWindow.codeView.lines[line]:gsub("%-%-%s", "", 1)
	return countOfReplaces
end

local function toggleComment()
	if mainWindow.codeView.selections[1] then
		local allLinesAreCommented = true
		
		for line = mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line do
			if not isLineCommented(line) then
				allLinesAreCommented = false
			end
		end
		
		for line = mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line do
			if allLinesAreCommented then
				uncommentLine(line)
			else
				commentLine(line)
			end
		end

		local modifyer = 3
		if allLinesAreCommented then
			modifyer = -3
		end
		setCursorPosition(cursor.position.symbol + modifyer, cursor.position.line)
		mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].from.symbol + modifyer, mainWindow.codeView.selections[1].to.symbol + modifyer
	else
		if isLineCommented(cursor.position.line) then
			if uncommentLine(cursor.position.line) > 0 then
				setCursorPositionAndClearSelection(cursor.position.symbol - 3, cursor.position.line)
			end
		else
			commentLine(cursor.position.line)
			setCursorPositionAndClearSelection(cursor.position.symbol + 3, cursor.position.line)
		end
	end
end

local function indentLine(line)
	mainWindow.codeView.lines[line] = string.rep(" ", mainWindow.codeView.indentationWidth) .. mainWindow.codeView.lines[line]
end

local function unindentLine(line)
	mainWindow.codeView.lines[line], countOfReplaces = string.gsub(mainWindow.codeView.lines[line], "^" .. string.rep("%s", mainWindow.codeView.indentationWidth), "")
	return countOfReplaces
end

local function indentOrUnindent(isIndent)
	if mainWindow.codeView.selections[1] then
		local countOfReplacesInFirstLine, countOfReplacesInLastLine
		
		for line = mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line do
			if isIndent then
				indentLine(line)
			else
				local countOfReplaces = unindentLine(line)
				if line == mainWindow.codeView.selections[1].from.line then
					countOfReplacesInFirstLine = countOfReplaces
				elseif line == mainWindow.codeView.selections[1].to.line then
					countOfReplacesInLastLine = countOfReplaces
				end
			end
		end		

		if isIndent then
			setCursorPosition(cursor.position.symbol + mainWindow.codeView.indentationWidth, cursor.position.line)
			mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].from.symbol + mainWindow.codeView.indentationWidth, mainWindow.codeView.selections[1].to.symbol + mainWindow.codeView.indentationWidth
		else
			if countOfReplacesInFirstLine > 0 then
				mainWindow.codeView.selections[1].from.symbol = mainWindow.codeView.selections[1].from.symbol - mainWindow.codeView.indentationWidth
				if cursor.position.line == mainWindow.codeView.selections[1].from.line then
					setCursorPosition(cursor.position.symbol - mainWindow.codeView.indentationWidth, cursor.position.line)
				end
			end

			if countOfReplacesInLastLine > 0 then
				mainWindow.codeView.selections[1].to.symbol = mainWindow.codeView.selections[1].to.symbol - mainWindow.codeView.indentationWidth
				if cursor.position.line == mainWindow.codeView.selections[1].to.line then
					setCursorPosition(cursor.position.symbol - mainWindow.codeView.indentationWidth, cursor.position.line)
				end
			end
		end
	else
		if isIndent then
			indentLine(cursor.position.line)
			setCursorPositionAndClearSelection(cursor.position.symbol + mainWindow.codeView.indentationWidth, cursor.position.line)
		else
			if unindentLine(cursor.position.line) > 0 then
				setCursorPositionAndClearSelection(cursor.position.symbol - mainWindow.codeView.indentationWidth, cursor.position.line)
			end
		end
	end
end

local function updateRAMProgressBar()
	if not mainWindow.topToolBar.isHidden then
		local totalMemory = computer.totalMemory()
		mainWindow.RAMUsageProgressBar.value = math.ceil((totalMemory - computer.freeMemory()) / totalMemory * 100)
	end
end

local function find()
	if not mainWindow.bottomToolBar.isHidden and mainWindow.bottomToolBar.inputTextBox.text ~= "" then
		findStartFrom = findStartFrom + 1
	
		for line = findStartFrom, #mainWindow.codeView.lines do
			local whereToFind, whatToFind = mainWindow.codeView.lines[line], mainWindow.bottomToolBar.inputTextBox.text
			if not mainWindow.bottomToolBar.caseSensitiveButton.pressed then
				whereToFind, whatToFind = unicode.lower(whereToFind), unicode.lower(whatToFind)
			end

			local success, starting, ending = pcall(string.unicodeFind, whereToFind, whatToFind)
			if success then
				if starting then
					mainWindow.codeView.selections[1] = {
						from = {symbol = starting, line = line},
						to = {symbol = ending, line = line},
						color = 0xCC9200
					}
					findStartFrom = line
					gotoLine(line)
					return
				end
			else
				GUI.error("Wrong searching regex", {title = {color = 0xFFDB40, text = "Warning"}})
			end
		end

		findStartFrom = 0
	end
end

local function findFromFirstDisplayedLine()
	findStartFrom = mainWindow.codeView.fromLine
	find()
end

local function toggleBottomToolBar()
	mainWindow.bottomToolBar.isHidden = not mainWindow.bottomToolBar.isHidden
	mainWindow.toggleBottomToolBarButton.pressed = not mainWindow.bottomToolBar.isHidden
	calculateSizes()
		
	if not mainWindow.bottomToolBar.isHidden then
		mainWindow:draw()
		mainWindow.bottomToolBar.inputTextBox:input()
		findFromFirstDisplayedLine()
	end
end

local function toggleTopToolBar()
	mainWindow.topToolBar.isHidden = not mainWindow.topToolBar.isHidden
	mainWindow.toggleTopToolBarButton.pressed = not mainWindow.topToolBar.isHidden
	calculateSizes()
end

local function toggleLeftToolBar()
	mainWindow.leftTreeView.isHidden = not mainWindow.leftTreeView.isHidden
	mainWindow.toggleLeftToolBarButton.pressed = not mainWindow.leftTreeView.isHidden
	calculateSizes()
end

local function createWindow()
	mainWindow = windows.fullScreen()

	mainWindow.codeView = mainWindow:addCodeView(1, 1, 1, 1, {""}, 1, 1, 1, {}, {}, config.highlightLuaSyntax, 2)
	mainWindow.codeView.scrollBars.vertical.onTouch = function()
		mainWindow.codeView.fromLine = mainWindow.codeView.scrollBars.vertical.value
	end
	mainWindow.codeView.scrollBars.horizontal.onTouch = function()
		mainWindow.codeView.fromSymbol = mainWindow.codeView.scrollBars.horizontal.value
	end
	mainWindow.topMenu = mainWindow:addMenu(1, 1, 1, colors.topMenu.backgroundColor, colors.topMenu.textColor, colors.topMenu.backgroundPressedColor, colors.topMenu.textPressedColor)
	
	local item1 = mainWindow.topMenu:addItem("MineCode", 0x0)
	item1.onTouch = function()
		local menu = GUI.contextMenu(item1.x, item1.y + 1)
		menu:addItem(localization.about).onTouch = function()
			mainWindow.settingsContainer.isHidden = false
			local y = math.floor(mainWindow.settingsContainer.height / 2 - #about / 2)
			mainWindow.settingsContainer:addTextBox(1, y, mainWindow.settingsContainer.width, #about, nil, 0xEEEEEE, about, 1):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
		end
		menu:addItem(localization.quit, false, "^W").onTouch = function()
			mainWindow:close()
		end
		menu:show()
	end

	local item2 = mainWindow.topMenu:addItem(localization.file)
	item2.onTouch = function()
		local menu = GUI.contextMenu(item2.x, item2.y + 1)
		menu:addItem(localization.new, false, "^N").onTouch = function()
			newFile()
		end
		menu:addItem(localization.open, false, "^O").onTouch = function()
			open()
		end
		if component.isAvailable("internet") then
			menu:addItem(localization.getFromWeb, false, "^U").onTouch = function()
				downloadFromWeb()
			end
		end
		menu:addSeparator()
		menu:addItem(localization.save, not mainWindow.leftTreeView.currentFile, "^S").onTouch = function()
			save()
		end
		menu:addItem(localization.saveAs, false, "^â§S").onTouch = function()
			saveAs()
		end
		menu:show()
	end

	local item3 = mainWindow.topMenu:addItem(localization.edit)
	item3.onTouch = function()
		local menu = GUI.contextMenu(item3.x, item3.y + 1)
		menu:addItem(localization.cut, not mainWindow.codeView.selections[1], "^X").onTouch = function()
			cut()
		end
		menu:addItem(localization.copy, not mainWindow.codeView.selections[1], "^C").onTouch = function()
			copy()
		end
		menu:addItem(localization.paste, not clipboard, "^V").onTouch = function()
			paste(clipboard)
		end
		menu:addSeparator()
		menu:addItem(localization.comment, false, "^/").onTouch = function()
			toggleComment()
		end
		menu:addItem(localization.indent, false, "Tab").onTouch = function()
			indentOrUnindent(true)
		end
		menu:addItem(localization.unindent, false, "â§Tab").onTouch = function()
			indentOrUnindent(false)
		end
		menu:addItem(localization.deleteLine, false, "^Del").onTouch = function()
			deleteLine(cursor.position.line)
		end
		menu:addSeparator()
		menu:addItem(localization.selectWord).onTouch = function()
			selectWord()
		end
		menu:addItem(localization.selectAll, false, "^A").onTouch = function()
			selectAll()
		end
		menu:show()
	end

	local item4 = mainWindow.topMenu:addItem(localization.view)
	item4.onTouch = function()
		local menu = GUI.contextMenu(item4.x, item4.y + 1)
		menu:addItem(localization.colorScheme).onTouch = function()
			mainWindow.settingsContainer.isHidden = false
			
			local colorSelectorsCount, colorSelectorCountX = 0, 4; for key in pairs(config.syntaxColorScheme) do colorSelectorsCount = colorSelectorsCount + 1 end
			local colorSelectorCountY = math.ceil(colorSelectorsCount / colorSelectorCountX)
			local colorSelectorWidth, colorSelectorHeight, colorSelectorSpaceX, colorSelectorSpaceY = math.floor(mainWindow.settingsContainer.width / colorSelectorCountX * 0.8), 3, 2, 1
			
			local startX, y = math.floor(mainWindow.settingsContainer.width / 2 - (colorSelectorCountX * (colorSelectorWidth + colorSelectorSpaceX) - colorSelectorSpaceX) / 2), math.floor(mainWindow.settingsContainer.height / 2 - (colorSelectorCountY * (colorSelectorHeight + colorSelectorSpaceY) - colorSelectorSpaceY + 3) / 2)
			mainWindow.settingsContainer:addLabel(1, y, mainWindow.settingsContainer.width, 1, 0xFFFFFF, localization.colorScheme):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top); y = y + 3
			local x, counter = startX, 1

			for key in pairs(config.syntaxColorScheme) do
				local colorSelector = mainWindow.settingsContainer:addColorSelector(x, y, colorSelectorWidth, colorSelectorHeight, config.syntaxColorScheme[key], key)
				colorSelector.onTouch = function()
					config.syntaxColorScheme[key] = colorSelector.color
					syntax.colorScheme = config.syntaxColorScheme
					saveConfig()
				end

				x, counter = x + colorSelectorWidth + colorSelectorSpaceX, counter + 1
				if counter > colorSelectorCountX then
					x, y, counter = startX, y + colorSelectorHeight + colorSelectorSpaceY, 1
				end
			end
		end
		menu:addItem(localization.cursorProperties).onTouch = function()
			mainWindow.settingsContainer.isHidden = false

			local elementWidth = math.floor(mainWindow.width * 0.3)
			local x, y = math.floor(mainWindow.width / 2 - elementWidth / 2), math.floor(mainWindow.height / 2) - 7
			mainWindow.settingsContainer:addLabel(1, y, mainWindow.settingsContainer.width, 1, 0xFFFFFF, localization.cursorProperties):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top); y = y + 3
			local inputTextBox = mainWindow.settingsContainer:addInputTextBox(x, y, elementWidth, 3, 0xCCCCCC, 0x777777, 0xCCCCCC, 0x2D2D2D, config.cursorSymbol, localization.cursorSymbol); y = y + 5
			inputTextBox.validator = function(text)
				if unicode.len(text) == 1 then return true end
			end
			inputTextBox.onInputFinished = function()
				config.cursorSymbol = inputTextBox.text; saveConfig()
			end
			local colorSelector = mainWindow.settingsContainer:addColorSelector(x, y, elementWidth, 3, config.cursorColor, localization.cursorColor); y = y + 5
			colorSelector.onTouch = function()
				config.cursorColor = colorSelector.color; saveConfig()
			end
			local horizontalSlider = mainWindow.settingsContainer:addHorizontalSlider(x, y, elementWidth, 0xFFDB80, 0x000000, 0xFFDB40, 0xDDDDDD, 1, 1000, config.cursorBlinkDelay * 1000, false, localization.cursorBlinkDelay .. ": ", " ms")
			horizontalSlider.onValueChanged = function()
				config.cursorBlinkDelay = horizontalSlider.value / 1000; saveConfig()
			end
		end

		if mainWindow.topToolBar.isHidden then
			menu:addItem(localization.toggleTopToolBar).onTouch = function()
				toggleTopToolBar()
			end
		end
		if config.enableAutoBrackets then
			menu:addItem(localization.disableAutoBrackets, false, "^]").onTouch = function()
				config.enableAutoBrackets = false
				saveConfig()
			end
		else
			menu:addItem(localization.enableAutoBrackets, false, "^]").onTouch = function()
				config.enableAutoBrackets = true
				saveConfig()
			end
		end

		menu:addSeparator()
		menu:addItem(localization.scalePlus, false, "^+").onTouch = function()
			scalePlus()
		end
		menu:addItem(localization.scaleMinus, false, "^-").onTouch = function()
			scaleMinus()
		end
		menu:show()
	end

	local item5 = mainWindow.topMenu:addItem(localization.gotoCyka)
	item5.onTouch = function()
		local menu = GUI.contextMenu(item5.x, item5.y + 1)
		menu:addItem(localization.pageUp, false, "PgUp").onTouch = function()
			pageUp()
		end
		menu:addItem(localization.pageDown, false, "PgDn").onTouch = function()
			pageDown()
		end
		menu:addItem(localization.gotoStart, false, "Home").onTouch = function()
			setCursorPositionToHome()
		end
		menu:addItem(localization.gotoEnd, false, "End").onTouch = function()
			setCursorPositionToEnd()
		end
		menu:show()
	end

	mainWindow.topToolBar = mainWindow:addContainer(1, 2, 1, 3)
	mainWindow.topToolBar.backgroundPanel = mainWindow.topToolBar:addPanel(1, 1, 1, 3, colors.topToolBar)
	mainWindow.titleTextBox = mainWindow.topToolBar:addTextBox(1, 1, 1, 3, 0x0, 0x0, {}, 1):setAlignment(GUI.alignment.horizontal.center, GUI.alignment.vertical.top)
	local titleTextBoxOldDraw = mainWindow.titleTextBox.draw
	mainWindow.titleTextBox.draw = function(titleTextBox)
		titleTextBoxOldDraw(titleTextBox)
		local sidesColor = mainWindow.errorMessage.isHidden and colors.title.default.sides or colors.title.onError.sides
		buffer.square(titleTextBox.x, titleTextBox.y, 1, titleTextBox.height, sidesColor, titleTextBox.colors.text, " ")
		buffer.square(titleTextBox.x + titleTextBox.width - 1, titleTextBox.y, 1, titleTextBox.height, sidesColor, titleTextBox.colors.text, " ")
	end

	mainWindow.RAMUsageProgressBar = mainWindow.topToolBar:addProgressBar(1, 2, 1, 0x777777, 0xBBBBBB, 0xAAAAAA, 50, true, true, "RAM: ", "%")

	--â¯ââº
	mainWindow.addBreakpointButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0x878787, 0xEEEEEE, 0xCCCCCC, 0x444444, "x")
	mainWindow.addBreakpointButton.onTouch = function()
		addBreakpoint()
	end

	mainWindow.toggleSyntaxHighlightingButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x696969, 0xEEEEEE, "â")
	mainWindow.toggleSyntaxHighlightingButton.switchMode, mainWindow.toggleSyntaxHighlightingButton.pressed = true, true
	mainWindow.toggleSyntaxHighlightingButton.onTouch = function()
		mainWindow.codeView.highlightLuaSyntax = not mainWindow.codeView.highlightLuaSyntax
		config.highlightLuaSyntax = mainWindow.codeView.highlightLuaSyntax
		saveConfig()
	end

	mainWindow.runButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0x4B4B4B, 0xEEEEEE, 0xCCCCCC, 0x444444, "â·")
	mainWindow.runButton.onTouch = function()
		run()
	end

	mainWindow.toggleLeftToolBarButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x4B4B4B, 0xEEEEEE, "â¦")
	mainWindow.toggleLeftToolBarButton.switchMode, mainWindow.toggleLeftToolBarButton.pressed = true, true
	mainWindow.toggleLeftToolBarButton.onTouch = function()
		mainWindow.leftTreeView.isHidden = not mainWindow.toggleLeftToolBarButton.pressed
		calculateSizes()
	end

	mainWindow.toggleBottomToolBarButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x696969, 0xEEEEEE, "â©")
	mainWindow.toggleBottomToolBarButton.switchMode, mainWindow.toggleBottomToolBarButton.pressed = true, false
	mainWindow.toggleBottomToolBarButton.onTouch = function()
		mainWindow.bottomToolBar.isHidden = not mainWindow.toggleBottomToolBarButton.pressed
		calculateSizes()
	end

	mainWindow.toggleTopToolBarButton = mainWindow.topToolBar:addAdaptiveButton(1, 1, 3, 1, 0xCCCCCC, 0x444444, 0x878787, 0xEEEEEE, "â§")
	mainWindow.toggleTopToolBarButton.switchMode, mainWindow.toggleTopToolBarButton.pressed = true, true
	mainWindow.toggleTopToolBarButton.onTouch = function()
		mainWindow.topToolBar.isHidden = not mainWindow.toggleTopToolBarButton.pressed
		calculateSizes()
	end

	mainWindow.bottomToolBar = mainWindow:addContainer(1, 1, 1, 1)
	mainWindow.bottomToolBar.caseSensitiveButton = mainWindow.bottomToolBar:addAdaptiveButton(1, 1, 2, 1, 0x3C3C3C, 0xEEEEEE, 0xBBBBBB, 0x2D2D2D, "Aa")
	mainWindow.bottomToolBar.caseSensitiveButton.switchMode = true
	mainWindow.bottomToolBar.onTouch = function()
		find()
	end
	mainWindow.bottomToolBar.inputTextBox = mainWindow.bottomToolBar:addInputTextBox(7, 1, 10, 3, 0xCCCCCC, 0x999999, 0xCCCCCC, 0x2D2D2D, "", localization.findSomeShit)
	mainWindow.bottomToolBar.inputTextBox.onInputFinished = function()
		findFromFirstDisplayedLine()
	end
	mainWindow.bottomToolBar.findButton = mainWindow.bottomToolBar:addAdaptiveButton(1, 1, 3, 1, 0x3C3C3C, 0xEEEEEE, 0xBBBBBB, 0x2D2D2D, localization.find)
	mainWindow.bottomToolBar.findButton.onTouch = function()
		find()
	end
	mainWindow.bottomToolBar.isHidden = true

	mainWindow.leftTreeView = mainWindow:addTreeView(1, 1, 1, 1, colors.leftTreeView.background, 0x3C3C3C, 0x3C3C3C, 0xEEEEEE, 0x888888, 0x444444, 0x00DBFF, "/")
	mainWindow.leftTreeView.onFileSelected = function(path)
		loadFile(path)
	end

	mainWindow.errorMessage = mainWindow:addContainer(1, 1, 1, 1)
	mainWindow.errorMessage.backgroundPanel = mainWindow.errorMessage:addPanel(1, 1, 1, 1, 0xFFFFFF, 30)
	mainWindow.errorMessage.errorTextBox = mainWindow.errorMessage:addTextBox(3, 2, 1, 1, nil, 0x4B4B4B, {}, 1)
	hideErrorMessage()

	mainWindow.settingsContainer = mainWindow:addContainer(1, 1, 1, 1)
	mainWindow.settingsContainer.backgroundPanel = mainWindow.settingsContainer:addPanel(1, 1, mainWindow.settingsContainer.width, mainWindow.settingsContainer.height, 0x0, 30)
	mainWindow.settingsContainer.backgroundPanel.onTouch = hideSettingsContainer
	mainWindow.settingsContainer.isHidden = true

	mainWindow.onAnyEvent = function(eventData)		
		if eventData[1] == "touch" and isClickedOnCodeArea(eventData[3], eventData[4]) then
			cursor.blinkState = true
			
			if eventData[5] == 1 then
				local menu = GUI.contextMenu(eventData[3], eventData[4])
				menu:addItem(localization.cut, not mainWindow.codeView.selections[1], "^X").onTouch = function()
					cut()
				end
				menu:addItem(localization.copy, not mainWindow.codeView.selections[1], "^C").onTouch = function()
					copy()
				end
				menu:addItem(localization.paste, not clipboard, "^V").onTouch = function()
					paste(clipboard)
				end
				menu:addSeparator()
				menu:addItem(localization.selectWord).onTouch = function()
					selectWord()
				end
				menu:addItem(localization.selectAll, false, "^A").onTouch = function()
					selectAll()
				end
				menu:show()
			else
				setCursorPositionAndClearSelection(convertScreenCoordinatesToCursorPosition(eventData[3], eventData[4]))

				local newUptime = computer.uptime()
				if newUptime - lastClickUptime <= config.doubleClickDelay then selectWord() end
				lastClickUptime = newUptime
			end
		elseif eventData[1] == "drag" and isClickedOnCodeArea(eventData[3], eventData[4]) then
			cursor.blinkState = true
			
			if eventData[5] ~= 1 then
				mainWindow.codeView.selections[1] = mainWindow.codeView.selections[1] or {from = {}, to = {}}
				mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].from.line = cursor.position.symbol, cursor.position.line
				mainWindow.codeView.selections[1].to.symbol, mainWindow.codeView.selections[1].to.line = fixCursorPosition(convertScreenCoordinatesToCursorPosition(eventData[3], eventData[4]))
				
				if mainWindow.codeView.selections[1].from.line > mainWindow.codeView.selections[1].to.line then
					mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line = swap(mainWindow.codeView.selections[1].from.line, mainWindow.codeView.selections[1].to.line)
					mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = swap(mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol)
				elseif mainWindow.codeView.selections[1].from.line == mainWindow.codeView.selections[1].to.line then
					if mainWindow.codeView.selections[1].from.symbol > mainWindow.codeView.selections[1].to.symbol then
						mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol = swap(mainWindow.codeView.selections[1].from.symbol, mainWindow.codeView.selections[1].to.symbol)
					end
				end
			end
		elseif eventData[1] == "key_down" then
			cursor.blinkState = true

			-- Ctrl or CMD
			if keyboard.isKeyDown(29) or keyboard.isKeyDown(219) then
				-- Slash
				if eventData[4] == 53 then
					toggleComment()
				-- ]
				elseif eventData[4] == 27 then
					config.enableAutoBrackets = not config.enableAutoBrackets
					saveConfig()
				-- A
				elseif eventData[4] == 30 then
					selectAll()
				-- C
				elseif eventData[4] == 46 then
					copy()
				-- V
				elseif eventData[4] == 47 then
					paste(clipboard)
				-- X
				elseif eventData[4] == 45 then
					cut()
				-- W
				elseif eventData[4] == 17 then
					mainWindow:close()
				-- N
				elseif eventData[4] == 49 then
					newFile()
				-- O
				elseif eventData[4] == 24 then
					open()
				-- U
				elseif eventData[4] == 22 and component.isAvailable("internet") then
					downloadFromWeb()
				-- S
				elseif eventData[4] == 31 then
					-- Shift
					if mainWindow.leftTreeView.currentFile and not keyboard.isKeyDown(42) then
						save()
					else
						saveAs()
					end
				-- F
				elseif eventData[4] == 33 then
					toggleBottomToolBar()
				-- G
				elseif eventData[4] == 34 then
					find()
				-- Backspace
				elseif eventData[4] == 14 then
					deleteLine(cursor.position.line)
				-- Delete
				elseif eventData[4] == 211 then
					deleteLine(cursor.position.line)
				-- +
				elseif eventData[4] == 13 then
					scalePlus()
				-- -
				elseif eventData[4] == 12 then
					scaleMinus()
				end
			-- Arrows up, down, left, right
			elseif eventData[4] == 200 then
				moveCursor(0, -1)
			elseif eventData[4] == 208 then
				moveCursor(0, 1)
			elseif eventData[4] == 203 then
				moveCursor(-1, 0)
			elseif eventData[4] == 205 then
				moveCursor(1, 0)
			-- Backspace
			elseif eventData[4] == 14 then
				backspace()
			-- Tab
			elseif eventData[4] == 15 then
				if keyboard.isKeyDown(42) then
					indentOrUnindent(false)
				else
					indentOrUnindent(true)
				end
			-- Enter
			elseif eventData[4] == 28 then
				enter()
			-- F5
			elseif eventData[4] == 63 then
				run()
			-- Home
			elseif eventData[4] == 199 then
				setCursorPositionToHome()
			-- End
			elseif eventData[4] == 207 then
				setCursorPositionToEnd()
			-- Page Up
			elseif eventData[4] == 201 then
				pageUp()
			-- Page Down
			elseif eventData[4] == 209 then
				pageDown()
			-- Delete
			elseif eventData[4] == 211 then
				delete()
			else
				pasteAutoBrackets(eventData[3])
			end
		elseif eventData[1] == "clipboard" then
			paste(splitStringIntoLines(eventData[3]))
		elseif eventData[1] == "scroll" then
			if isClickedOnCodeArea(eventData[3], eventData[4]) then
				scroll(eventData[5], config.scrollSpeed)
			end
		elseif eventData[1] == "component_added" or eventData[1] == "component_removed" then
			if eventData[3] == "screen" then
				os.sleep(0.5)
				changeScale(config.screenScale)
			end
		elseif not eventData[1] then
			cursor.blinkState = not cursor.blinkState
		end

		updateTitle()
		updateRAMProgressBar()
		mainWindow:draw()
		if cursor.blinkState then
			local x, y = mainWindow.codeView.codeAreaPosition + cursor.position.symbol - mainWindow.codeView.fromSymbol + 1, mainWindow.codeView.y + cursor.position.line - mainWindow.codeView.fromLine
			if 
				x >= mainWindow.codeView.codeAreaPosition + 1 and
				x <= mainWindow.codeView.codeAreaPosition + mainWindow.codeView.codeAreaWidth - 2 and
				y >= mainWindow.codeView.y and
				y <= mainWindow.codeView.y + mainWindow.codeView.height - 2
			then
				buffer.text(x, y, config.cursorColor, config.cursorSymbol)
			end
		end
		buffer.draw()
	end
end

---------------------------------------------------- RUSH B! ----------------------------------------------------

loadConfig()
createWindow()
changeScale(config.screenScale)
updateTitle()
updateRAMProgressBar()
mainWindow:draw()

if args[1] == "open" and fs.exists(args[2] or "") then
	loadFile(args[2])
else
	newFile()
end

mainWindow:draw()
buffer.draw()
mainWindow:handleEvents(config.cursorBlinkDelay)


D/MineOS/Applications/MineCode IDE.app/Resources/D5MineOS/Applications/MineCode IDE.app/Resources/About/F@MineOS/Applications/MineCode IDE.app/Resources/About/Russian.txt½MineCode IDE - ÑÑÐ¾ Ð¼Ð¾ÑÐ½ÑÐ¹ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½Ñ Ð´Ð»Ñ ÑÐ°Ð·ÑÐ°Ð±Ð¾ÑÐºÐ¸ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹ Ñ Ð±Ð¾Ð³Ð°ÑÑÐ¼ ÑÑÐ½ÐºÑÐ¸Ð¾Ð½Ð°Ð»Ð¾Ð¼: Ð¾Ñ Ð¿Ð¾Ð´ÑÐ²ÐµÑÐºÐ¸ ÑÐ¸Ð½ÑÐ°ÐºÑÐ¸ÑÐ° Lua, Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ñ ÑÐµÐºÑÑÐ° Ð¸ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð±ÑÑÐµÑÐ¾Ð¼ Ð¾Ð±Ð¼ÐµÐ½Ð° Ð´Ð¾ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ¸ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÑÑÐºÐ¸Ñ ÑÐ²ÐµÑÐ¾Ð²ÑÑ ÑÑÐµÐ¼. Ð£Ð´Ð¾Ð±Ð½ÑÐ¹ ÑÐ°Ð¹Ð»Ð¾Ð²ÑÐ¹ Ð¼ÐµÐ½ÐµÐ´Ð¶ÐµÑ ÑÐ°ÐºÐ¶Ðµ Ð¿ÑÐ¸Ð»Ð°Ð³Ð°ÐµÑÑÑ.F7MineOS/Applications/MineCode IDE.app/Resources/Icon.picOCIFA SbFþB )YScFUB )YSdFøB )YSeFøB )YYFUB )YSwFøB )YShFøB )YSâFÖB )YFÿB )YSiFøB )YSmFUB )YSlFøB )YS-FUB )YSnFøB )YSoFUB )YS F B )YYYSaFþB )YD<MineOS/Applications/MineCode IDE.app/Resources/Localization/FHMineOS/Applications/MineCode IDE.app/Resources/Localization/English.langf{	
	enableAutoBrackets = "Enable autobrackets",
	disableAutoBrackets = "Disable autobrackets",
	url = "http://example.com/something.lua",
	getFromWeb = "Download from URL",
	debugging = "Debugger on line ",
	runtimeError = "Runtime error",
	variablesNotAvailable = "No variables found",
	variables = "Values of the variables:",
	scalePlus = "Increase scale",
	scaleMinus = "Decrease scale",
	pathToFile = "Path to file",
	selectWord = "Select current word",
	gotoCyka = "Goto",
	gotoEnd = "Scroll to end",
	gotoStart = "Scroll to start",
	pageDown = "Page down",
	pageUp = "Page up",
	deleteLine = "Delete current line",
	cursorProperties = "Cursor properties",
	cursorSymbol = "Symbol",
	cursorColor = "Color",
	cursorBlinkDelay = "Blink delay",
	selection = "Selection: ",
	none = "none",
	view = "View",
	about = "About",
	quit = "Quit from MineCode",
	line = " line, ",
	symbol = " symbol",
	lines = " lines, ",
	symbols = " symbols",
	file = "File",
	cursor = "Cursor: ",
	new = "New",
	open = "Open",
	openFile = "Open file",
	save = "Save",
	saveAs = "Save as",
	colorScheme = "Color scheme",
	color = "Color",
	toggleTopToolBar = "Show top toolbar",
	find = "Find",
	findSomeShit = "Let's find some shitâ¦",
	cut = "Cut",
	copy = "Copy",
	paste = "Paste",
	selectAll = "Select all",
	edit = "Edit",
	comment = "Toggle comment",
	indent = "Indent",
	unindent = "Unindent",
}FHMineOS/Applications/MineCode IDE.app/Resources/Localization/Russian.lang3{
	enableAutoBrackets = "ÐÐºÐ»ÑÑÐ¸ÑÑ Ð°Ð²ÑÐ¾-ÑÐºÐ¾Ð±ÐºÐ¸",
	disableAutoBrackets = "ÐÑÐºÐ»ÑÑÐ¸ÑÑ Ð°Ð²ÑÐ¾-ÑÐºÐ¾Ð±ÐºÐ¸",
	url = "http://example.com/something.lua",
	getFromWeb = "ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ Ð¿Ð¾ URL",
	debugging = "ÐÑÐ»Ð°Ð´ÑÐ¸Ðº Ð½Ð° ÑÑÑÐ¾ÐºÐµ ",
	runtimeError = "ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ",
	variablesNotAvailable = "ÐÐµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð¾ Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½ÑÑ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÑ",
	variables = "ÐÐ½Ð°ÑÐµÐ½Ð¸Ñ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÑ:",
	scalePlus = "Ð£Ð²ÐµÐ»Ð¸ÑÐ¸ÑÑ Ð¼Ð°ÑÑÑÐ°Ð±",
	scaleMinus = "Ð£Ð¼ÐµÐ½ÑÑÐ¸ÑÑ Ð¼Ð°ÑÑÑÐ°Ð±",
	pathToFile = "ÐÑÑÑ Ðº ÑÐ°Ð¹Ð»Ñ",
	selectWord = "ÐÑÐ´ÐµÐ»Ð¸ÑÑ ÑÐµÐºÑÑÐµÐµ ÑÐ»Ð¾Ð²Ð¾",
	gotoCyka = "ÐÐµÑÐµÑÐ¾Ð´",
	gotoEnd = "Ð ÐºÐ¾Ð½ÐµÑ",
	gotoStart = "Ð Ð½Ð°ÑÐ°Ð»Ð¾",
	pageDown = "ÐÐ° ÑÑÑÐ°Ð½Ð¸ÑÑ Ð½Ð¸Ð¶Ðµ",
	pageUp = "ÐÐ° ÑÑÑÐ°Ð½Ð¸ÑÑ Ð²ÑÑÐµ",
	deleteLine = "Ð£Ð´Ð°Ð»Ð¸ÑÑ ÑÐµÐºÑÑÑÑ ÑÑÑÐ¾ÐºÑ",
	cursorProperties = "ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ ÐºÑÑÑÐ¾ÑÐ°",
	cursorSymbol = "Ð¡Ð¸Ð¼Ð²Ð¾Ð»",
	cursorColor = "Ð¦Ð²ÐµÑ",
	cursorBlinkDelay = "ÐÑÐµÐ¼Ñ Ð¼Ð¸Ð³Ð°Ð½Ð¸Ñ",
	selection = "ÐÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ: ",
	none = "Ð½ÐµÑ",
	view = "ÐÐ¸Ð´",
	about = "Ð Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ðµ",
	quit = "ÐÑÐ¹ÑÐ¸ Ð¸Ð· MineCode",
	line = " ÑÑÑÐ¾ÐºÐ°, ",
	symbol = " ÑÐ¸Ð¼Ð²Ð¾Ð»",
	lines = " ÑÑÑÐ¾Ðº, ",
	symbols = " ÑÐ¸Ð¼Ð²Ð¾Ð»Ð¾Ð²",
	file = "Ð¤Ð°Ð¹Ð»",
	cursor = "ÐÑÑÑÐ¾Ñ: ",
	new = "ÐÐ¾Ð²ÑÐ¹",
	open = "ÐÑÐºÑÑÑÑ",
	openFile = "ÐÑÐºÑÑÑÑ ÑÐ°Ð¹Ð»",
	save = "Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ",
	saveAs = "Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÐºÐ°Ðº",
	colorScheme = "Ð¦Ð²ÐµÑÐ¾Ð²Ð°Ñ ÑÑÐµÐ¼Ð°",
	color = "Ð¦Ð²ÐµÑ",
	toggleTopToolBar = "ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ Ð¿Ð°Ð½ÐµÐ»Ñ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÐ¾Ð²",
	find = "ÐÐ°Ð¹ÑÐ¸",
	findSomeShit = "ÐÐ°Ð²Ð°Ð¹ Ð½Ð°Ð¹Ð´ÐµÐ¼ ÐºÐ°ÐºÑÑ-Ð½Ð¸Ð±ÑÐ´Ñ ÑÑÐ¹Ð½Ñâ¦",
	cut = "ÐÑÑÐµÐ·Ð°ÑÑ",
	copy = "ÐÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ",
	paste = "ÐÑÑÐ°Ð²Ð¸ÑÑ",
	selectAll = "ÐÑÐ´ÐµÐ»Ð¸ÑÑ Ð²ÑÐµ",
	edit = "Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ",
	comment = "ÐÐ¾Ð¼Ð¼ÐµÐ½ÑÐ¸ÑÐ¾Ð²Ð°ÑÑ",
	indent = "Ð¢Ð°Ð±ÑÐ»Ð¸ÑÐ¾Ð²Ð°ÑÑ",
	unindent = "ÐÐµÑÐ°Ð±ÑÐ»Ð¸ÑÐ¾Ð²Ð°ÑÑ",
}D"MineOS/Applications/Photoshop.app/F/MineOS/Applications/Photoshop.app/Photoshop.luaâ

------------------------------------------------ ÐÐ½ÑÐ¾ÑÐ¼ÐµÑÐ¹Ð½, ÐµÐ¿ÑÐ° --------------------------------------------------------------

local photoshopVersion = "Photoshop v6.5"

local copyright = [[
	
	Photoshop v6.5 Ð´Ð»Ñ OpenComputers

	ÐÐ²ÑÐ¾Ñ: ECS
		ÐÐ¾Ð½ÑÐ°ÐºÑÑÐ¹ Ð°Ð´ÑÐµÑ: https://vk.com/id7799889
	Ð¡Ð¾Ð°Ð²ÑÐ¾Ñ: Pornogion
		ÐÐ¾Ð½ÑÐ°ÐºÑÑÐ¹ Ð°Ð´ÑÐµÑ: https://vk.com/id88323331

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 6.5:
		- ÐÐ°Ð»Ð¸ÑÑÐ° Ð·Ð°Ð¼ÐµÐ½ÐµÐ½Ð° Ð½Ð° Ð±Ð¾Ð»ÐµÐµ Ð±ÑÑÑÑÑÑ Ð¸ ÑÑÐ¸Ð»ÑÐ½ÑÑ, ÑÐ°Ð±Ð¾ÑÐ°ÑÑÑÑ Ð½Ð° ÑÑÐ¾Ð¹Ð½Ð¾Ð¼ Ð±ÑÑÐµÑÐµ
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð° Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑ Ð·Ð°Ð³ÑÑÐ·ÐºÐ¸ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¸Ð· ÑÑÑÐ¾ÐºÐ¸, ÑÐ¾Ð·Ð´Ð°Ð½Ð½Ð¾Ð¹ Ð¼ÐµÑÐ¾Ð´Ð¾Ð¼ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸Ñ OCIFString

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 6.4:
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð° Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ÑÑÑ Ð²ÑÐ±Ð¾ÑÐ° ÑÐ²ÐµÑÐ° ÑÐµÑÐºÐ¸ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸ Ð²Ð¾ Ð²ÐºÐ»Ð°Ð´ÐºÐµ "ÐÐ¸Ð´"

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 6.3:
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð° Ð¿Ð¾Ð´Ð´ÐµÑÐ¶ÐºÐ° ÑÐ·ÑÐºÐ¾Ð²ÑÑ Ð¿Ð°ÐºÐµÑÐ¾Ð²

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 6.2:
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½ ÑÑÐ±-Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½Ñ "ÐÐ¾Ð»Ð¸Ð³Ð¾Ð½"
		- Ð£Ð»ÑÑÑÐµÐ½ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½Ñ "ÐÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ", ÑÐµÐ¿ÐµÑÑ Ð¼Ð¾Ð¶Ð½Ð¾ Ð²ÑÐ´ÐµÐ»ÑÑÑ Ð¾Ð±Ð»Ð°ÑÑÐ¸ Ñ ÑÐ¸ÑÐ¸Ð½Ð¾Ð¹ Ð¸Ð»Ð¸ Ð²ÑÑÐ¾ÑÐ¾Ð¹, ÑÐ°Ð²Ð½ÑÐ¼Ð¸ 1

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 6.1:
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½ ÑÑÐ±-Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½Ñ "Ð­Ð»Ð»Ð¸Ð¿Ñ"

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 6.0:
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½ Ð¸ÑÑÑÑÐ¼ÐµÐ½Ñ "Ð¤Ð¸Ð³ÑÑÐ°", Ð²ÐºÐ»ÑÑÐ°ÑÑÐ¸Ð¹ Ð² ÑÐµÐ±Ñ Ð»Ð¸Ð½Ð¸Ñ, Ð¿ÑÑÐ¼Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº Ð¸ ÑÐ°Ð¼ÐºÑ
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½ ÑÐ¸Ð»ÑÑÑ ÑÐ°Ð·Ð¼ÑÑÐ¸Ñ Ð¿Ð¾ ÐÐ°ÑÑÑÑ
		- ÐÐµÑÐµÑÐ°Ð±Ð¾ÑÐ°Ð½Ð° ÐºÐ¾Ð½ÑÐµÐ¿ÑÐ¸Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸ÑÐ¼Ð¸

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 5.1:
		- Ð¦Ð²ÐµÑÐ¾Ð²Ð°Ñ Ð³Ð°Ð¼Ð¼Ð° Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½Ð° Ð½Ð° Ð±Ð¾Ð»ÐµÐµ Ð´ÐµÑÐ°Ð»ÑÐ½ÑÑ
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð° Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¾Ð½Ð½Ð°Ñ Ð¼Ð¸Ð½Ð¸-Ð¿Ð°Ð½ÐµÐ»Ñ Ðº Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÑ "Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ"
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð° Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ ÑÐ°Ð·Ð¼ÐµÑÐµ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ, Ð¾ÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÐ¼Ð°Ñ Ð¿Ð¾Ð´ ÑÐ°Ð¼Ð¸Ð¼ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸ÐµÐ¼
		- Ð£ÑÐºÐ¾ÑÐµÐ½ Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ ÐºÐ¸ÑÑÑÑ Ð¸ Ð»Ð°ÑÑÐ¸ÐºÐ¾Ð¼

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 5.0:
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½Ñ "Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ" Ð¸ Ð½ÐµÑÐºÐ¾Ð»ÑÐºÐ¾ ÑÑÐ½ÐºÑÐ¸Ð¹ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð½Ð¸Ð¼
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾ Ð¼ÐµÐ½Ñ "ÐÐ¾ÑÑÑÐ¸Ðµ ÐºÐ»Ð°Ð²Ð¸ÑÐ¸", Ð¿Ð¾Ð´ÑÐºÐ°Ð·ÑÐ²Ð°ÑÑÐµÐµ, ÐºÐ°Ðº Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ´Ð¾Ð±Ð½ÐµÐµ ÑÐ°Ð±Ð¾ÑÐ°ÑÑ Ñ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð¾Ð¹

	Ð§ÑÐ¾ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð² Ð²ÐµÑÑÐ¸Ð¸ 4.0:
		- ÐÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ð° Ð¿ÐµÑÐµÐ²ÐµÐ´ÐµÐ½Ð° Ð½Ð° Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÑ ÑÑÐ¾Ð¹Ð½Ð¾Ð³Ð¾ Ð±ÑÑÐµÑÐ°, ÑÐºÐ¾ÑÐ¾ÑÑÑ ÑÐ°Ð±Ð¾ÑÑ ÑÐ²ÐµÐ»Ð¸ÑÐµÐ½Ð° Ð² Ð´ÐµÑÑÑÐºÐ¸ ÑÐ°Ð·
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð¾Ð±ÑÐµÐ·ÐºÐ¸, ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð¸Ñ, Ð¿Ð¾Ð²Ð¾ÑÐ¾ÑÐ° Ð¸ Ð¾ÑÑÐ°Ð¶ÐµÐ½Ð¸Ñ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸
		- ÐÐ¾Ð±Ð°Ð²Ð»ÐµÐ½Ñ ÑÑÐ½ÐºÑÐ¸Ð¸ ÑÐ¾Ð½Ð°/Ð½Ð°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÐ¸, ÑÐ²ÐµÑÐ¾Ð²Ð¾Ð³Ð¾ Ð±Ð°Ð»Ð°Ð½ÑÐ° Ð¸ Ð½Ð°Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ ÑÐ¾ÑÐ¾ÑÐ¸Ð»ÑÑÑÐ°

]]

copyright = nil

------------------------------------------------ ÐÐ¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸ --------------------------------------------------------------

local ecs = require("ECSAPI")
local MineOSCore = require("MineOSCore")
local GUI = require("GUI")
local fs = require("filesystem")
local unicode = require("unicode")
local image = require("image")
local component = require("component")
local keyboard = require("keyboard")
local buffer = require("doubleBuffering")
local colorlib = require("colorlib")
local palette = require("palette")
local event = require("event")

------------------------------------------------ ÐÐµÑÐµÐ¼ÐµÐ½Ð½ÑÐµ --------------------------------------------------------------

--ÐÐ½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÑ Ð´Ð²Ð¾Ð¹Ð½Ð¾Ð³Ð¾ Ð±ÑÑÐµÑÐ°
buffer.start()

--ÐÐ°ÑÑÐ¸Ð² Ð»Ð¾ÐºÐ°Ð»Ð¸Ð°ÑÐ¸Ð¸
local localization = MineOSCore.getCurrentApplicationLocalization()

--ÐÐ°ÑÑÐ¸Ð² Ð¸Ð½ÑÑ Ð¾ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸
local selection

--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÑ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ
local args = {...}

--ÐÐ°ÑÑÐ¸Ð² Ð³Ð»Ð°Ð²Ð½Ð¾Ð³Ð¾ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local masterPixels = {
	width = 0,
	height = 0,
}

--ÐÐ°Ð·Ð¾Ð²Ð°Ñ ÑÐ²ÐµÑÐ¾Ð²Ð°Ñ ÑÑÐµÐ¼Ð° Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ
local colors = {
	leftToolbar = 0x3c3c3c,
	leftToolbarButton = 0x2d2d2d,
	leftToolbarButtonText = 0xeeeeee,
	topToolbar = 0x4b4b4b,
	drawingArea = 0x1e1e1e,
	console = 0x2d2d2d,
	consoleText = 0x999999,
	transparencyWhite = 0xffffff,
	transparencyGray = 0xcccccc,
	transparencyVariable = 0xffffff,
	oldBackground = 0x0,
	oldForeground = 0x0,
	topMenu = 0xeeeeee,
	topMenuText = 0x262626,
}

--Ð Ð°Ð·Ð»Ð¸ÑÐ½ÑÐµ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÑ Ð¸ ÑÐ°Ð·Ð¼ÐµÑÑ ÑÑÐ»Ð±Ð°ÑÐ¾Ð² Ð¸ ÐºÐ»Ð¸ÐºÐ°Ð±ÐµÐ»ÑÐ½ÑÑ Ð·Ð¾Ð½
local sizes = {
	widthOfLeftBar = 6,
}
sizes.xStartOfDrawingArea = sizes.widthOfLeftBar + 1
sizes.xEndOfDrawingArea = buffer.screen.width
sizes.yStartOfDrawingArea = 2
sizes.yEndOfDrawingArea = buffer.screen.height - 1
sizes.widthOfDrawingArea = sizes.xEndOfDrawingArea - sizes.xStartOfDrawingArea + 1
sizes.heightOfDrawingArea = sizes.yEndOfDrawingArea - sizes.yStartOfDrawingArea + 1
sizes.heightOfLeftBar = buffer.screen.height - 1
sizes.sizeOfPixelData = 4

--ÐÐ»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local function reCalculateImageSizes(x, y)
	sizes.xStartOfImage = x or 9
	sizes.yStartOfImage = y or 6
	sizes.xEndOfImage = sizes.xStartOfImage + masterPixels.width - 1
	sizes.yEndOfImage = sizes.yStartOfImage + masterPixels.height - 1
end
reCalculateImageSizes()

--ÐÐ½ÑÑÑÑÐ¼ÐµÐ½ÑÑ
local instruments = {
	"M",
	"B",
	"E",
	"F",
	"T",
	"S",
}
sizes.heightOfInstrument = 3
sizes.yStartOfInstruments = 2
local currentInstrument = 2
local currentBackground = 0x000000
local currentForeground = 0xFFFFFF
local currentAlpha = 0x00
local currentSymbol = " "
local currentBrushSize = 1
local savePath
local currentShape
local currentPolygonCountOfEdges
local showTransparencyGrid = true

------------------------------------------------ Ð¤ÑÐ½ÐºÑÐ¸Ð¸ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ --------------------------------------------------------------

--ÐÐ±ÑÐµÐºÑÑ Ð´Ð»Ñ ÑÐ°ÑÐ°
local obj = {}
local function newObj(class, name, ...)
	obj[class] = obj[class] or {}
	obj[class][name] = {...}
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-ÑÐ²Ð°Ð¿Ð¿ÐµÑ Ð¿ÐµÑÐµÐ¼ÐµÐ½Ð½ÑÑ, Ð¿Ð¾ÐºÐ° ÑÑÐ¾ ÑÐ·Ð°ÐµÑÑÑ ÑÐ¾Ð»ÑÐºÐ¾ Ð² Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ð¸
--Ð, Ð½Ðµ, Ð½Ð°ÐµÐ±Ð°Ð»!
--ÐÐ¾Ð½, Ð½Ð¸Ð¶Ðµ ÑÐ¾Ð¶Ðµ ÑÐ·Ð°ÐµÑÑÑ! Ð¥Ð°, ÑÐ´Ð¾Ð±Ð½ÐµÐ½ÑÐºÐ¾
local function swap(a, b)
	return b, a
end

--ÐÐ´ÐµÐºÐ²Ð°ÑÐ½Ð¾Ðµ Ð¾ÐºÑÑÐ³Ð»ÐµÐ½Ð¸Ðµ, Ð¸Ð±Ð¾ Ð² Ð»ÑÐ°ÑÐºÐµ Ð½ÐµÑ ÑÐ°ÐºÐ¾Ð³Ð¾, Ð¥ÐÐ¥
local function round(num) 
	if num >= 0 then
		return math.floor(num + 0.5) 
	else
		return math.ceil(num - 0.5)
	end
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° "Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾Ð¹ Ð·Ð¾Ð½Ñ", ÑÑÐ°ÐºÐ°Ñ ÑÐµÑÐ¾ÑÐºÐ° ÑÐµÑÐµÐ´ÑÑÑÐ°ÑÑÑ
local function drawTransparentZone(x, y)
	if showTransparencyGrid then
		y = y - 1

		local stro4ka1 = ""
		local stro4ka2 = ""
		if masterPixels.width % 2 == 0 then
			stro4ka1 = string.rep("â ", math.floor(masterPixels.width / 2))
			stro4ka2 = stro4ka1
		else
			stro4ka1 = string.rep("â ", math.floor(masterPixels.width / 2))
			stro4ka2 = stro4ka1 .. "â"
		end

		for i = 1, masterPixels.height do
			if i % 2 == 0 then
				buffer.square(x, y + i, masterPixels.width, 1, colors.transparencyWhite, colors.transparencyGray, " ")
				buffer.text(x + 1, y + i, colors.transparencyGray, stro4ka1)
			else
				buffer.square(x, y + i, masterPixels.width, 1, colors.transparencyWhite, colors.transparencyGray)
				buffer.text(x, y + i, colors.transparencyGray, stro4ka2)
			end
		end
	else
		buffer.square(x, y, masterPixels.width, masterPixels.height, colors.transparencyWhite, 0x000000, " ")
	end
end

--ÐÐ°Ð½Ð°Ð»ÑÐ½Ð°Ñ Ð·Ð°Ð»Ð¸Ð²ÐºÐ° ÑÐ¾Ð½Ð°
local function drawBackground()
	buffer.square(sizes.xStartOfDrawingArea, sizes.yStartOfDrawingArea, sizes.widthOfDrawingArea, sizes.heightOfDrawingArea + 1, colors.drawingArea, 0xFFFFFF, " ")
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° ÑÐ²ÐµÑÐ¾Ð²
local function drawColors()
	local xPos, yPos = 2, buffer.screen.height - 4
	buffer.square(xPos, yPos, 3, 2, currentBackground, 0xFFFFFF, " ")
	buffer.square(xPos + 3, yPos + 1, 1, 2, currentForeground, 0xFFFFFF, " ")
	buffer.square(xPos + 1, yPos + 2, 2, 1, currentForeground, 0xFFFFFF, " ")
	buffer.text(xPos + 1, yPos + 3, 0xaaaaaa, "ââ")

	newObj("Colors", 1, xPos, yPos, xPos + 2, yPos + 1)
	newObj("Colors", 2, xPos + 3, yPos + 1, xPos + 3, yPos + 2)
	newObj("Colors", 3, xPos + 1, yPos + 2, xPos + 3, yPos + 2)
	newObj("Colors", 4, xPos + 1, yPos + 3, xPos + 2, yPos + 3)
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¿Ð°Ð½ÐµÐ»Ð¸ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÐ¾Ð² ÑÐ»ÐµÐ²Ð°
local function drawLeftBar()
	--Ð Ð¸ÑÑÐµÐ¼ Ð¿Ð¾Ð´Ð»Ð¾Ð¶ÐµÑÐºÑ
	buffer.square(1, 5, sizes.widthOfLeftBar, sizes.heightOfLeftBar, colors.leftToolbar, 0xFFFFFF, " ")
	--Ð Ð¸ÑÑÐµÐ¼ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÑ
	local yPos = sizes.yStartOfInstruments
	for i = 1, #instruments do
		if currentInstrument == i then
			buffer.square(1, yPos, sizes.widthOfLeftBar, sizes.heightOfInstrument, colors.leftToolbarButton, 0xFFFFFF, " ")
		else
			buffer.square(1, yPos, sizes.widthOfLeftBar, sizes.heightOfInstrument, colors.leftToolbar, 0xFFFFFF, " ")
		end
		buffer.text(3, yPos + 1, colors.leftToolbarButtonText, instruments[i])

		newObj("Instruments", i, 1, yPos, sizes.widthOfLeftBar, yPos + sizes.heightOfInstrument - 1)

		yPos = yPos + sizes.heightOfInstrument
	end
	--Ð ÑÐ²ÐµÑÐ°
	drawColors()
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð²ÐµÑÑÐ½ÐµÐ³Ð¾ Ð¼ÐµÐ½Ñ
local function drawTopMenu()
	obj.menu = GUI.menu(1, 1, buffer.screen.width, colors.topMenu, colors.topMenuText, 0x3366CC, 0xFFFFFF, 0)
	obj.menu:addItem("PS", ecs.colors.blue)
	obj.menu:addItem(localization.file)
	obj.menu:addItem(localization.image)
	obj.menu:addItem(localization.edit)
	obj.menu:addItem(localization.view)
	obj.menu:addItem(localization.hotkeys)
	obj.menu:addItem(localization.about)
	obj.menu:draw()
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ, ÑÐ¾Ð·Ð´Ð°ÑÑÐ°Ñ Ð¿ÑÑÑÐ¾Ð¹ Ð¼Ð°ÑÑÐ¸Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð½Ð° Ð¾ÑÐ½Ð¾Ð²Ðµ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÑ ÑÐ°Ð½ÐµÐµ Ð´Ð»Ð¸Ð½Ñ Ð¸ ÑÐ¸ÑÐ¸Ð½Ñ
local function createEmptyMasterPixels()
	--Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð¿ÑÑÑÐ¾Ð¹ Ð¼Ð°ÑÑÐµÑÐ¿Ð¸ÐºÑÐµÐ»ÑÑ
	for j = 1, masterPixels.height * masterPixels.width do
		table.insert(masterPixels, 0x010101)
		table.insert(masterPixels, 0x010101)
		table.insert(masterPixels, 0xFF)
		table.insert(masterPixels, " ")
	end
end

--Ð¤Ð¾ÑÐ¼ÑÐ»Ð° ÐºÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ð¸ Ð¸ÑÐµÑÐ°ÑÐ¾ÑÐ° Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð² Ð°Ð±ÑÐ¾Ð»ÑÑÐ½ÑÐµ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local function convertIteratorToCoords(iterator)
	--ÐÑÐ¸Ð²Ð¾Ð´Ð¸Ð¼ Ð¸ÑÐµÑÐ°ÑÐ¾Ñ Ðº ÐºÐ¾ÑÑÐµÐºÑÐ½Ð¾Ð¼Ñ Ð²Ð¸Ð´Ñ (1 = 1, 5 = 2, 9 = 3, 13 = 4, 17 = 5, ...)
	iterator = (iterator + sizes.sizeOfPixelData - 1) / sizes.sizeOfPixelData
	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¾ÑÑÐ°ÑÐ¾Ðº Ð¾Ñ Ð´ÐµÐ»ÐµÐ½Ð¸Ñ Ð¸ÑÐµÑÐ°ÑÐ¾ÑÐ° Ð½Ð° ÑÐ¸ÑÐ¸Ð½Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
	local ostatok = iterator % masterPixels.width
	--ÐÑÐ»Ð¸ Ð¾ÑÑÐ°ÑÐ¾Ðº ÑÐ°Ð²ÐµÐ½ 0, ÑÐ¾ Ñ ÑÐ°Ð²ÐµÐ½ ÑÐ¸ÑÐ¸Ð½Ðµ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ, Ð° ÐµÑÐ»Ð¸ Ð½ÐµÑ, ÑÐ¾ Ñ ÑÐ°Ð²ÐµÐ½ Ð¾ÑÑÐ°ÑÐºÑ
	local x = (ostatok == 0) and masterPixels.width or ostatok
	--Ð ÑÐµÐ¿ÐµÑÑ ÐºÐ°Ðº Ð´Ð²Ð° Ð¿Ð°Ð»ÑÑÐ° Ð¿Ð¾Ð»ÑÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð¿Ð¾ Y
	local y = math.ceil(iterator / masterPixels.width)
	--ÐÑÐ¸ÑÐ°ÐµÐ¼ Ð¾ÑÑÐ°ÑÐ¾Ðº Ð¸Ð· Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²ÐºÐ¸
	ostatok = nil
	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ
	return x, y
end

--Ð¤Ð¾ÑÐ¼ÑÐ»Ð° ÐºÐ¾Ð½Ð²ÐµÑÑÐ°ÑÐ¸Ð¸ Ð°Ð±ÑÐ¾Ð»ÑÑÐ½ÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð² Ð¸ÑÐµÑÐ°ÑÐ¾Ñ Ð´Ð»Ñ Ð¼Ð°ÑÑÐ¸Ð²Ð°
local function convertCoordsToIterator(x, y)
	--ÐÐ¾Ð½Ð²ÐµÑÑÐ¸ÑÑÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð² Ð¸ÑÐµÑÐ°ÑÐ¾Ñ
	return (masterPixels.width * (y - 1) + x) * sizes.sizeOfPixelData - sizes.sizeOfPixelData + 1
end

--ÐÐ¸Ð½Ð¸-ÐºÐ¾Ð½ÑÐ¾Ð»ÑÐºÐ° Ð´Ð»Ñ Ð¾ÑÐ»Ð°Ð´ÐºÐ¸, ÑÐ¾Ð¾Ð±ÑÐ°ÑÑÐ°Ñ ÑÐ½Ð¸Ð·Ñ, ÑÐµ Ð¿ÑÐ¾Ð¸ÑÑÐ¾Ð´Ð¸Ñ Ð²Ð°ÑÐµ
local function console(text)
	buffer.square(sizes.xStartOfDrawingArea, buffer.screen.height, sizes.widthOfDrawingArea, 1, colors.console, colors.consoleText, " ")
	
	local _, total, used = ecs.getInfoAboutRAM()
	local RAMText = used .. "/" .. total .. " KB RAM"
	buffer.text(sizes.xEndOfDrawingArea - unicode.len(RAMText), buffer.screen.height, colors.consoleText, RAMText)
	
	buffer.text(sizes.xStartOfDrawingArea + 1, buffer.screen.height, colors.consoleText, text)
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ, Ð±ÐµÑÑÑÐ°Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð· Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ Ð¸ ÑÐ¸ÑÑÑÑÐ°Ñ ÐµÐ³Ð¾ Ð² Ð±ÑÑÐµÑÐµ ÐºÐ¾ÑÑÐµÐºÑÐ½Ð¾,
--Ñ.Ðµ. Ñ ÑÑÐµÑÐ¾Ð¼ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸ Ð¸ Ñ.Ð¿.
local function drawPixel(x, y, xPixel, yPixel, iterator)
	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÑÑÐºÑÑÐ¸Ðµ Ð´Ð°Ð½Ð½ÑÐµ Ð¾ Ð¿Ð¸ÐºÑÐµÐ»Ðµ
	local background, foreground, alpha, symbol = masterPixels[iterator], masterPixels[iterator + 1], masterPixels[iterator + 2], masterPixels[iterator + 3]
	--ÐÑÐ»Ð¸ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð½Ðµ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½ÑÐ¹
	if alpha == 0x00 then
		buffer.set(x, y, background, foreground, symbol)
	--ÐÑÐ»Ð¸ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½ÐµÐµ Ð½ÐµÐ¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾Ð³Ð¾
	elseif alpha > 0x00 then
		local blendColor
		if xPixel % 2 == 0 then
			if yPixel % 2 == 0 then
				blendColor = colors.transparencyGray
			else
				blendColor = colors.transparencyWhite
			end
		else
			if yPixel % 2 == 0 then
				blendColor = colors.transparencyWhite
			else
				blendColor = colors.transparencyGray
			end
		end

		buffer.set(x, y, colorlib.alphaBlend(blendColor, background, alpha), foreground, symbol)
	end
	background, foreground, alpha, symbol = nil, nil, nil, nil
end

--ÐÐ¸Ð·Ð´ÑÐ»Ð¸Ð½ÐºÐ°, Ð¿Ð¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑÐ°Ñ ÑÐ°Ð·Ð¼ÐµÑ ÑÐµÐºÑÑÐ° Ð¸ ÑÑÐ¿Ñ
local function drawTooltip(x, y, ...)
	local texts = {...}
	--Ð Ð°ÑÑÑÐ¸ÑÑÐ²Ð°ÐµÐ¼ ÑÐ¸ÑÐ¸Ð½Ñ Ð¿Ð¸Ð·Ð´ÑÐ»Ð¸Ð½ÐºÐ¸
	local maxWidth = 0; for i = 1, #texts do maxWidth = math.max(maxWidth, unicode.len(texts[i])) end
	--Ð Ð¸ÑÑÐµÐ¼ Ð¿Ð¸Ð·Ð´ÑÐ»Ð¸Ð½ÐºÑ
	buffer.square(x, y, maxWidth + 2, #texts, 0x000000, 0xFFFFFF, " ", 69); x = x + 1		
	for i = 1, #texts do buffer.text(x, y, 0xFFFFFF, texts[i]); y = y + 1 end
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ñ ÑÐ¾Ð¾ÑÐ². Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÐ¾Ð¼
local function drawSelection()
	local color = 0x000000
	local xStart, yStart = sizes.xStartOfImage + selection.x - 1, sizes.yStartOfImage + selection.y - 1
	local xEnd, yEnd = xStart + selection.width - 1, yStart + selection.height - 1
	local currentBackground

	local function nextColor()
		if color == 0x000000 then color = 0xFFFFFF else color = 0x000000 end
	end

	--"â"
	--"â"

	local function drawSelectionSquare(x1, y1, x2, y2, xStep, yStep, symbol)
		for y = y1, y2, yStep do
			for x = x1, x2, xStep do
				local background = buffer.get(x, y)
				buffer.set(x, y, background, color, symbol)
				nextColor()
			end
		end
	end

	local function drawCornerPoint(x, y, symbol)
		local background = buffer.get(x, y)
		buffer.set(x, y, background, color, symbol)
		nextColor()
	end

	if selection.width > 1 and selection.height > 1 then
		drawCornerPoint(xStart, yStart, "â")
		drawSelectionSquare(xStart + 1, yStart, xEnd - 1, yStart, 1, 1, "â")
		drawCornerPoint(xEnd, yStart, "â")
		drawSelectionSquare(xEnd, yStart + 1, xEnd, yEnd - 1, 1, 1, "â")
		drawCornerPoint(xEnd, yEnd, "â")
		drawSelectionSquare(xEnd - 1, yEnd, xStart + 1, yEnd, -1, 1, "â")
		drawCornerPoint(xStart, yEnd, "â")
		drawSelectionSquare(xStart, yEnd - 1, xStart, yStart + 1, 1, -1, "â")
	else
		if selection.width == 1 then
			drawSelectionSquare(xStart, yStart, xStart, yEnd, 1, 1, "â")
		elseif selection.height == 1 then 
			drawSelectionSquare(xStart, yStart, xEnd, yStart, 1, 1, "â")
		end
	end

	drawTooltip(xEnd + 2, yEnd - 1, localization.w .. ": " .. selection.width .. " px", localization.h .. ": " .. selection.height .. " px")
	-- drawTooltip(xEnd + 2, yEnd - 1, "Ð¨: " .. selection.width .. " px", "Ð: " .. selection.height .. " px", "S: " .. xStart .. "x" .. yStart, "E: " .. xEnd .. "x" .. yEnd)
end

local function line(x0, y0, x1, y1, background, applyToMasterPixels)
   	local steep = false;
    
    if math.abs(x0 - x1) < math.abs(y0 - y1 ) then
        x0, y0 = swap(x0, y0)
        x1, y1 = swap(x1, y1)
        steep = true;
    end

    if (x0 > x1) then
    	x0, x1 = swap(x0, x1)
    	y0, y1 = swap(y0, y1)
    end

    local dx = x1 - x0;
    local dy = y1 - y0;
    local derror2 = math.abs(dy) * 2
    local error2 = 0;
    local y = y0;
    
    for x = x0, x1, 1 do
        if steep then
        	if applyToMasterPixels then
        		image.set(masterPixels, y, x, background, 0x000000, 0x00, " ")
        	else
            	buffer.set(y, x, background, 0x000000, " ")
            end
        else
        	if applyToMasterPixels then
        		image.set(masterPixels, x, y, background, 0x000000, 0x00, " ")
        	else
            	buffer.set(x, y, background, 0x000000, " ")
            end
        end

        error2 = error2 + derror2;

        if error2 > dx then
            y = y + (y1 > y0 and 1 or -1);
            error2 = error2 - dx * 2;
        end
    end
end

local function drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	buffer.set(xStart, yStart, 0x99FF80, 0x000000, " ")
	buffer.set(xEnd, yEnd, 0x99FF80, 0x000000, " ")
end

local function drawLineShape()
	local xStart, yStart = sizes.xStartOfImage + selection.xStart - 1, sizes.yStartOfImage + selection.yStart - 1
	local xEnd, yEnd = sizes.xStartOfImage + selection.xEnd - 1, sizes.yStartOfImage + selection.yEnd - 1

	line(xStart, yStart, xEnd, yEnd, currentBackground)
	drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	drawTooltip(xEnd + 2, yEnd - 3, localization.w .. ": " .. selection.width .. " px", localization.h .. ": " .. selection.height .. " px", " ", localization.accept)
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ Ð¾Ð±Ð²Ð¾Ð´ÐºÐ¸ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¹ Ð·Ð¾Ð½Ñ
local function stroke(x, y, width, height, color, applyToMasterPixels)
	if applyToMasterPixels then
		local iterator
		for i = x, x + width - 1 do
			iterator = convertCoordsToIterator(i, y)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "

			iterator = convertCoordsToIterator(i, y + height - 1)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "
		end

		for i = y, y + height - 1 do
			iterator = convertCoordsToIterator(x, i)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "

			iterator = convertCoordsToIterator(x + width - 1, i)
			masterPixels[iterator] = color; masterPixels[iterator + 1] = 0x0; masterPixels[iterator + 2] = 0x0; masterPixels[iterator + 3] = " "
		end
	else
		buffer.square(x, y, width, 1, color, 0x000000, " ")
		buffer.square(x, y + height - 1, width, 1, color, 0x000000, " ")

		buffer.square(x, y, 1, height, color, 0x000000, " ")
		buffer.square(x + width - 1, y, 1, height, color, 0x000000, " ")
	end
end

local function ellipse(xStart, yStart, width, height, color, applyToMasterPixels)
	--helper function, draws pixel and mirrors it
	local function setpixel4(centerX, centerY, deltaX, deltaY, color)
		if applyToMasterPixels then
			image.set(masterPixels, centerX + deltaX, centerY + deltaY, color, 0x000000, 0x00, " ")
			image.set(masterPixels, centerX - deltaX, centerY + deltaY, color, 0x000000, 0x00, " ")
			image.set(masterPixels, centerX + deltaX, centerY - deltaY, color, 0x000000, 0x00, " ")
			image.set(masterPixels, centerX - deltaX, centerY - deltaY, color, 0x000000, 0x00, " ")
		else
			buffer.set(centerX + deltaX, centerY + deltaY, color, 0x000000, " ")
			buffer.set(centerX - deltaX, centerY + deltaY, color, 0x000000, " ")
			buffer.set(centerX + deltaX, centerY - deltaY, color, 0x000000, " ")
			buffer.set(centerX - deltaX, centerY - deltaY, color, 0x000000, " ")
		end
	end

	--red ellipse, 2*10px border
	local centerX = math.floor(xStart + width / 2)
	local centerY = math.floor(yStart + height / 2)
	local radiusX = math.floor(width / 2)
	local radiusY = math.floor(height / 2)
	local radiusX2 = radiusX ^ 2
	local radiusY2 = radiusY ^ 2
	
	--upper and lower halves
	local quarter = math.floor(radiusX2 / math.sqrt(radiusX2 + radiusY2))
	for x = 0, quarter do
		local y = radiusY * math.sqrt(1 - x^2 / radiusX2)
		setpixel4(centerX, centerY, x, math.floor(y), color);
	end

	--right and left halves
	quarter = math.floor(radiusY2 / math.sqrt(radiusX2 + radiusY2));
	for y = 0, quarter do
		x = radiusX * math.sqrt(1 - y^2 / radiusY2);
		setpixel4(centerX, centerY, math.floor(x), y, color);
	end
end

local function polygon(xCenter, yCenter, xStart, yStart, countOfEdges, color)
	local degreeStep = 360 / countOfEdges

	local deltaX, deltaY = xStart - xCenter, yStart - yCenter
	local radius = math.sqrt(deltaX ^ 2 + deltaY ^ 2)
	local halfRadius = radius / 2
	local startDegree = math.deg(math.asin(deltaX / radius))

	local function calculatePosition(degree)
		local radDegree = math.rad(degree)
		local deltaX2 = math.sin(radDegree) * radius
		local deltaY2 = math.cos(radDegree) * radius
		return round(xCenter + deltaX2), round(yCenter + (deltaY >= 0 and deltaY2 or -deltaY2))
	end

	local xOld, yOld, xNew, yNew = calculatePosition(startDegree)

	for degree = (startDegree + degreeStep - 1), (startDegree + 360), degreeStep do
		xNew, yNew = calculatePosition(degree)
		buffer.line(xOld, yOld, xNew, yNew, color, 0x000000, " ")
		xOld, yOld = xNew, yNew
	end
end

local function drawPolygonShape()
	local xStart, yStart = sizes.xStartOfImage + selection.xStart - 1, sizes.yStartOfImage + selection.yStart - 1
	local xEnd, yEnd = sizes.xStartOfImage + selection.xEnd - 1, sizes.yStartOfImage + selection.yEnd - 1

	local radius = math.floor(math.sqrt(selection.width ^ 2 + (selection.height*2) ^ 2))
	polygon(xStart, yStart, xEnd, yEnd, currentPolygonCountOfEdges, currentBackground)

	drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	drawTooltip(xEnd + 2, yEnd - 3, localization.radius .. ": " .. radius .. " px", localization.edges .. ": " .. currentPolygonCountOfEdges, " ", localization.accept)
end

local function drawSquareShape(type)
	local xStart, yStart = sizes.xStartOfImage + selection.x - 1, sizes.yStartOfImage + selection.y - 1
	local xEnd, yEnd = xStart + selection.width - 1, yStart + selection.height - 1
	
	if type == "filledSquare" then
		buffer.square(xStart, yStart, selection.width, selection.height, currentBackground, 0x000000, " ")
	elseif type == "frame" then
		stroke(xStart, yStart, selection.width, selection.height, currentBackground, false)
	elseif type == "ellipse" then
		ellipse(xStart, yStart, selection.width, selection.height, currentBackground, false)		
	end

	drawShapeCornerPoints(xStart, yStart, xEnd, yEnd)
	drawTooltip(xEnd + 2, yEnd - 3, localization.w .. ": " .. selection.width .. " px", localization.h .. ": " .. selection.height .. " px", " ", localization.accept)
end

local function drawMultiPointInstrument()
	if selection and selection.finished == true then
		if instruments[currentInstrument] == "M" then
			drawSelection()
		elseif instruments[currentInstrument] == "S" then
			if currentShape == localization.line then
				drawLineShape()
			elseif currentShape == localization.ellipse then
				drawSquareShape("ellipse")
			elseif currentShape == localization.rectangle then
				drawSquareShape("filledSquare")
			elseif currentShape == localization.border then
				drawSquareShape("frame")
			elseif currentShape == localization.polygon then
				drawPolygonShape()
			end
		end
	end
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local function drawImage()
	--Ð¡ÑÐ°ÑÑÐ¾Ð²ÑÐµ Ð½ÑÐ¶Ð½Ð¾ÑÑÐ¸
	local xPixel, yPixel = 1, 1
	local xPos, yPos = sizes.xStartOfImage, sizes.yStartOfImage

	--Ð£ÑÑÐ°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ðµ Ð¿ÑÐ¾ÑÐ¸ÑÐ¾Ð²ÐºÐ¸, ÑÑÐ¾Ð±Ñ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ° Ð½Ðµ ÑÑÐµÐ±ÑÐ²Ð°Ð»Ð° Ð·Ð° Ð´Ð¾Ð·Ð²Ð¾Ð»ÐµÐ½Ð½ÑÑ Ð·Ð¾Ð½Ñ
	buffer.setDrawLimit(sizes.xStartOfDrawingArea, sizes.yStartOfDrawingArea, sizes.widthOfDrawingArea, sizes.heightOfDrawingArea)

	--Ð Ð¸ÑÑÐµÐ¼ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½ÑÑ Ð·Ð¾Ð½Ñ
	drawTransparentZone(xPos, yPos)

	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð¼Ð°ÑÑÐ¸Ð² Ð¼Ð°ÑÑÐµÑÐ¿Ð¸ÐºÑÐµÐ»ÑÑÐ°
	for i = 1, #masterPixels, 4 do
		--Ð Ð¸ÑÑÐµÐ¼ Ð¿Ð¸ÐºÑÐµÐ»Ñ, ÐµÑÐ»Ð¸ Ñ Ð½ÐµÐ³Ð¾ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ Ð½Ðµ Ð°Ð±ÑÐ¾Ð»ÑÑÐ½Ð°Ñ, ÐÐÐÐ Ð¸Ð¼ÐµÐµÑÑÑ ÐºÐ°ÐºÐ¾Ð¹-ÑÐ¾ ÑÐ¸Ð¼Ð²Ð¾Ð»
		--Ð¢.Ðµ. Ð´Ð°Ð¶Ðµ ÐµÑÐ»Ð¸ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ Ð¸ Ð¾ÑÑÐµÐ»Ð°, Ð½Ð¾ ÑÐ¸Ð¼Ð²Ð¾Ð» ÐµÑÑÑ, ÑÐ¾ ÑÐ¸ÑÑÐµÐ¼ ÐµÐ³Ð¾
		if masterPixels[i + 2] ~= 0xFF or masterPixels[i + 3] ~= " " then
			drawPixel(xPos, yPos, xPixel, yPixel, i)
		end
		--ÐÑÑÐºÐ¸Ðµ ÑÐ°ÑÑÐµÑÑ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°Ñ
		xPixel = xPixel + 1
		xPos = xPos + 1
		if xPixel > masterPixels.width then xPixel = 1; xPos = sizes.xStartOfImage; yPixel = yPixel + 1; yPos = yPos + 1 end
	end

	if masterPixels.width > 0 and masterPixels.height > 0 then
		local text = localization.size  .. ": " .. masterPixels.width .. "x" .. masterPixels.height .. " px"
		xPos = math.floor(sizes.xStartOfImage + masterPixels.width / 2 - unicode.len(text) / 2)
		buffer.text(xPos, sizes.yEndOfImage + 1, 0xFFFFFF, text)
	end

	--Ð Ð¸ÑÑÐµÐ¼ Ð¼ÑÐ»ÑÑÐ¸Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½Ñ
	drawMultiPointInstrument()
	--Ð£Ð±Ð¸ÑÐ°ÐµÐ¼ Ð¾Ð³ÑÐ°Ð½Ð¸ÑÐµÐ½Ð¸Ðµ Ð¾ÑÑÐ¸ÑÐ¾Ð²ÐºÐ¸
	buffer.resetDrawLimit()
end

--ÐÑÐ¾ÑÑÐ¾ Ð´Ð»Ñ ÑÐ´Ð¾Ð±ÑÑÐ²Ð°
local function drawBackgroundAndImage()
	drawBackground()
	drawImage()
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ, ÑÐ¸ÑÑÑÑÐ°Ñ ÐÐ¡Ð, Ð°Ð±ÑÐ¾Ð»ÑÑÐ»Ð¸, ÐµÐ¿ÑÐ°
local function drawAll()
	drawBackground()
	drawLeftBar()
	drawTopMenu()
	drawBackgroundAndImage()

	buffer.draw()
end

------------------------------------------------ ÐÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°ÑÐµÐ»ÑÐ½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸ÐµÐ¼ Ð¸ Ð¿ÑÐ¾ÑÐ¸Ð¼ --------------------------------------------------------------

--Ð¡Ð¼ÐµÐ½Ð° Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÐ° Ð½Ð° ÑÐºÐ°Ð·Ð°Ð½Ð½ÑÐ¹ Ð½Ð¾Ð¼ÐµÑ
local function changeInstrumentTo(ID)
	currentInstrument = ID
	selection = nil
	drawAll()
end

--ÐÐµÑÐµÐ¼ÐµÑÐ°Ð»ÐºÐ° ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸ Ð² ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼ Ð½Ð°Ð¿ÑÐ°Ð²Ð»ÐµÐ½Ð¸Ð¸, Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÑÑÐ°Ñ Ð²ÑÐµ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÑ
local function move(direction)
	if instruments[currentInstrument] == "M" and selection and selection.finished == true then
		if direction == "up" then
			selection.y = selection.y - 1
			if selection.y < 1 then selection.y = 1 end
		elseif direction == "down" then
			selection.y = selection.y + 1
			if selection.y + selection.height - 1 > masterPixels.height then selection.y = selection.y - 1 end
		elseif direction == "left" then
			selection.x = selection.x - 1
			if selection.x < 1 then selection.x = 1 end
		elseif direction == "right" then
			selection.x = selection.x + 1
			if selection.x + selection.width - 1 > masterPixels.width then selection.x = selection.x - 1 end
		end
	else
		local howMuchUpDown = 2
		local howMuchLeftRight = 4
		if direction == "up" then
			reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage - howMuchUpDown)
		elseif direction == "down" then
			reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage + howMuchUpDown)
		elseif direction == "left" then
			reCalculateImageSizes(sizes.xStartOfImage - howMuchLeftRight, sizes.yStartOfImage)
		elseif direction == "right" then
			reCalculateImageSizes(sizes.xStartOfImage + howMuchLeftRight, sizes.yStartOfImage)
		end
	end
	drawBackgroundAndImage()
	buffer.draw()
end

--ÐÑÐ¾ÑÑÐ¾ Ð±Ð¾Ð»ÐµÐµ ÑÐ´Ð¾Ð±Ð½Ð°Ñ ÑÑÑÐ°Ð½Ð¾Ð²ÐºÐ° Ð¿Ð¸ÐºÑÐµÐ»Ñ, Ð° ÑÐ¾ Ð²ÑÐµ ÑÑÐ¸ Ð¿Ð»ÑÑÑ, Ð¼Ð¸Ð½ÑÑÑ, Ð±ÑÑÑ
local function setPixel(iterator, background, foreground, alpha, symbol)
	masterPixels[iterator] = background
	masterPixels[iterator + 1] = foreground
	masterPixels[iterator + 2] = alpha
	masterPixels[iterator + 3] = symbol
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ, Ð¼ÐµÐ½ÑÑÑÐ°Ñ ÑÐ²ÐµÑÐ° Ð¼ÐµÑÑÐ°Ð¼Ð¸
local function swapColors()
	currentBackground, currentForeground = swap(currentBackground, currentForeground)
	drawColors()
	console("Ð¦Ð²ÐµÑÐ° Ð¿Ð¾Ð¼ÐµÐ½ÑÐ½Ñ Ð¼ÐµÑÑÐ°Ð¼Ð¸")
end

--Ð£Ñ, ÑÑÐºÐ°! Ð¤ÑÐ½ÐºÑÐ¸Ñ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÐ° ÑÐµÐºÑÑÐ°
--ÐÑÑÐ°Ñ Ð´Ð¸ÑÑ, ÑÐ¿Ð¸Ð·Ð´Ð¸Ð» ÑÐ¾ ÑÑÐ°ÑÐ¾Ð³Ð¾ ÑÑ, Ð½Ð¾, Ð²ÑÐ¾Ð´Ðµ, Ð¿Ð°ÑÐµÑ Ð½Ð¾ÑÐ¼Ð°Ñ
--ÐÑÐ°Ð²Ð´Ð°, ÑÐµÑ ÐµÑÑÑ Ð¿ÑÐµÐ´ÑÑÐ²ÑÑÐ²Ð¸Ðµ, ÑÑÐ¾ ÐºÐ¾ÑÑÑÐ»ÑÐ½Ð°Ñ Ð¸ Ð±Ð°Ð³Ð¾Ð²Ð°Ð½Ð½Ð°Ñ Ð¾Ð½Ð°, Ð½Ñ Ð´Ð° Ð¿Ð¾ÑÑÐ¹
local function inputText(x, y, limit)
	local oldPixels = ecs.rememberOldPixels(x,y-1,x+limit-1,y+1)
	local text = ""
	local inputPos = 1

	local function drawThisShit()
		for i = 1, inputPos do
			ecs.invertedText(x + i - 1, y + 1, "â")
			ecs.adaptiveText(x + i - 1, y - 1, " ", currentBackground)
		end
		ecs.invertedText(x + inputPos - 1, y + 1, "â²")--"â²","â¼"
		ecs.invertedText(x + inputPos - 1, y - 1, "â¼")
		ecs.adaptiveText(x, y, ecs.stringLimit("start", text, limit, false), currentBackground)
	end

	drawThisShit()

	while true do
		local e = {event.pull()}
		if e[1] == "key_down" then
			if e[4] == 14 then
				if unicode.len(text) >= 1 then
					text = unicode.sub(text, 1, -2)
					if unicode.len(text) < (limit - 1) then
						inputPos = inputPos - 1
					end
					ecs.drawOldPixels(oldPixels)
					drawThisShit()
				end
			elseif e[4] == 28 then
				break
			elseif e[4] == 200 then
				text = text .. "â"
				if unicode.len(text) < limit then
					inputPos = inputPos + 1
				end
				drawThisShit()
			elseif e[4] == 208 then
				text = text .. "â"
				if unicode.len(text) < limit then
					inputPos = inputPos + 1
				end
				drawThisShit()
			else
				local symbol = ecs.convertCodeToSymbol(e[3])
				if symbol ~= nil then
					text = text .. symbol
					if unicode.len(text) < limit then
						inputPos = inputPos + 1
					end
					drawThisShit()
				end
			end
		elseif e[1] == "clipboard" then
			if e[3] then
				text = text .. e[3]
				if unicode.len(text) < limit then
					inputPos = inputPos + unicode.len(e[3])
				end
				drawThisShit()
			end
		end
	end

	ecs.drawOldPixels(oldPixels)
	if text == "" then text = " " end
	return text
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-Ð¿ÑÐ¸Ð¼ÐµÐ½ÑÑÐ¾Ñ ÑÐµÐºÑÑÐ° Ðº Ð¼Ð°ÑÑÐ¸Ð²Ñ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ
local function saveTextToPixels(x, y, text)
	local sText = unicode.len(text)
	local iterator
	x = x - 1
	for i = 1, sText do
		if x + i > masterPixels.width then break end
		iterator = convertCoordsToIterator(x + i, y)
		setPixel(iterator, masterPixels[iterator], currentBackground, masterPixels[iterator + 2], unicode.sub(text, i, i))
	end
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-ÑÐµÐ½ÑÑÐ°ÑÐ¾Ñ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸ Ð¿Ð¾ ÑÐµÐ½ÑÑÑ Ð¼Ð¾Ð½Ð¸ÐºÐ°
local function tryToFitImageOnCenterOfScreen()
	reCalculateImageSizes()

	local x, y = sizes.xStartOfImage, sizes.yStartOfImage
	if masterPixels.width < sizes.widthOfDrawingArea then
		x = math.floor(sizes.xStartOfDrawingArea + sizes.widthOfDrawingArea / 2 - masterPixels.width / 2) - 1
	end

	if masterPixels.height < sizes.heightOfDrawingArea then
		y = math.floor(sizes.yStartOfDrawingArea + sizes.heightOfDrawingArea / 2 - masterPixels.height / 2)
	end

	reCalculateImageSizes(x, y)
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ, ÑÐ¿ÑÐ°ÑÐ¸Ð²Ð°ÑÑÐ°Ñ ÑÐ·Ð²ÐµÑÑ, ÐºÐ°ÐºÐ¾Ð³Ð¾ ÑÐ°Ð·Ð¼ÐµÑÐ° Ð¿Ð¸ÐºÑÑ Ð¾Ð½  ÑÐ¾ÑÐµÑ ÑÐ¾Ð·Ð´Ð°ÑÑ - Ð½Ñ, Ð¸ ÑÐ¾Ð·Ð´Ð°ÐµÑ ÐµÐµ
local function new()
	selection = nil
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, localization.newDocument}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, localization.width}, {"Input", 0x262626, 0x880000, localization.height}, {"EmptyLine"}, {"Button", {0x999999, 0xffffff, "OK"}})

	data[1] = tonumber(data[1]) or 51
	data[2] = tonumber(data[2]) or 19

	masterPixels = {}
	masterPixels.width, masterPixels.height = data[1], data[2]
	createEmptyMasterPixels()
	tryToFitImageOnCenterOfScreen()
	drawAll()
end

--ÐÐ±ÑÑÐ½Ð°Ñ ÑÐµÐºÑÑÑÐ¸Ð²Ð½Ð°Ñ Ð·Ð°Ð»Ð¸Ð²ÐºÐ°, Ð°Ð»Ð³Ð¾ÑÐ¸ÑÐ¼ ÑÐ¿Ð¸Ð·Ð¶ÐµÐ½ Ñ Ð²Ð¸ÐºÐ¸
--ÐÑÑÑ Ð¸Ð½ÑÐ°, ÑÑÐ¾ Ð²ÑÐ¶Ð¸ÑÐ°ÐµÑ ÑÑÐµÐº, Ð½Ð¾ ÐÑÐ°, Ð²ÑÐ¾Ð´Ðµ, Ð½Ðµ Ð¾ÑÐ¾Ð±Ð¾ ÑÑÐ³Ð°ÐµÑÑÑ, ÑÐ°Ðº ÑÑÐ¾ Ð·Ð°ÐµÐ±Ð¾Ðº Ð²ÑÐµ
local function fill(x, y, startColor, fillColor)
	local function doFill(xStart, yStart)
		local iterator = convertCoordsToIterator(xStart, yStart)

		--ÐÐ°Ð²ÐµÑÑÐ°ÐµÐ¼ ÑÑÐ½ÐºÑÐ¸Ñ, ÐµÑÐ»Ð¸ ÑÐ²ÐµÑ Ð² Ð¼Ð°ÑÑÐ¸Ð²Ðµ Ð½Ðµ ÑÐ°ÐºÐ¾Ð¹, ÐºÐ°ÐºÐ¾Ð¹ Ð¼Ñ Ð·Ð°Ð»Ð¸Ð²Ð°ÐµÐ¼
		if masterPixels[iterator] ~= startColor or masterPixels[iterator] == fillColor then return end

		--ÐÐ°Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð² Ð¿Ð°Ð¼ÑÑÑ
		masterPixels[iterator] = fillColor
		masterPixels[iterator + 2] = currentAlpha

		doFill(xStart + 1, yStart)
		doFill(xStart - 1, yStart)
		doFill(xStart, yStart + 1)
		doFill(xStart, yStart - 1)

		iterator = nil
	end
	doFill(x, y)
end

--ÐÐ¸ÑÑÑ, ÐÐÐÐÐÐ¡Ð¢Ð¬
local function brush(x, y, background, foreground, alpha, symbol)
	--Ð¡Ð¼ÐµÑÐµÐ½Ð¸Ðµ Ð²Ð»ÐµÐ²Ð¾ Ð¸ Ð²Ð¿ÑÐ°Ð²Ð¾ Ð¾ÑÐ½Ð¾ÑÐ¸ÑÐµÐ»ÑÐ½Ð¾ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÐµÐ½ÑÑÐ° ÐºÐ¸ÑÑÐ¸
	--ÐÐÐ ÐÐ§, ÐÐ Ð¢Ð£ÐÐ
	--Ð§ÑÐ¾Ð±Ñ ÐºÐ¸ÑÑÐ¾ÑÐºÐ° Ð±ÑÐ»Ð° Ð¿Ð¾ ÑÐµÐ½ÑÑÑ Ð¼ÑÑÐ¸, Ð½Ñ
	local position = math.floor(currentBrushSize / 2)
	x, y = x - position, y - position
	--Ð¥ÑÐµÐ²Ð¸Ð½ÐºÐ° Ð´Ð»Ñ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ
	local newIterator
	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ ÐºÐ¸ÑÑÑ Ð¿Ð¾ ÑÐ¸ÑÐ¸Ð½Ðµ Ð¸ Ð²ÑÑÐ¾ÑÐµ
	for cyka = 1, currentBrushSize do
		for pidor = 1, currentBrushSize do
			--ÐÑÐ»Ð¸ ÑÑÐ¾Ñ ÐºÑÑÐ¾ÑÐµÐº Ð²ÑÐ¾Ð´Ð¸Ñ Ð² Ð³ÑÐ°Ð½Ð¸ÑÑ ÑÐ¸ÑÐ¾Ð²Ð°Ð±ÐµÐ»ÑÐ½Ð¾Ð¹ Ð·Ð¾Ð½Ñ, ÑÐ¾
			if x >= 1 and x <= masterPixels.width and y >= 1 and y <= masterPixels.height then
				
				--Ð¡ÑÐ¸ÑÐ°ÐµÐ¼ Ð¸ÑÐµÑÐ°ÑÐ¾Ñ Ð´Ð»Ñ ÐºÑÑÐ¾ÑÐºÐ° ÐºÐ¸ÑÑÐ¸
				newIterator = convertCoordsToIterator(x, y)

				--ÐÑÐ»Ð¸ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸ ÐºÐ¸ÑÑÐ¸ ÐÐÐ©Ð ÐÐÐ¢, ÑÐ¾ Ð¿ÑÐ¾ÑÑÐ¾ ÑÐ¸ÑÑÐµÐ¼ ÐºÐ°Ðº Ð¾Ð±ÑÑÐ½ÐµÐ½ÑÐºÐ¾ Ð²ÑÐµ
				if alpha == 0x00 then
					setPixel(newIterator, background, foreground, alpha, symbol)
				--ÐÑÐ»Ð¸ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸ ÐºÐ¸ÑÑÐ¸ ÐµÑÑÑ ÐºÐ°ÐºÐ°Ñ-ÑÐ¾, Ð½Ð¾ Ð¾Ð½Ð° Ð½Ðµ Ð°Ð±ÑÐ¾Ð»ÑÑÐ½Ð°Ñ
				elseif alpha < 0xFF and alpha > 0x00 then
					--ÐÑÐ»Ð¸ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð² Ð¼Ð°ÑÑÐ¸Ð²Ðµ Ð½Ð¸ ÑÑÑ Ð½Ðµ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½ÑÐ¹, ÑÐ¾ Ð¾ÑÑÐ°Ð²Ð»ÑÐµÐ¼ ÐµÐ³Ð¾ ÑÐ°ÐºÐ¸Ð¼ Ð¶Ðµ, ÑÐ°Ð·Ð²Ðµ ÑÑÐ¾ ÑÐ²ÐµÑ Ð¼ÐµÐ½ÑÐµÐ¼ Ð½Ð° ÑÐ±Ð»ÐµÐ½Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð½ÑÐ¹
					if masterPixels[newIterator + 2] == 0x00 then
						local gettedBackground = colorlib.alphaBlend(masterPixels[newIterator], background, alpha)
						setPixel(newIterator, gettedBackground, foreground, 0x00, symbol)
					--Ð ÐµÑÐ»Ð¸ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½ÑÐ¹, ÑÐ¾ ÑÐ¼ÐµÑÐ¸Ð²Ð°ÐµÐ¼ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸
					--ÐÐ¸Ð·Ð´Ð°Ð½ÑÑÑÑÑ Ð²Ð¾Ð¾Ð±ÑÐµ, ÑÑÐº
					else
						--ÐÑÐ»Ð¸ ÐµÐ³Ð¾ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð°Ñ
						if masterPixels[newIterator + 2] == 0xFF then
							setPixel(newIterator, background, foreground, alpha, symbol)
						--ÐÑÐ»Ð¸ Ð½Ðµ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð°Ñ
						else
							local newAlpha = masterPixels[newIterator + 2] - (0xFF - alpha)
							if newAlpha < 0x00 then newAlpha = 0x00 end
							setPixel(newIterator, background, foreground, newAlpha, symbol)
						end
					end
				--ÐÑÐ»Ð¸ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð°Ñ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑÐ½Ð°, Ñ.Ðµ. ÑÐ°Ð²Ð½Ð° 0xFF
				else
					setPixel(newIterator, 0x000000, 0x000000, 0xFF, " ")
				end
				
				--Ð Ð¸ÑÑÐµÐ¼ Ð¿Ð¸ÐºÑÐµÐ»Ñ Ð¸Ð· Ð¼Ð°ÑÑÐµÑÐ¿Ð¸ÐºÑÐµÐ»ÑÑÐ°
				drawPixel(x + sizes.xStartOfImage - 1, y + sizes.yStartOfImage - 1, x, y, newIterator)
			end

			x = x + 1
		end
		x = x - currentBrushSize
		y = y + 1
	end
end

--ÐÐ¸Ð°Ð»Ð¾Ð³Ð¾Ð²Ð¾Ðµ Ð¾ÐºÐ½Ð¾ Ð¾Ð±ÑÐµÐ·ÐºÐ¸ Ð¸ ÑÐ°ÑÑÐ¸ÑÐµÐ½Ð¸Ñ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸
local function cropOrExpand(text)
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
		{"EmptyLine"},
		{"CenterText", 0x262626, text},
		{"EmptyLine"},
		{"Input", 0x262626, 0x880000, localization.countOfPixels},
		{"Selector", 0x262626, 0x880000, localization.fromBottom, localization.fromTop, localization.fromLeft, localization.fromRight},
		{"EmptyLine"},
		{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
	)

	if data[3] == "OK" then
		local countOfPixels = tonumber(data[1])
		if countOfPixels then
			local direction = ""
			if data[2] == localization.fromBottom then
				direction = "fromBottom"
			elseif data[2] == localization.fromTop then
				direction = "fromTop"
			elseif data[2] == localization.fromLeft then
				direction = "fromLeft"
			else
				direction = "fromRight"
			end

			return direction, countOfPixels
		else
			ecs.error("ÐÐ²ÐµÐ´ÐµÐ½Ð¾ Ð½ÐµÐºÐ¾ÑÑÐµÐºÑÐ½Ð¾Ðµ ÐºÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹")
		end 
	end
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-Ð¾Ð±ÑÐµÐ·ÑÐ¸Ðº ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸
local function crop()
	local direction, countOfPixels = cropOrExpand(localization.crop)
	if direction then
		masterPixels = image.crop(masterPixels, direction, countOfPixels)
		reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage)
		drawAll()
	end
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-ÑÐ°ÑÑÐ¸ÑÐ¸ÑÐµÐ»Ñ ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸
local function expand()
	local direction, countOfPixels = cropOrExpand(localization.crop)
	if direction then
		masterPixels = image.expand(masterPixels, direction, countOfPixels, 0x010101, 0x010101, 0xFF, " ")
		reCalculateImageSizes(sizes.xStartOfImage, sizes.yStartOfImage)
		drawAll()
	end
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-Ð·Ð°Ð³ÑÑÐ·ÑÐ¸Ðº ÐºÐ°ÑÑÐ¸Ð½ÐºÐ¸ Ð¸Ð· ÑÐ°Ð¹Ð»Ð°
local function loadImageFromFile(path)
	if fs.exists(path) then
		selection = nil
		masterPixels = image.load(path)
		savePath = path
		tryToFitImageOnCenterOfScreen()
	else
		ecs.error("Ð¤Ð°Ð¹Ð» \"" .. path .. "\" Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ")
	end
end

--Ð¤ÑÐ½ÐºÑÐ¸Ñ-Ð·Ð°Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»Ñ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¹ Ð·Ð¾Ð½Ñ ÐºÐ°ÐºÐ¸Ð¼Ð¸-Ð»Ð¸Ð±Ð¾ Ð´Ð°Ð½Ð½ÑÐ¼Ð¸
local function fillSelection(background, foreground, alpha, symbol)
	for j = selection.y, selection.y + selection.height - 1 do
		for i = selection.x, selection.x + selection.width - 1 do
			local iterator = convertCoordsToIterator(i, j)
			masterPixels[iterator] = background
			masterPixels[iterator + 1] = foreground
			masterPixels[iterator + 2] = alpha
			masterPixels[iterator + 3] = symbol
		end
	end

	drawAll()
end

local function applyShapeToMasterPixels()
	if currentShape == localization.line then
		line(selection.xStart, selection.yStart, selection.xEnd, selection.yEnd, currentBackground, true)
	elseif currentShape == localization.rectangle then
		fillSelection(currentBackground, 0x00000, 0x00, " ")
	elseif currentShape == localization.border then
		stroke(selection.x, selection.y, selection.width, selection.height, currentBackground, true)
	elseif currentShape == localization.ellipse then
		ellipse(selection.x, selection.y, selection.width, selection.height, currentBackground, true)
	end

	selection = nil
	drawBackgroundAndImage()
	buffer.draw()
end

------------------------------------------------ Ð¡ÑÐ°ÑÑ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ --------------------------------------------------------------

--Ð Ð¸ÑÑÐµÐ¼ Ð²ÐµÑÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ ÑÐ¸ÑÑÐ¾ Ð´Ð»Ñ ÐºÑÐ°ÑÐ¾ÑÑ
drawAll()

--ÐÑÐºÑÑÐ²Ð°ÐµÐ¼ ÑÐ°Ð¹Ð»Ñ Ð¿Ð¾ Ð°ÑÐ³ÑÐ¼ÐµÐ½ÑÐ°Ð¼ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ
if args[1] == "o" or args[1] == "open" or args[1] == "-o" or args[1] == "load" then
	loadImageFromFile(args[2])
else
	new()
end

--ÐÑÑÐ¸ÑÐ¾Ð²ÑÐ²Ð°ÐµÐ¼ Ð¸Ð½ÑÐµÑÑÐµÐ¹Ñ ÑÐ½Ð¾Ð²Ð°, Ð¿Ð¾ÑÐºÐ¾Ð»ÑÐºÑ Ñ Ð½Ð°Ñ Ð»Ð¸Ð±Ð¾ ÑÐ¾Ð·Ð´Ð°Ð»ÑÑ Ð½Ð¾Ð²ÑÐ¹ Ð´Ð¾ÐºÑÐ¼ÐµÐ½Ñ, Ð»Ð¸Ð±Ð¾ Ð¾ÑÐºÑÑÐ»ÑÑ Ð¸Ð¼ÐµÑÑÐ¸Ð¹ÑÑ ÑÐ°Ð¹Ð»
drawAll()

--ÐÐ½Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ Ð¸Ð²ÐµÐ½ÑÑ
while true do
	local e = {event.pull()}
	if e[1] == "touch" or e[1] == "drag" or e[1] == "drop" then
		--ÐÐµÐ²ÑÐ¹ ÐºÐ»Ð¸Ðº
		if e[5] == 0 then
			--ÐÑÐ»Ð¸ ÐºÐ»Ð¸ÐºÐ½ÑÐ»Ð¸ Ð½Ð° ÑÐ¸ÑÐ¾Ð²Ð°Ð±ÐµÐ»ÑÐ½ÑÑ Ð·Ð¾Ð½ÐºÑ
			if ecs.clickedAtArea(e[3], e[4], sizes.xStartOfImage, sizes.yStartOfImage, sizes.xEndOfImage, sizes.yEndOfImage) then
				
				--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸ Ð¸ Ð¸ÑÐµÑÐ°ÑÐ¾Ñ
				local x, y = e[3] - sizes.xStartOfImage + 1, e[4] - sizes.yStartOfImage + 1
				local iterator = convertCoordsToIterator(x, y)
				
				--ÐÑÐµ Ð´Ð»Ñ Ð¸Ð½ÑÑÑÑÐ¼ÐµÐ½ÑÐ¾Ð² Ð¼ÑÐ»ÑÑÐ¸ÑÐ¾ÑÐµÑÐ½Ð¾Ð³Ð¾ ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ
				if instruments[currentInstrument] == "M" or instruments[currentInstrument] == "S" then
					if e[1] == "touch" then
						selection = {}
						selection.xStart, selection.yStart = x, y

					elseif e[1] == "drag" and selection then
						local x1, y1 = selection.xStart, selection.yStart
						local x2, y2 = x, y
						if x1 > x2 then
							x1, x2 = swap(x1, x2)
						end
						if y1 > y2 then
							y1, y2 = swap(y1, y2)
						end

						selection.x, selection.y = x1, y1
						selection.x2, selection.y2 = x2, y2
						selection.xEnd, selection.yEnd = x, y
						selection.width = selection.x2 - selection.x + 1
						selection.height = selection.y2 - selection.y + 1

						selection.finished = true
					end

					--ÐÑÐ»Ð¸ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»Ð½Ð¾ÑÑÑÑ Ð·Ð°Ð²ÐµÑÑÐµÐ½Ð¾, ÑÐ¾ Ð¾ÑÐ´Ð°ÐµÐ¼ ÐºÐ¾Ð½ÑÑÐ¾Ð»Ñ Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð¾ÑÐ½ÑÐ¼ ÑÑÐ½ÐºÑÐ¸ÑÐ¼
					-- if instruments[currentInstrument] == "M" then
						drawBackgroundAndImage()
						buffer.draw()
					-- end
				--ÐÐ¸ÑÑÑ
				elseif instruments[currentInstrument] == "B" then
					
					--ÐÑÐ»Ð¸ Ð½Ð°Ð¶Ð°ÑÐ° ÐºÐ»Ð°Ð²Ð¸ÑÐ° Ð°Ð»ÑÑ
					if keyboard.isKeyDown(56) then
						local _, gettedForeground, gettedBackground = component.gpu.get(e[3], e[4])
						currentBackground = gettedBackground
						currentForeground = gettedForeground
						drawColors()
						buffer.draw()
					
					--ÐÑÐ»Ð¸ Ð¾Ð±ÑÑÐ½Ð°Ñ ÐºÐ¸ÑÑÑ, Ð¿ÑÐ¾ÑÑÐ¾ ÐºÐ¸ÑÑÑ, Ð²Ð¾Ð¾Ð±ÑÐµ Ð²ÑÐµÐ¼ ÐºÐ¸ÑÑÑÐ¼ ÐºÐ¸ÑÑÑ
					else
						brush(x, y, currentBackground, currentForeground, currentAlpha, currentSymbol)
						--ÐÐ¸ÑÐµÐ¼ ÑÑÐ¾-ÑÐ¾ Ð² ÐºÐ¾Ð½ÑÐ¾Ð»Ð¸
						console("ÐÐ¸ÑÑÑ: ÐºÐ»Ð¸Ðº Ð½Ð° ÑÐ¾ÑÐºÑ "..e[3].."x"..e[4]..", ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸: "..x.."x"..y..", Ð¸Ð½Ð´ÐµÐºÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ: "..iterator)
						buffer.draw()
					end
				--ÐÐ°ÑÑÐ¸Ðº
				elseif instruments[currentInstrument] == "E" then
					brush(x, y, currentBackground, currentForeground, 0xFF, currentSymbol)
					console("ÐÐ°ÑÑÐ¸Ðº: ÐºÐ»Ð¸Ðº Ð½Ð° ÑÐ¾ÑÐºÑ "..e[3].."x"..e[4]..", ÐºÐ¾Ð¾ÑÐ´Ð¸Ð½Ð°ÑÑ Ð² Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ð¸: "..x.."x"..y..", Ð¸Ð½Ð´ÐµÐºÑ Ð¼Ð°ÑÑÐ¸Ð²Ð° Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ñ: "..iterator)
					buffer.draw()
				--Ð¢ÐµÐºÑÑ
				elseif instruments[currentInstrument] == "T" then
					local limit = masterPixels.width - x + 1
					local text = inputText(e[3], e[4], limit)
					saveTextToPixels(x, y, text)
					drawImage()
					buffer.draw()

				--ÐÐ°Ð»Ð¸Ð²ÐºÐ°
				elseif instruments[currentInstrument] == "F" then

					fill(x, y, masterPixels[iterator], currentBackground)
					drawImage()
					buffer.draw()

				end

				iterator, x, y = nil, nil, nil

			end

			--Ð¦Ð²ÐµÑÐ°
			for key in pairs(obj["Colors"]) do
				if ecs.clickedAtArea(e[3], e[4], obj["Colors"][key][1], obj["Colors"][key][2], obj["Colors"][key][3], obj["Colors"][key][4]) then
					if key == 1 then
						currentBackground = palette.show("auto", "auto", currentBackground) or currentBackground
						drawAll()
					elseif key == 2 or key == 3 then
						currentForeground = palette.show("auto", "auto", currentForeground) or currentForeground
						drawAll()
					elseif key == 4 then
						buffer.text(obj["Colors"][key][1], obj["Colors"][key][2], 0xFF0000, "ââ")
						os.sleep(0.2)
						swapColors()
						buffer.draw()
					end
					break
				end	
			end

			--ÐÐ½ÑÑÑÑÐ¼ÐµÐ½ÑÑ
			for key in pairs(obj["Instruments"]) do
				if ecs.clickedAtArea(e[3], e[4], obj["Instruments"][key][1], obj["Instruments"][key][2], obj["Instruments"][key][3], obj["Instruments"][key][4]) then
					selection = nil
					currentInstrument = key
					drawLeftBar(); buffer.draw()
					if instruments[currentInstrument] == "S" then
						local action = GUI.contextMenu(obj["Instruments"][key][3] + 1, obj["Instruments"][key][2], {localization.line}, {localization.ellipse}, {localization.rectangle}, {localization.polygon}, {localization.border}):show()
						currentShape = action or localization.line
						
						if currentShape == localization.polygon then
							local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
								{"EmptyLine"},
								{"CenterText", 0x262626, localization.edges},
								{"EmptyLine"},
								{"Selector", 0x262626, 0x880000, "3", "4", "5", "6", "7", "8", "9", "10"},
								{"EmptyLine"}, 
								{"Button", {0xaaaaaa, 0xffffff, "OK"}}
							)
							currentPolygonCountOfEdges = tonumber(data[1])
						end
						drawAll()
					end
					break
				end
			end

			--ÐÐµÑÑÐ½Ð¸Ð¹ Ð¼ÐµÐ½Ñ-Ð±Ð°Ñ
			local object = obj.menu:getClickedObject(e[3], e[4])
			if object then
				object:press()
				buffer.draw()
				local action
				if object.text == localization.file then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.new, false, "^N"}, {localization.open, false, "^O"}, {localization.createFromString}, "-", {localization.save, (savePath == nil), "^S"}, {localization.saveAs}, "-", {localization.exit}):show()
				elseif object.text == localization.image then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.crop}, {localization.expand}, "-", {localization.rotateBy90}, {localization.rotateBy180}, "-", {localization.flipHorizontal}, {localization.flipVertical}):show()
				elseif object.text == localization.edit then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.hueSaturation}, {localization.colorBalance}, {localization.photoFilter}, "-", {localization.invertColors}, {localization.blackWhite}, "-", {localization.gaussianBlur}):show()
				elseif object.text == localization.view then
					action = GUI.contextMenu(object.x, object.y + 1, {localization.transparencyPad}):show()
				elseif object.text == localization.about then
					ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true, {"EmptyLine"}, {"CenterText", 0x880000, photoshopVersion}, {"EmptyLine"}, {"CenterText", 0x262626, localization.developers}, {"CenterText", 0x555555, "Ð¢Ð¸Ð¼Ð¾ÑÐµÐµÐ² ÐÐ³Ð¾ÑÑ"}, {"CenterText", 0x656565, "vk.com/id7799889"}, {"CenterText", 0x656565, "Ð¢ÑÐ¸ÑÐ¾Ð½Ð¾Ð² ÐÐ»ÐµÐ±"}, {"CenterText", 0x656565, "vk.com/id88323331"}, {"EmptyLine"}, {"CenterText", 0x262626, localization.testers}, {"CenterText", 0x656565, "Ð¨ÐµÑÑÐ°ÐºÐ¾Ð² Ð¢Ð¸Ð¼Ð¾ÑÐµÐ¹"}, {"CenterText", 0x656565, "vk.com/id113499693"}, {"CenterText", 0x656565, "ÐÐµÑÑÐ¾Ð¼Ð¾Ð² Ð Ð¾Ð¼Ð°Ð½"}, {"CenterText", 0x656565, "vk.com/id83715030"}, {"CenterText", 0x656565, "ÐÐ¼ÐµÐ»Ð°ÐµÐ½ÐºÐ¾ ÐÐ°ÐºÑÐ¸Ð¼"},  {"CenterText", 0x656565, "vk.com/paladincvm"}, {"EmptyLine"},{"Button", {0xbbbbbb, 0xffffff, "OK"}})
				elseif object.text == localization.hotkeys then
					ecs.universalWindow( "auto", "auto", 42, 0xeeeeee, true, 
						table.unpack(localization.hotkeysLines)
					)				
				end

				if action == localization.exit then
					ecs.prepareToExit()
					return
				elseif action == localization.hueSaturation then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.hueSaturation},
						{"EmptyLine"},
						{"Slider", 0x262626, 0x880000, 0, 100, 50, localization.hue .. ": ", ""},
						{"Slider", 0x262626, ecs.colors.red, 0, 100, 50,  localization.saturation .. ": ", ""},
						{"Slider", 0x262626, 0x000000, 0, 100, 50,  localization.brightness .. ": ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[4] == "OK" then
						masterPixels = image.hueSaturationBrightness(masterPixels, data[1] - 50, data[2] - 50, data[3] - 50)
						drawAll()
					end
				elseif action == localization.gaussianBlur then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.gaussianBlur},
						{"EmptyLine"},
						{"Slider", 0x262626, 0x880000, 1, 5, 2, localization.radius .. ": ", ""},
						{"Slider", 0x262626, 0x880000, 1, 255, 0x88, localization.force .. ": ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[3] == "OK" then
						masterPixels = image.gaussianBlur(masterPixels, tonumber(data[1]), tonumber(data[2]))
						drawAll()
					end
				elseif action == localization.colorBalance then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.colorBalance},
						{"EmptyLine"},
						{"Slider", 0x262626, 0x880000, 0, 100, 50, "R: ", ""},
						{"Slider", 0x262626, ecs.colors.green, 0, 100, 50, "G: ", ""},
						{"Slider", 0x262626, ecs.colors.blue, 0, 100, 50, "B: ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[4] == "OK" then
						masterPixels = image.colorBalance(masterPixels, data[1] - 50, data[2] - 50, data[3] - 50)
						drawAll()
					end
				elseif action == localization.photoFilter then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.photoFilter},
						{"EmptyLine"},
						{"Color", localization.filterColor, 0x333333},
						{"Slider", 0x262626, 0x880000, 0, 255, 100, localization.transparency .. ": ", ""},
						{"EmptyLine"}, 
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[3] == "OK" then
						masterPixels = image.photoFilter(masterPixels, data[1], data[2])
						drawAll()
					end
				elseif action == localization.crop then
					crop()
				elseif action == localization.expand then
					expand()
				elseif action == localization.flipVertical then
					masterPixels = image.flipVertical(masterPixels)
					drawAll()
				elseif action == localization.flipHorizontal then
					masterPixels = image.flipHorizontal(masterPixels)
					drawAll()
				elseif action == localization.invertColors then
					masterPixels = image.invert(masterPixels)
					drawAll()
				elseif action == localization.blackWhite then
					masterPixels = image.blackAndWhite(masterPixels)
					drawAll()
				elseif action == localization.rotateBy90 then
					masterPixels = image.rotate(masterPixels, 90)
					drawAll()
				elseif action == localization.rotateBy180 then
					masterPixels = image.rotate(masterPixels, 180)
					drawAll()
				elseif action == localization.new then
					new()
					drawAll()
				elseif action == localization.saveAs then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, localization.saveAs}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, localization.path}, {"Selector", 0x262626, 0x880000, "OCIF4", "OCIF1", "OCIFString", "RAW"}, {"CenterText", 0x262626, "Ð ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑÐµÑÑÑ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÑ"}, {"CenterText", 0x262626, "Ð¼ÐµÑÐ¾Ð´ ÐºÐ¾Ð´Ð¸ÑÐ¾Ð²Ð°Ð½Ð¸Ñ OCIF4"}, {"EmptyLine"}, {"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}})
					if data[3] == "OK" then
						data[1] = data[1] or "Untitled"
						data[2] = data[2] or "OCIF4"
						
						if data[2] == "RAW" then
							data[2] = 0
						elseif data[2] == "OCIF1" then
							data[2] = 1
						elseif data[2] == "OCIF4" then
							data[2] = 4
						elseif data[2] == "OCIFString" then
							data[2] = 6
						else
							data[2] = 4
						end

						local filename = string.gsub(data[1], ".pic$", "") .. ".pic"
						local encodingMethod = data[2]

						image.save(filename, masterPixels, encodingMethod)
						savePath = filename
					end
				elseif action == localization.save then
					image.save(savePath, masterPixels)

				elseif action == localization.open then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true, {"EmptyLine"}, {"CenterText", 0x262626, localization.open}, {"EmptyLine"}, {"Input", 0x262626, 0x880000, localization.path}, {"EmptyLine"}, {"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}})
					if data[2] == "OK" then
						local fileFormat = ecs.getFileFormat(data[1])
					
						if not data[1] then
							ecs.error("ÐÐµÐºÐ¾ÑÑÐµÐºÑÐ½Ð¾Ðµ Ð¸Ð¼Ñ ÑÐ°Ð¹Ð»Ð°!")
						elseif not fs.exists(data[1]) then
							ecs.error("Ð¤Ð°Ð¹Ð»\""..data[1].."\" Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ!")
						elseif fileFormat ~= ".pic" and fileFormat ~= ".rawpic" and fileFormat ~= ".png" then 
							ecs.error("Ð¤Ð¾ÑÐ¼Ð°Ñ ÑÐ°Ð¹Ð»Ð° \""..fileFormat.."\" Ð½Ðµ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑÑÑ!")
						else
							loadImageFromFile(data[1])
							drawAll()
						end
					end
				elseif action == localization.createFromString then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.createFromString},
						{"EmptyLine"},
						{"Input", 0x262626, 0x880000, localization.string},
						{"EmptyLine"},
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)
					if data[2] == "OK" then
						local success, picture = pcall(image.fromString, data[1])
						if success then
							masterPixels, selection, savePath = picture, nil, nil
							tryToFitImageOnCenterOfScreen()
							drawAll()
						else
							error("ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ð·Ð´Ð°ÑÑ Ð¸Ð·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ Ð¸Ð· ÑÑÐ¾Ð¹ ÑÑÑÐ¾ÐºÐ¸!")
						end
					end
				elseif action == localization.transparencyPad then
					local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
						{"EmptyLine"},
						{"CenterText", 0x262626, localization.transparencyPad},
						{"EmptyLine"},
						{"Color", localization.transparencyColor .. " 1", colors.transparencyWhite},
						{"Color", localization.transparencyColor .. " 2", colors.transparencyGray},
						{"EmptyLine"},
						{"Switch", 0xF2B233, 0xffffff, 0x262626, localization.transparencyGrid, showTransparencyGrid},
						{"EmptyLine"},
						{"Button", {0xaaaaaa, 0xffffff, "OK"}, {0x888888, 0xffffff, localization.cancel}}
					)

					if data[4] == "OK" then
						colors.transparencyWhite, colors.transparencyGray, showTransparencyGrid = data[1], data[2], data[3]
						drawAll()
					end
				end

				drawTopMenu()
				buffer.draw()
			end
		else
			--ÐÑÐ»Ð¸ ÐºÐ»Ð¸ÐºÐ½ÑÐ»Ð¸ Ð½Ð° ÑÐ¸ÑÐ¾Ð²Ð°Ð±ÐµÐ»ÑÐ½ÑÑ Ð·Ð¾Ð½ÐºÑ
			if ecs.clickedAtArea(e[3], e[4], sizes.xStartOfImage, sizes.yStartOfImage, sizes.xEndOfImage, sizes.yEndOfImage) then
				
				if instruments[currentInstrument] == "M" and selection then
					local action = GUI.contextMenu(e[3], e[4], {localization.deselect}, {localization.crop, true}, "-", {localization.fill}, {localization.border}, "-", {localization.clear}):show()
					if action == localization.deselect then
						selection = nil
						drawAll()
					elseif action == localization.clear then
						fillSelection(0x0, 0x0, 0xFF, " ")
					elseif action == localization.fill then
						fillSelection(currentBackground, 0x0, 0x0, " ")
					elseif action == localization.border then
						stroke(selection.x, selection.y, selection.width, selection.height, currentBackground, true)
						drawAll()
					end
				else
					local x, y, width, height = e[3], e[4], 30, 12
					--Ð ÑÑÐ¾ ÑÑÐ¾Ð± Ð·Ð° ÐºÑÐ°Ñ ÑÐºÑÐ°Ð½Ð° Ð½Ðµ Ð»ÐµÐ·Ð»Ð¾
					if y + height >= buffer.screen.height then y = buffer.screen.height - height end
					if x + width + 1 >= buffer.screen.width then x = buffer.screen.width - width - 1 end

					currentBrushSize, currentAlpha = table.unpack(ecs.universalWindow(x, y, width, 0xeeeeee, true, {"EmptyLine"}, {"CenterText", 0x880000, localization.brushParameters}, {"Slider", 0x262626, 0x880000, 1, 10, currentBrushSize, localization.size ..  ": ", " px"}, {"Slider", 0x262626, 0x880000, 0, 255, currentAlpha, localization.transparency .. ": ", ""}, {"EmptyLine"}, {"Button", {0xbbbbbb, 0xffffff, "OK"}}))
					buffer.draw()
				end
			end
		end

	elseif e[1] == "key_down" then
		--Ð¡ÑÑÐµÐ»ÐºÐ¸
		if e[4] == 200 then
			move("up")
		elseif e[4] == 208 then
			move("down")
		elseif e[4] == 203 then
			move("left")
		elseif e[4] == 205 then
			move("right")
		-- --ÐÑÐ¾Ð±ÐµÐ»
		-- elseif e[4] == 57 then
		-- 	drawAll()
		--ENTER
		elseif e[4] == 28 then
			if instruments[currentInstrument] == "S" and selection and selection.finished then
				applyShapeToMasterPixels()
			end
		--BACKSPACE
		elseif e[4] == 14 then
			if selection and selection.finished then
				fillSelection(0x000000, 0x000000, 0x00, " ")
				drawAll()
			end
		--X
		elseif e[4] == 45 then
			swapColors()
			buffer.draw()
		--B
		elseif e[4] == 48 then
			changeInstrumentTo(2)
		--E
		elseif e[4] == 18 then
			changeInstrumentTo(3)
		--G
		elseif e[4] == 34 then
			changeInstrumentTo(4)
		--T
		elseif e[4] == 20 then
			changeInstrumentTo(5)
		--M
		elseif e[4] == 50 then
			changeInstrumentTo(1)
		--D
		elseif e[4] == 32 then
			if keyboard.isControlDown() then
				selection = nil
				drawAll()
			else
				currentBackground = 0x000000
				currentForeground = 0xFFFFFF
				currentAlpha = 0x00
				drawColors()
				buffer.draw()
			end
		end
	elseif e[1] == "scroll" then
		if e[5] == 1 then
			move("up")
		else
			move("down")
		end
	end
end

------------------------------------------------ ÐÑÑÐ¾Ð´ Ð¸Ð· Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ --------------------------------------------------------------
D,MineOS/Applications/Photoshop.app/Resources/D2MineOS/Applications/Photoshop.app/Resources/About/F=MineOS/Applications/Photoshop.app/Resources/About/Russian.txt;Photoshop - ÑÑÐ¾ Ð¼Ð¾ÑÐ½ÑÐ¹ Ð³ÑÐ°ÑÐ¸ÑÐµÑÐºÐ¸Ð¹ ÑÐµÐ´Ð°ÐºÑÐ¾Ñ, Ð½Ð°Ð¿Ð¸ÑÐ°Ð½Ð½ÑÐ¹ ÑÐ¿ÐµÑÐ¸Ð°Ð»ÑÐ½Ð¾ Ð´Ð»Ñ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð½Ð°ÑÐµÐ¹ ÐÐ¡. ÐÐ½ Ð¿Ð¾Ð´Ð´ÐµÑÐ¶Ð¸Ð²Ð°ÐµÑ ÑÐ°Ð±Ð¾ÑÑ Ñ ÐºÐ¸ÑÑÑÐ¼Ð¸, Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑÑ, Ð¸Ð¼ÐµÐµÑ ÑÑÐ½ÐºÑÐ¸Ð¸ Ð·Ð°Ð»Ð¸Ð²ÐºÐ¸, Ð²ÑÐ±Ð¾ÑÐ° ÑÐ²ÐµÑÐ° Ð¸Ð· ÐºÑÐ°ÑÐ¾ÑÐ½Ð¾Ð¹ Ð¿Ð°Ð»Ð¸ÑÑÑ, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ ÑÐ¾Ð·Ð´Ð°Ð²Ð°ÑÑ Ð½Ð°ÑÑÐ¾ÑÑÐ¸Ðµ Ð¼Ð¸Ð½Ð¸-ÑÐµÐ´ÐµÐ²ÑÑ Ð¿ÑÑÐ¼Ð¾ Ð½Ð° Ð²Ð°ÑÐµÐ¼ ÐÐ. ÐÑÑ Ð³ÑÐ°ÑÐ¸ÐºÐ° Ð² Ð½Ð°ÑÐµÐ¹ ÐÐ¡ Ð½Ð°ÑÐ¸ÑÐ¾Ð²Ð°Ð½Ð° Ð¸Ð¼ÐµÐ½Ð½Ð¾ Ð² ÑÑÐ¾Ð¹ Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ðµ.F4MineOS/Applications/Photoshop.app/Resources/Icon.pic£OCIFA SEFÖB TYSSFHB TYSBFÖB *YS FHB TYFÖB TYB )YYB ÿYYFÿB )YSPFHB TYSâFÿB )YD9MineOS/Applications/Photoshop.app/Resources/Localization/FEMineOS/Applications/Photoshop.app/Resources/Localization/English.lang®{
	newDocument = "New document",
	width = "Width",
	height = "Height",
	cancel = "Cancel",
	w = "W",
	h = "H",

	view = "View",
	transparencyPad = "Transparency pad",
	transparencyColor = "Transparency color",
	transparencyGrid = "Transparency grid",

	path = "Path",
	string = "String",
	file = "File",
	image = "Image",
	edit = "Edit",
	hotkeys = "Hot keys",
	about = "About",
	brushSize = "Brush size",
	transparency = "Transparency",
	brushParameters = "Brush parameters",
	size = "Size",

	new = "New",
	open = "Open",
	createFromString = "Create from OCIFString",
	save = "Save",
	saveAs = "Save as",
	exit = "Exit",

	crop = "Crop",
	expand = "Expand",
	rotateBy90 = "Rotate by 90 degrees",
	rotateBy180 = "Rotate by 180 degrees",
	flipVertical = "Flip vertical",
	flipHorizontal = "Flip horizontal",

	hueSaturation = "Hue/Saturation",
	colorBalance = "Color balance",
	photoFilter = "Photo filter",
	invertColors = "Invert colors",
	blackWhite = "Black and white",
	gaussianBlur = "Gaussian blur",

	countOfPixels = "Count of pixels",
	fromBottom = "From bottom",
	fromTop = "From top",
	fromLeft = "From left",
	fromRight = "From right",
	hue = "Hue",
	saturation = "Saturation",
	brightness = "Brightness",
	filterColor = "Filter color",
	radius = "Radius",
	force = "Force",
	edges = "Edges",
	accept = "Enter - accept",

	line = "Line",
	ellipse = "Ellipse",
	rectangle = "Rectangle",
	polygon = "Polygon",
	border = "Border",

	fill = "Fill",
	clear = "Clear",
	deselect = "Deselect",

	hotkeysLines = {
		{"EmptyLine"},
		{"CenterText", 0x880000, "Hotkeys"},
		{"EmptyLine"},
		{"CenterText", 0x000000, "B - Brush"},
		{"CenterText", 0x000000, "E - Eraser"},
		{"CenterText", 0x000000, "T - Text"},
		{"CenterText", 0x000000, "G - Fill"},
		{"CenterText", 0x000000, "M - Selection"},
		{"CenterText", 0x000000, " "},
		{"CenterText", 0x000000, "Arrows - move image"},
		{"CenterText", 0x000000, "X - swap colors"},
		{"CenterText", 0x000000, "D - make colors black&white"},
		{"CenterText", 0x000000, "Ctrl+D - deselect"},
		{"CenterText", 0x000000, "Alt+Click - pick color (brush only)"},
		{"EmptyLine"},
		{"Button", {0xbbbbbb, 0xffffff, "OK"}},
	},

	developers = "Developers:",
	testers = "Testers:",
}FEMineOS/Applications/Photoshop.app/Resources/Localization/Russian.langE{
	newDocument = "ÐÐ¾Ð²ÑÐ¹ Ð´Ð¾ÐºÑÐ¼ÐµÐ½Ñ",
	width = "Ð¨Ð¸ÑÐ¸Ð½Ð°",
	height = "ÐÑÑÐ¾ÑÐ°",
	cancel = "ÐÑÐ¼ÐµÐ½Ð°",
	w = "Ð¨",
	h = "Ð",

	view = "ÐÐ¸Ð´",
	transparencyPad = "ÐÐ¾Ð´Ð»Ð¾Ð¶ÐºÐ° Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸",
	transparencyColor = "Ð¦Ð²ÐµÑ Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸",
	transparencyGrid = "Ð¡ÐµÑÐºÐ° Ð¿ÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÐ¸",

	path = "ÐÑÑÑ",
	string = "Ð¡ÑÑÐ¾ÐºÐ°",
	file = "Ð¤Ð°Ð¹Ð»",
	image = "ÐÐ·Ð¾Ð±ÑÐ°Ð¶ÐµÐ½Ð¸Ðµ",
	edit = "Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ",
	hotkeys = "ÐÐ¾ÑÑÑÐ¸Ðµ ÐºÐ»Ð°Ð²Ð¸ÑÐ¸",
	about = "Ð Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ðµ",
	brushSize = "Ð Ð°Ð·Ð¼ÐµÑ ÐºÐ¸ÑÑÐ¸",
	transparency = "ÐÑÐ¾Ð·ÑÐ°ÑÐ½Ð¾ÑÑÑ",
	brushParameters = "ÐÐ°ÑÐ°Ð¼ÐµÑÑÑ ÐºÐ¸ÑÑÐ¸",
	size = "Ð Ð°Ð·Ð¼ÐµÑ",

	new = "ÐÐ¾Ð²ÑÐ¹",
	open = "ÐÑÐºÑÑÑÑ",
	createFromString = "Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð¸Ð· OCIFString",
	save = "Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ",
	saveAs = "Ð¡Ð¾ÑÑÐ°Ð½Ð¸ÑÑ ÐºÐ°Ðº",
	exit = "ÐÑÑÐ¾Ð´",

	crop = "ÐÐ±ÑÐµÐ·Ð°ÑÑ",
	expand = "Ð Ð°ÑÑÐ¸ÑÐ¸ÑÑ",
	rotateBy90 = "ÐÐ¾Ð²ÐµÑÐ½ÑÑÑ Ð½Ð° 90 Ð³ÑÐ°Ð´ÑÑÐ¾Ð²",
	rotateBy180 = "ÐÐ¾Ð²ÐµÑÐ½ÑÑÑ Ð½Ð° 180 Ð³ÑÐ°Ð´ÑÑÐ¾Ð²",
	flipVertical = "ÐÑÑÐ°Ð·Ð¸ÑÑ Ð¿Ð¾ Ð²ÐµÑÑÐ¸ÐºÐ°Ð»Ð¸",
	flipHorizontal = "ÐÑÑÐ°Ð·Ð¸ÑÑ Ð¿Ð¾ Ð³Ð¾ÑÐ¸Ð·Ð¾Ð½ÑÐ°Ð»Ð¸",

	hueSaturation = "Ð¢Ð¾Ð½/ÐÐ°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÑ",
	colorBalance = "Ð¦Ð²ÐµÑÐ¾Ð²Ð¾Ð¹ Ð±Ð°Ð»Ð°Ð½Ñ",
	photoFilter = "Ð¤Ð¾ÑÐ¾ÑÐ¸Ð»ÑÑÑ",
	invertColors = "ÐÐ½Ð²ÐµÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ ÑÐ²ÐµÑÐ°",
	blackWhite = "Ð§ÐµÑÐ½Ð¾-Ð±ÐµÐ»ÑÐ¹ ÑÐ¸Ð»ÑÑÑ",
	gaussianBlur = "Ð Ð°Ð·Ð¼ÑÑÐ¸Ðµ Ð¿Ð¾ ÐÐ°ÑÑÑÑ",

	countOfPixels = "ÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð¿Ð¸ÐºÑÐµÐ»ÐµÐ¹",
	fromBottom = "Ð¡Ð½Ð¸Ð·Ñ",
	fromTop = "Ð¡Ð²ÐµÑÑÑ",
	fromLeft = "Ð¡Ð»ÐµÐ²Ð°",
	fromRight = "Ð¡Ð¿ÑÐ°Ð²Ð°",
	hue = "Ð¢Ð¾Ð½",
	saturation = "ÐÐ°ÑÑÑÐµÐ½Ð½Ð¾ÑÑÑ",
	brightness = "Ð¯ÑÐºÐ¾ÑÑÑ",
	filterColor = "Ð¦Ð²ÐµÑ ÑÐ¸Ð»ÑÑÑÐ°",
	radius = "Ð Ð°Ð´Ð¸ÑÑ",
	force = "Ð¡Ð¸Ð»Ð°",
	edges = "ÐÑÐ°Ð½Ð¸",
	accept = "Enter - Ð¿ÑÐ¸Ð¼ÐµÐ½Ð¸ÑÑ",

	line = "ÐÐ¸Ð½Ð¸Ñ",
	ellipse = "Ð­Ð»Ð»Ð¸Ð¿Ñ",
	rectangle = "ÐÑÑÐ¼Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº",
	polygon = "ÐÐ½Ð¾Ð³Ð¾ÑÐ³Ð¾Ð»ÑÐ½Ð¸Ðº",
	border = "Ð Ð°Ð¼ÐºÐ°",

	fill = "ÐÐ°Ð»Ð¸Ð²ÐºÐ°",
	clear = "ÐÑÐ¸ÑÑÐ¸ÑÑ",
	deselect = "Ð£Ð±ÑÐ°ÑÑ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ",

	hotkeysLines = {
		{"EmptyLine"},
		{"CenterText", 0x880000, "ÐÐ¾ÑÑÑÐ¸Ðµ ÐºÐ»Ð°Ð²Ð¸ÑÐ¸"},
		{"EmptyLine"},
		{"CenterText", 0x000000, "B - ÐºÐ¸ÑÑÑ"},
		{"CenterText", 0x000000, "E - Ð»Ð°ÑÑÐ¸Ðº"},
		{"CenterText", 0x000000, "T - ÑÐµÐºÑÑ"},
		{"CenterText", 0x000000, "G - Ð·Ð°Ð»Ð¸Ð²ÐºÐ°"},
		{"CenterText", 0x000000, "M - Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ"},
		{"CenterText", 0x000000, " "},
		{"CenterText", 0x000000, "Arrows - Ð¿ÐµÑÐµÐ¼ÐµÑÐµÐ½Ð¸Ðµ"},
		{"CenterText", 0x000000, "X - Ð¿Ð¾Ð¼ÐµÐ½ÑÑÑ ÑÐ²ÐµÑÐ° Ð¼ÐµÑÑÐ°Ð¼Ð¸"},
		{"CenterText", 0x000000, "D - ÑÐ¼ÐµÐ½Ð¸ÑÑ ÑÐ²ÐµÑÐ° Ð½Ð° ÑÐµÑÐ½ÑÐ¹ Ð¸ Ð±ÐµÐ»ÑÐ¹"},
		{"CenterText", 0x000000, "Ctrl+D - ÑÐ±ÑÐ°ÑÑ Ð²ÑÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ"},
		{"CenterText", 0x000000, "Alt+Click - Ð²ÑÐ±ÑÐ°ÑÑ ÑÐ²ÐµÑ (ÑÐ¾Ð»ÑÐºÐ¾ Ð´Ð»Ñ ÐºÐ¸ÑÑÐ¸)"},
		{"EmptyLine"},
		{"Button", {0xbbbbbb, 0xffffff, "OK"}},
	},

	developers = "Ð Ð°Ð·ÑÐ°Ð±Ð¾ÑÑÐ¸ÐºÐ¸:",
	testers = "Ð¢ÐµÑÑÐµÑÑ:",
}DMineOS/Applications/VK.app/D%MineOS/Applications/VK.app/Resources/D+MineOS/Applications/VK.app/Resources/About/F6MineOS/Applications/VK.app/Resources/About/Russian.txtJÐÐ¾Ð»Ð½Ð¾ÑÐµÐ½Ð½ÑÐ¹ ÐºÐ»Ð¸ÐµÐ½Ñ Ð´Ð»Ñ ÑÐ°Ð¹ÑÐ° VK.com, Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÑÑÐ¸Ð¹ Ð¾Ð±ÑÐ°ÑÑÑÑ Ñ Ð²Ð°ÑÐ¸Ð¼Ð¸ Ð´ÑÑÐ·ÑÑÐ¼Ð¸, Ð¿ÑÐ¾ÑÐ¼Ð°ÑÑÐ¸Ð²Ð°ÑÑ Ð¾ÑÐ½Ð¾Ð²Ð½ÑÑ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¸Ñ Ð¿ÑÐ¾ÑÐ¸Ð»ÐµÐ¹, ÑÐ¸ÑÐ°ÑÑ Ð½Ð¾Ð²Ð¾ÑÑÐ½ÑÑ Ð»ÐµÐ½ÑÑ, Ð° ÑÐ°ÐºÐ¶Ðµ Ð¿ÑÐ¾ÑÐ»ÑÑÐ¸Ð²Ð°ÑÑ Ð°ÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸.F-MineOS/Applications/VK.app/Resources/Icon.picËOCIFAÿSâFB  YSâFB  YA	 SKFÏB YSiF=B YSnF=B YSlF=B YSCF=B YS F B YYYYSVFÏB YSeF=B YStF=B YF/MineOS/Applications/VK.app/Resources/VKLogo.picOCIF#AÿS FÕB  Y	
#YYY
#Y	
F¬B  Y
F B  Y	
F7B  Y#Y"#YY !"#YY#FgB  YY !"#YY !"#Y	!"#Y	F<B  Y !"#YY	#YYY
	
A SâF<B ÕY
B ªYB ÖY
B YB YB 7YYY	"B gY
YYFÕB gYY
B Y"B «Y
"FgB ×YB 7YYYYYY B ÕYYF7B ªYB Y"Y !B ¬Y	B Y		B <YB lY!B gYY	YY"B Y
YYF×B ÖYY	 B ¬YB ÕYB ÿYY FªB YB ×Y
F«B <YB ÖYFÖB gYY	!B ÕYYB ªYB YB «YB ×YYY!Y
B YB YF¬B gY	B ×Y	Y
FÿB YB ¬Y !B «YB ÖYFB gYB 7YYB ¬Y	FB YB ÖYB 7YFB ×YB ÖYYB 7YFB 7YB ×Y Y	
S
 F<B ÖY	
FÕB YFÖB ÖY	
YB ×Y
FªB ÖYF¬B ×Y	Y
 !FB ×YFB ×Y
	FgB ÖY	
FB ×Y	Y	
F×B ÿYB ×YYF!MineOS/Applications/VK.app/VK.lua×æ
---------------------------------------------------- ÐÐ¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸ ----------------------------------------------------------------

local advancedLua = require("advancedLua")
local json = require("json")
local serialization = require("serialization")
local event = require("event")
local ecs = require("ECSAPI")
local fs = require("filesystem")
local buffer = require("doubleBuffering")
local context = require("context")
local image = require("image")
local unicode = require("unicode")
local component = require("component")
local computer = require("computer")
local GUI = require("GUI")

---------------------------------------------------- ÐÐ¾Ð½ÑÑÐ°Ð½ÑÑ ----------------------------------------------------------------

local VKAPIVersion = "5.52"

local colors = {
	leftBar = 0x262626,
	leftBarAlternative = 0x383838,
	leftBarText = 0xFFFFFF,
	leftBarSelection = 0x00A8FF,
	leftBarSelectionText = 0xFFFFFF,

	scrollBar = 0xCCCCCC,
	scrollBarPipe = 0x666666,

	mainZone = 0xFFFFFF,
	senderCloudColor = 0x3392FF,
	senderCloudTextColor = 0xFFFFFF,
	yourCloudColor = 0x55BBFF,
	yourCloudTextColor = 0xFFFFFF,
	systemMessageColor = 0x555555,
	dateTime = 0x777777,

	loginGUIBackground = 0x002440,

	topBar = 0x002440,
	topBarText = 0xFFFFFF,

	statusBar = 0x1b1b1b,
	statusBarText = 0xAAAAAA,

	audioPlayButton = 0x002440,
	audioPlayButtonText = 0xFFFFFF,

	messageInputBarColor = 0xEEEEEE,
	messageInputBarTextBackgroundColor = 0xFFFFFF,
	messsageInputBarTextColor = 0x262626,
}

local leftBarHeight = buffer.screen.height - 9
local leftBarWidth = math.floor(buffer.screen.width * 0.20)

local topBarHeight = 3

local mainZoneWidth = buffer.screen.width - leftBarWidth
local mainZoneHeight = buffer.screen.height - topBarHeight - 1
local mainZoneX = leftBarWidth + 1
local mainZoneY = topBarHeight + 1

local cloudWidth = math.floor(mainZoneWidth * 0.7)

-------------------------------------------------------------------------------------------------------------------------------

local settingsPath = "MineOS/System/VK/Settings.cfg"
local VKLogoImagePath = "MineOS/Applications/VK.app/Resources/VKLogo.pic"
-- local leftBarElements = {"ÐÐ¾Ð²Ð¾ÑÑÐ¸", "ÐÑÑÐ·ÑÑ", "Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ", "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸", "ÐÑÑÐ¾Ð´"}
local leftBarElements = { "ÐÐ¾Ñ ÑÑÑÐ°Ð½Ð¸ÑÐ°", "ÐÑÑÐ·ÑÑ", "Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ", "ÐÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸", "ÐÐ¾Ð²Ð¾ÑÑÐ¸", "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸", "ÐÑÑÐ¾Ð´" }
local currentLeftBarElement = 3
local personalInfo
local access_token
local whatIsOnScreen

local countOfDialogsToLoadFromServer = 10
local countOfAudioToLoadFromServer = 10
local countOfMessagesToLoadFromServer = 10

local dialogToShowFrom = 1
local audioToShowFrom = 1
local messageToShowFrom = 1

local dialogScrollSpeed = 5
local audioScrollSpeed = 5
local messagesScrollSpeed = 5
local profileScrollSpeed = 2
local friendsScrollSpeed = 5

local countOfFriendsToGetOnFriendsTab = 12
local currentFriendsOffset = 0
local currentFriends = {}

local countOfFriendsToDisplayInProfile = 16
local currentProfileY = mainZoneY + 2

local currentMessagesPeerID, currentMessagesAvatarText
local dialogPreviewTextLimit = mainZoneWidth - 15
local currentProfile

local settings = {saveAuthData = false, addSendingInfo = true}

local vip = {
	[7799889] = {avatarColor = 0x000000, avatarTextColor = 0xCCCCCC, avatarBottomText = "DEV", avatarBottomTextColor = 0x1b1b1b},
	[113499693] = {avatarColor = 0xFF99CC, avatarTextColor = 0x000000, avatarBottomText = "DEV", avatarBottomTextColor = 0xff6dbf},
	[60991376] = {avatarColor = 0xEEEEEE, avatarTextColor = 0x000000, avatarBottomText = "DEV", avatarBottomTextColor = 0x555555},
}

local messageEndAdderText = " (Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½Ð¾ Ñ MineOS VKClient)"

local news
local currentNews = 1
local countOfNewsToShow = 10
local countOfNewsToGet = 20

---------------------------------------------------- ÐÐµÐ±-ÑÐ°ÑÑÑ ----------------------------------------------------------------

local function loadSettings()
	if fs.exists(settingsPath) then settings = table.fromFile(settingsPath) end
end

local function saveSettings()
	table.toFile(settingsPath, settings)
end

--ÐÐ±ÑÐµÐºÑÑ
local obj = {}
local function newObj(class, name, ...)
	obj[class] = obj[class] or {}
	obj[class][name] = {...}
end

--ÐÐµÐ±Ð°Ð³-ÑÑÐ½ÐºÑÐ¸Ñ Ð½Ð° ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸Ðµ Ð³Ð¾Ð²Ð½Ð° Ð² ÑÐ°Ð¹Ð», ÐÐÐÐ ÐÐ Ð§Ð
local function saveToFile(filename, stro4ka)
	local file = io.open(filename, "w")
	file:write(stro4ka)
	file:close()
end

--ÐÐ°Ð½Ð°Ð»ÑÐ½ÑÐ¹ URL-Ð·Ð°Ð¿ÑÐ¾Ñ, Ð´ÐµÐºÐ¾Ð´Ð¸ÑÑÑÑÐ¸Ð¹ÑÑ ÑÐµÑÐµÐ· ÐÐ£Ð¡ÐÐ Ð² ÑÐ»ÑÑÐ°Ðµ ÑÑÐ¿ÐµÑÐ°, ÐµÐ¿ÑÑ
local function request(url)
	local success, response = ecs.internetRequest(url)
	if success then response = json:decode(response) end
	return success, response
end

--ÐÑÐ¿ÑÐ°Ð²Ð»ÑÐµÐ¼ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° Ð°Ð²ÑÐ¾ÑÐ¸Ð·Ð°ÑÐ¸Ñ Ð¿Ð¾ Ð»Ð¾Ð³Ð¸Ð½Ñ Ð¸ Ð¿Ð°ÑÐ¾Ð»Ñ
local function getLoginDataRequest(username, password)
	local url = "https://oauth.vk.com/token?grant_type=password&client_id=3697615&client_secret=AlVXZFMUqyrnABp8ncuU&username=" .. username .. "&password=" .. password .. "&v=" .. VKAPIVersion
	return request(url)
end

--ÐÐ°Ð¿ÑÐ¾Ñ Ðº Ð¼ÐµÑÐ¾Ð´Ð°Ð¼ VK API
local function VKAPIRequest(method, ... )
	local arguments = { ... }
	local stringArguments = ""

	local url = "https://api.vk.com/method/" .. method .. "?" .. table.concat(arguments, "&") .. "&access_token=" .. access_token .. "&v=" .. VKAPIVersion

	return request(url)
end

--ÐÐ°Ð¿ÑÐ¾Ñ Ð½Ð° Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð²
local function getDialogsRequest(fromDialog, count)
	return VKAPIRequest("messages.getDialogs", "offset=" .. fromDialog, "count=" .. count, "preview_length=" .. dialogPreviewTextLimit)
end

--ÐÐ°Ð¿ÑÐ¾Ñ Ð½Ð° Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð²
local function getMessagesRequest(peerID, fromMessage, count)
	return VKAPIRequest("messages.getHistory", "offset=" .. fromMessage, "count=" .. count, "peer_id=" .. peerID)
end

--ÐÐ°Ð¿ÑÐ¾Ñ Ð½Ð° Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° Ð¼ÑÐ·ÑÑÐºÐ¸
local function getAudioRequest(id, fromAudio, count)
	return VKAPIRequest("audio.get", "offset=" .. fromAudio, "count=" .. count, "owner_id=" .. id, "need_user=1")
end

--Ð­ÑÐ° ÑÑÐ¹Ð½Ñ Ð´ÐµÐ»Ð°ÐµÑ ÑÑÑÐ¾ÐºÑ Ð¾ÑÑÐµÐ½Ð½Ð¾Ð¹ Ð¿ÑÑÐµÐ¼ Ð·Ð°Ð¼ÐµÐ½Ñ Ð³Ð¾Ð²Ð½Ð° Ð½Ð° ÐºÐ¾Ð½ÑÐµÑÐºÑ
local function optimizeStringForURLSending(code)
  if code then
    code = string.gsub(code, "([^%w ])", function (c)
      return string.format("%%%02X", string.byte(c))
    end)
    code = string.gsub(code, " ", "+")
  end
  return code 
end

local function optimizeStringForWrongSymbols(s)
	--Ð£Ð´Ð°Ð»ÑÐµÐ¼ Ð½ÐµÐºÐ¾ÑÑÐµÐºÑÐ½ÑÐµ ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ
	s = string.gsub(s, "	", " ")
	s = string.gsub(s, "\r\n", "\n")
	s = string.gsub(s, "\n", "")
	--ÐÐ°Ð¼ÐµÐ½ÑÐµÐ¼ "ÑÐ¸ÑÐ¾ÐºÐ¸Ðµ" Ð´Ð²ÑÑÐ¿Ð¸ÐºÑÐµÐ»ÑÐ½ÑÐµ ÑÐ¸Ð¼Ð²Ð¾Ð»Ñ Ð½Ð° Ð·Ð½Ð°Ðº Ð²Ð¾Ð¿ÑÐ¾ÑÐ°
	local massiv = {}
	for i = 1, unicode.len(s) do
		massiv[i] = unicode.sub(s, i, i)
		if unicode.isWide(massiv[i]) then massiv[i] = "?" end
	end
	--ÐÐ¾Ð·Ð²ÑÐ°ÑÐ°ÐµÐ¼ Ð¾Ð¿ÑÐ¸Ð¼Ð¸Ð·ÑÐ¾Ð²Ð°Ð½Ð½ÑÑ ÑÑÑÐ¾ÐºÑ
	return table.concat(massiv)
end

local function convertIDtoPeerID(whatIsThisID, ID)
	if whatIsThisID == "user" then
		return ID
	elseif whatIsThisID == "chat" then
		return (2000000000 + ID)
	elseif whatIsThisID == "group" then
		return -ID
	end
end

local function getPeerIDFromMessageArray(messageArray)
	local peerID
	--ÐÑÐ»Ð¸ ÑÑÐ¾ ÑÐ°Ñ
	if messageArray.users_count then
		peerID = convertIDtoPeerID("chat", messageArray.chat_id)
	--ÐÐ»Ð¸ ÐµÑÐ»Ð¸ ÑÑÐ¾ Ð´Ð¸Ð°Ð»Ð¾Ð³ Ñ Ð³ÑÑÐ¿Ð¿Ð¾Ð¹ ÐºÐ°ÐºÐ¾Ð¹-ÑÐ¾
	elseif messageArray.user_id < 0 then
		peerID = convertIDtoPeerID("group", messageArray.user_id)
	--ÐÐ»Ð¸ ÐµÑÐ»Ð¸ Ð¿ÑÐ¾ÑÑÐ¾ ÐºÐ°ÐºÐ¾Ð¹-ÑÐ¾ ÑÑÐ°Ð»ÐºÐµÑ-Ð¾Ð´Ð¸Ð½Ð¾ÑÐºÐ°
	else
		peerID = convertIDtoPeerID("user", messageArray.user_id)
	end

	return peerID
end

--ÐÐ°Ð¿ÑÐ¾Ñ Ð½Ð° Ð¾ÑÐ¿ÑÐ°Ð²ÐºÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ ÑÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñ Ð¿Ð¸Ð´Ð¾ÑÑ
local function sendMessageRequest(peerID, message)
	--ÐÐµÐ»Ð°ÐµÐ¼ ÑÑÑÐ¾ÑÐºÑ Ð½Ðµ Ð¿Ð¸Ð´Ð¾ÑÑÐºÐ¾Ð¹
	message = optimizeStringForURLSending(message)
	return VKAPIRequest("messages.send", "peer_id=" .. peerID, "message=" .. message)
end

local function usersInformationRequest(...)
	return VKAPIRequest("users.get", "user_ids=" .. table.concat({...}, ","), "fields=contacts,education,site,city,bdate,online,status,last_seen,quotes,about,games,books,counters,relatives,connections,blacklisted,activities,interests,music,movies,tv")
end

local function userFriendsRequest(ID, count, offset, order, nameCase)
	return VKAPIRequest("friends.get", "user_id=" .. ID, "count=" .. count, "offset=" .. offset, "order=" .. order, "name_case=" .. nameCase, "fields=domain,online,last_seen")
end

local function userFriendsListsRequest(ID) 
	return VKAPIRequest("friends.getLists", "user_id=" .. ID, "return_system=1")
end

local function userWallRequest(ID, count, offset)
	return VKAPIRequest("wall.get", "owner_id=" .. ID, "count=" .. count, "offset=" .. offset)
end

local function setCurrentAudioPlaying(ownerID, audioID)
	return VKAPIRequest("audio.setBroadcast", "audio=" .. ownerID .. "_" .. audioID)
end

local function newsRequest(count)
	return VKAPIRequest("newsfeed.get", "filters=post", "return_banned=1", "max_photos=0", "count=" .. count, "fields=name,first_name,last_name")
end

local function setCrazyTypingRequest(peer_id)
	return VKAPIRequest("messages.setActivity", "type=typing", "peer_id=" .. peer_id)
end





---------------------------------------------------- GUI-ÑÐ°ÑÑÑ ----------------------------------------------------------------

local function createAvatarHashColor(hash)
	return math.abs(hash % 0xFFFFFF)
end

local function drawAvatar(x, y, width, height, user_id, text)
	local avatarColor = createAvatarHashColor(user_id)
	local textColor = avatarColor > 8388607 and 0x000000 or 0xFFFFFF

	--Ð¥Ð¾ÑÑ ÑÐµÐ±Ðµ Ð¿ÐµÑÑÐ¾Ð½Ð°Ð»ÑÐ½ÑÑ Ð°Ð²ÐºÑ, Ð° ÑÐ¾ ÑÐµ Ð·Ð° ÑÑÐ¹Ð½Ñ?
	if vip[user_id] then
		avatarColor = vip[user_id].avatarColor
		textColor = vip[user_id].avatarTextColor
	end

	buffer.square(x, y, width, height, avatarColor, textColor, " ")
	buffer.text(x + math.floor(width / 2) - math.floor(unicode.len(text) / 2), y + math.floor(height / 2), textColor, unicode.upper(text))

	if vip[user_id] and vip[user_id].avatarBottomText then buffer.text(x + math.floor(width / 2) - math.floor(unicode.len(text) / 2), y + height - 1, vip[user_id].avatarBottomTextColor, vip[user_id].avatarBottomText) end
end

--ÐÑÐ¾Ð²ÐµÑÐºÐ° ÐºÐ»Ð¸ÐºÐ° Ð² Ð¾Ð¿ÑÐµÐ´ÐµÐ»ÐµÐ½Ð½ÑÑ Ð¾Ð±Ð»Ð°ÑÑÑ Ð¿Ð¾ "Ð¾Ð±ÑÐµÐºÑÑ". ÐÐ¾Ð¼Ñ Ð½Ð° ÑÑÐ¹ Ð²ÑÑÐ°Ð»Ð¾ÑÑ ÐÐÐ?
local function clickedAtZone(x, y, zone)
	if x >= zone[1] and y >= zone[2] and x <= zone[3] and y <= zone[4] then
		return true
	end
	return false
end

--ÐÐ½ÑÐµÑÑÐµÐ¹Ñ Ð»Ð¾Ð³Ð¸Ð½Ð° Ð² Ð°ÐºÐºÐ°ÑÐ½Ñ ÐÐ, Ð¿Ð¾ÑÑÐ°ÑÐ°ÑÑÑ ÑÐ´ÐµÐ»Ð°ÑÑ Ð¿Ð¾Ð³ÑÐ°ÑÐ¾Ð½Ð¸ÑÑÐµÐ¹
--Ð¥Ð¾ÑÑ ÑÐ°Ñ! ÐÐ¾Ð³Ð¾ Ñ Ð¾Ð±Ð¼Ð°Ð½ÑÐ²Ð°Ñ, Ð°Ð³Ð°
local function loginGUI(startUsername, startPassword)
	local background = 0x002440
	local buttonColor = 0x666DFF
	local textColor = 0x262626
	local username, password = startUsername or "E-Mail Ð¸Ð»Ð¸ Ð½Ð¾Ð¼ÐµÑ ÑÐµÐ»ÐµÑÐ¾Ð½Ð°", startPassword or "ÐÐ°ÑÐ¾Ð»Ñ"

	local textFieldWidth = 50
	local textFieldHeight = 3
	local x, y = math.floor(buffer.screen.width / 2 - textFieldWidth / 2), math.floor(buffer.screen.height / 2)

	local obj = {}
	obj.username = {x, y, x + textFieldWidth - 1, y + 2}; y = y + textFieldHeight + 1
	obj.password = {x, y, x + textFieldWidth - 1, y + 2}; y = y + textFieldHeight + 1
	obj.button = GUI.button(x, y, textFieldWidth, textFieldHeight, buttonColor, 0xFFFFFF, 0xFFFFFF, buttonColor, "ÐÐ¾Ð¹ÑÐ¸")

	local VKLogoImage = image.load(VKLogoImagePath)

	local function draw()
		buffer.clear(colors.loginGUIBackground)

		buffer.image(x + 5, obj.username[2] - 15, VKLogoImage)

		buffer.square(x, obj.username[2], textFieldWidth, 3, 0xFFFFFF, 0x000000, " ")
		buffer.square(x, obj.password[2], textFieldWidth, 3, 0xFFFFFF, 0x000000, " ")
		buffer.text(x + 1, obj.username[2] + 1, textColor, ecs.stringLimit("end", username, textFieldWidth - 2))
		buffer.text(x + 1, obj.password[2] + 1, textColor, ecs.stringLimit("end", string.rep("â", unicode.len(password)), textFieldWidth - 2))

		obj.button:draw()

		buffer.draw()
	end

	while true do
		draw()
		local e = {event.pull()}
		if e[1] == "touch" then
			if clickedAtZone(e[3], e[4], obj.username) then
				username = ""
				username = ecs.inputText(x + 1, obj.username[2] + 1, textFieldWidth - 2, username, 0xFFFFFF, 0x262626) or ""
			
			elseif clickedAtZone(e[3], e[4], obj.password) then
				password = ""
				password = ecs.inputText(x + 1, obj.password[2] + 1, textFieldWidth - 2, password, 0xFFFFFF, 0x262626, false, "*") or ""
			
			elseif obj.button:isClicked(e[3], e[4]) then
				obj.button:press(0.2)
				draw()
				local success, loginData = getLoginDataRequest(username, password)
				if success then 
					if settings.saveAuthData then settings.username = username; settings.password = password; saveSettings() end
					loginData.username = username
					loginData.password = password
					return loginData
				else
					GUI.error("ÐÑÐ¸Ð±ÐºÐ° Ð°Ð²ÑÐ¾ÑÐ¸Ð·Ð°ÑÐ¸Ð¸: " .. tostring(loginData))
				end
			end
		end
	end
end

---------------------------------------------------- GUI Ð´Ð»Ñ Ð²Ð·Ð°Ð¸Ð¼Ð¾Ð´ÐµÐ¹ÑÑÐ²Ð¸Ñ Ñ VK API ----------------------------------------------

local function drawPersonalAvatar(x, y, width, height)
	drawAvatar(x, y, width, height, personalInfo.id, unicode.sub(personalInfo.first_name, 1, 1) .. unicode.sub(personalInfo.last_name, 1, 1))
end

local function status(text)
	buffer.square(mainZoneX, buffer.screen.height, mainZoneWidth, 1, colors.statusBar)
	buffer.text(mainZoneX + 1, buffer.screen.height, colors.statusBarText, text)
	buffer.draw()
end

local function drawTopBar(text)
	buffer.square(mainZoneX, 1, mainZoneWidth, 3, colors.topBar)
	local x = math.floor(mainZoneX + mainZoneWidth / 2 - unicode.len(text) / 2 - 1)
	buffer.text(x, 2, colors.topBarText, text)
end

--Ð Ð¸ÑÑÐµÐ¼ Ð³Ð»Ð°Ð²Ð½ÑÑ Ð·Ð¾Ð½Ñ
local function clearGUIZone()
	buffer.square(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight, colors.mainZone)
end

local function drawEmptyCloud(x, y, cloudWidth, cloudHeight, cloudColor, fromYou)
	local upperPixel = "â"
	local lowerPixel = "â"

	--Ð Ð¸ÑÑÐµÐ¼ ÑÐ¸Ð½ÑÐ¸ÑÐ»ÑÑÐµÑÐºÐ¸
	if not fromYou then
		buffer.set(x, y - cloudHeight + 2, colors.mainZone, cloudColor, upperPixel)
		buffer.set(x + 1, y - cloudHeight + 2, cloudColor, 0xFFFFFF, " ")
		x = x + 2
	else
		buffer.set(x + cloudWidth + 3, y - cloudHeight + 2, colors.mainZone, cloudColor, upperPixel)
		buffer.set(x + cloudWidth + 2, y - cloudHeight + 2, cloudColor, 0xFFFFFF, " ")
	end

	--ÐÐ°Ð¿Ð¾Ð»Ð½ÑÑÐµÑÐºÐ¸
	buffer.square(x + 1, y - cloudHeight + 1, cloudWidth, cloudHeight, cloudColor, 0xFFFFFF, " ")
	buffer.square(x, y - cloudHeight + 2, cloudWidth + 2, cloudHeight - 2, cloudColor, 0xFFFFFF, " ")
	
	--Ð¡Ð³ÑÑÐ³Ð»ÐµÐ½Ð½ÑÐµ ÐºÑÐ°ÐµÑÐºÐ¸
	buffer.set(x, y - cloudHeight + 1, colors.mainZone, cloudColor, lowerPixel)
	buffer.set(x + cloudWidth + 1, y - cloudHeight + 1, colors.mainZone, cloudColor, lowerPixel)
	buffer.set(x, y, colors.mainZone, cloudColor, upperPixel)
	buffer.set(x + cloudWidth + 1, y, colors.mainZone, cloudColor, upperPixel)

	return y - cloudHeight + 1
end

local function drawTextCloud(x, y, cloudColor, textColor, fromYou, text)
	local y = drawEmptyCloud(x, y, cloudWidth, #text + 2, cloudColor, fromYou)
	x = fromYou and x + 2 or x + 4

	for i = 1, #text do
		buffer.text(x, y + i, textColor, text[i])
	end

	return y
end

local function getAttachments(messageArray)
	local text = "ÐÐ»Ð¾Ð¶ÐµÐ½Ð¸Ñ: "
	for j = 1, #messageArray.attachments do
		if messageArray.attachments[j].type == "sticker" then
			text = text .. "ÑÑÐ¸ÐºÐµÑ, "
		elseif messageArray.attachments[j].type == "photo" then
			text = text .. "ÑÐ¾ÑÐ¾, "
		elseif messageArray.attachments[j].type == "video" then
			text = text .. "Ð²Ð¸Ð´ÐµÐ¾, "
		elseif messageArray.attachments[j].type == "audio" then
			text = text .. "Ð°ÑÐ´Ð¸Ð¾, "
		elseif messageArray.attachments[j].type == "wall" then
			text = text .. "Ð·Ð°Ð¿Ð¸ÑÑ Ð½Ð° ÑÑÐµÐ½Ðµ, "
		end
	end
	text = unicode.sub(text, 1, -3)

	return text
end

local function drawMessageInputBar(currentText)
	local x, y = mainZoneX, buffer.screen.height - 5
	obj.messageInputBar = GUI.object(x, y, mainZoneWidth - 4, 4)
	buffer.square(x, y, mainZoneWidth, 5, colors.messageInputBarColor)
	buffer.square(x + 2, y + 1, mainZoneWidth - 4, 3, colors.messageInputBarTextBackgroundColor)
	buffer.text(x + 4, y + 2, colors.messsageInputBarTextColor, ecs.stringLimit("start", currentText or "ÐÐ²ÐµÐ´Ð¸ÑÐµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ", mainZoneWidth - 8))
end

local function getUserNamesFromTheirIDs(IDsArray)
	local success, usersData = usersInformationRequest(table.unpack(IDsArray))
	local userNames = {}
	if success and usersData.response then
		for i = 1, #usersData.response do
			userNames[usersData.response[i].id] = {
				first_name = usersData.response[i].first_name,
				last_name = usersData.response[i].last_name,
			}
		end
	end
	return success, userNames
end

local function messagesGUI()

	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ Ð¸ÑÑÐ¾ÑÐ¸Ñ Ð¿ÐµÑÐµÐ¿Ð¸ÑÐºÐ¸")
	local success, messages = getMessagesRequest(currentMessagesPeerID, messageToShowFrom - 1, countOfMessagesToLoadFromServer)
	if success and messages.response then

		whatIsOnScreen = "messages"

		if currentMessagesPeerID > 2000000000 then
			status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ Ð¸Ð¼ÐµÐ½Ð° Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¹ Ð¸Ð· Ð¿ÐµÑÐµÐ¿Ð¸ÑÐºÐ¸ (Ð°ÐºÑÑÐ°Ð»ÑÐ½Ð¾ Ð´Ð»Ñ ÐºÐ¾Ð½ÑÐµÑÐµÐ½ÑÐ¸Ð¹)")

			local IDsArray = {};
			for i = 1, #messages.response.items do table.insert(IDsArray, messages.response.items[i].user_id) end
			local userNamesSuccess, userNames = getUserNamesFromTheirIDs(IDsArray)
			for i = 1, #messages.response.items do 
				messages.response.items[i].first_name = userNames[messages.response.items[i].user_id].first_name or "N/A"
				messages.response.items[i].last_name = userNames[messages.response.items[i].user_id].last_name or "N/A"
			end
			IDsArray = nil
		end

		clearGUIZone()
		drawTopBar("Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ")

		-- saveToFile("lastMessagesRequest.json", serialization.serialize(messages))

		buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

		local y = buffer.screen.height - 7
		local xSender = mainZoneX + 2
		local xYou = buffer.screen.width - 7

		for i = 1, #messages.response.items do

			local messageTextArray = {}

			--ÐÑÐ»Ð¸ ÑÑÑÐ¾ÐºÐ° Ð¿Ð¸Ð·Ð´Ð°ÑÐ°Ñ
			if messages.response.items[i].body ~= "" then table.insert(messageTextArray, optimizeStringForWrongSymbols(messages.response.items[i].body)) end
			if messages.response.items[i].fwd_messages then table.insert(messageTextArray, "ÐÐµÑÐµÑÐ»Ð°Ð½Ð½ÑÐµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ") end
			if messages.response.items[i].attachments then table.insert(messageTextArray, getAttachments(messages.response.items[i])) end
			if messages.response.items[i].action == "chat_invite_user" then table.insert(messageTextArray, "ÐÐ¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ Ð¿Ð¾Ð´ ID " .. messages.response.items[i].from_id .. " Ð¿ÑÐ¸Ð³Ð»Ð°ÑÐ¸Ð» Ð² Ð±ÐµÑÐµÐ´Ñ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ Ð¿Ð¾Ð´ ID " .. messages.response.items[i].action_mid) end

			messageTextArray = string.wrap(messageTextArray, cloudWidth - 4)
			local peerID = getPeerIDFromMessageArray(messages.response.items[i])

			--ÐÐµÐ»Ð°ÐµÐ¼ Ð´Ð°ÑÑ Ð¿Ð¸Ð·Ð´Ð°ÑÐ¾Ð¹
			-- messages.response.items[i].date = os.date("%d.%m.%y Ð² %X", messages.response.items[i].date)
			messages.response.items[i].date = os.date("%H:%M", messages.response.items[i].date)

			if messages.response.items[i].out == 1 then
				y = drawTextCloud(xYou - cloudWidth - 6, y, colors.yourCloudColor, colors.yourCloudTextColor, true, messageTextArray)
				drawPersonalAvatar(xYou, y, 6, 3)
				buffer.text(xYou - cloudWidth - unicode.len(messages.response.items[i].date) - 8, y + 1, colors.dateTime, messages.response.items[i].date)
			else
				y = drawTextCloud(xSender + 8, y, colors.senderCloudColor, colors.senderCloudTextColor, false, messageTextArray)
				drawAvatar(xSender, y, 6, 3, peerID, messages.response.items[i].first_name and (unicode.sub(messages.response.items[i].first_name, 1, 1) .. unicode.sub(messages.response.items[i].last_name, 1, 1)) or currentMessagesAvatarText)
				buffer.text(xSender + cloudWidth + 14, y + 1, colors.dateTime, messages.response.items[i].date)
			end

			y = y - 2
		end

		local currentText

		drawMessageInputBar(currentText)

		status("ÐÑÑÐ¾ÑÐ¸Ñ Ð¿ÐµÑÐµÐ¿Ð¸ÑÐºÐ¸ Ð·Ð°Ð³ÑÑÐ¶ÐµÐ½Ð°, Ð¾Ð¶Ð¸Ð´Ð°Ñ Ð²Ð²Ð¾Ð´Ð° ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ")

		buffer.resetDrawLimit()
		-- buffer.draw()
	end
end

local function drawDialog(y, dialogBackground, avatarID, avatarText, text1, text2, text3)
	--Ð Ð¸ÑÑÐµÐ¼ Ð¿Ð¾Ð´Ð»Ð¾Ð¶ÐºÑ Ð¿Ð¾Ð´ Ð´Ð¸Ð°Ð»Ð¾Ð³ Ð½ÑÐ¶Ð½Ð¾Ð³Ð¾ ÑÐ²ÐµÑÐ°
	buffer.square(mainZoneX, y, mainZoneWidth, 5, dialogBackground)
	--Ð Ð¸ÑÑÐµÐ¼ Ð°Ð²Ð°ÑÐ°ÑÐºÑ, ÑÐ¾ ÑÐ¶
	drawAvatar(mainZoneX + 2, y + 1, 6, 3, avatarID, avatarText)
	--ÐÐ¸ÑÐµÐ¼ Ð²ÑÐµ, ÑÑÐ¾ Ð½ÑÐ¶Ð½Ð¾
	y = y + 1
	if text1 then buffer.text(mainZoneX + 10, y, 0x000000, text1); y = y + 1 end
	if text2 then buffer.text(mainZoneX + 10, y, 0x555555, text2); y = y + 1 end
	if text3 then buffer.text(mainZoneX + 10, y, 0x666666, text3); y = y + 1 end
end

local function dialogsGUI()

	local success, dialogs = getDialogsRequest(dialogToShowFrom - 1, countOfDialogsToLoadFromServer)
	if success and dialogs.response then
		
		whatIsOnScreen = "dialogs"

		obj.dialogList = {}

		clearGUIZone()
		drawTopBar("Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ")

		--ÐÐ±Ð°ÑÐ¸Ð¼ ÐÐÐÐÐÐ§ÐÐ ÑÐ¿Ð°Ð¼Ð°
		obj.crazyTypingButton = GUI.adaptiveButton(mainZoneX + 2, 2, 1, 0, 0xFFFFFF, colors.topBar, 0xAAAAAA, 0x000000, "CrazyTyping")
		-- obj.spamButton = {buffer.adaptiveButton(obj.crazyTypingButton[3] + 2, 2, 1, 0, 0xFFFFFF, colors.topBar, "Ð¡Ð¿Ð°Ð¼")}

		--ÐÐ£ Ð¢Ð« ÐÐÐÐ¯Ð, ÐÐÐ
		status("ÐÐ¾Ð»ÑÑÐ°Ñ Ð¸Ð¼ÐµÐ½Ð° Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¹ Ð¿Ð¾ ID")
		local IDsArray = {}
		for i = 1, #dialogs.response.items do
			if not dialogs.response.items[i].message.chat_id and dialogs.response.items[i].message.user_id and dialogs.response.items[i].message.user_id > 0 then
				table.insert(IDsArray, dialogs.response.items[i].message.user_id)
			end
		end
		local userNamesSuccess, userNames = getUserNamesFromTheirIDs(IDsArray)
		for i = 1, #dialogs.response.items do
			if not dialogs.response.items[i].message.chat_id and dialogs.response.items[i].message.user_id and dialogs.response.items[i].message.user_id > 0 then
				dialogs.response.items[i].message.title = userNames[dialogs.response.items[i].message.user_id].first_name or "N/A" .. " " .. userNames[dialogs.response.items[i].message.user_id].last_name or ""
			end
		end

		local y = mainZoneY
		local avatarText = ""
		local peerID
		local color

		for i = 1, #dialogs.response.items do
			--ÐÐ±ÐµÐ¼ÑÑ Ñ ÑÐ²ÐµÑÐ°Ð¼Ð¸
			if dialogs.response.items[i].unread then
				if i % 2 == 0 then 
					color = 0xCCDBFF
				else
					color = 0xCCDBFF
				end
			else
				if i % 2 == 0 then 
					color = 0xEEEEEE
				else
					color = 0xFFFFFF
				end
			end
			
			avatarText = unicode.sub(dialogs.response.items[i].message.title, 1, 2)
			peerID = getPeerIDFromMessageArray(dialogs.response.items[i].message)

			--ÐÐ±Ð»Ñ Ñ ÑÐµÐºÑÑÐ¾Ð¼ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð°
			local text1 = dialogs.response.items[i].message.title
			local text2
			local text3

			--ÐÑÐ»Ð¸ ÑÑÐ¾ Ð±Ð°Ð½Ð°Ð»ÑÐ½Ð¾Ðµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ
			if dialogs.response.items[i].message.body and dialogs.response.items[i].message.body ~= "" then
				text2 = optimizeStringForWrongSymbols(dialogs.response.items[i].message.body)
			end

			--ÐÑÐ»Ð¸ ÐµÑÑÑ ÐºÐ°ÐºÐ¸Ðµ-Ð»Ð¸Ð±Ð¾ Ð¿ÐµÑÐµÑÐ»Ð°Ð½Ð½ÑÐµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ, ÑÐ¾
			if dialogs.response.items[i].message.fwd_messages then
				text3 = "ÐÐµÑÐµÑÐ»Ð°Ð½Ð½ÑÐµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ"
			--ÐÑÐ»Ð¸ ÐµÑÑÑ ÐºÐ°ÐºÐ¸Ðµ-Ð»Ð¸Ð±Ð¾ Ð²Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ, ÑÐ¾
			elseif dialogs.response.items[i].message.attachments then
				text3 = getAttachments(dialogs.response.items[i].message)
			end

			--Ð Ð¸ÑÑÐµÐ¼ Ð´Ð¸Ð°Ð»Ð¾Ð³
			drawDialog(y, color, peerID, avatarText, text1, text2, text3)

			--Ð Ð¸ÑÑÐµÐ¼ Ð¿Ð¸Ð·Ð´ÑÐ»Ð¸Ð½ÐºÑ, Ð¿Ð¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑÑÑ ÐºÐ¾Ð»-Ð²Ð¾ Ð½ÐµÐ¿ÑÐ¾ÑÐ¸ÑÐ°Ð½Ð½ÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ð¹
			if dialogs.response.items[i].unread and dialogs.response.items[i].unread ~= 0 then
				local cyka = tostring(dialogs.response.items[i].unread)
				local cykaWidth = unicode.len(cyka) + 2
				local cykaX = buffer.screen.width - cykaWidth - 2
				buffer.square(cykaX, y + 2, cykaWidth, 1, ecs.colors.blue)
				buffer.text(cykaX + 1, y + 2, 0xFFFFFF, cyka)
			end

			obj.dialogList[i] = GUI.object(mainZoneX, y, mainZoneWidth, 5)
			obj.dialogList[i][5], obj.dialogList[i][6], obj.dialogList[i][7], obj.dialogList[i][8], obj.dialogList[i][9] = peerID, avatarText, text1, text2, text3

			y = y + 5
		end
	end

	status("Ð¡Ð¿Ð¸ÑÐ¾Ðº Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð² Ð¿Ð¾Ð»ÑÑÐµÐ½")
end

--ÐÑÐ¸ÑÐºÐ° Ð°ÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐµÐ¹
--Ð-Ð-Ð-Ð!!!!! ÐÐÐ ÐÐ ÐÐ¡ÐÐÐ«Ð Ð¢Ð ÐÐ£ÐÐÐÐ¬ÐÐÐ§ÐÐ PLAY, ÐÐÐ¯ÐÐ¬!!!! Ð¨Ð¢Ð Ð¢Ð« ÐÐÐÐÐÐ¨Ð¬, SANGAR, ÐÐ ÐÐÐ ÐÐ¢Ð!!!!
local function audioGUI(ID)
	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº Ð°ÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐµÐ¹")
	local success, audios = getAudioRequest(ID, audioToShowFrom - 1, countOfAudioToLoadFromServer)
	if success and audios.response then
		whatIsOnScreen = "audio"
		obj.audio = {}
		clearGUIZone()
		drawTopBar("ÐÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸ " .. audios.response.items[1].name_gen)

		local y = mainZoneY
		local color
		for i = 2, #audios.response.items do
			color = 0xFFFFFF
			if i % 2 == 0 then color = 0xEEEEEE end

			buffer.square(mainZoneX, y, mainZoneWidth, 5, color)
			obj.audio[i] = GUI.button(mainZoneX + 2, y + 1, 5, 3, colors.audioPlayButton, colors.audioPlayButtonText, 0x66FF80, colors.audioPlayButton, ">")
			obj.audio[i][5] = audios.response.items[i]

			local x = mainZoneX + 9
			buffer.text(x, y + 1, colors.audioPlayButton, audios.response.items[i].artist)
			x = x + unicode.len(audios.response.items[i].artist)
			buffer.text(x, y + 1, 0x000000, " - " .. audios.response.items[i].title)

			x = mainZoneX + 9
			local hours = string.format("%02.f", math.floor(audios.response.items[i].duration / 3600))
			local minutes = string.format("%02.f", math.floor(audios.response.items[i].duration / 60 - (hours * 60)))
			local seconds = string.format("%02.f", math.floor(audios.response.items[i].duration - hours * 3600 - minutes * 60))
			buffer.text(x, y + 2, 0x888888, "ÐÐ»Ð¸ÑÐµÐ»ÑÐ½Ð¾ÑÑÑ: " .. hours .. ":" .. minutes .. ":" .. seconds)

			y = y + 5
		end
	else
		GUI.error("ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ð¸ ÑÐ¿Ð¸ÑÐºÐ° Ð°ÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐµÐ¹")
	end
end

local function checkField(field)
	if field and field ~= "" and field ~= " " then return true end
	return false
end

local function userProfileRequest()
	--ÐÐ±Ð°ÑÐ¸Ð¼ Ð¾ÑÐ½Ð¾Ð²Ð½ÑÑ Ð¸Ð½ÑÑ
	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ðµ Ð¿Ð¾Ð´ ID " .. currentProfile.ID)
	local profileSuccess, userProfile = usersInformationRequest(currentProfile.ID)
	
	--ÐÐ±Ð°ÑÐ¸Ð¼ ÑÑÐµÐ½Ñ
	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ð¼Ð¾Ðµ ÑÑÐµÐ½Ñ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ " .. currentProfile.ID)
	local wallSuccess, wall = userWallRequest(currentProfile.ID, 20, currentProfile.wallOffset)
	--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¸Ð½ÑÑ Ð¾ ÑÐ·Ð²ÐµÑÑÑ ÑÐ¾ ÑÑÐµÐ½Ñ
	local userNamesSuccess, userNames
	if wallSuccess and wall.response then
		local IDsArray = {}
		for i = 1, #wall.response.items do table.insert(IDsArray, wall.response.items[i].from_id) end
		status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ Ð¸Ð¼ÐµÐ½Ð° Ð»ÑÐ´ÐµÐ¹, Ð¾ÑÑÐ°Ð²Ð¸Ð²ÑÐ¸Ñ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ Ð½Ð° ÑÑÐµÐ½Ðµ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ " .. currentProfile.ID)
		userNamesSuccess, userNames = getUserNamesFromTheirIDs(IDsArray)
		IDsArray = nil
	end

	--ÐÐ±Ð°ÑÐ¸Ð¼ ÑÑÐµÐ½Ð´ÑÐ¾Ð²
	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ Ð¾ Ð´ÑÑÐ·ÑÑÑ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ Ð¿Ð¾Ð´ ID " .. currentProfile.ID)
	local friendsSuccess, friends = userFriendsRequest(currentProfile.ID, countOfFriendsToDisplayInProfile, 0, "random", "nom")

	--ÐÐ½Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ Ð½Ð° Ð¿Ð¸Ð·Ð´Ð°ÑÐ¾ÑÑÑ
	if (profileSuccess and userProfile.response) and (wallSuccess and wall.response) and (userNamesSuccess) and (friendsSuccess and friends.response) then
		-- saveToFile("lastUserProfileRequest.json", serialization.serialize(userProfile))
		currentProfile.userProfile = userProfile
		currentProfile.wall = wall
		currentProfile.userNames = userNames
		currentProfile.friends = friends
		return true
	else
		GUI.error("ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð·Ð°Ð³ÑÑÐ·ÐºÐµ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ð¸ Ð¾ Ð¿ÑÐ¾ÑÐ¸Ð»Ðµ")
		return false
	end
end

local function userProfileGUI()
	clearGUIZone()
	whatIsOnScreen = "userProfile"
	drawTopBar("Ð¡ÑÑÐ°Ð½Ð¸ÑÐ° Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ " .. currentProfile.ID)

	buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

	local xAvatar, yAvatar = mainZoneX + 4, currentProfileY
	local x, y = xAvatar, yAvatar
	local avatarWidth = 18
	local avatarHeight = math.floor(avatarWidth / 2)

	--Ð Ð¸ÑÑÐµÐ¼ Ð°Ð²ÐºÑ
	currentProfile.avatarText =  unicode.sub(currentProfile.userProfile.response[1].first_name, 1, 1) .. unicode.sub(currentProfile.userProfile.response[1].last_name, 1, 1)
	drawAvatar(x, y, avatarWidth, avatarHeight, currentProfile.ID, currentProfile.avatarText)
	--Ð Ð¸ÑÑÐµÐ¼ Ð¸Ð¼ÑÑÐºÐ¾ Ð¸ ÑÑÐ°ÑÑÑ
	x = x + avatarWidth + 4
	buffer.text(x, y, 0x000000, currentProfile.userProfile.response[1].first_name .. " " .. currentProfile.userProfile.response[1].last_name); y = y + 1
	buffer.text(x, y, 0xAAAAAA, currentProfile.userProfile.response[1].status); y = y + 2

	--ÐÐ½ÑÐ°Ð°Ð°Ð°Ð°
	local informationOffset = 20
	local informationKeyColor = 0x888888
	local informationTitleColor = 0x000000
	local informationValueColor = 0x002440
	local informationSeparatorColor = 0xCCCCCC

	local function drawInfo(x, y2, key, value)
		if checkField(value) then
			value = {value}
			value = string.wrap(value, buffer.screen.width - x - 4 - informationOffset)
			buffer.text(x, y2, informationKeyColor, key)
			for i = 1, #value do
				buffer.text(x + informationOffset, y2, informationValueColor, value[i])
				y2 = y2 + 1
			end
			y = y2
		end
	end

	local function drawSeparator(x, y2, text)
		buffer.text(x, y2, informationTitleColor, text)
		buffer.text(x + unicode.len(text) + 1, y2, informationSeparatorColor, string.rep("â", buffer.screen.width - x - unicode.len(text)))
		y = y + 1
	end

	drawSeparator(x, y, "ÐÑÐ½Ð¾Ð²Ð½Ð°Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ"); y = y + 1

	drawInfo(x, y, "ÐÐ°ÑÐ° ÑÐ¾Ð¶Ð´ÐµÐ½Ð¸Ñ:", currentProfile.userProfile.response[1].bdate)
	if currentProfile.userProfile.response[1].city then drawInfo(x, y, "ÐÐ¾ÑÐ¾Ð´:", currentProfile.userProfile.response[1].city.title) end
	drawInfo(x, y, "ÐÐ±ÑÐ°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ:", currentProfile.userProfile.response[1].university_name)
	drawInfo(x, y, "ÐÐµÐ±-ÑÐ°Ð¹Ñ", currentProfile.userProfile.response[1].site); y = y + 1

	drawSeparator(x, y, "ÐÐ¾Ð½ÑÐ°ÐºÑÐ½Ð°Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ"); y = y + 1

	drawInfo(x, y, "ÐÐ¾Ð±Ð¸Ð»ÑÐ½ÑÐ¹ ÑÐµÐ»ÐµÑÐ¾Ð½:", currentProfile.userProfile.response[1].mobile_phone)
	drawInfo(x, y, "ÐÐ¾Ð¼Ð°ÑÐ½Ð¸Ð¹ ÑÐµÐ»ÐµÑÐ¾Ð½:", currentProfile.userProfile.response[1].home_phone)
	drawInfo(x, y, "Skype:", currentProfile.userProfile.response[1].skype); y = y + 1

	drawSeparator(x, y, "ÐÐ¸ÑÐ½Ð°Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ"); y = y + 1

	drawInfo(x, y, "ÐÐ½ÑÐµÑÐµÑÑ:", currentProfile.userProfile.response[1].interests)
	drawInfo(x, y, "ÐÐµÑÑÐµÐ»ÑÐ½Ð¾ÑÑÑ:", currentProfile.userProfile.response[1].activities)
	drawInfo(x, y, "ÐÑÐ±Ð¸Ð¼Ð°Ñ Ð¼ÑÐ·ÑÐºÐ°:", currentProfile.userProfile.response[1].music)
	drawInfo(x, y, "ÐÑÐ±Ð¸Ð¼Ð°Ñ ÑÐ¸Ð»ÑÐ¼Ñ:", currentProfile.userProfile.response[1].movies)
	drawInfo(x, y, "ÐÑÐ±Ð¸Ð¼Ð°Ñ ÑÐµÐ»ÐµÑÐ¾Ñ:", currentProfile.userProfile.response[1].tv)
	drawInfo(x, y, "ÐÑÐ±Ð¸Ð¼Ð°Ñ ÐºÐ½Ð¸Ð³Ð¸:", currentProfile.userProfile.response[1].books)
	drawInfo(x, y, "ÐÑÐ±Ð¸Ð¼Ð°Ñ Ð¸Ð³ÑÑ:", currentProfile.userProfile.response[1].games)
	drawInfo(x, y, "Ð ÑÐµÐ±Ðµ:", currentProfile.userProfile.response[1].about)

	-- Ð ÐÐÐ¢ Ð Ð¡Ð¢ÐÐÐÐ§ÐÐ ÐÐÐÐªÐÐ¥ÐÐÐ ÐÐ ÐÐ ÐÐÐÐÐÐ ÐÐ£Ð¨Ð
	y = y + 1
	buffer.square(x, y, buffer.screen.width - x - 2, 1, 0xCCCCCC); buffer.text(x + 1, y, 0x262626, "Ð¡ÑÐµÐ½Ð°"); y = y + 2
	--ÐÐµÑÐµÐ±Ð¸ÑÐ°ÐµÐ¼ Ð²ÑÑ ÑÑÐµÐ½ÐºÑ
	for i = 1, #currentProfile.wall.response.items do
		--ÐÑÐ»Ð¸ ÑÑÐ¾ Ð½Ðµ ÑÐµÐ¿Ð¾ÑÑ Ð¸Ð»Ð¸ ÐµÑÐµ Ð½Ðµ ÑÑÐ¹Ð½Ñ ÐºÐ°ÐºÐ°Ñ-ÑÐ¾
		if currentProfile.wall.response.items[i].text ~= "" then
			-- GUI.error(userNames)
			drawAvatar(x, y, 6, 3, currentProfile.wall.response.items[i].from_id, unicode.sub(currentProfile.userNames[currentProfile.wall.response.items[i].from_id].first_name, 1, 1) .. unicode.sub(currentProfile.userNames[currentProfile.wall.response.items[i].from_id].last_name, 1, 1))
			buffer.text(x + 8, y, informationValueColor, currentProfile.userNames[currentProfile.wall.response.items[i].from_id].first_name .. " " .. currentProfile.userNames[currentProfile.wall.response.items[i].from_id].last_name)
			local date = os.date("%d.%m.%y Ð² %H:%M", currentProfile.wall.response.items[i].date)
			buffer.text(buffer.screen.width - unicode.len(date) - 2, y, 0xCCCCCC, date)
			y = y + 1
			local text = {currentProfile.wall.response.items[i].text}
			text = string.wrap(text, buffer.screen.width - x - 10)
			for i = 1, #text do
				buffer.text(x + 8, y, 0x000000, text[i])
				y = y + 1
			end
			y = y + 1
			if #text == 1 then y = y + 1 end
		end
	end

	--ÐÐ¾Ð´ÐÐ²Ð¾ÑÐ½Ð°Ñ Ð¿Ð°ÑÐ°ÑÐ°
	informationOffset = 13
	x, y = xAvatar, yAvatar
	y = y + avatarHeight + 1

	currentProfile.avatarWidth = avatarWidth
	currentProfile.sendMessageButton = GUI.button(x, y, avatarWidth, 1, 0xCCCCCC, 0x000000, 0x888888, 0x000000,"Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ")
	y = y + 2
	currentProfile.audiosButton = GUI.button(x, y, avatarWidth, 1, 0xCCCCCC, 0x000000, 0x888888, 0x000000, "ÐÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸")
	y = y + 2

	drawInfo(x, y, "ÐÐ¾Ð´Ð¿Ð¸ÑÑÐ¸ÐºÐ¸: ", currentProfile.userProfile.response[1].counters.followers)
	drawInfo(x, y, "Ð¤Ð¾ÑÐ¾Ð³ÑÐ°ÑÐ¸Ð¸: ", currentProfile.userProfile.response[1].counters.photos)
	drawInfo(x, y, "ÐÐ¸Ð´ÐµÐ¾Ð·Ð°Ð¿Ð¸ÑÐ¸: ", currentProfile.userProfile.response[1].counters.videos)
	drawInfo(x, y, "ÐÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸: ", currentProfile.userProfile.response[1].counters.audios)

	--ÐÑÑÐ·ÑÑÐºÐ¸, ÐÐÐ¢ÐÐÐÐÐÐ, ÐÐ¥ÐÐ¥ÐÐ¥ÐÐ¥ÐÐ¥ÐÐ¥ÐÐ¥ÐÐ¥ÐÐ¥Ð		
	y = y + 1
	buffer.square(x, y, avatarWidth, 1, 0xCCCCCC); buffer.text(x + 1, y, 0x262626, "ÐÑÑÐ·ÑÑ (" .. currentProfile.userProfile.response[1].counters.friends .. ")"); y = y + 2
	local xPos, yPos = x + 1, y
	local count = 1
	for i = 1, #currentProfile.friends.response.items do
		drawAvatar(xPos, yPos, 6, 3, currentProfile.friends.response.items[i].id, unicode.sub(currentProfile.friends.response.items[i].first_name, 1, 1) .. unicode.sub(currentProfile.friends.response.items[i].last_name, 1, 1))
		buffer.text(xPos - 1, yPos + 3, 0x000000, ecs.stringLimit("end", currentProfile.friends.response.items[i].first_name .. " " .. currentProfile.friends.response.items[i].last_name, 8))
		xPos = xPos + 10
		if i % 2 == 0 then xPos = x + 1; yPos = yPos + 5 end
		count = count + 1
		if count > countOfFriendsToDisplayInProfile then break end
	end

	buffer.resetDrawLimit()
end

local function loadAndShowProfile(ID)
	currentProfileY = mainZoneY + 2
	currentProfile = {ID = ID, wallOffset = 0}
	if userProfileRequest() then userProfileGUI(currentProfile.ID) end
end

local function friendsGUI()
	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº Ð´ÑÑÐ·ÐµÐ¹")
	local success, friends = userFriendsRequest(personalInfo.id, countOfFriendsToGetOnFriendsTab, currentFriendsOffset, "hints", "nom")
	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº ÐºÐ°ÑÐµÐ³Ð¾ÑÐ¸Ð¹ Ð´ÑÑÐ·ÐµÐ¹")
	local successLists, friendsLists = userFriendsListsRequest(personalInfo.id)
	if (success and friends.response) and (successLists and friendsLists.response) then
		-- saveToFile("lastFriendsResponse.json", serialization.serialize(friends))
		clearGUIZone()
		currentFriends = {sendMessageButtons = {}, openProfileButtons = {}}
		whatIsOnScreen = "friends"
		drawTopBar("ÐÑÑÐ·ÑÑ")
		buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

		local function getListName(listID)
			local name = "N/A"
			for i = 1, #friendsLists.response.items do
				if friendsLists.response.items[i].id == listID then
					name = friendsLists.response.items[i].name
					break
				end
			end
			return name
		end

		local x, y = mainZoneX + 2, mainZoneY
		for i = 1, #friends.response.items do
			--ÐÐ°Ð´Ð»Ð¾Ð¶ÐºÐ°
			if i % 2 == 0 then buffer.square(mainZoneX, y, mainZoneWidth, 5 + (friends.response.items[i].lists and 1 or 0), 0xEEEEEE) end
			--Ð®Ð·ÐµÑ
			y = y + 1
			local subbedName = unicode.sub(friends.response.items[i].first_name, 1, 1) .. unicode.sub(friends.response.items[i].last_name, 1, 1)
			drawAvatar(x, y, 6, 3, friends.response.items[i].id, subbedName)
			local text = friends.response.items[i].first_name .. " " .. friends.response.items[i].last_name
			buffer.text(x + 8, y, colors.topBar, text)
			local text2 = friends.response.items[i].last_seen and (", " .. (friends.response.items[i].online == 1 and "Ð¾Ð½Ð»Ð°Ð¹Ð½" or "Ð±ÑÐ»(Ð°) Ð² ÑÐµÑÐ¸ " .. os.date("%d.%m.%y Ð² %H:%M", friends.response.items[i].last_seen.time))) or " "
			buffer.text(x + 8 + unicode.len(text), y, 0xAAAAAA, text2)

			if friends.response.items[i].lists then
				y = y + 1
				local cykaX = x + 8
				for listID = 1, #friends.response.items[i].lists do
					local listName = getListName(friends.response.items[i].lists[listID])
					local listWidth = unicode.len(listName) + 2
					local listBackColor = math.floor(0xFFFFFF / friends.response.items[i].lists[listID])
					local listTextColor = (listBackColor > 0x7FFFFF and 0x000000 or 0xFFFFFF)
					buffer.square(cykaX, y, listWidth, 1, listBackColor, listTextColor, " ")
					buffer.text(cykaX + 1, y, listTextColor, listName)
					cykaX = cykaX + listWidth + 2
				end
			end

			y = y + 1
			buffer.text(x + 8, y, 0x999999, "ÐÐ°Ð¿Ð¸ÑÐ°ÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ")
			currentFriends.sendMessageButtons[friends.response.items[i].id] = {x + 8, y, x + 18, y, subbedName}
			y = y + 1
			buffer.text(x + 8, y, 0x999999, "ÐÑÐºÑÑÑÑ Ð¿ÑÐ¾ÑÐ¸Ð»Ñ")
			currentFriends.openProfileButtons[friends.response.items[i].id] = {x + 8, y, x + 18, y, subbedName}

			y = y + 2
		end

		buffer.resetDrawLimit()
	else
		GUI.error("ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ð¸ ÑÐ¿Ð¸ÑÐºÐ° Ð´ÑÑÐ·ÐµÐ¹ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ")
	end
end

local function newsGUI()
	clearGUIZone()
	drawTopBar("ÐÐ¾Ð²Ð¾ÑÑÐ¸")
	whatIsOnScreen = "news"
	buffer.setDrawLimit(mainZoneX, mainZoneY, mainZoneWidth, mainZoneHeight)

	local function getAvatarTextAndNameForNews(source_id)
		local avatarText, name = "N/A", "N/A"
		if source_id < 0 then
			for i = 1, #news.response.groups do
				if news.response.groups[i].id == math.abs(source_id) then
					avatarText = unicode.sub(news.response.groups[i].name, 1, 2)
					name = news.response.groups[i].name
					break
				end
			end
		else
			for i = 1, #news.response.profiles do
				if news.response.profiles[i].id == source_id then
					avatarText = unicode.sub(news.response.profiles[i].first_name, 1, 1) .. unicode.sub(news.response.profiles[i].last_name, 1, 1)
					name = news.response.profiles[i].first_name .. " " .. news.response.profiles[i].last_name
					break
				end
			end
		end
		return avatarText, name
	end

	local x, y = mainZoneX + 2, mainZoneY
	for item = currentNews, currentNews + countOfNewsToShow do
		if news.response.items[item] then
			--ÐÐµÐ»Ð°ÐµÐ¼ ÑÐµÐºÑÑ Ð¿Ð¸Ð·Ð´Ð°ÑÑÐ¼
			news.response.items[item].text = optimizeStringForWrongSymbols(news.response.items[item].text)
			--Ð£Ð±Ð¸ÑÐ°ÐµÐ¼ Ð³Ð¾Ð²Ð½Ð¾ Ð¸Ð· Ð½Ð¾Ð²Ð¾ÑÑÐµÐ¹
			if news.response.items[item].text == "" then
				if news.response.items[item].copy_history then
					news.response.items[item].text = "Ð ÐµÐ¿Ð¾ÑÑ"
				elseif news.response.items[item].attachments then
					 news.response.items[item].text = getAttachments(news.response.items[item])
				end
			end
			--ÐÐµÐ»Ð°ÐµÐ¼ ÐµÐ³Ð¾ ÐµÑÐµ Ð¿Ð¸Ð·Ð¶Ðµ
			local text = {news.response.items[item].text}; text = string.wrap(text, buffer.screen.width - x - 10)
			--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¸Ð½ÑÑ Ð½ÑÐ¶Ð½ÑÑ
			local avatarText, name = getAvatarTextAndNameForNews(news.response.items[item].source_id)
			--Ð¡Ð¼ÐµÑÑÐ¸ÑÑÑÑ Ð¿Ð¾ÑÐ¾Ð¼ Ð½Ð° ÑÑÐ¾ÐºÐ° Ð²Ð¾Ñ
			local yShift = 5
			if #text > 2 then yShift = yShift + #text - 2 end
			
			--Ð Ð¸ÑÑÐµÐ¼ Ð°Ð²ÐºÑ Ð¸ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¹Ð½Ð¸
			if item % 2 == 0 then buffer.square(mainZoneX, y, mainZoneWidth, yShift, 0xEEEEEE) end
			drawAvatar(x, y + 1, 6, 3, math.abs(news.response.items[item].source_id), avatarText)
			buffer.text(x + 7, y + 1, colors.topBar, name)
			--Ð Ð¸ÑÑÐµÐ¼ ÑÐµÐºÑÑ
			for line = 1, #text do
				buffer.text(x + 7, y + line + 1, 0x000000, text[line])
			end

			y = y + yShift
		end
	end

	buffer.resetDrawLimit()
end

local function getAndShowNews()
	status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº Ð½Ð¾Ð²Ð¾ÑÑÐµÐ¹")
	local success, news1 = newsRequest(countOfNewsToGet)
	if success and news1.response then
		news = news1
		currentNews = 1
		newsGUI()
	else
		GUI.error("ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð¿Ð¾Ð»ÑÑÐµÐ½Ð¸Ð¸ ÑÐ¿Ð¸ÑÐºÐ° Ð½Ð¾Ð²Ð¾ÑÑÐµÐ¹")
	end
end

local function drawLeftBar()
	--ÐÐ¾Ð´Ð»Ð¾Ð¶ÐºÐ° Ð¿Ð¾Ð´ ÑÐ»ÐµÐ¼ÐµÐ½ÑÑ
	buffer.square(1, 1, leftBarWidth, buffer.screen.height, colors.leftBar, 0xFFFFFF, " ")
	
	if personalInfo then
		drawPersonalAvatar(3, 2, 6, 3)
		buffer.text(11, 3, 0xFFFFFF, ecs.stringLimit("end", personalInfo.first_name .. " " .. personalInfo.last_name, leftBarWidth - 11))
	end

	--Ð­Ð»ÐµÐ¼ÐµÐ½ÑÑ
	obj.leftBar = {}
	local y, color = 6
	for i = 1, #leftBarElements do
		color = colors.leftBarAlternative
		if i % 2 == 0 then color = colors.leftBar end
		if i == currentLeftBarElement then color = colors.leftBarSelection end

		newObj("leftBar", i, 1, y, leftBarWidth, y + 2)

		buffer.square(1, y, leftBarWidth, 3, color, 0xFFFFFF, " ")
		y = y + 1
		buffer.text(3, y, colors.leftBarText, ecs.stringLimit("end", leftBarElements[i], leftBarWidth - 4))
		y = y + 2
	end
end

--ÐÐ»Ð°Ð²Ð½Ð¾Ðµ ÐÐ£Ð Ñ Ð»ÐµÐ²ÑÐ±Ð°ÑÐ¾Ð¼ Ð¸ Ð¿ÑÐ¾ÑÐ¸Ð¼
local function mainGUI()
	drawLeftBar()
	--ÐÑÐ¾Ð±ÑÐ°Ð¶Ð°ÐµÐ¼ Ð³ÑÑ Ð½ÑÐ¶Ð½ÑÑ Ð²ÑÐ±ÑÐ°Ð½Ð½ÑÑ
	if leftBarElements[currentLeftBarElement] == "Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ" then
		status("ÐÐ¾Ð»ÑÑÐ°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð²")
		messageToShowFrom = 1
		dialogToShowFrom = 1
		dialogsGUI()
	elseif leftBarElements[currentLeftBarElement] == "ÐÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸" then
		status("ÐÐ¾Ð»ÑÑÐ°Ñ ÑÐ¿Ð¸ÑÐ¾Ðº Ð°ÑÐ´Ð¾Ð·Ð°Ð¿Ð¸ÑÐµÐ¹")
		audioToShowFrom = 1
		audioGUI(personalInfo.id)
	elseif leftBarElements[currentLeftBarElement] == "ÐÐ¾Ñ ÑÑÑÐ°Ð½Ð¸ÑÐ°" then
		loadAndShowProfile(personalInfo.id)
		-- loadAndShowProfile(186860159)
	elseif leftBarElements[currentLeftBarElement] == "ÐÑÑÐ·ÑÑ" then
		friendsGUI()
	elseif leftBarElements[currentLeftBarElement] == "ÐÐ¾Ð²Ð¾ÑÑÐ¸" then
		getAndShowNews()
	end

	buffer.draw()
end

local function spam(id)
	while true do
		local randomMessages = {
			"Ð¢Ñ Ð¼Ð¾Ðµ Ð·Ð¾Ð»Ð¾ÑÑÐµ",
			"Ð¢Ñ Ð½Ð¸ÐºÐ¾Ð³Ð´Ð° Ð½Ðµ ÑÐ´ÐµÐ»Ð°ÐµÑÑ ÑÐ°Ð¹Ñ",
			"Ð¢Ñ Ð½Ð¸ÑÑÐ¾Ð¶ÐµÑÑÐ²Ð¾",
			"Ð¢Ð²Ð¾Ñ Ð¶Ð¸Ð·Ð½Ñ Ð½Ð¸ÑÐµÐ³Ð¾ Ð½Ðµ Ð·Ð½Ð°ÑÐ¸Ñ",
			"Ð¢Ñ Ð½Ð¸ÑÐµÐ³Ð¾ Ð½Ðµ Ð´Ð¾Ð±ÑÐµÑÑÑÑ",
			"Ð¢Ñ Ð·Ð°Ð²Ð°Ð»Ð¸ÑÑ ÑÐºÐ·Ð°Ð¼ÐµÐ½Ñ",
			"Ð¢Ñ Ð½Ð¸ÐºÐ¾Ð¼Ñ Ð½Ðµ Ð½ÑÐ¶Ð½Ð°",
			"Ð¢Ñ Ð½Ðµ Ð½Ð°Ð¿Ð¸ÑÐµÑÑ ÐºÑÑÑÐ¾Ð²ÑÑ",
			"Ð¢Ð²Ð¾Ðµ Ð¶Ð¸Ð²Ð¾ÑÐ½Ð¾Ðµ Ð¿Ð¾Ð¼ÑÐµÑ Ð·Ð°Ð²ÑÑÐ°",
			"ÐÐµ Ð´Ð¾Ð±Ð°Ð²Ð»ÑÐ¹ Ð² Ð§Ð¡!",
			"ÐÐµÑÐµÐ´Ð°ÐµÐ¼ Ð¿ÑÐ¸Ð²ÐµÑ Ð¾Ñ Ð¯ÑÐ¸ Ð¸ ÐÐµÐ½Ñ (Ð° ÐºÑÐ¾ Ñ?)",
			"Ð¥ÑÐ¹!",
			"ÐÐ¸Ð·Ð´Ð°!",
			"ÐÐ°Ð»ÑÐ¿Ð°!",
			"ÐÐµÐ½Ð¸Ñ!",
			"Ð¥ÐµÑ!",
			"ÐÐ°Ð²Ð°Ð»ÐºÐ°!"
		}
		local text = randomMessages[math.random(1, #randomMessages)] .. " (Ñ Ð»ÑÐ±Ð¾Ð²ÑÑ, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½Ð¾ Ñ OpenComputers)"
		sendMessageRequest(tostring(id), text)
		print("ÐÑÐ¿ÑÐ°Ð²Ð»ÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ: " .. text)
		os.sleep(2)
	end
end


---------------------------------------------------- Ð¡ÑÐ°ÑÑ ÑÐºÑÐ¸Ð¿ÑÐ° ----------------------------------------------------------------

--ÐÐ½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð¸ÑÑÐµÐ¼ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÑ Ð´Ð²Ð¾Ð¹Ð½Ð¾Ð³Ð¾ Ð±ÑÑÑÐµÑÐ°
--Ð­Ñ, ÑÑÐ¾ Ð±Ñ Ñ Ð´ÐµÐ»Ð°Ð», ÐµÑÐ»Ð¸ Ð± Ð½Ðµ Ð½Ð°ÐºÐ¾Ð´Ð¸Ð» ÐµÐµ? 0.2 ÑÐ¿Ñ Ð½Ð° GPU Ð¼ÐµÑÑÐ²ÐµÑÐ°!
buffer.start()
--Ð¥ÑÑÑÐ¸Ð¼ Ð½Ð°ÑÑÑÑÑÑÑÐ¾ÐµÑÐºÐ¸
loadSettings()
--ÐÐºÑÐ¸Ð²Ð¸ÑÑÐµÐ¼ ÑÐ¾ÑÐ¼Ñ Ð»Ð¾Ð³Ð¸Ð½Ð°
local loginData = loginGUI(settings.username or "E-Mail", settings.password or "password")
access_token = loginData.access_token
--ÐÐ¾Ð»ÑÑÐ°ÐµÐ¼ Ð¿ÐµÑÑÐ¾Ð½Ð°Ð»ÑÐ½ÑÐµ Ð´Ð°Ð½Ð½ÑÐµ
_, personalInfo = usersInformationRequest(loginData.user_id)
personalInfo = personalInfo.response[1]

-- --ÐÐ±ÐµÐ¼ÑÑ Ð² Ð¿Ð¾Ð¿ÑÐ°Ð½ÑÐºÐ¸Ð¹
-- spam(21321257)

--ÐÐºÑÐ¸Ð²Ð¸ÑÑÐµÐ¼ Ð³Ð»Ð°Ð²Ð½Ð¾Ðµ GUI
clearGUIZone()
mainGUI()

while true do
	local e = {event.pull()}
	if e[1] == "touch" then

		if whatIsOnScreen == "audio" then
			for key in pairs(obj.audio) do
				if obj.audio[key]:isClicked(e[3], e[4]) then
					obj.audio[key]:press(0.2)

					if component.isAvailable("openfm_radio") then
						component.openfm_radio.stop()
						component.openfm_radio.setURL(obj.audio[key][5].url)
						component.openfm_radio.start()
						status("ÐÑÐ²Ð¾Ð¶Ñ Ð² ÑÑÐ°ÑÑÑ Ð¸Ð³ÑÐ°ÐµÐ¼ÑÑ Ð¼ÑÐ·ÑÐºÑ")
						setCurrentAudioPlaying(currentProfile and currentProfile.ID or personalInfo.id, obj.audio[key][5].id)
					else
						GUI.error("Ð­ÑÐ° ÑÑÐ½ÐºÑÐ¸Ñ Ð´Ð¾ÑÑÑÐ¿Ð½Ð° ÑÐ¾Ð»ÑÐºÐ¾ Ð¿ÑÐ¸ Ð½Ð°Ð»Ð¸ÑÐ¸Ð¸ ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð¼Ð¾Ð´Ð° OpenFM, Ð´Ð¾Ð±Ð°Ð²Ð»ÑÑÑÐµÐ³Ð¾ Ð¿Ð¾Ð»Ð½Ð¾ÑÐµÐ½Ð½Ð¾Ðµ Ð¸Ð½ÑÐµÑÐ½ÐµÑ-ÑÐ°Ð´Ð¸Ð¾")
					end

					break
				end
			end
		end

		if whatIsOnScreen == "dialogs" then
			for key in pairs(obj.dialogList) do
				if obj.dialogList[key]:isClicked(e[3], e[4]) then
					drawDialog(obj.dialogList[key].y, 0xFF8888, obj.dialogList[key][5], obj.dialogList[key][6], obj.dialogList[key][7], obj.dialogList[key][8], obj.dialogList[key][9])
					buffer.draw()
					os.sleep(0.2)
					status("ÐÐ°Ð³ÑÑÐ¶Ð°Ñ Ð¿ÐµÑÐµÐ¿Ð¸ÑÐºÑ Ñ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»ÐµÐ¼ " .. obj.dialogList[key][7])
					currentMessagesPeerID = obj.dialogList[key][5]
					currentMessagesAvatarText = obj.dialogList[key][6]
					messagesGUI()
					break
				end
			end

			if obj.crazyTypingButton:isClicked(e[3], e[4]) then
				obj.crazyTypingButton:press(0.2)
				local data = ecs.universalWindow("auto", "auto", 36, 0x262626, true,
					{"EmptyLine"},
					{"CenterText", ecs.colors.orange, "CrazyTyping"},
					{"EmptyLine"},
					{"Slider", 0xFFFFFF, ecs.colors.orange, 1, 15, 5, "ÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¾Ð²: ", ""},
					{"Slider", 0xFFFFFF, ecs.colors.orange, 1, 100, 5, "ÐÐ¾Ð»Ð¸ÑÐµÑÑÐ²Ð¾ Ð·Ð°Ð¿ÑÐ¾ÑÐ¾Ð²: ", ""},
					{"Slider", 0xFFFFFF, ecs.colors.orange, 1, 5000, 500, "ÐÐ°Ð´ÐµÑÐ¶ÐºÐ° Ð¼ÐµÐ¶Ð´Ñ Ð·Ð°Ð¿ÑÐ¾ÑÐ°Ð¼Ð¸: ", " Ð¼Ñ"},
					{"EmptyLine"},
					{"Button", {ecs.colors.orange, 0xffffff, "OK"}, {0x999999, 0xffffff, "ÐÑÐ¼ÐµÐ½Ð°"}}
				)
				if data[4] == "OK" then
					for i = 1, data[2] do
						local count = 1
						for key in pairs(obj.dialogList) do
							-- GUI.error("ÐÐ±Ð°ÑÑ ÑÐ¿Ð°Ð¼ Ð´Ð¸Ð°Ð»Ð¾Ð³Ñ Ð¿Ð¾Ð´ Ð¿Ð¸ÑÐ¾Ð¼: " .. obj.dialogList[key][5])
							ecs.info("auto", "auto", "CrazyTyping", "ÐÐ°Ð¿ÑÐ¾Ñ: " .. i ..  " Ð¸Ð· " .. data[2] ..  ", Ð´Ð¸Ð°Ð»Ð¾Ð³: " .. count .. " Ð¸Ð· ".. data[1] .. ", peerID: " .. obj.dialogList[key][5])
							setCrazyTypingRequest(obj.dialogList[key][5])
							count = count + 1
							if count > data[1] then break end
							os.sleep(data[3] / 1000)
						end
					end
					buffer.draw(true)
				end
			end
		end

		if whatIsOnScreen == "messages" then
			if obj.messageInputBar:isClicked(e[3], e[4]) then
				drawMessageInputBar(" ")
				buffer.draw()
				local newText = ecs.inputText(obj.messageInputBar.x + 4, obj.messageInputBar.y + 2, obj.messageInputBar.width - 4, "", colors.messageInputBarTextBackgroundColor, colors.messsageInputBarTextColor)
				if newText and newText ~= " " and newText ~= "" then
					computer.beep(1700)
					status("ÐÑÐ¿ÑÐ°Ð²Ð»ÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°ÑÐµÐ»Ñ")
					sendMessageRequest(currentMessagesPeerID, newText .. (settings.addSendingInfo and messageEndAdderText or ""))
					status("ÐÐ±Ð½Ð¾Ð²Ð»ÑÑ Ð¸ÑÑÐ¾ÑÐ¸Ñ Ð¿ÐµÑÐµÐ¿Ð¸ÑÐºÐ¸")
					messageToShowFrom = 1
					messagesGUI()
				end
				drawMessageInputBar(" ")
			end
		end

		if whatIsOnScreen == "userProfile" then
			if currentProfile.audiosButton:isClicked(e[3], e[4]) then
				currentProfile.audiosButton:press(0.2)
				audioToShowFrom = 1
				audioGUI(currentProfile.ID)
				buffer.draw()
			elseif currentProfile.sendMessageButton:isClicked(e[3], e[4]) then
				currentProfile.sendMessageButton:press(0.2)
				currentMessagesPeerID = currentProfile.ID
				messageToShowFrom = 1
				currentMessagesAvatarText = currentProfile.avatarText
				messagesGUI()
			end
		end

		if whatIsOnScreen == "friends" then
			for ID in pairs(currentFriends.sendMessageButtons) do
				if clickedAtZone(e[3], e[4], currentFriends.sendMessageButtons[ID]) then
					buffer.text(currentFriends.sendMessageButtons[ID][1], currentFriends.sendMessageButtons[ID][2], 0x000000, "ÐÐ°Ð¿Ð¸ÑÐ°ÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ")
					buffer.draw()
					currentMessagesPeerID = ID
					messageToShowFrom = 1
					currentMessagesAvatarText = currentFriends.sendMessageButtons[ID][5]
					messagesGUI()
					break
				end
			end

			for ID in pairs(currentFriends.openProfileButtons) do
				if clickedAtZone(e[3], e[4], currentFriends.openProfileButtons[ID]) then
					buffer.text(currentFriends.openProfileButtons[ID][1], currentFriends.openProfileButtons[ID][2], 0x000000, "ÐÑÐºÑÑÑÑ Ð¿ÑÐ¾ÑÐ¸Ð»Ñ")
					buffer.draw()
					loadAndShowProfile(ID)
					buffer.draw()
					break
				end
			end
		end

		for key in pairs(obj.leftBar) do
			if clickedAtZone(e[3], e[4], obj.leftBar[key]) then
				-- GUI.error("ÐÐ»Ð¸ÐºÐ½ÑÐ»Ð¸ Ð½Ð° Ð»ÐµÑÑ Ð±Ð°Ñ ÑÑÐ»ÐµÐ¼ÐµÐ½Ñ")
				local oldLeftBarElement = currentLeftBarElement
				currentLeftBarElement = key

				drawLeftBar()
				buffer.draw()

				if leftBarElements[currentLeftBarElement] == "ÐÑÑÐ¾Ð´" then
					os.sleep(0.3)
					buffer.clear(0x262626)
					ecs.prepareToExit()
					return
				elseif leftBarElements[currentLeftBarElement] == "ÐÑÐ´Ð¸Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸" then
					currentProfile = currentProfile or {}
					currentProfile.ID = personalInfo.id
				elseif leftBarElements[currentLeftBarElement] == "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸" then
					local data = ecs.universalWindow("auto", "auto", 36, 0x262626, true,
						{"EmptyLine"},
						{"CenterText", ecs.colors.orange, "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸"},
						{"EmptyLine"},
						{"Switch", ecs.colors.orange, 0xffffff, 0xFFFFFF, "Ð¡Ð¾ÑÑÐ°Ð½ÑÑÑ Ð´Ð°Ð½Ð½ÑÐµ Ð°Ð²ÑÐ¾ÑÐ¸Ð·Ð°ÑÐ¸Ð¸", settings.saveAuthData},
						{"EmptyLine"},
						{"Switch", ecs.colors.orange, 0xffffff, 0xFFFFFF, "ÐÐ¾Ð±Ð°Ð²Ð»ÑÑÑ Ð¿ÑÐ¸Ð¿Ð¸ÑÐºÑ \"ÐÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½Ð¾ Ñ ...\"", settings.addSendingInfo},
						{"EmptyLine"},
						{"CenterText", ecs.colors.orange, "OpenComputers VK Client v4.0"},
						{"EmptyLine"},
						{"CenterText", ecs.colors.white, "ÐÐ²ÑÐ¾Ñ: ÐÐ³Ð¾ÑÑ Ð¢Ð¸Ð¼Ð¾ÑÐµÐµÐ², vk.com/id7799889"},
						{"CenterText", ecs.colors.white, "ÐÑÐµ Ð¿ÑÐ°Ð²Ð° Ð·Ð°ÑÐ¸ÑÐµÐ½Ñ, ÐµÐ¿ÑÐ°! ÐÐ¾Ð¿ÑÐ¾Ð±ÑÐ¹ ÑÐ¾Ð»ÑÐºÐ¾ ÑÐ¿Ð¸Ð·Ð´Ð¸ÑÑ!"},
						{"EmptyLine"},
						{"Button", {ecs.colors.orange, 0xffffff, "OK"}, {0x999999, 0xffffff, "ÐÑÐ¼ÐµÐ½Ð°"}}
					)
					if data[3] == "OK" then
						settings.saveAuthData = data[1]
						settings.addSendingInfo = data[2]

						if settings.saveAuthData then
							settings.username = loginData.username
							settings.password = loginData.password
						else
							settings.username = nil
							settings.password = nil
						end
						saveSettings()

						currentLeftBarElement = oldLeftBarElement
					end
				end

				mainGUI()
				break
			end
		end
	elseif e[1] == "scroll" then
		if e[5] == 1 then
			if whatIsOnScreen == "dialogs" then
				dialogToShowFrom = dialogToShowFrom - dialogScrollSpeed
				if dialogToShowFrom < 1 then dialogToShowFrom = 1 end
				status("ÐÑÐ¾ÐºÑÑÑÐ¸Ð²Ð°Ñ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¸, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑ")
				dialogsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "messages" then
				messageToShowFrom = messageToShowFrom + messagesScrollSpeed
				status("ÐÑÐ¾ÐºÑÑÑÐ¸Ð²Ð°Ñ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑ")
				messagesGUI()
				buffer.draw()
			elseif whatIsOnScreen == "audio" then
				audioToShowFrom = audioToShowFrom - audioScrollSpeed
				if audioToShowFrom < 1 then audioToShowFrom = 1 end
				status("ÐÑÐ¾ÐºÑÑÑÐ¸Ð²Ð°Ñ Ð°ÑÐ´Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑ")
				audioGUI(currentProfile and currentProfile.ID or personalInfo.id)
				buffer.draw()
			elseif whatIsOnScreen == "userProfile" then
				currentProfileY = currentProfileY + profileScrollSpeed
				if currentProfileY > mainZoneY + 2 then currentProfileY = mainZoneY + 2 end
				userProfileGUI()
				buffer.draw()
			elseif whatIsOnScreen == "friends" then
				currentFriendsOffset = currentFriendsOffset - friendsScrollSpeed
				if currentFriendsOffset < 0 then currentFriendsOffset = 0 end
				friendsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "news" then
				currentNews = currentNews - 1
				if currentNews < 1 then currentNews = 1 end
				newsGUI()
				buffer.draw()
			end
		else
			if whatIsOnScreen == "dialogs" then
				dialogToShowFrom = dialogToShowFrom + dialogScrollSpeed
				status("ÐÑÐ¾ÐºÑÑÑÐ¸Ð²Ð°Ñ Ð´Ð¸Ð°Ð»Ð¾Ð³Ð¸, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑ")
				dialogsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "messages" then
				messageToShowFrom = messageToShowFrom - messagesScrollSpeed
				if messageToShowFrom < 1 then messageToShowFrom = 1 end
				status("ÐÑÐ¾ÐºÑÑÑÐ¸Ð²Ð°Ñ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑ")
				messagesGUI()
				buffer.draw()
			elseif whatIsOnScreen == "audio" then
				audioToShowFrom = audioToShowFrom + audioScrollSpeed
				status("ÐÑÐ¾ÐºÑÑÑÐ¸Ð²Ð°Ñ Ð°ÑÐ´Ð¾Ð·Ð°Ð¿Ð¸ÑÐ¸, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÑÑ Ð·Ð°Ð¿ÑÐ¾Ñ Ð½Ð° ÑÐµÑÐ²ÐµÑ")
				audioGUI(currentProfile and currentProfile.ID or personalInfo.id)
				buffer.draw()
			elseif whatIsOnScreen == "userProfile" then
				currentProfileY = currentProfileY - profileScrollSpeed
				userProfileGUI()
				buffer.draw()
			elseif whatIsOnScreen == "friends" then
				currentFriendsOffset = currentFriendsOffset + friendsScrollSpeed
				friendsGUI()
				buffer.draw()
			elseif whatIsOnScreen == "news" then
				currentNews = currentNews + 1
				newsGUI()
				buffer.draw()
			end
		end
	end
end

-- local success, dialogs = getDialogsRequest(0, 5)
-- saveToFile(serialization.serialize(dialogs))


-- sendMessageRequest(dialogs.response.items[2], "ÑÐµÑÑÐ¾Ð²Ð¾Ðµ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ, Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½Ð¾ ÑÐµÑÐµÐ· OpenComputers VK Client by ÐÐ³Ð¾ÑÑ, ÐµÐ¿ÑÐ°")





DMineOS/Desktop/FMineOS/Desktop/VK.lnk$return "/MineOS/Applications/VK.app"DMineOS/Pictures/DMineOS/System/DMineOS/System/OS/F!MineOS/System/OS/Applications.txt¼{
  GitHubUserURL="https://raw.githubusercontent.com/",
  GitHubApplicationListURL="https://raw.githubusercontent.com/IgorTimofeev/OpenComputers/master/Applications.txt",
  ----------------------------------------------------- ÐÑÐµ Ð´Ð»Ñ ÐÐ¡ --------------------------------------------------------------------------
  {
    name="OS.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/OS.lua",
    about="IgorTimofeev/OpenComputers/master/MineOS/About/",
    type="Script",
    forceDownload=true,
    version=3.48,
  },
  {
    name="MineOS/Pictures/Raspberry.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Raspberry.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Nettle.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Nettle.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Catniss.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Catniss.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Nocturnal.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Nocturnal.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Ciri.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Ciri.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/AhsokaTanoHiRes.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/AhsokaTanoHiRes.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/Girl.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/Girl.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/TemplarAssassin.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/TemplarAssassin.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/Pictures/ChristmasTree.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Wallpapers/ChristmasTree.pic",
    type="Wallpaper",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Languages/Russian.lang",
    url="IgorTimofeev/OpenComputers/master/MineOS/Languages/Russian.lang",
    type="Script",
    forceDownload=true,
    version=1.18,
  },
  {
    name="MineOS/System/OS/Languages/English.lang",
    url="IgorTimofeev/OpenComputers/master/MineOS/Languages/English.lang",
    type="Script",
    forceDownload=true,
    version=1.18,
  },

  ----------------------------------------------------- Ð¡Ð¸ÑÑÐµÐ¼Ð½ÑÐµ Ð¸ÐºÐ¾Ð½ÐºÐ¸ --------------------------------------------------------------------------
  {
    name="MineOS/System/OS/Icons/Application.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Application.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Languages.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Languages.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/OK.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/OK.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Downloading.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Downloading.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/OS_Logo.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/OS_Logo.pic",
    type="Icon",
    preLoadFile=true,
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/3DModel.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/3DModel.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Computer.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Computer.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Robot.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Robot.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Tablet.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Tablet.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Pastebin.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Pastebin.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Love.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Love.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/HDD.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/HDD.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Floppy.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Floppy.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Steve.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Steve.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Folder.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Folder.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Finger.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Finger.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/FileNotExists.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/FileNotExists.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Script.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Script.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Text.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Text.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Update.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Update.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Security.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Security.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Config.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Config.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Image.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Image.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Lua.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Lua.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/SampleIcon.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/SampleIcon.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Archive.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Archive.pic",
    type="Icon",
    version=1.0,
  },
  {
    name="MineOS/System/OS/Icons/Trash.pic",
    url="IgorTimofeev/OpenComputers/master/MineOS/Icons/Trash.pic",
    type="Icon",
    version=1.01,
  },

  ----------------------------------------------------- ÐÐ¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸ --------------------------------------------------------------------------

  {
    name="lib/MineOSCore.lua",
    url="IgorTimofeev/OpenComputers/master/lib/MineOSCore.lua",
    type="Library",
    version=1.48,
  },
  {
    name="lib/advancedLua.lua",
    url="IgorTimofeev/OpenComputers/master/lib/advancedLua.lua",
    type="Library",
    preLoadFile=true,
    version=1.07,
  },
  {
    name="MineOS/System/OS/EFI.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/EFI.lua",
    type="Library",
    forceDownload=true,
    version=1.0,
  },
  {
    name="lib/ECSAPI.lua",
    url="IgorTimofeev/OpenComputers/master/lib/ECSAPI.lua",
    type="Library",
    preLoadFile=true,
    version=1.13,
  },
  {
    name="lib/colorlib.lua",
    url="IgorTimofeev/OpenComputers/master/lib/colorlib.lua",
    type="Library",
    preLoadFile=true,
    version=1.03,
  },
  {
    name="lib/image.lua",
    url="IgorTimofeev/OpenComputers/master/lib/image.lua",
    type="Library",
    preLoadFile=true,
    version=1.23,
  },
  {
    name="lib/serialization.lua",
    url="IgorTimofeev/OpenComputers/master/lib/serialization.lua",
    type="Library",
    version=1.05,
  },
  {
    name="lib/GUI.lua",
    url="IgorTimofeev/OpenComputers/master/lib/GUI.lua",
    type="Library",
    version=1.41,
  },
  {
    name="lib/windows.lua",
    url="IgorTimofeev/OpenComputers/master/lib/windows.lua",
    type="Library",
    version=1.17,
  },
  {
    name="lib/rayEngine.lua",
    url="IgorTimofeev/OpenComputers/master/lib/rayEngine.lua",
    type="Library",
    version=1.38,
  },
  {
    name="lib/json.lua",
    url="IgorTimofeev/OpenComputers/master/lib/json.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/modemConnection.lua",
    url="IgorTimofeev/OpenComputers/master/lib/modemConnection.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/bigLetters.lua",
    url="IgorTimofeev/OpenComputers/master/lib/bigLetters.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/libPNGImage.lua",
    url="IgorTimofeev/OpenComputers/master/lib/libPNGImage.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/crc32lua.lua",
    url="IgorTimofeev/OpenComputers/master/lib/crc32lua.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/deflatelua.lua",
    url="IgorTimofeev/OpenComputers/master/lib/deflatelua.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/context.lua",
    url="IgorTimofeev/OpenComputers/master/lib/context.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/syntax.lua",
    url="IgorTimofeev/OpenComputers/master/lib/syntax.lua",
    type="Library",
    version=1.12,
  },
  {
    name="lib/palette.lua",
    url="IgorTimofeev/OpenComputers/master/lib/palette.lua",
    type="Library",
    version=1.09,
  },
  {
    name="lib/doubleBuffering.lua",
    url="IgorTimofeev/OpenComputers/master/lib/doubleBuffering.lua",
    type="Library",
    version=1.19,
  },
  {
    name="lib/compressor.lua",
    url="IgorTimofeev/OpenComputers/master/lib/compressor.lua",
    type="Library",
    version=1.06,
  },
  {
    name="lib/xmlParser.lua",
    url="IgorTimofeev/OpenComputers/master/lib/xmlParser.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/SHA2.lua",
    url="IgorTimofeev/OpenComputers/master/lib/SHA2.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/vector.lua",
    url="IgorTimofeev/OpenComputers/master/lib/vector.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/matrix.lua",
    url="IgorTimofeev/OpenComputers/master/lib/matrix.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/OpenComputersGL/Main.lua",
    url="IgorTimofeev/OpenComputers/master/lib/OpenComputersGL/Main.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/OpenComputersGL/Materials.lua",
    url="IgorTimofeev/OpenComputers/master/lib/OpenComputersGL/Materials.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/OpenComputersGL/Renderer.lua",
    url="IgorTimofeev/OpenComputers/master/lib/OpenComputersGL/Renderer.lua",
    type="Library",
    version=1.0,
  },
  {
    name="lib/PolyCatEngine/Main.lua",
    url="IgorTimofeev/OpenComputers/master/lib/PolyCatEngine/Main.lua",
    type="Library",
    version=1.01,
  },
  {
    name="lib/PolyCatEngine/PostProcessing.lua",
    url="IgorTimofeev/OpenComputers/master/lib/PolyCatEngine/PostProcessing.lua",
    type="Library",
    version=1.01,
  },

  ----------------------------------------------------- Ð¡ÐºÑÐ¸Ð¿ÑÑ Ð¸ Ð´Ð¾Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ñ Ðº Ð½Ð¸Ð¼ --------------------------------------------------------------------------

  {
    name="init.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Init.lua",
    type="Script",
    forceDownload=true,
    version=1.13,
  },
  {
    name="etc/profile",
    url="IgorTimofeev/OpenComputers/master/etc/profile",
    type="Script",
    forceDownload=true,
    version=1.0,
  },
  {
    name="bin/clear.lua",
    url="IgorTimofeev/OpenComputers/master/Applications/clear.lua",
    type="Script",
    forceDownload=true,
    version=1.0,
  },
  {
    name="bin/scale.lua",
    url="IgorTimofeev/OpenComputers/master/Applications/scale.lua",
    type="Script",
    forceDownload=true,
    version=1.01,
  },
  {
    name="usr/misc/greetings/English.txt",
    url="IgorTimofeev/OpenComputers/master/Applications/Motd/English.txt",
    type="Script",
    forceDownload=true,
    version=1.03,
  },
  {
    name="usr/misc/greetings/Russian.txt",
    url="IgorTimofeev/OpenComputers/master/Applications/Motd/Russian.txt",
    type="Script",
    forceDownload=true,
    version=1.03,
  },
  {
    name="etc/motd",
    url="IgorTimofeev/OpenComputers/master/Applications/Motd/motd.lua",
    type="Script",
    forceDownload=true,
    version=1.02,
  },
  ----------------------------------------------------- Screensavers --------------------------------------------------------------------------
  {
    name="MineOS/System/OS/Screensavers/Matrix.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Screensavers/Matrix.lua",
    type="Script",
    forceDownload=true,
    version=1.00,
  },
  {
    name="MineOS/System/OS/Screensavers/Mandala.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Screensavers/Mandala.lua",
    type="Script",
    forceDownload=true,
    version=1.00,
  },
  {
    name="MineOS/System/OS/Screensavers/Clock.lua",
    url="IgorTimofeev/OpenComputers/master/MineOS/Screensavers/Clock.lua",
    type="Script",
    forceDownload=true,
    version=1.00,
  },
  ----------------------------------------------------- ÐÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ñ --------------------------------------------------------------------------
  {
    name="MineOS/Applications/MineCode IDE",
    url="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/MineCodeIDE.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/Icon.pic",
    createShortcut="dock",
    forceDownload=true,
    version=1.54,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/Localization/Russian.lang"
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/MineCodeIDE/Localization/English.lang"
      },
    }
  },
  {
    name="MineOS/Applications/OCGLTest",
    url="IgorTimofeev/OpenComputers/master/Applications/OCGLTest/OCGLTest.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/OCGLTest/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/GeoScan2",
    url="IgorTimofeev/OpenComputers/master/Applications/GeoScan2/GeoScan2.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/GeoScan2/Icon.pic",
    createShortcut="desktop",
    version=1.02,
    resources={
      {
        name="Earth.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/GeoScan2/Earth.pic",
      }
    },
  },
  {
    name="MineOS/Applications/SmartHouse",
    url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/SmartHouse.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Icon.pic",
    createShortcut="desktop",
    version=1.29,
    resources={
      {
        name="Modules/command_block/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/command_block/Icon.pic",
      },
      {
        name="Modules/command_block/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/command_block/Main.lua",
      },
      --
      {
        name="Modules/redstone/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/redstone/Icon.pic",
      },
      {
        name="Modules/redstone/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/redstone/Main.lua",
      },
      --
      {
        name="Modules/mfsu/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/mfsu/Icon.pic",
      },
      {
        name="Modules/mfsu/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/mfsu/Main.lua",
      },
      --
      {
        name="Modules/screen/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/screen/Icon.pic",
      },
      {
        name="Modules/screen/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/screen/Main.lua",
      },
      --
      {
        name="Modules/homePC/Server.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/homePC/Server.pic",
      },
      {
        name="Modules/homePC/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/homePC/Icon.pic",
      },
      {
        name="Modules/homePC/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/homePC/Main.lua",
      },
      --
      {
        name="Modules/motion_sensor/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/motion_sensor/Icon.pic",
      },
      {
        name="Modules/motion_sensor/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/motion_sensor/Main.lua",
      },
      --
      {
        name="Modules/reactor/Icon.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/reactor/Icon.pic",
      },
      {
        name="Modules/reactor/Main.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/SmartHouse/Modules/reactor/Main.lua",
      },
    },
  },
  {
    name="MineOS/Applications/VK",
    url="IgorTimofeev/OpenComputers/master/Applications/VK/VK.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/VK/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/VK/Icon.pic",
    createShortcut="desktop",
    forceDownload=true,
    version=1.25,
    resources={
      {
        name="VKLogo.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/VK/VKLogo.pic",
      },
    },
  },
  {
    name="MineOS/Applications/Control2",
    url="IgorTimofeev/OpenComputers/master/Applications/Control2/Control2.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Control2/Icon.pic",
    createShortcut="desktop",
    version=1.05,
    resources={
      {
        name="LuaLogo.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Control2/LuaLogo.pic",
      },
      {
        name="Modules/00_LuaConsole.lua",
        url="IgorTimofeev/OpenComputers/master/Applications/Control2/Modules/00_LuaConsole.lua",
      },
    },
  },
  {
    name="MineOS/Applications/Weather",
    url="IgorTimofeev/OpenComputers/master/Applications/Weather/Weather.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Weather/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Weather/Icon.pic",
    createShortcut="desktop",
    version=1.12,
    resources={
      {
        name="Cloudy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Cloudy.pic",
      },
      {
        name="Cloudy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Cloudy.pic",
      },
      {
        name="Rainy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Rainy.pic",
      },
      {
        name="Snowy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Snowy.pic",
      },
      {
        name="Stormy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Stormy.pic",
      },
      {
        name="Sunny.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/Sunny.pic",
      },
      {
        name="SunnyWithClouds.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Weather/SunnyWithClouds.pic",
      },
    },
  },
  {
    name="MineOS/Applications/3DPrint",
    url="IgorTimofeev/OpenComputers/master/Applications/3DPrint/3DPrint.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/3DPrint/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/3DPrint/Icon.pic",
    createShortcut="desktop",
    version=1.11,
  },
  {
    name="MineOS/Applications/FlappyBird",
    url="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/FlappyBird.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/Icon.pic",
    createShortcut="desktop",
    version=1.11,
    resources={
      {
        name="Flappy.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/FlappyBird/Flappy.pic",
      },
    },
  },
  {
    name="MineOS/Applications/RayWalk",
    url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/RayWalk.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/RayWalk/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Icon.pic",
    createShortcut="desktop",
    version=1.60,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Localization/Russian.lang"
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Localization/English.lang"
      },
------------
      {
        name="RayEngine.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/RayEngine.cfg",
      },
------------
      {
        name="Weapons/Weapons.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/Weapons.cfg",
      },
------------
      {
        name="Weapons/CrosshairTextures/Angled.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Angled.pic",
      },
      {
        name="Weapons/CrosshairTextures/Default.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Default.pic",
      },
      {
        name="Weapons/CrosshairTextures/Half.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Half.pic",
      },
      {
        name="Weapons/CrosshairTextures/Dotted.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/CrosshairTextures/Dotted.pic",
      },
------------
      {
        name="Weapons/FireTextures/PowderFire.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/FireTextures/PowderFire.pic",
      },
      {
        name="Weapons/FireTextures/Plasma.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/FireTextures/Plasma.pic",
      },
------------
      {
        name="Weapons/WeaponTextures/Pistol.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Pistol.pic",
      },
      {
        name="Weapons/WeaponTextures/Sniper.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Sniper.pic",
      },
      {
        name="Weapons/WeaponTextures/Rifle.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Rifle.pic",
      },
      {
        name="Weapons/WeaponTextures/Plasmer.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Weapons/WeaponTextures/Plasmer.pic",
      },
------------
      {
        name="Worlds/ExampleWorld/Map.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/Map.cfg",
      },
      {
        name="Worlds/ExampleWorld/Player.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/Player.cfg",
      },
      {
        name="Worlds/ExampleWorld/World.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/World.cfg",
      },
      {
        name="Worlds/ExampleWorld/Blocks.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/ExampleWorld/Blocks.cfg",
      },
------------
      {
        name="Worlds/SundownBeams/Map.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/Map.cfg",
      },
      {
        name="Worlds/SundownBeams/Player.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/Player.cfg",
      },
      {
        name="Worlds/SundownBeams/World.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/World.cfg",
      },
      {
        name="Worlds/SundownBeams/Blocks.cfg",
        url="IgorTimofeev/OpenComputers/master/Applications/RayWalk/Worlds/SundownBeams/Blocks.cfg",
      },
    },
  },
  {
    name="MineOS/Applications/GuessWord",
    url="IgorTimofeev/OpenComputers/master/Applications/GuessWord/GuessWord.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/GuessWord/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/GuessWord/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Calendar",
    url="IgorTimofeev/OpenComputers/master/Applications/Calendar/Calendar.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Calendar/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Calendar/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/PrintImage",
    url="IgorTimofeev/OpenComputers/master/Applications/PrintImage/PrintImage.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/PrintImage/Icon.pic",
    createShortcut="desktop",
    version=1.05,
  },
  {
    name="MineOS/Applications/Palette",
    url="IgorTimofeev/OpenComputers/master/Applications/Palette/Palette.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Palette/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/Stargate",
    url="IgorTimofeev/OpenComputers/master/Applications/Stargate/Stargate.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Stargate/Icon.pic",
    createShortcut="desktop",
    version=1.04,
    resources={
      {
        name="Gate.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Stargate/Gate.pic",
      },
      {
        name="GateCore.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Stargate/GateCore.pic",
      },
    },
  },
  {
    name="MineOS/Applications/RunningString",
    url="IgorTimofeev/OpenComputers/master/Applications/RunningString/RunningString.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/RunningString/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/RunningString/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Graph",
    url="IgorTimofeev/OpenComputers/master/Applications/Graph/Graph.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Graph/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/Battleship",
    url="IgorTimofeev/OpenComputers/master/Applications/Battleship/Battleship.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Battleship/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Battleship/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Radio",
    url="IgorTimofeev/OpenComputers/master/Applications/Radio/Radio.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Radio/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Radio/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/FuckTheRain",
    url="IgorTimofeev/OpenComputers/master/Applications/FuckTheRain/FuckTheRain.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/FuckTheRain/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/FuckTheRain/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/ForceAdmin",
    url="IgorTimofeev/OpenComputers/master/Applications/ForceAdmin/ForceAdmin.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/ForceAdmin/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/ForceAdmin/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/MineSweeper",
    url="IgorTimofeev/OpenComputers/master/Applications/MineSweeper/MineSweeper.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/MineSweeper/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/MineSweeper/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/DanceFloor",
    url="IgorTimofeev/OpenComputers/master/Applications/DanceFloor/DanceFloor.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/DanceFloor/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/DanceFloor/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/QuantumCube",
    url="IgorTimofeev/OpenComputers/master/Applications/QuantumCube/QuantumCube.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/QuantumCube/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/QuantumCube/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Photoshop",
    url="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Photoshop.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Photoshop/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Icon.pic",
    createShortcut="dock",
    forceDownload=true,
    version=1.03,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Localization/Russian.lang"
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/Photoshop/Localization/English.lang"
      },
    }
  },
  {
    name="MineOS/Applications/Shooting",
    url="IgorTimofeev/OpenComputers/master/Applications/Shooting/Shooting.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Shooting/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/HoloClock",
    url="IgorTimofeev/OpenComputers/master/Applications/HoloClock/HoloClock.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/HoloClock/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  -- {
  --   name="MineOS/Applications/Finder",
  --   url="IgorTimofeev/OpenComputers/master/Applications/Finder/Finder.lua",
  --   about="IgorTimofeev/OpenComputers/master/Applications/Finder/About/",
  --   type="Application",
  --   icon="IgorTimofeev/OpenComputers/master/Applications/Finder/Icon.pic",
  --   createShortcut="dock",
  --   forceDownload=true,
  --   version=1.12,
  -- },
  {
    name="MineOS/Applications/AppMarket",
    url="IgorTimofeev/OpenComputers/master/Applications/AppMarket/AppMarket.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/AppMarket/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/AppMarket/Icon.pic",
    createShortcut="dock",
    forceDownload=true,
    version=1.54,
     resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/AppMarket/Localization/Russian.lang",
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/AppMarket/Localization/English.lang",
      },
    },
  },
  {
    name="MineOS/Applications/Control",
    url="IgorTimofeev/OpenComputers/master/Applications/Control/Control.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Control/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Control/Icon.pic",
    createShortcut="desktop",
    version=1.01,
  },
  {
    name="MineOS/Applications/Piano",
    url="IgorTimofeev/OpenComputers/master/Applications/Piano/Piano.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Piano/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/CodeDoor",
    url="IgorTimofeev/OpenComputers/master/Applications/CodeDoor/CodeDoor.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/CodeDoor/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/CodeDoor/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Keyboard",
    url="IgorTimofeev/OpenComputers/master/Applications/Keyboard/Keyboard.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Keyboard/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Keyboard/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Nano",
    url="IgorTimofeev/OpenComputers/master/Applications/Nano/Nano.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Nano/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Nano/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Camera",
    url="IgorTimofeev/OpenComputers/master/Applications/Camera/Camera.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Camera/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Camera/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/Autorun",
    url="IgorTimofeev/OpenComputers/master/Applications/Autorun/Autorun.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Autorun/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Autorun/Icon.pic",
    createShortcut="desktop",
    version=1.0,
  },
  {
    name="MineOS/Applications/HEX",
    url="IgorTimofeev/OpenComputers/master/Applications/HEX/HEX.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/HEX/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/HEX/Icon.pic",
    createShortcut="desktop",
    version=1.02,
  },
  {
    name="MineOS/Applications/ChristmasTree",
    url="IgorTimofeev/OpenComputers/master/Applications/ChristmasTree/ChristmasTree.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/ChristmasTree/About/",
    type="Application",
    createShortcut="desktop",
    icon="IgorTimofeev/OpenComputers/master/Applications/ChristmasTree/Icon.pic",
    version=1.0,
  },
  -- ÐÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ InfoPanel
  {
    name="MineOS/Applications/InfoPanel",
    url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/InfoPanel.lua",
    type="Application",
    about="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/About/",
    icon="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Icon.pic",
    createShortcut="desktop",
    version=1.01,
    resources = {
      {
        name="Pages/Rules.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Rules.txt",
      },
      {
        name="Pages/Main.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Main.txt",
      },
      {
        name="Pages/SSPI.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/SSPI.txt",
      },
      {
        name="Pages/Claims.txt",
        url="IgorTimofeev/OpenComputers/master/Applications/InfoPanel/Claims.txt",
      },
    }
  },
  --ÐÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ Ð§Ð°Ñ
  {
    name="MineOS/Applications/Chat",
    url="IgorTimofeev/OpenComputers/master/Applications/Chat/Chat.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/Chat/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/Chat/Icon.pic",
    createShortcut="desktop",
    version=1.01,
    resources = {
      {
        name="Avatars/MyAvatar.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/Chat/MyAvatar.pic",
      }
    },
  },
  {
    name="MineOS/Applications/TurretControl",
    url="IgorTimofeev/OpenComputers/master/Applications/TurretControl/TurretControl.lua",
    type="Application",
    about="IgorTimofeev/OpenComputers/master/Applications/TurretControl/About/",
    icon="IgorTimofeev/OpenComputers/master/Applications/TurretControl/Icon.pic",
    createShortcut="desktop",
    version=1.01,
    resources={
      {
        name="Turret.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/TurretControl/Turret.pic",
      },
    },
  },
  {
    name="MineOS/Applications/HoloEdit",
    url="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/HoloEdit.lua",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/Icon.pic",
    createShortcut="desktop",
    version=1.02,
    resources={
      {
        name="Localization/Russian.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/Localization/Russian.lang",
      },
      {
        name="Localization/English.lang",
        url="IgorTimofeev/OpenComputers/master/Applications/HoloEdit/Localization/English.lang",
      },
    },
  },
  {
    name="MineOS/Applications/BufferDemo",
    url="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/BufferDemo.lua",
    about="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/About/",
    type="Application",
    icon="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/Icon.pic",
    createShortcut="desktop",
    version=1.0,
    resources={
      {
        name="Wallpaper.pic",
        url="IgorTimofeev/OpenComputers/master/Applications/BufferDemo/Wallpaper.pic",
      },
    },
  },
}
FMineOS/System/OS/EFI.lualocal ee,gpu,sc,bg,fg,re,sce
local pr,cm,ls,ps=component.proxy,computer,component.list,computer.pullSignal

local function init()
	local g=ls("gpu")()
	local s=ls("screen")()
	local e=ls("eeprom")()

	if g and s and e then
		gpu,sc,ee=pr(g),pr(s),pr(e)
		computer.getBootAddress=function() return ee.getData() end
		computer.setBootAddress=function(address) return ee.setData(address) end
		gpu.bind(sc.address)
		re={};re.width,re.height=gpu.maxResolution()
		gpu.setResolution(re.width,re.height)
		sce=math.floor(re.height/2)
	else
		error("")
	end
end

local function pu(t) while true do local e={ps()};if e[1]==t then return e end end end

local function sleep(timeout)
	local deadline=cm.uptime() + (timeout or 0)
	while cm.uptime()<deadline do ps(deadline - cm.uptime()) end
end

local function bGP()
	gpu.bind(sc.address)
	re={}
	re.width,re.height=gpu.maxResolution()
	gpu.setResolution(re.width,re.height)
end

local colors={b=0xDDDDDD,t1=0x444444,t2=0x999999,t3=0x888888}

local function sB(color) if color~=bg then bg=color;gpu.setBackground(color) end end
local function sF(color) if color~=fg then fg=color;gpu.setForeground(color) end end
local function clear() gpu.fill(1,1,re.width,re.height," ") end
local function cT(y,color,text) sF(color);gpu.set(math.floor(re.width/2-#text/2),y,text) end
local function l() sB(colors.b);clear();cT(sce-1,colors.t1,"MineOS EFI") end

local function fade(fromColor,toColor,step)
	for color=fromColor,toColor,step do
		sB(color)
		clear()
		sleep(0.05)
	end
	sB(toColor)
	clear()
end

local function bt(fs)
	cT(sce,colors.t2,"Booting from " .. fs.address)
	ee.setData(fs.address)
	local openS,fileOrR=pcall(fs.open,"/init.lua","r")
	if openS then
		local data,rData="",""
		while rData do data=data..rData;rData=fs.read(fileOrR,math.huge) end
		fs.close(fileOrR)
		
		local loadS,loadR=load(data)
		if loadS then
			local xpS,xpR=xpcall(loadS,debug.traceback)
			if not xpS then error(xpR) end
		else
			error(loadR)
		end
	else
		error("init.lua not found")
	end
end

local function cbf(f) return f.exists("/init.lua") or f.exists("/MineOS/EFI.lua") end

local function gB()
	local dr={}
	for address in ls("filesystem") do local fs=pr(address);if cbf(fs) then table.insert(dr,fs) end end
	return dr
end

local function menu(t,v)
	local y,sv,b,f=math.floor(sce-#v/2-1),1
	while true do
		sB(colors.b)
		clear()
		cT(y,colors.t1,t)
		for i=1,#v do
			b,f=colors.b,colors.t3
			if i==sv then b,f=colors.t3,colors.b end
			sB(b)
			cT(y+i+1,f,"   "..v[i].."   ")
		end
		local e=pu("key_down")
		if e[4]==200 then
			sv=sv>1 and sv-1 or 1
		elseif e[4]==208 then
			sv=sv<#v and sv+1 or #v
		elseif e[4]==28 then
			return sv
 		end
	end
end

local function waitForAlt(t,dr)
	local dl=cm.uptime()+t
	while cm.uptime()<dl do
		local e={ps(dl-cm.uptime())}
		if e[1]=="key_down" and e[4]==56 then
			while true do
				local v={};for i=1,#dr do v[i]=(dr[i].getLabel() or "Unnamed").." "..(dr[i].spaceTotal()>524288 and "HDD" or "FDD").." ("..dr[i].address..")" end; table.insert(v, "Back")
				local d=menu("Choose drive",v);
				if d==#v then break end
				v={"Set as bootable"};if not dr[d].isReadOnly() then v[2]="Format" end; table.insert(v, "Back")
				local a=menu("Drive \""..dr[d].address.."\"",v)
				if a==1 then
					l();bt(dr[d]);return
				elseif a==2 and #v==3 then
					for _,file in pairs(dr[d].list("/")) do dr[d].remove("/"..file) end;cm.shutdown(true)
				end
			end
		end
	end
	
	local fs=pr(ee.getData() or "")
	l();bt((fs and cbf(fs)) and fs or dr[1])
end

init()
bGP()
fade(0x0,colors.b,0x202020)
l()
cT(sce,colors.t2,"Initialising system")
local dr=gB()
if #dr>0 then cT(re.height - 1,colors.t2,"Hold Alt to enter boot options menu");waitForAlt(1.2,dr) else cT(sce,colors.t2,"Bootable drives not found");pu("key_down");fade(colors.b,0x0,-0x202020);cm.shutdown() end
DMineOS/System/OS/Icons/F"MineOS/System/OS/Icons/3DModel.picôOCIFAÿS F×B  YYYYF)B  YF B  YA	 SmF)B ÕYSâF×B SYS F×B ×YB SYYYB ÕYF)B ÕYSâF×B SYS.F)B ÕYSdF)B ÕYS3F)B ÕYSâF×B SYSâF×B SYF&MineOS/System/OS/Icons/Application.picOCIFAÿS F B  YYYYA SaF*B ×YS F B ×YS.F*B ×YSpF*B ×YSâFòB ãYFB >YFzB üYF"MineOS/System/OS/Icons/Archive.picOCIFAÿSâF×B  YFÖB  YS FÿB  YYFÖB  YYF B  YF×B  YYFSB  YA SâFSB ×YB ÖYB ¬YScFÿB SYSaFÿB SYSpFÿB SYSkFÿB SYS F B ×YFÿB ¬YB ÕYB SYFSB ×YB ÖYB ¬YF×B ÖYF#MineOS/System/OS/Icons/Computer.pic¨OCIFA S F B  YYB *YSâFÕB  YSâF B *YAÿSâF¬B  YS FÕB  YF¬B  YSâF¬B  YSâF¬B  YF!MineOS/System/OS/Icons/Config.pic°OCIFAÿS F B  YYF×B  YYYYA S-F×B SYYYScF B ×YSfF B ×YS F×B ×YF B ×YSgF B ×YS.F B ×YF&MineOS/System/OS/Icons/Downloading.pic OCIF@AÿS F B  Y 	
 Y 	
 Y 	
 Y	
 Y	
 Y	
 Y
 Y Y
	 Y
	
 Y	
 Y	
 Y 	
 Y 	
 Y 	
 Y 	
 A S F B AY#$'(34=>Y#$'(34=>Y#$'()*+,-./0123456789:;<=>Y#$Y#$'()*3456789:;<=>Y#$34Y#$'()*3456789:;<=>Y	#$34Y
#$'()*3456789:;<=>Y#$34Y#$'()*3456789:;<=>Y#$34Y#$'()*3456789:;<=>Y#$34B ;Y789:B Y !"#$%&'()*+,-./0123456789:;<=>?@Y!"%&)*1256;<?@Y!"%&)*+,-./01256789:;<?@Y!"%&?@Y!"%&'()*+,-./0123456789:;<=>?@Y
!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y
!"%&+,12?@Y	!"%&'()*+,1256789:;<=>?@Y

!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y
!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y
!"%&+,12?@Y!"%&'()*+,1256789:;<=>?@Y !"#$%&'()*+,-./0123456789:;<=>?@B PY+,-./0B 
)Y-./0Y-./0Y-./0Y	-./0Y
-./0Y-./0Y-./0Y-./0Y-./0Y-./0B 	YYYY	
Y	
Y
Y		
YYF(MineOS/System/OS/Icons/FileNotExists.picÆOCIFA
 SlFB ÿYS F B ÿYFB ÿYYYSoFB ÿYSnFB ÿYSeFB ÿYYStFB ÿYYSsFB ÿYSiFB ÿYYSxFB ÿYSFFB ÿYF!MineOS/System/OS/Icons/Finger.picÇOCIFAÿS F B  Y	Y
Y	
YY	
Y	
Y	Y
Y	Y
	Y	
Y	
Y
YA S F B  Y
Y	Y	Y	
YYY	
Y
	Y		
Y	

YY
Y		Y	
F!MineOS/System/OS/Icons/Floppy.picOCIFA S-F«B ÿYYS FªB §YYF«B §YYF B §YYB ªYSâFªB §YS*F B ªYAÿS F B  YF!MineOS/System/OS/Icons/Folder.picpOCIFA S F B þYFþB øYB ýYB óYAÿS FþB  YSâFþB  YFMineOS/System/OS/Icons/HDD.picðOCIFAÿS F B  YYYYA S*F¦B ¬YFüB ¬YSâF B ÖYB ÕYSâF B ÖYSâF B ÕYSâF B ÕYS F B ×YB ÖYB ÕYB ¬YFüB ¬YSâF B ÖYSâF B ×YB ¬YF MineOS/System/OS/Icons/Image.picOCIFAÿS F B  YYYYA ScF B ×YSiF B ×YSpF B ×YS F B þYB ©YB ZYB ÔYB ØYB ûYB "YB ìYB ôYB øYB §YB éYB ýYB ×YB YB òYB NYB ÊYB ÓYS.F B ×YF$MineOS/System/OS/Icons/Languages.pic0OCIF<ADÿSmFTB  Y3SÙFTB  YSkFSB  Y4SÑF~B  Y
SpF B  Y4SoF B  YYYSnF B  Y	YY3FB  YFTB  Y/SeF B  Y9Y
YY27<Y
FB  YFSB  Y26FTB  Y59;SÐ¸F~B  YF B  Y7Y2Y	
ScF B  Y7FB  YSÏFB  Y7Y3SiF B  Y6YFB  Y	YFSB  Y/58FTB  Y.7ShF B  Y0:Y8YYSgF B  Y
YFB  YYFTB  Y08SÎ±FB  Y<Y	:SÏFB  Y2SaF B  YY6YFB  YYFSB  Y-FTB  Y2SÎ­FB  Y5SSF B  Y5Y3FB  YSWF B  Y.SVFSB  Y,SLFTB  Y-SÃ¤F B  Y/SÑF B  Y3SCF B  YYSIF B  Y9SÐµF~B  YF B  Y	SØ§FTB  YSÎµFB  Y8SÐ°F B  Y8Y3SØªFTB  Y
SÐ¾F~B  YF B  Y4Y5<SÐºF B  Y
SØ®FTB  YSÎ¾FB  Y6SÏFB  Y	;SÑF~B  Y	F B  Y	Y1SØºFTB  Y	SÐ²F~B  YS FTB  Y4<Y&	
*+,-./0123456789:;<Y,-FSB  Y39:;<Y4	
"#$%&'()*+,-./0123456789:;<F B  Y2	
 $%&'()*+,-./0123456789:;<YY48Y	
-./012:;<Y./0123456789:;<Y/0Y	/02345678Y
/013456789:;<Y	
./0123456789:;<Y69:;<Y	
8Y%	
*+,-./0123456789:;<Y
()*+FB  Y
	Y
-.Y9:;<Y	<Y,-./01Y	
/0126F~B  Y()*+,SÑF~B  YSÑF B  Y	Y
SÙFTB  YSÎ»FB  Y4Y8SØ±FTB  YSÑF B  Y

SÎ·FB  Y4SÑF~B  YF B  Y:SÑF B  Y9SÎ³FB  Y7SÏFB  Y9SÐ¼F~B  YF B  Y;SÐ½F B  Y0Y6SÑF~B  YF B  Y		SÐF B  Y/SzF B  YSÐ·F B  Y
Y2SÎ½FB  Y5SÏFB  Y:;Y	9SÐ±F~B  YF B  Y4Y57Y	SuF B  YYFB  YFTB  Y1StF B  YFSB  Y0FTB  Y:SsF B  Y	Y	FSB  Y1SrF B  Y;Y5YSÎ¹FB  Y3SÐF~B  YF B  Y	SlF B  YYY1FB  YYFSB  Y.7FTB  Y6SvF B  YA SÎFB ÿY1S FTB sY"#B <Y"&B =Y$%Y(B Y!)Y$B ÍYYB ÕYB YB £YYB «Y B ÎYYB 7Y*B YYB Y)B ¤YB rY B ¬Y+B ×YB hYB mY&'Y!#'B YYB gY(Y%FSB ÿYB ÏY B ×YB ÔY!B ÖYF5 B Y$Y"Y$%YB 5Y
 "#$&B =Y'YYY	YY'Y"#$Y
B ÔYY)B Y
%B Y)Y#Y'+Y	),Y*+Y
*B Y&Y'+Y&Y	(*+YY$%Y
,B ÖYB ×Y.YYY'B Y	YB mY Y,Y "Y	YY%Y
B ùYB 7Y!(Y!"Y#,Y	&Y)Y#YY
B ~Y	%B YB YYYYB Y	"B YY	.B þYB 8Y	Y
B AYB ÿY
2Y	1YB BYY	YY!B £YB 1Y#$%Y)*B ¤YYY	Y-Y&B CYY
-B Y B <YYB sY(B ÕY"#Y
YYB 
Y
!Y!B Y+Y&Y&Y	'-YY
B 6Y
'()Y "#$%B TY&B UY(B Y
B ªYB kY	 !B «YB fY
Y'YB ¬Y,B nY	B lY-Y	#$Y B gY!"YY B ÍYB ÎYB hY!YYY	B ÏY!Y-Y
.B  Y()*Y
+B Y,B (Y*Y%(B rYYFB Y)YB ×YB YY'(B =YYY$B BY*B Y)B YB ÿY
YB ªY!B Y+B hYYB <YB lYB nYB YB rY"YB UY%&Y$B ¤Y.Y,B Y-B SY"B Y B ~Y!Y"#B Y B 2Y+B TY$'Y%B YY(*Y&,B ÏY+B 6Y#B YY B 7Y	&YY%'()*B mY!#F
~B ÕYB ÎYB ÖYB ÏY "%B ×Y'B ¤Y!B ¬Y&B ÿYB Y$B Y#FMineOS/System/OS/Icons/Love.picGOCIF*AÿS F B  Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y
#$%&'()*Y()*Y	*Y
YY*Y)*Y()*Y&'()*Y	$%&'()*Y(	
"#$%&'()*A S F B ãY
YYY	YYYB Y
()Y(Y$%Y	#$%&'Y)Y&'Y"#Y !B PYB ;YB ØY	 !"#$Y Y
 !"#$%&Y !"YB AY	
 Y	
 Y	
 YY	
 YY	
 Y	Y
	
YY		
YY	
YB 
VY#$%&'Y	"()Y
 !"*Y*Y)Y(Y&'Y$%Y"#Y !B éY
Y	YYB 
)YYYY	Y
YYYYYB Y 	
 !"Y!"Y!"Y!"Y	
 !"Y
!"Y	
 !"Y
!"Y		
 !Y
Y	
YY	
YY	
Y	
B 	­YY	Y
#$%&'Y'(Y%&'Y#$%Y!"#Y !YFMineOS/System/OS/Icons/Lua.pic,OCIFAÿS F B  YYYYA SrFøB )YFýB )YSpFýB )YSaF B ×YSfFøB )YSuF B ×YStFýB )YSeFøB )YS F B )YYYB ×YS.F B ×YSdFøB )YSiFýB )YYSnFýB )YFøB )YSoFøB )YSlF B ×YS=FýB )YFMineOS/System/OS/Icons/OK.pic}OCIF AÿS F B  Y 	
 Y	
 Y	
 Y	
 Y	
 Y	
 Y	
 Y
 Y	 Y
	 Y	
 Y	
 Y	
 Y	
 Y	
 Y 	
 A S F B $YYYYYY	Y
	Y		
Y


Y	YYYYF"MineOS/System/OS/Icons/OS_Logo.picOCIFAÿSâFpB  YFkB  YY
YYFfB  YYF;B  Y	YYF@B  YS F B  Y	
YYYYYY	
B aY	YYSâFaB  YB SYF0B *YYYYB )YB 1YB [YA S F B *Y
YYY	YYYB kYYYYYYB ;YYB 0Y
YYY	YB )YYYB aYYYYYYSâFqB kY	YF:B fY
B *YF;B ~YYB kYYY	YB fYYB @YB 6YYB 5Y
B lYF\B *Y
YB aY
B 5YB `YYB 0YFAB kYFfB aY	B UYB lYB \Y

Y	B @YYFlB @YYB kYYYYY
B ;Y
F+B *YFpB lYF*B fYB [YYYB 5YY	B kYB `Y
YB ;YYYB 0Y
YYY	YYYB aYYB \Y	B 6Y	B )Y	B SYY	
YYB (Y	FUB @YFTB aYB 5YFB ~YB *YF[B *Y
Y	YB SY
	Y
YB 1YB `YB 0YY		YB aYFSB [Y
Y	YYB *YYB `YYYB ;YYYB 5YYYB \Y
YB 0Y
YY	YYYB aY
Y
YY
F@B ~YB kYYB fYB UYB TY	FaB TY	B `YYB fYB SY	B \YYB *Y
YYB 0YYYY
B )Y	F`B aY
Y
Y
Y	YB SYY	Y	B \YF0B *Y
YYYYYB +YB `Y
YB SY
YYB \Y	B 6Y	B )YYY	YYB aY
YYFB `YB 0YF5B 6YYB )YB *YYF6B fYB ;YB kYB )YFkB ~YY
YB fYY	B ;YY	YYB UYYB lYYYYYB @Y
YYYF~B ;YB kYYB @YF)B 
YB [Y	YB :YB ;YYYB 5YB 6YB 0Y
YY	YYB *YYY	YYYYF#MineOS/System/OS/Icons/Pastebin.pic!OCIFA SmFÊB *YSrFÊB *YSuFÊB *YSpFÊB *YSaFÿB *YSPFÿB *YSoFÊB *YSnFÿB *YSeFÿB *YFÊB *YStFÿB *YFÊB *YSsFÿB *YSbFÿB *YSiFÿB *YSCFÊB *YSâ©F{B *YYS FÿB *YF{B *YYF MineOS/System/OS/Icons/Robot.picäOCIFAÿS F B  YF)B  YFSB  YF*B  YSâF)B  YSâFSB  YF*B  YYA SâF*B  YS F)B )YSâF B SYF*B VYB +YB SYB  YB ÞYB ­YB YF%MineOS/System/OS/Icons/SampleIcon.picòOCIFA SmF B ÿYSlF B ÿYSaF B ÿYFÿB iYSpF B ÿYFÿB iYSoF B ÿYSnF B ÿYSeF B ÿYSSF B ÿYSIF B ÿYS.FÿB iYScF B ÿYS F B ÿYYYB iYFÿB iYF!MineOS/System/OS/Icons/Script.piceOCIFA S F B  YFÿB  YYYYS_FÿB  YS>FûB  YF#MineOS/System/OS/Icons/Security.pic¶OCIF AÿS F B  Y	
 Y	
Y
	
 Y Y Y Y Y Y	 Y

 Y Y Y	 Y	
 Y	
 Y	
 A S F B YYYYYYY	Y
YYYB 
nYYYY	
YYYYY	Y
B  YYYY	Y
YY
B ÖYYYYYY	B 7YYYYYYY
Y		
Y			
Y
	
Y	
Y	
Y
B YYYYYYY	Y
YYYYYB 	=YYYY	
YYYY	Y
B ¬YYYY	YYYY
B 
8YYYY	
Y	YY	Y
YYB Y
YYB Y YYYYYYY	Y
YYYYYYF MineOS/System/OS/Icons/Steve.picÖOCIFA S F B ÃY	
Y	
Y	
YYYB ÿYB aY	
B Y	
B 0Y	
Y	
YYY	
B 8YF!MineOS/System/OS/Icons/Tablet.pic(OCIFAÿSâF0B  YSâFB  YSâFB  YSâF0B  YA SâF1B 0YS F8B 1YFÀB 1YF{B `YB 1YB 0YFýB 1YFB `YFéB 1YFðB 1YB 0YSâF8B 1YFÀB 1YF{B 1YFýB 1YFéB 1YFðB 1YSâFbB YFMineOS/System/OS/Icons/Text.pic°OCIFAÿS F B  YYFÿB  YYYYA SeF B ×YSTF B ×YStF B ×YS FÿB ×YF B ×YSxF B ×YS-FÿB øYYYF MineOS/System/OS/Icons/Trash.picÁOCIFAÿSâF×B  YFÕB  YSâF¬B  YSâF¬B  YSâF×B  YF¬B  YFÕB  YSâF×B  YFÕB  YS F B  YYA SâFSB «YF!MineOS/System/OS/Icons/Update.picOCIF AÿS F B  Y	
 Y Y Y Y
 Y
 YYY	Y

Y Y
 Y
 Y Y Y	
 A S F B Y	
 Y		
 Y	
 Y
	 B ¤YY	
B CY	
Y	
B sY	
Y	
B Y	
Y	
YB Y	
Y	
Y	
DMineOS/System/OS/Installer/F(MineOS/System/OS/Installer/Language.langk{
	beginOsInstall = "Ð§ÑÐ¾Ð±Ñ Ð½Ð°ÑÐ°ÑÑ ÑÑÑÐ°Ð½Ð¾Ð²ÐºÑ ÐÐ¡, Ð½Ð°Ð¶Ð¼Ð¸ÑÐµ Ð´Ð°Ð»ÐµÐµ",
	acceptLicense = "ÐÑÐ¸Ð½Ð¸Ð¼Ð°Ñ",
	osInstallation = "Ð£ÑÑÐ°Ð½Ð¾Ð²ÐºÐ° ÐÐ¡",
	downloading = "ÐÐ°Ð³ÑÑÐ·ÐºÐ°",
	needToRestart = "Ð¡Ð¸ÑÑÐµÐ¼Ð° ÑÑÑÐ°Ð½Ð¾Ð²Ð»ÐµÐ½Ð°, Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼Ð° Ð¿ÐµÑÐµÐ·Ð°Ð³ÑÑÐ·ÐºÐ°",
	restart = "ÐÐµÑÐµÐ·Ð°Ð³ÑÑÐ·Ð¸ÑÑ",
}
DMineOS/System/OS/Languages/F'MineOS/System/OS/Languages/English.lang9{
	pressAnyKeyToContinue = "Press any key to continue",
	screensaver = "Screensaver",
	screensaverDelay = "Delay",
	screensaverDisabled = "Disabled",

	areYouSure = "Are you sure?",
	emptyTrash = "Empty trash"
	type = "Type",
	size = "Size",
	date = "Date",
	path = "Path",
	folder = "Folder",
	unknown = "Unknown",
	calculatingSize = "calculatingâ¦",
	contextMenuProperties = "Properties",
	contextMenuNewFile = "New file",
	contextMenuNewFolder = "New folder",
	contextMenuNewApplication = "New MineOS application",
	contextMenuPaste = "Paste",
	contextMenuCopy = "Copy",
	contextMenuCut = "Cut",
	contextMenuRemoveWallpaper = "Remove wallpaper",
	contextMenuEdit = "Edit",
	contextMenuEditInPhotoshop = "Edit in Photoshop",
	contextMenuRename = "Rename",
	contextMenuCreateShortcut = "Create shortcut",
	contextMenuUploadToPastebin = "Upload to Pastebin",
	contextMenuAddToDock = "Add to Dock",
	contextMenuRemoveFromDock = "Remove from Dock",
	contextMenuMoveRight = "Move right",
	contextMenuMoveLeft = "Move left",
	contextMenuArchive = "Compress",
	contextMenuDelete = "Delete",
	contextMenuAddToFavourites = "Add to favourites",
	contextMenuCreateApplication = "Create MineOS application",
	contextMenuSetAsWallpaper = "Set as wallpaper",
	contextMenuShowPackageContent = "Show package content",
	contextMenuShowContainingFolder = "Show containing folder",
	contextMenuRemoveFromFavourites = "Remove from favourites",
	contextMenuFlashEEPROM = "Write file to EEPROM",

	favourites = "Favourites",
	disks = "HDDs",
	network = "Network",
	search = "Search",
	sortByType = "Sort by type",
	sortByName = "Sort by name",
	sortByDate = "Sort by date",
	showFileFormat = "Show file format",
	hideFileFormat = "Hide file format",
	showHiddenFiles = "Show hidden files",
	hideHiddenFiles = "Hide hidden files",
	showApplicationIcons = "Show application icons",
	hideApplicationIcons = "Hide application icons",

	aboutSystem = "About this PC",
	updates = "Updates",
	shutdown = "Shutdown",
	logout = "Logout",
	reboot = "Reboot",
	returnToShell = "Return to Shell",

	protectYourComputer = "Computer protection",
	inputPassword = "Input password",
	confirmInputPassword = "Confirm password",
	oldPassword = "Old password",
	newPassword = "New password",
	setProtectionMethod = "Change computer protection method",
	wrongOldPassword = "Wrong old password!",
	passwordSucessfullyChanged = "Password have been successfully changed!",
	withoutProtection = "Without protection",
	passwordProtection = "Password protection",
	biometricProtection = "Biometric protection",
	putFingerToVerify = "Put your finger to authorization",
	putFingerToRegister = "Put your finger to create biometric signature",
	fingerprintCreated = "Biometric signature has been created",
	accessDenied = "Access denied",
	welcomeBack = "Welcome, ",
	passwordsAreDifferent = "Passwords are different",
	incorrectPassword = "Incorrect password",
	mineOSCreatorUsedMasterPassword = "The creator of this operating system have used Master-Password",
	loginToSystem = "Login",

	colorScheme = "Color scheme",
	backgroundColor = "Background color",
	interfaceColor = "Interface color",
	screenResolution = "Screen resolution",
	changePassword = "Change password",
	cancel = "Cancel",
	shortcut = "shortcut",
	shortcutIsCorrupted = "Shortcut file is corrupted",

	settings = "Preferences",
	viewTab = "View",

	errorWhileRunningProgram = "Error while running ",
	sendFeedback = "Send feedback",
	yourContacts = "Your contacts",
	additionalInfo = "Additional information",
	stackTraceback = "Stack traceback",
	fileDoesntExists = "File doesn't exists",
	fileSuccessfullySent = "File has been successfully sent",
	sendFile = "Send file",
	pathToFile = "Path to file",
	sendMessage = "Send message",
	messageText = "Message text",
	gotMessageFrom = "Got message from ",
	gotFileFrom = "Got file from ",
	pathToSave = "Path to save file",
}F'MineOS/System/OS/Languages/Russian.lang}{
	pressAnyKeyToContinue = "ÐÐ°Ð¶Ð¼Ð¸ÑÐµ Ð»ÑÐ±ÑÑ ÐºÐ»Ð°Ð²Ð¸ÑÑ, ÑÑÐ¾Ð±Ñ Ð¿ÑÐ¾Ð´Ð¾Ð»Ð¶Ð¸ÑÑ",
	screensaver = "ÐÐ°ÑÑÐ°Ð²ÐºÐ°",
	screensaverDelay = "ÐÐ°Ð´ÑÐµÐ¶ÐºÐ°",
	screensaverDisabled = "ÐÑÐºÐ»ÑÑÐµÐ½Ð°",

	areYouSure = "ÐÑ ÑÐ²ÐµÑÐµÐ½Ñ?",
	emptyTrash = "ÐÑÐ¸ÑÑÐ¸ÑÑ ÐºÐ¾ÑÐ·Ð¸Ð½Ñ",
	type = "Ð¢Ð¸Ð¿",
	size = "Ð Ð°Ð·Ð¼ÐµÑ",
	date = "ÐÐ°ÑÐ°",
	path = "ÐÑÑÑ",
	folder = "ÐÐ°Ð¿ÐºÐ°",
	unknown = "ÐÐµÐ¸Ð·Ð²ÐµÑÑÐ½Ð¾",
	calculatingSize = "Ð¸Ð´ÐµÑ Ð¿Ð¾Ð´ÑÑÐµÑâ¦",
	contextMenuProperties = "Ð¡Ð²Ð¾Ð¹ÑÑÐ²Ð°",
	contextMenuNewFile = "ÐÐ¾Ð²ÑÐ¹ ÑÐ°Ð¹Ð»",
	contextMenuNewFolder = "ÐÐ¾Ð²Ð°Ñ Ð¿Ð°Ð¿ÐºÐ°",
	contextMenuNewApplication = "ÐÐ¾Ð²Ð¾Ðµ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ MineOS",
	contextMenuPaste = "ÐÑÑÐ°Ð²Ð¸ÑÑ",
	contextMenuCopy = "ÐÐ¾Ð¿Ð¸ÑÐ¾Ð²Ð°ÑÑ",
	contextMenuCut = "ÐÑÑÐµÐ·Ð°ÑÑ",
	contextMenuRemoveWallpaper = "Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð¾Ð±Ð¾Ð¸",
	contextMenuEdit = "Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ",
	contextMenuEditInPhotoshop = "Ð ÐµÐ´Ð°ÐºÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð² Photoshop",
	contextMenuRename = "ÐÐµÑÐµÐ¸Ð¼ÐµÐ½Ð¾Ð²Ð°ÑÑ",
	contextMenuCreateShortcut = "Ð¡Ð¾Ð·Ð´Ð°ÑÑ ÑÑÐ»ÑÐº",
	contextMenuUploadToPastebin = "ÐÐ°Ð³ÑÑÐ·Ð¸ÑÑ Ð½Ð° Pastebin",
	contextMenuAddToDock = "ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ Ð² Dock",
	contextMenuRemoveFromDock = "Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð¸Ð· Dock",
	contextMenuMoveRight = "ÐÐµÑÐµÐ´Ð²Ð¸Ð½ÑÑÑ Ð¿ÑÐ°Ð²ÐµÐµ",
	contextMenuMoveLeft = "ÐÐµÑÐµÐ´Ð²Ð¸Ð½ÑÑÑ Ð»ÐµÐ²ÐµÐµ",
	contextMenuArchive = "Ð¡Ð¶Ð°ÑÑ",
	contextMenuDelete = "Ð£Ð´Ð°Ð»Ð¸ÑÑ",
	contextMenuAddToFavourites = "ÐÐ¾Ð±Ð°Ð²Ð¸ÑÑ Ð² Ð¸Ð·Ð±ÑÐ°Ð½Ð½Ð¾Ðµ",
	contextMenuCreateApplication = "Ð¡Ð¾Ð·Ð´Ð°ÑÑ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ MineOS",
	contextMenuSetAsWallpaper = "Ð£ÑÑÐ°Ð½Ð¾Ð²Ð¸ÑÑ ÐºÐ°Ðº Ð¾Ð±Ð¾Ð¸",
	contextMenuShowPackageContent = "ÐÐ¾ÐºÐ°Ð·Ð°ÑÑ ÑÐ¾Ð´ÐµÑÐ¶Ð¸Ð¼Ð¾Ðµ Ð¿Ð°ÐºÐµÑÐ°",
	contextMenuShowContainingFolder = "ÐÑÐºÑÑÑÑ ÑÐ¾Ð´ÐµÑÐ¶Ð°ÑÑÑ Ð¿Ð°Ð¿ÐºÑ",
	contextMenuRemoveFromFavourites = "Ð£Ð´Ð°Ð»Ð¸ÑÑ Ð¸Ð· Ð¸Ð·Ð±ÑÐ°Ð½Ð½Ð¾Ð³Ð¾",
	contextMenuFlashEEPROM = "ÐÐ°Ð¿Ð¸ÑÐ°ÑÑ ÑÐ°Ð¹Ð» Ð½Ð° EEPROM",

	favourites = "ÐÐ·Ð±ÑÐ°Ð½Ð½Ð¾Ðµ",
	disks = "ÐÐ¸ÑÐºÐ¸",
	network = "Ð¡ÐµÑÑ",
	search = "ÐÐ¾Ð¸ÑÐº",
	sortByType = "Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿Ð¾ ÑÐ¸Ð¿Ñ",
	sortByName = "Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿Ð¾ Ð¸Ð¼ÐµÐ½Ð¸",
	sortByDate = "Ð¡Ð¾ÑÑÐ¸ÑÐ¾Ð²Ð°ÑÑ Ð¿Ð¾ Ð´Ð°ÑÐµ",
	showFileFormat = "ÐÐ¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ ÑÐ¾ÑÐ¼Ð°Ñ ÑÐ°Ð¹Ð»Ð¾Ð²",
	hideFileFormat = "Ð¡ÐºÑÑÐ²Ð°ÑÑ ÑÐ¾ÑÐ¼Ð°Ñ ÑÐ°Ð¹Ð»Ð¾Ð²",
	showHiddenFiles = "ÐÐ¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ ÑÐºÑÑÑÑÐµ ÑÐ°Ð¹Ð»Ñ",
	hideHiddenFiles = "Ð¡ÐºÑÑÐ²Ð°ÑÑ ÑÐºÑÑÑÑÐµ ÑÐ°Ð¹Ð»Ñ",
	showApplicationIcons = "ÐÐ¾ÐºÐ°Ð·ÑÐ²Ð°ÑÑ Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹",
	hideApplicationIcons = "Ð¡ÐºÑÑÐ²Ð°ÑÑ Ð¸ÐºÐ¾Ð½ÐºÐ¸ Ð¿ÑÐ¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ð¹",

	aboutSystem = "ÐÐ± ÑÑÐ¾Ð¼ ÐÐ",
	updates = "ÐÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ",
	shutdown = "ÐÑÐºÐ»ÑÑÐ¸ÑÑ",
	logout = "Ð Ð°Ð·Ð»Ð¾Ð³Ð¸Ð½Ð¸ÑÑÑÑ",
	reboot = "ÐÐµÑÐµÐ·Ð°Ð³ÑÑÐ·Ð¸ÑÑ",
	returnToShell = "ÐÐµÑÐ½ÑÑÑÑÑ Ð² Shell",

	protectYourComputer = "ÐÐ°ÑÐ¸ÑÐ° ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑÐ°",
	inputPassword = "ÐÐ²ÐµÐ´Ð¸ÑÐµ Ð¿Ð°ÑÐ¾Ð»Ñ",
	confirmInputPassword = "ÐÐ¾Ð´ÑÐ²ÐµÑÐ´Ð¸ÑÐµ Ð¿Ð°ÑÐ¾Ð»Ñ",
	oldPassword = "Ð¡ÑÐ°ÑÑÐ¹ Ð¿Ð°ÑÐ¾Ð»Ñ",
	newPassword = "ÐÐ¾Ð²ÑÐ¹ Ð¿Ð°ÑÐ¾Ð»Ñ",
	setProtectionMethod = "ÐÐ·Ð¼ÐµÐ½Ð¸ÑÑ Ð¼ÐµÑÐ¾Ð´ Ð·Ð°ÑÐ¸ÑÑ ÐºÐ¾Ð¼Ð¿ÑÑÑÐµÑÐ°",
	wrongOldPassword = "ÐÐµÐ²ÐµÑÐ½ÑÐ¹ ÑÑÐ°ÑÑÐ¹ Ð¿Ð°ÑÐ¾Ð»Ñ",
	passwordSucessfullyChanged = "ÐÐ°ÑÐ¾Ð»Ñ ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¸Ð·Ð¼ÐµÐ½ÐµÐ½!",
	withoutProtection = "ÐÐµÐ· Ð·Ð°ÑÐ¸ÑÑ",
	passwordProtection = "ÐÐ°ÑÐ¸ÑÐ° Ð¿Ð°ÑÐ¾Ð»ÐµÐ¼",
	biometricProtection = "ÐÐ¸Ð¾Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ°Ñ",
	putFingerToVerify = "ÐÑÐ¸Ð»Ð¾Ð¶Ð¸ÑÐµ Ð¿Ð°Ð»ÐµÑ Ð´Ð»Ñ Ð°Ð²ÑÐ¾ÑÐ¸Ð·Ð°ÑÐ¸Ð¸",
	putFingerToRegister = "ÐÑÐ¸Ð»Ð¾Ð¶Ð¸ÑÐµ Ð¿Ð°Ð»ÐµÑ Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð±Ð¸Ð¾Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¾Ð³Ð¾ ÑÐ½Ð¸Ð¼ÐºÐ°",
	fingerprintCreated = "ÐÐ¸Ð¾Ð¼ÐµÑÑÐ¸ÑÐµÑÐºÐ¸Ð¹ ÑÐ½Ð¸Ð¼Ð¾Ðº ÑÐ¾Ð·Ð´Ð°Ð½",
	accessDenied = "ÐÐ¾ÑÑÑÐ¿ Ð·Ð°Ð¿ÑÐµÑÐµÐ½",
	welcomeBack = "ÐÐ¾Ð±ÑÐ¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°ÑÑ, ",
	passwordsAreDifferent = "ÐÐ°ÑÐ¾Ð»Ð¸ ÑÐ°Ð·Ð»Ð¸ÑÐ°ÑÑÑÑ",
	incorrectPassword = "ÐÐµÐ²ÐµÑÐ½ÑÐ¹ Ð¿Ð°ÑÐ¾Ð»Ñ",
	mineOSCreatorUsedMasterPassword = "Ð¡Ð¾Ð·Ð´Ð°ÑÐµÐ»Ñ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½Ð½Ð¾Ð¹ ÑÐ¸ÑÑÐµÐ¼Ñ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð» Ð¼Ð°ÑÑÐµÑ-ÐºÐ»ÑÑ",
	loginToSystem = "ÐÑÐ¾Ð´ Ð² ÑÐ¸ÑÑÐµÐ¼Ñ",

	colorScheme = "Ð¦Ð²ÐµÑÐ¾Ð²Ð°Ñ ÑÑÐµÐ¼Ð°",
	backgroundColor = "Ð¦Ð²ÐµÑ ÑÐ¾Ð½Ð°",
	interfaceColor = "Ð¦Ð²ÐµÑ Ð¸Ð½ÑÐµÑÑÐµÐ¹ÑÐ°",
	screenResolution = "Ð Ð°Ð·ÑÐµÑÐµÐ½Ð¸Ðµ ÑÐºÑÐ°Ð½Ð°",
	changePassword = "ÐÐ·Ð¼ÐµÐ½Ð¸ÑÑ Ð¿Ð°ÑÐ¾Ð»Ñ",
	cancel = "ÐÑÐ¼ÐµÐ½Ð°",
	shortcut = "ÑÑÐ»ÑÐº",
	shortcutIsCorrupted = "Ð¤Ð°Ð¹Ð» ÑÑÐ»ÑÐºÐ° Ð¿Ð¾Ð²ÑÐµÐ¶Ð´ÐµÐ½ Ð¸Ð»Ð¸ Ð¸Ð¼ÐµÐµÑ Ð½ÐµÐ¸Ð·Ð²ÐµÑÑÐ½ÑÐ¹ ÑÐ¾ÑÐ¼Ð°Ñ",

	settings = "ÐÐ°ÑÑÑÐ¾Ð¹ÐºÐ¸",
	viewTab = "ÐÐ¸Ð´",

	errorWhileRunningProgram = "ÐÑÐ¸Ð±ÐºÐ° Ð¿ÑÐ¸ Ð²ÑÐ¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ ",
	sendFeedback = "ÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ Ð¾ÑÑÐµÑ",
	yourContacts = "ÐÐ°ÑÐ¸ ÐºÐ¾Ð½ÑÐ°ÐºÑÑ",
	additionalInfo = "ÐÐ¾Ð¿Ð¾Ð»Ð½Ð¸ÑÐµÐ»ÑÐ½Ð°Ñ Ð¸Ð½ÑÐ¾ÑÐ¼Ð°ÑÐ¸Ñ",
	stackTraceback = "Ð¡ÑÐµÐº Ð¾ÑÐ¸Ð±ÐºÐ¸",
	fileDoesntExists = "Ð¤Ð°Ð¹Ð» Ð½Ðµ ÑÑÑÐµÑÑÐ²ÑÐµÑ",
	fileSuccessfullySent = "Ð¤Ð°Ð¹Ð» ÑÑÐ¿ÐµÑÐ½Ð¾ Ð¾ÑÐ¿ÑÐ°Ð²Ð»ÐµÐ½",
	sendFile = "ÐÑÐ¿ÑÐ°Ð²Ð¸ÑÑ ÑÐ°Ð¹Ð»",
	pathToFile = "ÐÑÑÑ Ðº ÑÐ°Ð¹Ð»Ñ",
	sendMessage = "Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ",
	messageText = "Ð¢ÐµÐºÑÑ ÑÐ¾Ð¾Ð±ÑÐµÐ½Ð¸Ñ",
	gotMessageFrom = "Ð¡Ð¾Ð¾Ð±ÑÐµÐ½Ð¸Ðµ Ð¾Ñ ",
	gotFileFrom = "ÐÑÐ¸Ð½ÑÑ ÑÐ°Ð¹Ð» Ð¾Ñ ",
	pathToSave = "ÐÑÑÑ Ð´Ð»Ñ ÑÐ¾ÑÑÐ°Ð½ÐµÐ½Ð¸Ñ",
}FMineOS/System/OS/License.txtçÐÐ½Ð¸Ð¼Ð°ÑÐµÐ»ÑÐ½Ð¾ Ð¿ÑÐ¾ÑÑÐ¸ÑÐµ ÑÑÐ»Ð¾Ð²Ð¸Ñ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ Ð»Ð¸ÑÐµÐ½Ð·Ð¸Ð¾Ð½Ð½Ð¾Ð³Ð¾ ÑÐ¾Ð³Ð»Ð°ÑÐµÐ½Ð¸Ñ
Ð¿ÐµÑÐµÐ´ ÑÑÑÐ°Ð½Ð¾Ð²ÐºÐ¾Ð¹ Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð¾Ð½Ð½Ð¾Ð¹ ÑÐ¸ÑÑÐµÐ¼Ñ.

ÐÐ°Ð¶Ð¸Ð¼Ð°Ñ ÐºÐ½Ð¾Ð¿ÐºÑ "Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°Ñ", ÐÑ ÑÐ¾Ð³Ð»Ð°ÑÐ°ÐµÑÐµÑÑ Ñ Ð½Ð¸Ð¶ÐµÑÐ»ÐµÐ´ÑÑÑÐ¸Ð¼:
  â ÐÑ Ð½ÐµÐ·Ð°Ð¼ÐµÐ´Ð»Ð¸ÑÐµÐ»ÑÐ½Ð¾ Ð¿Ð¾ÑÑÑÐ¿Ð°ÐµÑÐµ Ð² Ð°Ð½Ð°Ð»ÑÐ½Ð¾Ðµ ÑÐ°Ð±ÑÑÐ²Ð¾ Ðº Ð°Ð²ÑÐ¾ÑÑ
    Ð´Ð°Ð½Ð½Ð¾Ð¹ ÐÐ¡.
  â ÐÐµÐºÐ¾ÑÐ¾ÑÑÐµ ÐÐ°ÑÐ¸ Ð¿ÐµÑÑÐ¾Ð½Ð°Ð»ÑÐ½ÑÐµ Ð´Ð°Ð½Ð½ÑÐµ (Ð»Ð¾Ð³Ð¸Ð½Ñ, Ð¿Ð°ÑÐ¾Ð»Ð¸ Ð´Ð»Ñ 
    ÑÐ°Ð¹ÑÐ¾Ð² pastebin.com Ð¸ vk.com) Ð¼Ð¾Ð³ÑÑ Ð±ÑÑÑ Ð¿ÑÐ¾ÑÐ¸ÑÐ°Ð½Ñ Ð´ÑÑÐ³Ð¸Ð¼Ð¸
    Ð»ÑÐ´ÑÐ¼Ð¸ Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ñ Ð² ÐºÐ¾ÑÑÑÑÐ½ÑÑ ÑÐµÐ»ÑÑ Ð¸Ð·-Ð·Ð° ÐÐ°ÑÐµÐ¹ Ð¶Ðµ
    Ð½ÐµÐ²Ð½Ð¸Ð¼Ð°ÑÐµÐ»ÑÐ½Ð¾ÑÑÐ¸.
  â ÐÑ Ð¾Ð±ÑÐ·ÑÐµÑÐµÑÑ Ð½Ðµ ÑÐ°ÑÐ¿ÑÐ¾ÑÑÑÐ°Ð½ÑÑÑ Ð´Ð°Ð½Ð½ÑÑ ÐÐ¡, Ð° ÑÐ°ÐºÐ¶Ðµ
    Ð¾ÑÐ´ÐµÐ»ÑÐ½ÑÐµ ÐµÐµ ÐºÐ¾Ð¼Ð¿Ð¾Ð½ÐµÐ½ÑÑ Ð¿Ð¾Ð´ ÑÐ²Ð¾Ð¸Ð¼ Ð°Ð²ÑÐ¾ÑÑÐºÐ¸Ð¼ Ð·Ð½Ð°ÐºÐ¾Ð¼ Ð±ÐµÐ· ÑÐºÐ°Ð·Ð°Ð½Ð¸Ñ
    ÐºÐ¾Ð¿Ð¸ÑÐ°Ð¹ÑÐ°.
  â ÐÑ Ð¿ÑÐ¸Ð½Ð¸Ð¼Ð°ÐµÑÐµ ÑÐ¾Ñ ÑÐ°ÐºÑ, ÑÑÐ¾ Ð°Ð²ÑÐ¾Ñ ÐÐ¡ Ð½Ðµ Ð½ÐµÑÐµÑ ÐºÐ°ÐºÐ¾Ð¹-Ð»Ð¸Ð±Ð¾
    Ð¾ÑÐ²ÐµÑÑÑÐ²ÐµÐ½Ð½Ð¾ÑÑÐ¸ Ð·Ð° Ð»ÑÐ±Ð¾Ð¹ ÑÐ¸Ð·Ð¸ÑÐµÑÐºÐ¸Ð¹ Ð¸ Ð¼Ð¾ÑÐ°Ð»ÑÐ½ÑÐ¹ ÑÑÐµÑÐ±,
    ÐºÐ¾ÑÐ¾ÑÑÐ¹ ÐÑ Ð¼Ð¾Ð¶ÐµÑÐµ Ð¿Ð¾Ð½ÐµÑÑÐ¸, Ð¸ÑÐ¿Ð¾Ð»ÑÐ·ÑÑ Ð´Ð°Ð½Ð½ÑÑ ÐÐ¡.
  â ...
  â ÐÐ° ÐºÐ¾Ð³Ð¾ ÑÑÐ¾ ÐµÐ±ÐµÑ, Ð±ÑÐ°ÑÐ°Ð½? ÐÐ¾Ð³Ð¸ Ð² ÑÑÐºÐ¸, ÑÑÐ¹ Ð² Ð·Ð°Ð»ÑÐ¿Ñ, Ð¸ Ð²Ð¿ÐµÑÐµÐ´
    Ð½Ð°Ð²ÑÑÑÐµÑÑ Ð½ÐµÐ¸Ð·Ð²ÐµÐ´Ð°Ð½Ð½Ð¾Ð¼Ñ! 
    
Ð ÑÐ»ÑÑÐ°Ðµ Ð½ÐµÑÐ¾Ð³Ð»Ð°ÑÐ¸Ñ Ñ Ð»ÑÐ±ÑÐ¼ Ð¸Ð· Ð²ÑÑÐµÐ¿ÐµÑÐµÑÐ¸ÑÐ»ÐµÐ½Ð½ÑÑ Ð¿ÑÐ½ÐºÑÐ¾Ð²,
Ð²Ñ Ð¾Ð±ÑÐ·Ð°Ð½Ñ Ð½Ð°Ð¶Ð°ÑÑ ÑÐ¾ÑÐµÑÐ°Ð½Ð¸Ðµ ÐºÐ»Ð°Ð²Ð¸Ñ Ctrl+Alt+C, ÑÑÐ¾Ð±Ñ Ð·Ð°Ð²ÐµÑÑÐ¸ÑÑ
Ð¿ÑÐ¾Ð³ÑÐ°Ð¼Ð¼Ñ ÑÑÑÐ°Ð½Ð¾Ð²ÐºÐ¸.
FMineOS/System/OS/OSSettings.cfg«{
  ["dockShortcuts"] = {
    [1] = {
      ["path"] = "/MineOS/Applications/AppMarket.app"
    },
    [2] = {
      ["path"] = "/MineOS/Applications/MineCode IDE.app"
    },
    [3] = {
      ["path"] = "/MineOS/Applications/Photoshop.app"
    }
  },
  ["language"] = "Russian",
  ["protectionMethod"] = "withoutProtection",
  ["showHelpOnApplicationStart"] = false,
  ["screensaverDelay"] = 20,
  ["screensaver"] = "Matrix"
}DMineOS/System/OS/Screensavers/F'MineOS/System/OS/Screensavers/Clock.lua¬local gpu = require("component").gpu
local event = require("event")
local w, h, t, q = gpu.getResolution()
local numb, ha, wh, p, s, u, e, gsB, gS, ti, r, slp, tn = {29850,29351,30887,18925,14735,27343,9383,31407,31147,[0]=31599}, h/2-2, {0, 8, nil, 18, 26}, "â", "  ", h%2, w/2, gpu.setBackground, gpu.set, table.insert, math.random, os.sleep, tonumber

local function drawN(x, y, n)
  local c = 0
  for i = 0, 14 do
    if bit32.extract(numb[n], i) == 1 then
      gsB(60928)
      gS(x, y, s)
    else
      gsB(0)
      gS(x, y, s)
    end
    c, x = c + 1, x + 2
    if c % 3 == 0 then
      y, x = y + 1, x - 6
    end
  end
end

gsB(0)
gpu.fill(1, 1, w, h, " ")
local tbl = {x = {}, y = {}}
for x = 1, w, 2 do
  for y = 1, ha-1-u do
    ti(tbl.x, x)
    ti(tbl.y, y)
  end
end
for n = 1, #tbl.x do
  k = r(n)
  tbl.x[n], tbl.x[k], tbl.y[n], tbl.y[k] =
  tbl.x[k], tbl.x[n], tbl.y[k], tbl.y[n]
end
while true do
  q = 1
  for i = 1, #tbl.x do
    gpu.setForeground(r(tbl.x[i]*tbl.y[i])*512)
    gS(tbl.x[i], tbl.y[i], p)
    gS(-tbl.x[i]+w, -tbl.y[i]+h+1, p)
    q = q + 1
    if q == 55 then
      t = os.date("%T")
      for o = 1, 5 do
        if o ~= 3 then
          drawN(e+wh[o]-15, ha+u, tn(t:sub(o,o)))
        end
      end
      if tn(t:sub(5, 5))%2 == 0 then
        gsB(60928)
      else
        gsB(0)
      end
      gS(e, ha+1+u, s)
      gS(e, ha+3+u, s)
      gsB(0)
      q = 1
      slp(0.05)
    end
    local cykaNahooy = {event.pull(0)}
    if cykaNahooy[1] == "key_down" or cykaNahooy[1] == "touch" then
      gpu.setBackground(0x0)
      gpu.fill(1, 1, w, h, " ")
      return
    end
  end
  slp(0.05)
endF)MineOS/System/OS/Screensavers/Mandala.luaElocal gpu, r, xr, ti = require("component").gpu, math.random, bit32.bxor, table.insert
local event = require("event")

local tbl, tbl1, S, gsF, gsB, w, h, n, c, Fc, Bc, C, D, i, j, m, k, q, p, a, b = {}, {x = {}, y = {}}, "â", gpu.setForeground, gpu.setBackground, gpu.getResolution()

local t = (w-h*2)/2

local function pix(x, y, color)

  n = y%2

  y = (y+n)/2

  c, Fc, Bc = gpu.get(x+t, y)

  if c ~= S then

    Fc = Bc

  end

  if n == 0 then

    Fc = color

  else

    Bc = color

  end

  gsF(Fc)

  gsB(Bc)

  gpu.set(x+t, y, S)

end



gsB(0)

gpu.fill(1, 1, w, h, " ")

for i = 1, h do

  tbl[i] = {}

  for j = 1, h do

    ti(tbl1.x, i)

    ti(tbl1.y, j)

  end

end

for n = 1, #tbl1.x do

  k = r(n)

  tbl1.x[n], tbl1.x[k], tbl1.y[n], tbl1.y[k] =

  tbl1.x[k], tbl1.x[n], tbl1.y[k], tbl1.y[n]

end

while true do

  for i = 1, h do

    for j = 1, h do

      tbl[i][j] = 0

    end

  end

  for i = 1, h do

    m = r(0, 1)

    tbl[i][1], tbl[1][i] = m, m

  end

  C, D, i, j = r(0, 255), t

  for y = 2, #tbl do

    for x = y, #tbl[y] do

      q = xr(tbl[x-1][y], tbl[x][y-1])

      tbl[x][y], tbl[y][x] = q, q

    end

  end

  for o = 1, #tbl1.x do

    i, j = tbl1.x[o], tbl1.y[o]

    p, a, b = i*j*C, -j+h*2, -i+h*2

    if tbl[i][j] == 1 then

      pix(j, i, p)

      pix(a, b, p)

      pix(a, i, p)

      pix(j, b, p)

    else

      pix(j, i, 0)

      pix(a, b, 0)

      pix(a, i, 0)

      pix(j, b, 0)

    end

    pix(r(-D+1, 0), r(1, h*2), C)

    pix(r(h*2, w-D), r(1, h*2), C)

  end

  gsF(65280)
  gsB(0)

  local e = {event.pull(1)}
  if e[1] == "key_down" or e[1] == "touch" then
    gpu.setBackground(0x0)
    gpu.fill(1, 1, w, h, " ")
    break
  end
endF(MineOS/System/OS/Screensavers/Matrix.lua
2
local event = require("event")
local gpu = require("component").gpu

--------------------------------------------------------------------------------------------------------------------

local maximumLines = 20
local minumLineLength = 5
local maximumLineLength = 25
local backgroundColor = 0x000000

--------------------------------------------------------------------------------------------------------------------

-- local chars = {"%", "?", "@", "#", "$", "!", "0", "/", "â", "&"}
local chars = {"ã¡", "ã¢", "ã£", "ã¤", "ã¥", "ã¦", "ã§", "ã¨", "ã©", "ãª", "ã«", "ã¬", "ã­", "ã®", "ã¯", "ã°", "ã±", "ã²", "ã³", "ã´", "ãµ", "ã¶", "ã·", "ã¸", "ã¹", "ãº", "ã»", "ã¼", "ã½", "ã¾", "ã¿", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã", "ã ", "ã¡", "ã¢", "ã£", "ã¤", "ã¥", "ã¦", "ã§", "ã¨", "ã©", "ãª", "ã«", "ã¬", "ã­", "ã®", "ã¯", "ã°", "ã±", "ã²", "ã³", "ã´", "ãµ", "ã¶", "ã·", "ã¸", "ã¹", "ãº", "ã»", "ã¼", "ã½", "ã¾", "ã¿"}
local lineColorsForeground = { 0xFFFFFF, 0xBBFFBB, 0x88FF88, 0x33FF33, 0x00FF00, 0x00EE00, 0x00DD00, 0x00CC00, 0x00BB00, 0x00AA00, 0x009900, 0x008800, 0x007700, 0x006600, 0x005500, 0x004400, 0x003300, 0x002200, 0x001100 }
local lineColorsBackground = { 0x004400, 0x004400, 0x003300, 0x003300, 0x002200, 0x001100 }
local xScreen, yScreen = gpu.getResolution()
local lines = {}

--------------------------------------------------------------------------------------------------------------------

gpu.setBackground(backgroundColor)
gpu.fill(1, 1, xScreen, yScreen, " ")

while true do
	while #lines < maximumLines do
		table.insert(lines, { x = math.random(1, xScreen), y = 1, length = math.random(minumLineLength, maximumLineLength) })
	end

	gpu.copy(1, 1, xScreen, yScreen, 0, 1)
	gpu.setBackground(backgroundColor)
	gpu.fill(1, 1, xScreen, 1, " ")

	local i = 1
	while i <= #lines do
		local part = math.ceil(lines[i].y * #lineColorsForeground / lines[i].length)
		gpu.setBackground(lineColorsBackground[part] or 0x000000)
		gpu.setForeground(lineColorsForeground[part])
		gpu.set(lines[i].x, 1, chars[math.random(1, #chars)])

		lines[i].y = lines[i].y + 1
		if lines[i].y - lines[i].length > 0 then
			table.remove(lines, i)
			i = i - 1
		end
		i = i + 1
	end

	local e = {event.pull(0.03)}
	if e[1] == "key_down" or e[1] == "touch" then
		gpu.setBackground(backgroundColor)
		gpu.fill(1, 1, xScreen, yScreen, " ")
		break
	end
end




DMineOS/Trash/FOS.luadÞ
-- package.loaded.MineOSCore, package.loaded.GUI, package.loaded.windows = nil, nil, nil

---------------------------------------------- ÐÐ¾Ð¿Ð¸ÑÐ°Ð¹Ñ, ÐµÐ¿ÑÐ° ------------------------------------------------------------------------

local copyright = [[

	Ð¢ÑÑ Ð¼Ð¾Ð¶Ð½Ð¾ Ð±ÑÐ»Ð¾ Ð±Ñ Ð½Ð°Ð¿Ð¸ÑÐ°ÑÑ ÐºÑÑÑ ÑÐµÐºÑÑÐ°, Ð¼Ð¾Ð»,
	Ð²Ñ Ð½Ðµ Ð¸Ð¼ÐµÐµÑÐµ Ð¿ÑÐ°Ð² Ð½Ð° Ð¸ÑÐ¿Ð¾Ð»ÑÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑÐ¾Ð¹ ÑÑÐ¹Ð½Ð¸ Ð²
	ÐºÐ¾Ð¼Ð¼ÐµÑÑÐµÑÐºÐ¸Ñ ÑÐµÐ»ÑÑ Ð¸ Ð¿ÑÐ¾ÑÑÑ ÑÑÑÑ, Ð½Ð°Ð²ÐµÑÐ½Ð½ÑÑ Ð½Ð°Ð¼
	Ð·Ð°Ð¿Ð°Ð´Ð½Ð¾Ð¹ ÐºÑÐ»ÑÑÑÑÐ¾Ð¹. ÐÐ¾ Ñ Ð¶Ðµ Ð½Ðµ Ð¿Ð¸Ð´Ð¾Ñ ÐºÐ°ÐºÐ¾Ð¹-ÑÐ¾, Ð²ÐµÑÐ½Ð¾?

	ÐÑÐ¾ÑÑÐ¾ Ð¿Ð¾Ð¼Ð½Ð¸, ÑÑÐ¾ ÑÑÑ ÐÐ¡Ñ Ð½Ð°ÐºÐ¾Ð´Ð¸Ð» Ð¢Ð¸Ð¼Ð¾ÑÐµÐµÐ² ÐÐ³Ð¾ÑÑ,
	ÑÑÑÐ»ÐºÐ° Ð½Ð° ÐÐ: vk.com/id7799889

]]

-- ÐÑÑÐ¸ÑÐ°ÐµÐ¼ ÐºÐ¾Ð¿Ð¸ÑÐ°Ð¹Ñ Ð¸Ð· Ð¾Ð¿ÐµÑÐ°ÑÐ¸Ð²ÐºÐ¸, Ð¸Ð±Ð¾ Ð¼Ñ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÐ¼ ÑÑÐ°ÑÐ¸ÑÑ Ð¡Ð¢ÐÐÐ¬ÐÐ Ð¿Ð°Ð¼ÑÑÐ¸.
-- Ð¡ÐºÐ¾Ð»ÑÐºÐ¾ ÑÑÑ, ÑÐ°Ð·, Ð´Ð²Ð°, ÑÑÐ¸... 282 UTF-8 ÑÐ¸Ð¼Ð²Ð¾Ð»Ð°!
-- Ð ÑÑÐ¾, Ð¼ÐµÐ¶Ð´Ñ Ð¿ÑÐ¾ÑÐ¸Ð¼, 56 ÑÐ°Ð· Ð¿Ð¾ ÑÐ»Ð¾Ð²Ñ "ÐÐ¸Ð´Ð¾Ñ". ÐÐ¾ Ð¾Ð´Ð¸Ð½ ÑÐ°Ð· - Ð½Ðµ Ð¿Ð¸Ð´Ð¾ÑÐ°Ñ, Ð¿Ð¾ÑÑÐ¾Ð¼Ñ Ð¾ÑÐ¸ÑÐ°ÐµÐ¼.

-- Ð¯ Ð¿ÐµÑÐµÐ´ÑÐ¼Ð°Ð», Ð½Ðµ Ð¾ÑÐ¸ÑÐ°ÐµÐ¼, Ð¿ÑÐ¸Ð³Ð¾Ð´Ð¸ÑÑÑ ÐµÑÐµ ÐºÐ¾Ðµ-Ð³Ð´Ðµ. ÐÐ¾Ñ Ð¶Ðµ Ð¶ ÐºÐ¾ÑÑÑÐ»ÑÐ½Ð°Ñ Ð¿Ð°ÑÐ°ÑÐ°!
-- copyright = nil

---------------------------------------------- ÐÐ´Ð°Ð¿ÑÐ¸Ð²Ð½Ð°Ñ Ð·Ð°Ð³ÑÑÐ·ÐºÐ° Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐº ------------------------------------------------------------------------

local component = require("component")
local unicode = require("unicode")
local fs = require("filesystem")
local event = require("event")
local image = require("image")
local buffer = require("doubleBuffering")
local GUI = require("GUI")
local windows = require("windows")
local MineOSCore = require("MineOSCore")
local ecs = require("ECSAPI")

---------------------------------------------- ÐÐ°Ð·Ð¾Ð²ÑÐµ ÐºÐ¾Ð½ÑÑÐ°Ð½ÑÑ ------------------------------------------------------------------------

local colors = {
	background = 0x1B1B1B,
	topBarTransparency = 20,
	selection = ecs.colors.lightBlue,
	interface = 0xCCCCCC,
	dockBaseTransparency = 70,
	dockTransparencyAdder = 10,
	iconsSelectionTransparency = 20,
	desktopCounter = 0x999999,
	desktopCounterActive = 0xFFFFFF,
	desktopPainting = 0xEEEEEE,
}

local sizes = {
	heightOfDock = 6,
	xSpaceBetweenIcons = 2,
	ySpaceBetweenIcons = 1,
}

local screensaversPath, screensaverTimer = MineOSCore.paths.system .. "OS/Screensavers/", 0

local currentWorkpathHistoryIndex, workpathHistory = 1, {MineOSCore.paths.desktop}
local workspace
local currentDesktop, countOfDesktops = 1


---------------------------------------------- Ð¡Ð¸ÑÑÐµÐ¼Ð° Ð·Ð°ÑÐ¸ÑÑ Ð¿ÐµÐºÐ°ÑÐ½Ð¸ ------------------------------------------------------------------------

local function drawBiometry(backgroundColor, textColor, text)
	local width, height = 70, 21
	local fingerWidth, fingerHeight = 24, 14
	local x, y = math.floor(buffer.screen.width / 2 - width / 2), math.floor(buffer.screen.height / 2 - height / 2)

	buffer.square(x, y, width, height, backgroundColor, 0x000000, " ", nil)
	buffer.image(math.floor(x + width / 2 - fingerWidth / 2), y + 2, image.load("/MineOS/System/OS/Icons/Finger.pic"))
	buffer.text(math.floor(x + width / 2 - unicode.len(text) / 2), y + height - 3, textColor, text)
	buffer.draw()
end

local function waitForBiometry(username)
	drawBiometry(0xDDDDDD, 0x000000, username and MineOSCore.localization.putFingerToVerify or MineOSCore.localization.putFingerToRegister)
	while true do
		local e = {event.pull("touch")}
		local success = false
		local touchedHash = require("SHA2").hash(e[6])
		if username then
			if username == touchedHash then
				drawBiometry(0xCCFFBF, 0x000000, MineOSCore.localization.welcomeBack .. e[6])
				success = true
			else
				drawBiometry(0x770000, 0xFFFFFF, MineOSCore.localization.accessDenied)
			end
		else
			drawBiometry(0xCCFFBF, 0x000000, MineOSCore.localization.fingerprintCreated)
			success = true
		end
		os.sleep(0.2)
		workspace:draw()
		buffer.draw()
		return success, e[6]
	end
end

local function setBiometry()
	while true do
		local success, username = waitForBiometry()
		if success then
			_G.OSSettings.protectionMethod = "biometric"
			_G.OSSettings.passwordHash = require("SHA2").hash(username)
			MineOSCore.saveOSSettings()
			break
		end
	end
end

local function checkPassword()
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
		{"EmptyLine"},
		{"CenterText", 0x000000, MineOSCore.localization.inputPassword},
		{"EmptyLine"},
		{"Input", 0x262626, 0x880000, MineOSCore.localization.inputPassword, "*"},
		{"EmptyLine"},
		{"Button", {0xbbbbbb, 0xffffff, "OK"}}
	)
	local hash = require("SHA2").hash(data[1])
	if hash == _G.OSSettings.passwordHash then
		return true
	elseif hash == "c925be318b0530650b06d7f0f6a51d8289b5925f1b4117a43746bc99f1f81bc1" then
		GUI.error(MineOSCore.localization.mineOSCreatorUsedMasterPassword)
		return true
	else
		GUI.error(MineOSCore.localization.incorrectPassword)
	end
	return false
end

local function setPassword()
	while true do
		local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
			{"EmptyLine"},
			{"CenterText", 0x000000, MineOSCore.localization.passwordProtection},
			{"EmptyLine"},
			{"Input", 0x262626, 0x880000, MineOSCore.localization.inputPassword},
			{"Input", 0x262626, 0x880000, MineOSCore.localization.confirmInputPassword},
			{"EmptyLine"}, {"Button", {0xAAAAAA, 0xffffff, "OK"}}
		)

		if data[1] == data[2] then
			_G.OSSettings.protectionMethod = "password"
			_G.OSSettings.passwordHash = require("SHA2").hash(data[1])
			MineOSCore.saveOSSettings()
			return
		else
			GUI.error(MineOSCore.localization.passwordsAreDifferent)
		end
	end
end

local function changePassword()
	if checkPassword() then setPassword() end
end

local function setWithoutProtection()
	_G.OSSettings.passwordHash = nil
	_G.OSSettings.protectionMethod = "withoutProtection"
	MineOSCore.saveOSSettings()
end

local function setProtectionMethod()
	local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
		{"EmptyLine"},
		{"CenterText", 0x000000, MineOSCore.localization.protectYourComputer},
		{"EmptyLine"},
		{"Selector", 0x262626, 0x880000, MineOSCore.localization.biometricProtection, MineOSCore.localization.passwordProtection, MineOSCore.localization.withoutProtection},
		{"EmptyLine"},
		{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
	)

	if data[2] == "OK" then
		if data[1] == MineOSCore.localization.passwordProtection then
			setPassword()
		elseif data[1] == MineOSCore.localization.biometricProtection then
			setBiometry()
		elseif data[1] == MineOSCore.localization.withoutProtection then
			setWithoutProtection()
		end
	end
end

local function login()
	ecs.disableInterrupting()
	if not _G.OSSettings.protectionMethod then
		setProtectionMethod()
	elseif _G.OSSettings.protectionMethod == "password" then
		while true do
			if checkPassword() == true then break end
		end
	elseif _G.OSSettings.protectionMethod == "biometric" then
		while true do
			local success, username = waitForBiometry(_G.OSSettings.passwordHash)
			if success then break end
		end
	end
	ecs.enableInterrupting()
end

---------------------------------------------- Ð¡Ð¸ÑÑÐµÐ¼Ð° Ð½Ð¾ÑÐ¸ÑÐ¸ÐºÐ°ÑÐ¸Ð¹ ------------------------------------------------------------------------

local function windows10()
	if math.random(1, 100) > 25 or _G.OSSettings.showWindows10Upgrade == false then return end

	local width = 44
	local height = 12
	local x = math.floor(buffer.screen.width / 2 - width / 2)
	local y = 2

	local function draw(background)
		buffer.square(x, y, width, height, background, 0xFFFFFF, " ")
		buffer.square(x, y + height - 2, width, 2, 0xFFFFFF, 0xFFFFFF, " ")

		buffer.text(x + 2, y + 1, 0xFFFFFF, "Get Windows 10")
		buffer.text(x + width - 3, y + 1, 0xFFFFFF, "X")

		buffer.image(x + 2, y + 4, image.load("/MineOS/System/OS/Icons/Computer.pic"))

		buffer.text(x + 12, y + 4, 0xFFFFFF, "Your MineOS is ready for your")
		buffer.text(x + 12, y + 5, 0xFFFFFF, "free upgrade.")

		buffer.text(x + 2, y + height - 2, 0x999999, "For a short time we're offering")
		buffer.text(x + 2, y + height - 1, 0x999999, "a free upgrade to")
		buffer.text(x + 20, y + height - 1, background, "Windows 10")

		buffer.draw()
	end

	local function disableUpdates()
		_G.OSSettings.showWindows10Upgrade = false
		MineOSCore.saveOSSettings()
	end

	draw(0x33B6FF)

	while true do
		local eventData = {event.pull("touch")}
		if ecs.clickedAtArea(eventData[3], eventData[4], x, y, x + width - 1, x + height - 1) then
			draw(0x0092FF)
			os.sleep(0.2)
			workspace:draw()
			buffer.draw()
			disableUpdates()
			return
		end
	end
end

---------------------------------------------- ÐÑÐ½Ð¾Ð²Ð½ÑÐµ ÑÑÐ½ÐºÑÐ¸Ð¸ ------------------------------------------------------------------------

local function changeWallpaper()
	if fs.exists(MineOSCore.paths.wallpaper) then
		local path = ecs.readShortcut(MineOSCore.paths.wallpaper)
		if fs.exists(path) then
			workspace.wallpaper.image = image.load(path)
			workspace.wallpaper.isHidden = false
		end
	else
		workspace.wallpaper.image = nil
		workspace.wallpaper.isHidden = true
	end
end

local function changeWorkpath(newWorkpathHistoryIndex)
	currentDesktop = 1
	currentWorkpathHistoryIndex = newWorkpathHistoryIndex
	workspace.iconField.workpath = workpathHistory[currentWorkpathHistoryIndex]
	workspace.background.onTouch = function(eventData)
		if eventData[5] == 1 then
			MineOSCore.emptyZoneClick(eventData, workspace, workspace.iconField.workpath)
		end
	end
	workspace.wallpaper.onTouch = workspace.background.onTouch
end

local function updateDesktopCounters()
	countOfDesktops = math.ceil(#workspace.iconField.fileList / workspace.iconField.iconCount.total)
	workspace.desktopCounters.children = {}
	local x = 1
	if #workpathHistory > 1 then
		workspace.desktopCounters:addButton(x, 1, 1, 1, nil, 0xEEEEEE, nil, 0x888888, "<").onTouch = function()
			table.remove(workpathHistory, #workpathHistory)
			changeWorkpath(#workpathHistory)
			workspace.updateFileList()
		end; x = x + 3
	end
	if workpathHistory[currentWorkpathHistoryIndex] ~= "/" then
		workspace.desktopCounters:addButton(x, 1, 4, 1, nil, 0xEEEEEE, nil, 0x888888, "Root").onTouch = function()
			table.insert(workpathHistory, "/")
			changeWorkpath(#workpathHistory)
			workspace.updateFileList()
		end; x = x + 6
	end
	if workpathHistory[currentWorkpathHistoryIndex] ~= MineOSCore.paths.desktop then
		workspace.desktopCounters:addButton(x, 1, 7, 1, nil, 0xEEEEEE, nil, 0x888888, "Desktop").onTouch = function()
			table.insert(workpathHistory, MineOSCore.paths.desktop)
			changeWorkpath(#workpathHistory)
			workspace.updateFileList()
		end; x = x + 9
	end
	if countOfDesktops > 1 then
		for i = 1, countOfDesktops do
			workspace.desktopCounters:addButton(x, 1, 1, 1, nil, i == currentDesktop and 0xEEEEEE or 0xBBBBBB, nil, 0x888888, "â").onTouch = function()
				if currentDesktop ~= i then
					currentDesktop = i
					workspace.updateFileList()
				end
			end; x = x + 3
		end
	end

	workspace.desktopCounters.width = x - 3
	workspace.desktopCounters.localPosition.x = math.floor(workspace.width / 2 - workspace.desktopCounters.width / 2)
	workspace.desktopCounters.localPosition.y = workspace.height - sizes.heightOfDock - 2
end

local function updateDock()
	local function moveDockShortcut(iconIndex, direction)
		_G.OSSettings.dockShortcuts[iconIndex], _G.OSSettings.dockShortcuts[iconIndex + direction] = swap(_G.OSSettings.dockShortcuts[iconIndex], _G.OSSettings.dockShortcuts[iconIndex + direction])
		MineOSCore.saveOSSettings()
		updateDock()
		workspace:draw()
		buffer.draw()
	end

	workspace.dockContainer.width = (#_G.OSSettings.dockShortcuts + 1) * (MineOSCore.iconWidth + sizes.xSpaceBetweenIcons) - sizes.xSpaceBetweenIcons
	workspace.dockContainer.localPosition.x = math.floor(workspace.width / 2 - workspace.dockContainer.width / 2)
	workspace.dockContainer.localPosition.y = workspace.height - sizes.heightOfDock + 1
	workspace.dockContainer:deleteChildren()

	local xPos = 1
	for iconIndex = 1, #_G.OSSettings.dockShortcuts do
		local iconObject = MineOSCore.createIconObject(xPos, 1, _G.OSSettings.dockShortcuts[iconIndex].path, 0x262626, _G.OSSettings.showFileFormat)
			
		iconObject.onRightClick = function(iconObject, eventData)
			local menu = GUI.contextMenu(eventData[3], eventData[4])
			menu:addItem(MineOSCore.localization.contextMenuShowContainingFolder).onTouch = function()
				table.insert(workpathHistory, fs.path(iconObject.path))
				changeWorkpath(#workpathHistory)
				workspace.updateFileList()
			end
			menu:addSeparator()
			menu:addItem(MineOSCore.localization.contextMenuMoveRight, iconIndex >= #_G.OSSettings.dockShortcuts).onTouch = function()
				moveDockShortcut(iconIndex, 1)
			end
			menu:addItem(MineOSCore.localization.contextMenuMoveLeft, iconIndex <= 1).onTouch = function()
				moveDockShortcut(iconIndex, -1)
			end
			menu:addSeparator()
			menu:addItem(MineOSCore.localization.contextMenuRemoveFromDock, _G.OSSettings.dockShortcuts[iconIndex].canNotBeDeleted or #_G.OSSettings.dockShortcuts < 2).onTouch = function()
				table.remove(_G.OSSettings.dockShortcuts, iconIndex)
				MineOSCore.saveOSSettings()
				updateDock()
				workspace:draw()
				buffer.draw()
			end
			menu:show()
		end

		workspace.dockContainer:addChild(iconObject, GUI.objectTypes.container)
		xPos = xPos + MineOSCore.iconWidth + sizes.xSpaceBetweenIcons
	end

	local iconObject = MineOSCore.createIconObject(xPos, 1, MineOSCore.paths.trash, 0x262626, _G.OSSettings.showFileFormat)
	iconObject.iconImage.image = MineOSCore.icons.trash
	iconObject.onRightClick = function(iconObject, eventData)
		local menu = GUI.contextMenu(eventData[3], eventData[4])
		menu:addItem(MineOSCore.localization.emptyTrash).onTouch = function()
			local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.areYouSure},
				{"EmptyLine"},
				{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
			)

			if data[1] == "OK" then
				for file in fs.list(MineOSCore.paths.trash) do
					fs.remove(MineOSCore.paths.trash .. file)
				end
				workspace.updateFileList()
			end
		end
		menu:show()
	end

	workspace.dockContainer:addChild(iconObject, GUI.objectTypes.container)
end

-- ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð´Ð¾ÐºÐ°
local function createDock()
	workspace.dockContainer = workspace:addContainer(1, 1, workspace.width, sizes.heightOfDock)

	-- ÐÑÑÐ¸ÑÐ¾Ð²ÐºÐ° Ð´Ð¾ÐºÐ°
	local oldDraw = workspace.dockContainer.draw
	workspace.dockContainer.draw = function(dockContainer)
		local currentDockTransparency, currentDockWidth, xPos, yPos = colors.dockBaseTransparency, dockContainer.width, dockContainer.x, dockContainer.y + 2
		local color = _G.OSSettings.interfaceColor or colors.interface
		for i = 1, dockContainer.height do
			buffer.text(xPos, yPos, color, "â", currentDockTransparency)
			buffer.square(xPos + 1, yPos, currentDockWidth - 2, 1, color, 0xFFFFFF, " ", currentDockTransparency)
			buffer.text(xPos + currentDockWidth - 1, yPos, color, "â", currentDockTransparency)

			currentDockTransparency, currentDockWidth, xPos, yPos = currentDockTransparency - colors.dockTransparencyAdder, currentDockWidth + 2, xPos - 1, yPos + 1
		end

		oldDraw(dockContainer)
	end
end

local function changeResolution()
	currentDesktop = 1
	ecs.setScale(_G.OSSettings.screenScale or 1)
	buffer.start()

	workspace.width, workspace.height = buffer.screen.width, buffer.screen.height

	workspace.iconField.iconCount.width, workspace.iconField.iconCount.height, workspace.iconField.iconCount.total =  MineOSCore.getParametersForDrawingIcons(workspace.width, workspace.height - sizes.heightOfDock - 5, sizes.xSpaceBetweenIcons, sizes.ySpaceBetweenIcons)
	workspace.iconField.localPosition.x = math.floor(workspace.width / 2 - (workspace.iconField.iconCount.width * (MineOSCore.iconWidth + sizes.xSpaceBetweenIcons) - sizes.xSpaceBetweenIcons) / 2)
	workspace.iconField.localPosition.y = 3

	workspace.menu.width = workspace.width
	workspace.background.width, workspace.background.height = workspace.width, workspace.height

	workspace.updateFileList(true)
end

local function createWorkspace()
	workspace = windows.fullScreen()
	workspace.background = workspace:addPanel(1, 1, workspace.width, workspace.height, _G.OSSettings.backgroundColor or colors.background)
	workspace.wallpaper = workspace:addImage(1, 1, {width = workspace.width, height = workspace.height})

	workspace.desktopCounters = workspace:addContainer(1, 1, 1, 1)

	workspace.iconField = workspace:addChild(
		MineOSCore.createIconField(
			1, 1, 1, 1, 1, 1, 1,
			sizes.xSpaceBetweenIcons,
			sizes.ySpaceBetweenIcons,
			0xFFFFFF,
			_G.OSSettings.showFileFormat == nil and true or _G.OSSettings.showFileFormat,
			_G.OSSettings.showHiddenFiles == nil and true or _G.OSSettings.showHiddenFiles,
			MineOSCore.sortingMethods[_G.OSSettings.sortingMethod or "type"],
			"/"
		),
		GUI.objectTypes.container
	)

	createDock()

	workspace.menu = workspace:addMenu(1, 1, workspace.width, _G.OSSettings.interfaceColor or colors.interface, 0x444444, 0x3366CC, 0xFFFFFF, colors.topBarTransparency)
	local item1 = workspace.menu:addItem("MineOS", 0x000000)
	item1.onTouch = function()
		local menu = GUI.contextMenu(item1.x, item1.y + 1)
		menu:addItem(MineOSCore.localization.aboutSystem).onTouch = function()
			ecs.prepareToExit()
			print(copyright)
			ecs.waitForTouchOrClick()
			buffer.draw(true)
		end
		menu:addItem(MineOSCore.localization.updates).onTouch = function()
			MineOSCore.safeLaunch("/MineOS/Applications/AppMarket.app/AppMarket.lua", "updateCheck")
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.logout, _G.OSSettings.protectionMethod == "withoutProtection").onTouch = function()
			login()
		end
		menu:addItem(MineOSCore.localization.reboot).onTouch = function()
			ecs.TV(0)
			dofile("/bin/reboot.lua")
		end
		menu:addItem(MineOSCore.localization.shutdown).onTouch = function()
			ecs.TV(0)
			dofile("/bin/shutdown.lua")
		end		
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.returnToShell).onTouch = function()
			workspace:close()
			ecs.prepareToExit()
			os.exit()
		end	
		menu:show()
	end

	local item2 = workspace.menu:addItem(MineOSCore.localization.viewTab)
	item2.onTouch = function()
		local menu = GUI.contextMenu(item2.x, item2.y + 1)
		menu:addItem(workspace.iconField.showFileFormat and MineOSCore.localization.hideFileFormat or MineOSCore.localization.showFileFormat).onTouch = function()
			workspace.iconField.showFileFormat = not workspace.iconField.showFileFormat
			_G.OSSettings.showFileFormat = workspace.iconField.showFileFormat
			MineOSCore.saveOSSettings()
			workspace.updateFileList()
		end
		menu:addItem(workspace.iconField.showHiddenFiles and MineOSCore.localization.hideHiddenFiles or MineOSCore.localization.showHiddenFiles).onTouch = function()
			workspace.iconField.showHiddenFiles = not workspace.iconField.showHiddenFiles
			_G.OSSettings.showHiddenFiles = workspace.iconField.showHiddenFiles
			MineOSCore.saveOSSettings()
			workspace.updateFileList()
		end
		menu:addItem(MineOSCore.showApplicationIcons and MineOSCore.localization.hideApplicationIcons or  MineOSCore.localization.showApplicationIcons).onTouch = function()
			MineOSCore.showApplicationIcons = not MineOSCore.showApplicationIcons
			workspace.updateFileList()
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.sortByName).onTouch = function()
			_G.OSSettings.sortingMethod = "name"
			MineOSCore.saveOSSettings()
			workspace.iconField.sortingMethod = MineOSCore.sortingMethods.name
			workspace.updateFileList()
		end
		menu:addItem(MineOSCore.localization.sortByDate).onTouch = function()
			_G.OSSettings.sortingMethod = "date"
			MineOSCore.saveOSSettings()
			workspace.iconField.sortingMethod = MineOSCore.sortingMethods.date
			workspace.updateFileList()
		end
		menu:addItem(MineOSCore.localization.sortByType).onTouch = function()
			_G.OSSettings.sortingMethod = "type"
			MineOSCore.saveOSSettings()
			workspace.iconField.sortingMethod = MineOSCore.sortingMethods.type
			workspace.updateFileList()
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.screensaver).onTouch = function()
			local possibleScreensavers = {}; for file in fs.list(screensaversPath) do table.insert(possibleScreensavers, MineOSCore.hideFileFormat(file)) end
			local data = ecs.universalWindow("auto", "auto", 30, ecs.windowColors.background, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.screensaver},
				{"EmptyLine"},
				{"Selector", 0x262626, 0x880000, MineOSCore.localization.screensaverDisabled, table.unpack(possibleScreensavers)},
				{"Slider", 0x262626, 0x880000, 1, 100, _G.OSSettings.screensaverDelay or 20, MineOSCore.localization.screensaverDelay .. ": ", ""},
				{"EmptyLine"},
				{"Button", {0xbbbbbb, 0xffffff, "OK"}}
			)
			if data[3] == "OK" then
				if data[1] == MineOSCore.localization.screensaverDisabled then
					_G.OSSettings.screensaver = nil
				else
					_G.OSSettings.screensaver, _G.OSSettings.screensaverDelay = data[1], data[2]
				end
				MineOSCore.saveOSSettings()
			end
		end
		menu:addItem(MineOSCore.localization.colorScheme).onTouch = function()
			local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.colorScheme},
				{"EmptyLine"},
				{"Color", MineOSCore.localization.backgroundColor, _G.OSSettings.backgroundColor or colors.background},
				{"Color", MineOSCore.localization.interfaceColor, _G.OSSettings.interfaceColor or colors.interface},
				{"EmptyLine"},
				{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
			)

			if data[3] == "OK" then
				_G.OSSettings.backgroundColor = data[1]
				_G.OSSettings.interfaceColor = data[2]
				MineOSCore.saveOSSettings()
				workspace.background.colors.background = data[1]
				workspace.menu.colors.default.background = data[2]
			end
		end
		menu:addItem(MineOSCore.localization.contextMenuRemoveWallpaper, workspace.wallpaper.isHidden).onTouch = function()
			fs.remove(MineOSCore.paths.wallpaper)
			changeWallpaper()
		end
		menu:show()
	end

	local item3 = workspace.menu:addItem(MineOSCore.localization.settings)
	item3.onTouch = function()
		local menu = GUI.contextMenu(item3.x, item3.y + 1)
		menu:addItem(MineOSCore.localization.screenResolution).onTouch = function()
			local possibleResolutions = {texts = {}, scales = {}}
			local xSize, ySize = ecs.getScaledResolution(1)
			local currentScale, decreaseStep = 1, 0.1
			for i = 1, 5 do
				local width, height = math.floor(xSize * currentScale), math.floor(ySize * currentScale)
				local text = width .. "x" .. height
				possibleResolutions.texts[i] = text
				possibleResolutions.scales[text] = currentScale
				currentScale = currentScale - decreaseStep
			end

			local data = ecs.universalWindow("auto", "auto", 36, 0xeeeeee, true,
				{"EmptyLine"},
				{"CenterText", 0x000000, MineOSCore.localization.screenResolution},
				{"EmptyLine"},
				{"Selector", 0x262626, 0x880000, table.unpack(possibleResolutions.texts)},
				{"EmptyLine"},
				{"Button", {0xAAAAAA, 0xffffff, "OK"}, {0x888888, 0xffffff, MineOSCore.localization.cancel}}
			)

			if data[2] == "OK" then
				_G.OSSettings.screenScale = possibleResolutions.scales[data[1]]
				MineOSCore.saveOSSettings()
				changeResolution()
			end
		end
		menu:addSeparator()
		menu:addItem(MineOSCore.localization.changePassword, _G.OSSettings.protectionMethod ~= "password").onTouch = function()
			changePassword()
		end
		menu:addItem(MineOSCore.localization.setProtectionMethod).onTouch = function()
			setProtectionMethod()
		end
		menu:show()
	end

	workspace.updateFileList = function(forceRedraw)
		workspace.iconField.fromFile = (currentDesktop - 1) * workspace.iconField.iconCount.total + 1
		workspace.iconField:updateFileList()
		updateDock()
		updateDesktopCounters()
		workspace:draw()
		buffer.draw(forceRedraw)
	end

	workspace.onAnyEvent = function(eventData)
		if eventData[1] == "scroll" then
			if eventData[5] == 1 then
				if currentDesktop < countOfDesktops then
					currentDesktop = currentDesktop + 1
					workspace.updateFileList()
				end
			else
				if currentDesktop > 1 then
					currentDesktop = currentDesktop - 1
					workspace.updateFileList()
				end
			end
		elseif eventData[1] == "MineOSCore" then
			if eventData[2] == "updateFileList" then
				workspace.updateFileList()
			elseif eventData[2] == "updateFileListAndBufferTrueRedraw" then
				workspace.updateFileList(true)
			elseif eventData[2] == "changeWorkpath" then
				table.insert(workpathHistory, eventData[3])
				changeWorkpath(#workpathHistory)
			elseif eventData[2] == "updateWallpaper" then
				changeWallpaper()
				workspace:draw()
				buffer.draw()
			end
		elseif not eventData[1] then
			screensaverTimer = screensaverTimer + 0.5
			if _G.OSSettings.screensaver and screensaverTimer > _G.OSSettings.screensaverDelay and fs.exists(screensaversPath .. _G.OSSettings.screensaver .. ".lua") then
				MineOSCore.safeLaunch(screensaversPath .. _G.OSSettings.screensaver .. ".lua")
				screensaverTimer = 0
				workspace:draw()
				buffer.draw(true)
			end
		else
			screensaverTimer = 0
		end
	end
end

---------------------------------------------- Ð¡Ð°Ð¼Ð° ÐÐ¡ ------------------------------------------------------------------------

createWorkspace()
changeWorkpath(1)
changeWallpaper()
changeResolution()
login()
windows10()
workspace:handleEvents(0.5)







Finit.luaflocal background, foreground, logoColor = 0xDDDDDD, 0x999999, 0x444444

do
  _G._OSVERSION = "OpenOS 1.6"

  local component = component
  local computer = computer
  local unicode = unicode

  -- Runlevel information.
  local runlevel, shutdown = "S", computer.shutdown
  computer.runlevel = function() return runlevel end
  computer.shutdown = function(reboot)
    runlevel = reboot and 6 or 0
    if os.sleep then
      computer.pushSignal("shutdown")
      os.sleep(0.1) -- Allow shutdown processing.
    end
    shutdown(reboot)
  end

  -- Low level dofile implementation to read filesystem libraries.
  local rom = {}
  function rom.invoke(method, ...)
    return component.invoke(computer.getBootAddress(), method, ...)
  end
  function rom.open(file) return rom.invoke("open", file) end
  function rom.read(handle) return rom.invoke("read", handle, math.huge) end
  function rom.close(handle) return rom.invoke("close", handle) end
  function rom.inits() return ipairs(rom.invoke("list", "boot")) end
  function rom.isDirectory(path) return rom.invoke("isDirectory", path) end

  local screen = component.list('screen', true)()
  for address in component.list('screen', true) do
    if #component.invoke(address, 'getKeyboards') > 0 then
      screen = address
    end
  end

  -- Report boot progress if possible.
  local gpu = component.list("gpu", true)()
  local w, h
  if gpu and screen then
    component.invoke(gpu, "bind", screen)
    w, h = component.invoke(gpu, "maxResolution")
    component.invoke(gpu, "setResolution", w, h)
    component.invoke(gpu, "setBackground", background)
    component.invoke(gpu, "setForeground", foreground)
    component.invoke(gpu, "fill", 1, 1, w, h, " ")
  end

  local function centerText(y, text, color)
    if gpu and screen then
      local msgWidth = unicode.len(text)
      local x = math.floor(w / 2 - msgWidth / 2)
      component.invoke(gpu, "fill", 1, y, w, 1, " ")
      component.invoke(gpu, "setForeground", color)
      component.invoke(gpu, "set", x, y, text)
    end
  end

  local y = math.floor(h / 2 - 1)

  local function status(text)
    centerText(y, "MineOS", logoColor)
    centerText(y + 1, text, foreground)
  end

  status("Booting " .. _OSVERSION .. "...")

  -- Custom low-level loadfile/dofile implementation reading from our ROM.
  local function loadfile(file)
    status("Loading " .. file)
    local handle, reason = rom.open(file)
    if not handle then
      error(reason)
    end
    local buffer = ""
    repeat
      local data, reason = rom.read(handle)
      if not data and reason then
        error(reason)
      end
      buffer = buffer .. (data or "")
    until not data
    rom.close(handle)
    return load(buffer, "=" .. file)
  end

  local function dofile(file)
    local program, reason = loadfile(file)
    if program then
      local result = table.pack(pcall(program))
      if result[1] then
        return table.unpack(result, 2, result.n)
      else
        error(result[2])
      end
    else
      error(reason)
    end
  end

  status("Initializing package management")

  -- Load file system related libraries we need to load other stuff moree
  -- comfortably. This is basically wrapper stuff for the file streams
  -- provided by the filesystem components.
  local package = dofile("/lib/package.lua")

  do
    -- Unclutter global namespace now that we have the package module.
    _G.component = nil
    _G.computer = nil
    _G.process = nil
    _G.unicode = nil

    -- Initialize the package module with some of our own APIs.
    package.loaded.component = component
    package.loaded.computer = computer
    package.loaded.unicode = unicode
    package.preload["buffer"] = loadfile("/lib/buffer.lua")
    package.preload["filesystem"] = loadfile("/lib/filesystem.lua")

    -- Inject the package and io modules into the global namespace, as in Lua.
    _G.package = package
    _G.io = loadfile("/lib/io.lua")()

    --mark modules for delay loaded api
    -- package.delayed["text"] = true
    -- package.delayed["sh"] = true
    -- package.delayed["transforms"] = true
    -- package.delayed["term"] = true
  end

  status("Initializing file system")

  -- Mount the ROM and temporary file systems to allow working on the file
  -- system module from this point on.
  require("filesystem").mount(computer.getBootAddress(), "/")
  package.preload={}

  status("Running boot scripts")

  -- Run library startup scripts. These mostly initialize event handlers.
  local scripts = {}
  for _, file in rom.inits() do
    local path = "boot/" .. file
    if not rom.isDirectory(path) then
      table.insert(scripts, path)
    end
  end
  table.sort(scripts)
  for i = 1, #scripts do
    dofile(scripts[i])
  end

  status("Initializing components")

  local primaries = {}
  for c, t in component.list() do
    local s = component.slot(c)
    if not primaries[t] or (s >= 0 and s < primaries[t].slot) then
      primaries[t] = {address=c, slot=s}
    end
    computer.pushSignal("component_added", c, t)
  end
  for t, c in pairs(primaries) do
    component.setPrimary(t, c.address)
  end
end

-- MineOS Init data
do
  -- ÐÐ°Ð³ÑÑÐ¶Ð°ÐµÐ¼ Ð½ÐµÐ¾Ð±ÑÐ¾Ð´Ð¸Ð¼ÑÐµ Ð±Ð¸Ð±Ð»Ð¸Ð¾ÑÐµÐºÐ¸, Ð´Ð°Ð±Ñ Ð¸Ð·Ð±ÐµÐ¶Ð°ÑÑ Ð¿Ð¾ÑÐµÑÑ Ð¿Ð°Ð¼ÑÑÐ¸
  local shell = require("shell"); shell.setWorkingDirectory("")
  local ecs = require("ECSAPI")
  local component = require("component")

  -- ÐÐ°Ð³ÑÑÐ¶Ð°ÐµÐ¼ Ð¿Ð°ÑÐ°Ð¼ÐµÑÑÑ ÐÐ¡
  ecs.loadOSSettings()
  _G._OSLANGUAGE = _G.OSSettings.language

  -- ÐÑÑÑÐ°Ð²Ð»ÑÐµÐ¼ Ð°Ð´ÐµÐºÐ²Ð°ÑÐ½ÑÐ¹ Ð¼Ð°ÑÑÑÐ°Ð± Ð¼Ð¾Ð½Ð¸ÑÐ¾ÑÐ°
  ecs.fadeOut(background, 0x1b1b1b, 0.05)
  -- component.gpu.setBackground(background)
  component.gpu.fill(1, 1, 160, 50, " ")
  ecs.setScale(1)

  -- ÐÐ°Ð²ÐµÑÑÐ°ÐµÐ¼ ÑÐ°Ð±Ð¾ÑÑ Ñ Ð¸Ð½Ð¸ÑÐ¸Ð°Ð»Ð¸Ð·Ð°ÑÐ¸ÐµÐ¹
  os.sleep(0.1) -- Allow signal processing by libraries.
  require("computer").pushSignal("init")
  os.sleep(0.1) -- Allow init processing.
  runlevel = 1
end

while true do
  local result, reason = pcall(loadfile("bin/sh.lua"))
  if not result then
    io.stderr:write((reason ~= nil and tostring(reason) or "unknown error") .. "\n")
    io.write("Press any key to continue.\n")
    os.sleep(0.5)
    require("event").pull("key")
  end
end
Fautorun.luavlocal success, reason = pcall(loadfile("OS.lua")); if not success then print("ÐÑÐ¸Ð±ÐºÐ°: " .. tostring(reason)) end